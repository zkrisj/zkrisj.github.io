<html>
<head>
    <meta charset="utf-8" />
<meta name="description" content="" />
<meta name="viewport" content="width=device-width, initial-scale=1" />

<title>Vitest 知识总结 ｜ 青训营笔记 | zkrisj</title>

<link rel="shortcut icon" href="https://zkrisj.github.io/favicon.ico?v=1683589449040">

<link href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" rel="stylesheet">
<link rel="stylesheet" href="https://zkrisj.github.io/styles/main.css">
<!-- <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.0/dist/css/bootstrap.min.css"> -->

<script src="https://cdn.jsdelivr.net/npm/@highlightjs/cdn-assets/highlight.min.js"></script>
<script src="https://cdn.bootcdn.net/ajax/libs/highlight.js/9.12.0/languages/dockerfile.min.js"></script>
<script src="https://cdn.bootcdn.net/ajax/libs/highlight.js/9.12.0/languages//dart.min.js"></script>

<!-- <script src="https://cdn.jsdelivr.net/npm/moment@2.27.0/moment.min.js"></script> -->
<!-- <script src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.slim.min.js"></script> -->
<!-- <script src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js"></script> -->
<!-- <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.0/dist/js/bootstrap.min.js"></script> -->
<!-- DEMO JS -->
<!--<script src="media/scripts/index.js"></script>-->



    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.css">
    
</head>
<body>
<div class="main gt-bg-theme-color-first">
    <nav class="navbar navbar-expand-lg">
    <a class="navbar-brand" href="/">
        <img class="user-avatar" src="/images/avatar.png" alt="头像">
        <div class="site-name gt-c-content-color-first">
            zkrisj
        </div>
    </a>
    <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent"
        aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation" id="changeNavbar">
        <i class="fas fa-bars gt-c-content-color-first" style="font-size: 18px"></i>
    </button>
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
        <div class="navbar-nav mr-auto" style="text-align: center">
            
            <div class="nav-item">
                
                <a href="/" class="menu gt-a-link">
                    首页
                </a>
                
            </div>
            
            <div class="nav-item">
                
                <a href="/archives" class="menu gt-a-link">
                    归档
                </a>
                
            </div>
            
            <div class="nav-item">
                
                <a href="/tags" class="menu gt-a-link">
                    标签
                </a>
                
            </div>
            
            <div class="nav-item">
                
                <a href="/post/about" class="menu gt-a-link">
                    关于
                </a>
                
            </div>
            
        </div>
        <div style="text-align: center">
            <form id="gridea-search-form" style="position: relative" data-update="1683589449040"
                action="/search/">
                <input class="search-input" autocomplete="off" spellcheck="false" name="q" placeholder="搜索文章" />
                <i class="fas fa-search gt-c-content-color-first" style="position: absolute; top: 7px; left: 10px;"></i>
            </form>
        </div>
    </div>
</nav>
<script>
    /* 移动端导航栏展开/收起切换 */
    document.getElementById('changeNavbar').onclick = () => {
        var element = document.getElementById('navbarSupportedContent');
        if (element.style.display === 'none' || element.style.display === '') {
            element.style.display = 'block';
        } else {
            element.style.display = 'none';
        }
    }
</script>

    <div class="post-container">
        <div class="post-detail gt-bg-theme-color-second">
            <article class="gt-post-content">
                <h2 class="post-title">
                    Vitest 知识总结 ｜ 青训营笔记
                </h2>
                <div class="post-info">
                    <time class="post-time gt-c-content-color-first">
                        · 2023-02-17 ·
                    </time>
                    
                        <a href="https://zkrisj.github.io/tag/mTJ3nHw_s/" class="post-tags">
                            # 测试
                        </a>
                    
                </div>
                <div class="post-content">
                    <h2 id="vitest-简介">Vitest 简介</h2>
<p>由 Vite 提供支持的极速原生的单元测试框架。安装 <code>pnpm add -D vitest</code>，Vitest 需要 Vite &gt;=v3.0.0 和 Node &gt;=v14。</p>
<ol>
<li>
<p>Vite 支持<br>
重复使用 Vite 的配置、转换器、解析器和插件 - 在您的应用程序和测试中保持一致。</p>
</li>
<li>
<p>兼容 Jest<br>
拥有预期、快照、覆盖等 - 从 Jest 迁移很简单。</p>
</li>
<li>
<p>智能即时浏览模式<br>
智能文件监听模式，就像是测试的 HMR！</p>
</li>
<li>
<p>ESM, TypeScript, JSX<br>
由 esbuild 提供的开箱即用 ESM、TypeScript 和 JSX 支持。</p>
</li>
</ol>
<h2 id="vitest-跟其他的测试框架进行对比">Vitest 跟其他的测试框架进行对比</h2>
<p>Vitest 和基于浏览器的运行器之间的主要区别是速度和执行上下文。简而言之，基于浏览器的运行器，如 Cypress，可以捕捉到基于 Node 的运行器（如 Vitest）所不能捕捉的问题（比如样式问题、原生 DOM 事件、Cookies、本地存储和网络故障），但基于浏览器的运行器比 Vitest 慢几个数量级，因为它们要执行打开浏览器，编译样式表以及其他步骤。</p>
<h3 id="jest">Jest</h3>
<p><a href="https://jestjs.io/zh-Hans/">Jest</a> 通过为大多数的 JavaScript 项目提供了开箱即用的测试支持，填补了测试框架的空白，有着舒适的 API（例如 <code>it</code> 和 <code>expect</code>），以及大多数所需要的全套测试功能（例如快照，对象模拟，代码测试覆盖率）。</p>
<p>如果你的项目由 Vite 驱动，Jest 和 Vite 之间有很多重复的部分，让用户不得不创建两个不同的配置文件。配置和维护两个不同的容器是一件极其不合理的操作。使用 Vitest，你就可以将开发，构建和测试环境的配置定义为单个容器，共享相同的插件和 <code>vite.config.js</code>。同时可以通过相同的插件 API 进行扩展，与 Vite 形成完美的集成。</p>
<p>由于 Jest 的使用规模，Vitest 提供了与之兼容的 API，允许在大多数项目中将其作为备选使用，同时还包括了单元测试时最常见的功能（模拟，快照以及覆盖率）。Vitest 与大多数 Jest API 和生态系统库都有较好的兼容性，因此在大多数项目中，可以无缝的将 Jest 替换成 Vitest 。</p>
<h3 id="cypress">Cypress</h3>
<p><a href="https://www.cypress.io/">Cypress</a> 是著名的端到端测试工具，是基于浏览器的测试工具，是 Vitest 的补充工具之一。</p>
<p>基于浏览器运行测试的框架（Cypress、Web Test），会捕获到 Vitest 无法捕获的问题，因为他们都是使用真实的浏览器和 APIs。相比之下，Vitest 专注于为非浏览器逻辑提供最佳的开发体验。如果你想使用 Cypress，建议将 Vitest 用于测试项目中非浏览器逻辑，将 Cypress 用于测试依赖浏览器的逻辑。</p>
<p>Cypress 更像是一个 IDE 而不是测试框架，因为您还可以在浏览器中看到真实呈现的组件，以及它的测试结果和日志。Cypress 还尝试将 Vite 集成进他们自己的产品中：使用 Vitesse 重新构建他们的应用程序的 UI，并使用 Vite 来测试驱动他们项目的开发。</p>
<p>Vitest 支持各种实现部分浏览器环境的第三方包，例如 jsdom，可以让我们快速的对于任何引用浏览器 APIs 的代码进行单元测试。但这些浏览器环境在实现上有局限性，例如 jsdom 缺少相当数量的特性，诸如 <code>window.navigation</code> 或者布局引擎（<code>offsetTop</code> 等）。</p>
<p>Cypress 不是对业务代码进行单元测试的好选择，但使用 Cypress（用于端对端和组件测试）配合 Vitest（用于非浏览器逻辑的单元测试）将满足你应用程序的测试需求。</p>
<h2 id="vitest-主要功能">Vitest 主要功能</h2>
<ul>
<li>与 Vite 通用的配置、转换器、解析器和插件。</li>
<li>使用你的应用程序中的相同配置来进行测试！</li>
<li>智能文件监听模式（默认启用），就像是测试的 HMR！</li>
<li>支持测试 Vue、React、Lit 等框架中的组件。</li>
<li>开箱即用的 ES Module / TypeScript / JSX support / PostCSS</li>
<li>ESM 优先，支持模块顶级 await</li>
<li>注重性能，通过 tinypool 使用 Worker 线程尽可能多地并发运行</li>
<li>使用 Tinybench 来支持基准测试</li>
<li>套件和测试的过滤、超时、并发配置</li>
<li>Jest 的快照功能</li>
<li>内置 Chai 进行断言 + 与 Jest expect 语法兼容的 API</li>
<li>内置用于对象模拟(Mock)的 Tinyspy</li>
<li>使用 jsdom 或 happy-dom 用于 DOM 模拟</li>
<li>通过 c8 来输出代码测试覆盖率</li>
<li>类似于 Rust 语言的 源码内联测试</li>
<li>通过 expect-type 进行类型测试</li>
</ul>
<h3 id="测试环境">测试环境</h3>
<p>Vitest 提供 <code>environment</code> 选项以在特定环境中运行代码，可以使用 <code>environmentOptions</code> 选项修改环境的行为方式。默认情况下，可以使用这些环境：</p>
<ul>
<li><code>node</code> 为默认环境</li>
<li><code>jsdom</code> 通过提供 Browser API 模拟浏览器环境，使用 <a href="https://github.com/jsdom/jsdom"><code>jsdom</code></a> 包</li>
<li><code>happy-dom</code> 通过提供 Browser API 模拟浏览器环境，被认为比 jsdom 更快，但缺少一些 API，使用 <a href="https://github.com/capricorn86/happy-dom"><code>happy-dom</code></a> 包</li>
<li><code>edge-runtime</code> 模拟 Vercel 的 <a href="https://edge-runtime.vercel.app/">edge-runtime</a>，使用 <a href="https://www.npmjs.com/package/@edge-runtime/vm"><code>@edge-runtime/vm</code></a> 包</li>
</ul>
<ol>
<li>设置 <code>environment</code> 选项时，它将应用于项目中的所有测试文件。要获得更细粒度的控制，可以使用控制注释为特定文件指定环境，以 <code>@vitest-environment</code> 开头，后跟环境名称的注释：</li>
</ol>
<pre><code class="language-ts">// @vitest-environment jsdom

import { test } from 'vitest'

test('test', () =&gt; {
  expect(typeof window).not.toBe('undefined')
})
</code></pre>
<p>也可以通过设置 <code>environmentMatchGlobs</code> 选项，根据 glob 模式指定环境。</p>
<ol start="2">
<li>从 0.23.0 开始，你可以创建自己的包，名为 <code>vitest-environment-${name}</code>，来扩展 Vitest 环境。该包应导出一个具有 <code>Environment</code> 属性的对象：</li>
</ol>
<pre><code class="language-ts">import type { Environment } from 'vitest'

export default &lt;Environment&gt;{
  name: 'custom',
  setup() {
    // custom setup
    return {
      teardown() {
        // called after all tests with this env have been run
      },
    }
  },
}
</code></pre>
<p>可以通过 <code>vitest/environments</code> 访问默认的 Vitest 环境：</p>
<pre><code class="language-ts">import { builtinEnvironments, populateGlobal } from 'vitest/environments'

console.log(builtinEnvironments) // { jsdom, happy-dom, node, edge-runtime }
</code></pre>
<p><code>populateGlobal</code> 实用函数用于将属性从对象移动到全局命名空间。</p>
<h3 id="测试上下文">测试上下文</h3>
<p>Vitest 的测试上下文允许你定义可在测试中使用的工具(utils)、状态(states)和固定装置(fixtures)。</p>
<ol>
<li>每个测试回调的第一个参数是测试上下文。</li>
</ol>
<pre><code class="language-ts">import { it } from 'vitest'

it('should work', (ctx) =&gt; {
  // prints name of the test
  console.log(ctx.meta.name)
})
</code></pre>
<ol start="2">
<li>内置的测试上下文。</li>
</ol>
<ul>
<li>context.meta<br>
包含关于测试的元数据的只读对象。</li>
<li>context.expect<br>
绑定到当前测试的 expect API。</li>
</ul>
<ol start="3">
<li>每个测试的上下文都不同。可以在 <code>beforeEach</code> 和 <code>afterEach</code> hooks 中访问和扩展它们。</li>
</ol>
<pre><code class="language-ts">import { beforeEach, it } from 'vitest'

beforeEach(async (context) =&gt; {
  // extend context
  context.foo = 'bar'
})

it('should work', ({ foo }) =&gt; {
  console.log(foo) // 'bar'
})
</code></pre>
<ol start="4">
<li>可以通过添加聚合(aggregate)类型 <code>TestContext</code>, 为你的自定义上下文属性提供类型支持。</li>
</ol>
<pre><code class="language-ts">declare module 'vitest' {
  export interface TestContext {
    foo?: string
  }
}
</code></pre>
<p>如果只想为特定的 <code>beforeEach</code>、<code>afterEach</code>、<code>it</code> 或 <code>test</code> hooks 提供属性类型，则可以将类型作为泛型传递。</p>
<pre><code class="language-ts">interface LocalTestContext {
  foo: string
}

beforeEach&lt;LocalTestContext&gt;(async (context) =&gt; {
  // typeof context is 'TestContext &amp; LocalTestContext'
  context.foo = 'bar'
})

it&lt;LocalTestContext&gt;('should work', ({ foo }) =&gt; {
  // typeof foo is 'string'
  console.log(foo) // 'bar'
})
</code></pre>
<h3 id="扩展断言matchers">扩展断言(Matchers)</h3>
<p>由于 Vitest 兼容 Chai 和 Jest，所以可以根据个人喜好使用 <code>chai.use</code> API 或者 <code>expect.extend</code>。</p>
<ol>
<li>可以使用对象包裹断言的形式调用 <code>expect.extend</code> 方法扩展默认的断言。</li>
</ol>
<pre><code class="language-ts">expect.extend({
  // 第一个参数是接收值，其余参数将直接传给断言
  toBeFoo(received, expected) {
    const { isNot } = this
    return {
      // 请勿根据 isNot 参数更改你的 &quot;pass&quot; 值，Vitest 为你做了这件事情
      pass: received === 'foo',
      message: () =&gt; `${received} is${isNot ? ' not' : ''} foo`,
    }
  },
})
</code></pre>
<p>断言方法可以访问上下文 <code>this</code> 对象中的这些属性:</p>
<ul>
<li><code>isNot</code><br>
如果断言是在 <code>not</code> 方法上调用的( <code>expect(received).not.toBeFoo()</code> )，则返回 <code>true</code>。</li>
<li><code>promise</code><br>
如果断言是在 <code>resolved/rejected</code> 中调用的，它的值将包含此断言的名称。否则，它将是一个空字符串。</li>
<li><code>equals</code><br>
这是一个工具函数，他可以帮助你比较两个值。如果是相同的则返回 <code>true</code>，反之返回 <code>false</code>。这个方法几乎在每个断言内部都有使用。默认情况下，它支持非对称的断言。</li>
<li><code>utils</code><br>
它包含了一系列工具函数，可以使用它们来显示信息。</li>
</ul>
<p><code>this</code> 上下文也包含了当前测试的信息，可以通过调用 <code>expect.getState()</code> 来获取它，有用的属性是：</p>
<ul>
<li><code>currentTestName</code><br>
当前测试的全称(包括 describe 块)。</li>
<li><code>testPath</code><br>
当前测试的路径。</li>
</ul>
<p>断言的返回值应该兼容如下接口：</p>
<pre><code class="language-ts">interface MatcherResult {
  pass: boolean
  message: () =&gt; string
  // 如果你传了这些参数，它们将自动出现在 diff 信息中，
  // 所以即便断言不通过，你也不必自己输出 diff
  actual?: unknown
  expected?: unknown
}
</code></pre>
<ol start="2">
<li>使用 TypeScript 时，可以使用以下代码扩展默认的 Matchers 接口：</li>
</ol>
<pre><code class="language-ts">interface CustomMatchers&lt;R = unknown&gt; {
  toBeFoo(): R
}

declare global {
  namespace Vi {
    interface Assertion extends CustomMatchers {}
    interface AsymmetricMatchersContaining extends CustomMatchers {}
  }
  // jest.Matchers interface will also work.
}
</code></pre>
<h3 id="源码内联测试">源码内联测试</h3>
<p>Vitest 还提供了一种方式，可以运行与你的代码实现放在一起的测试，允许测试与实现共享相同的闭包，并且能够在不导出的情况下针对私有状态进行测试。可用于:</p>
<ul>
<li>小范围的功能或工具的单元测试</li>
<li>原型设计</li>
<li>内联断言<br>
对于更复杂的测试，比如组件测试或 E2E 测试，建议<strong>使用单独的测试文件取而代之</strong>。</li>
</ul>
<ol>
<li>首先，在 <code>if (import.meta.vitest)</code> 代码块内写一些测试代码并放在文件的末尾，例如：</li>
</ol>
<pre><code class="language-ts">// src/index.ts

// 函数实现
export function add(...args: number[]) {
  return args.reduce((a, b) =&gt; a + b, 0)
}

// 源码内的测试套件
if (import.meta.vitest) {
  const { it, expect } = import.meta.vitest
  it('add', () =&gt; {
    expect(add()).toBe(0)
    expect(add(1)).toBe(1)
    expect(add(1, 2, 3)).toBe(6)
  })
}
</code></pre>
<ol start="2">
<li>更新 Vitest 配置文件内的 <code>includeSource</code> 以获取到 <code>src/</code> 下的文件：</li>
</ol>
<pre><code class="language-ts">// vite.config.ts
import { defineConfig } from 'vitest/config'

export default defineConfig({
  test: {
    includeSource: ['src/**/*.{js,ts}'],
  },
})
</code></pre>
<ol start="3">
<li>执行测试。</li>
</ol>
<pre><code class="language-js">npx vitest
</code></pre>
<ol start="4">
<li>对于生产环境的构建，你需要设置配置文件内的 <code>define</code> 选项，让打包器清除无用的代码。</li>
</ol>
<pre><code class="language-ts">// vite.config.ts
import { defineConfig } from 'vitest/config'

export default defineConfig({
+ define: {
+   'import.meta.vitest': 'undefined',
+ },
  test: {
    includeSource: ['src/**/*.{js,ts}']
  },
})
</code></pre>
<ol start="5">
<li>要获得对 <code>import.meta.vitest</code> 的 TypeScript 支持，添加 <code>vitest/importMeta</code> 到 <code>tsconfig.json</code>：</li>
</ol>
<pre><code class="language-json">// tsconfig.json
{
  &quot;compilerOptions&quot;: {
    &quot;types&quot;: [
+     &quot;vitest/importMeta&quot;
    ]
  }
}
</code></pre>
<h3 id="快照">快照</h3>
<p>当希望确保函数的输出不会意外更改时，可以使用快照测试，兼容 Jest 快照测试。使用快照时，Vitest 将获取给定值的快照，将其比较时将参考存储在测试旁边的快照文件。如果两个快照不匹配，则测试将失败：要么更改是意外的，要么参考快照需要更新到测试结果的新版本。</p>
<p>要将一个值快照，你可以使用 <code>expect()</code> 的 <code>toMatchSnapshot()</code> API：</p>
<pre><code class="language-ts">import { expect, it } from 'vitest'
it('renders correctly', () =&gt; {
  const result = toUpperCase('foobar')
  expect(result).toMatchSnapshot()
})
</code></pre>
<p>此测试在第一次运行时，Vitest 会创建一个快照文件，如下所示：</p>
<pre><code class="language-ts">// Vitest Snapshot v1

exports['toUpperCase 1'] = '&quot;FOOBAR&quot;'
</code></pre>
<p>快照文件应该与代码更改一起提交，并作为代码审查过程的一部分进行审查。在随后的测试运行中，Vitest 会将执行的输出与之前的快照进行比较。如果他们匹配，测试就会通过。如果它们不匹配，要么测试运行时在你的代码中发现了应该修复的错误，要么实现已经更改，需要更新快照：</p>
<ul>
<li>在监听(watch)模式下, 你可以在终端中键入 <code>u</code> 键直接更新失败的快照。</li>
<li>或者，你可以在 CLI 中使用 <code>--update</code> 或 <code>-u</code> 标记，<code>vitest -u</code> 使 Vitest 进入快照更新模式。</li>
</ul>
<h3 id="指定超时阈值">指定超时阈值</h3>
<p>你可以选择将超时阈值（以毫秒为单位）作为第三个参数传递给测试。默认值为 5 秒。</p>
<pre><code class="language-ts">import { test } from 'vitest'

test('name', async () =&gt; { /* ... */ }, 1000)
</code></pre>
<p>Hooks 也可以接收超时阈值，默认值为 5 秒。</p>
<pre><code class="language-ts">import { beforeAll } from 'vitest'

beforeAll(async () =&gt; { /* ... */ }, 1000)
</code></pre>
<h3 id="选择-跳过-待办测试套件和测试">选择、跳过、待办测试套件和测试</h3>
<ol>
<li>使用 <code>.only</code> 仅运行某些测试套件或测试。</li>
</ol>
<pre><code class="language-ts">import { assert, describe, it } from 'vitest'

// 仅运行此测试套件（以及标记为 Only 的其他测试套件）
describe.only('suite', () =&gt; {
  it('test', () =&gt; {
    assert.equal(Math.sqrt(4), 3)
  })
})

describe('another suite', () =&gt; {
  it('skipped test', () =&gt; {
    // 已跳过测试，因为测试在 Only 模式下运行
    assert.equal(Math.sqrt(4), 3)
  })

  it.only('test', () =&gt; {
    // 仅运行此测试（以及标记为 Only 的其他测试）
    assert.equal(Math.sqrt(4), 2)
  })
})
</code></pre>
<ol start="2">
<li>使用 <code>.skip</code> 以避免运行某些测试套件或测试。</li>
</ol>
<pre><code class="language-ts">import { assert, describe, it } from 'vitest'

describe.skip('skipped suite', () =&gt; {
  it('test', () =&gt; {
    // 已跳过此测试套件，无错误
    assert.equal(Math.sqrt(4), 3)
  })
})

describe('suite', () =&gt; {
  it.skip('skipped test', () =&gt; {
    // 已跳过此测试，无错误
    assert.equal(Math.sqrt(4), 3)
  })
})
</code></pre>
<ol start="3">
<li>使用 <code>.todo</code> 留存将要实施的测试套件和测试的待办事项。</li>
</ol>
<pre><code class="language-ts">import { describe, it } from 'vitest'

// 此测试套件的报告中将显示一个条目
describe.todo('unimplemented suite')

// 此测试的报告中将显示一个条目
describe('suite', () =&gt; {
  it.todo('unimplemented test')
})
</code></pre>
<h3 id="类型测试">类型测试</h3>
<ol>
<li>从 Vitest 0.25.0 开始，Vitest 附带 expect-type 包，可以使用 <code>expectTypeOf</code> 或 <code>assertType</code> 语法为你的类型编写测试。</li>
<li>在测试文件中触发的任何类型错误都将被视为测试错误，因此可以使用任何类型技巧来测试项目中的类型。</li>
<li>默认情况下，<code>*.test-d.ts</code> 文件中的所有测试都被视为类型测试，但可以使用 <code>typecheck.include</code> 配置选项更改它。</li>
<li>Vitest 不运行或编译这些文件，它们仅由编译器静态分析，因此你不能使用任何动态语句，所以不能使用动态测试名称和 <code>test.each</code>、<code>test.runIf</code>、<code>test.skipIf</code>、<code>test.each</code>、<code>test.concurrent</code> API，但可以使用其他 API，例如 <code>test</code>、<code>describe</code>、<code>.only</code>、<code>.skip</code> 和 <code>.todo</code>。</li>
<li>使用 CLI 标志，如 <code>--allowOnly</code> 和 <code>-t</code> 也支持类型检查。</li>
</ol>
<pre><code class="language-ts">import { assertType, expectTypeOf } from 'vitest'
import { mount } from './mount.js'

test('my types work properly', () =&gt; {
  expectTypeOf(mount).toBeFunction()
  expectTypeOf(mount).parameter(0).toMatchTypeOf&lt;{ name: string }&gt;()

  // @ts-expect-error name is a string
  assertType(mount({ name: 42 }))
})
</code></pre>
<ol start="6">
<li>在 <code>package.json</code> 文件 <code>scripts</code> 部分添加如下命令：</li>
</ol>
<pre><code class="language-json">{
  &quot;scripts&quot;: {
    &quot;typecheck&quot;: &quot;vitest typecheck&quot;
  }
}
</code></pre>
<p>Vitest 使用 <code>tsc --noEmit</code> 或 <code>vue-tsc --noEmit</code>，具体取决于配置。</p>
<h3 id="同时运行多个测试">同时运行多个测试</h3>
<p>在连续测试中使用 <code>.concurrent</code> 将会并发运行它们。</p>
<pre><code class="language-ts">import { describe, it } from 'vitest'
// 标记为concurrent的两个测试将并行运行
describe('suite', () =&gt; {
  it('serial test', async () =&gt; {
    /* ... */
  })
  it.concurrent('concurrent test 1', async ({ expect }) =&gt; {
    /* ... */
  })
  it.concurrent('concurrent test 2', async ({ expect }) =&gt; {
    /* ... */
  })
})
</code></pre>
<p>在测试套件中使用 <code>.concurrent</code>，则其中的每个测试用例都将并发运行。</p>
<pre><code class="language-ts">import { describe, it } from 'vitest'
// 此套件中的所有测试都将并行运行
describe.concurrent('suite', () =&gt; {
  it('concurrent test 1', async ({ expect }) =&gt; {
    /* ... */
  })
  it('concurrent test 2', async ({ expect }) =&gt; {
    /* ... */
  })
  it.concurrent('concurrent test 3', async ({ expect }) =&gt; {
    /* ... */
  })
})
</code></pre>
<p>还可以将 <code>.skip</code>、<code>.only</code> 和 <code>.todo</code> 用于并发测试套件和测试用例。</p>
<h2 id="vitest-配置">Vitest 配置</h2>
<p>Vitest 的主要优势之一是它与 Vite 的统一配置，<code>vitest</code> 将读取你的根目录 <code>vite.config.ts</code> 以匹配插件，例如 <code>resolve.alias</code> 和 <code>plugins</code> 的配置将会在 Vitest 中开箱即用。</p>
<ul>
<li>创建 <code>vitest.config.ts</code>，优先级将会最高。</li>
<li>将 <code>--config</code> 选项传递给 CLI，例如 <code>vitest --config ./path/to/vitest.config.ts</code>。</li>
<li>在 <code>defineConfig</code> 上使用 <code>process.env.VITEST</code> 或 <code>mode</code> 属性（如果没有被覆盖，将设置为 <code>test</code>）有条件地在 <code>vite.config.ts</code> 中应用不同的配置。</li>
</ul>
<p>使用 <code>vite</code> 的 <code>defineConfig</code> 还需要将 <code>三斜线指令</code> 写在配置文件的顶部，可以参考下面的格式：</p>
<pre><code class="language-ts">/// &lt;reference types=&quot;vitest&quot; /&gt;
import { defineConfig } from 'vite'

export default defineConfig({
  test: {
    /* 使用global避免全局导入（description、test、expect） */
    // globals: true,
  },
})
</code></pre>
<p>使用 <code>vitest</code> 的 <code>defineConfig</code> 可以参考下面的格式：</p>
<pre><code class="language-ts">import { defineConfig } from 'vitest/config'

export default defineConfig({
  test: {
    // ...
  },
})
</code></pre>
<p>如果有需要，可以获取到 Vitest 的默认选项以扩展它们：</p>
<pre><code class="language-ts">import { configDefaults, defineConfig } from 'vitest/config'

export default defineConfig({
  test: {
    exclude: [...configDefaults.exclude, 'packages/template/*'],
  },
})
</code></pre>
<h3 id="对象模拟mocking">对象模拟(Mocking)</h3>
<p>在编写测试时，可能会因为时间问题，需要创建内部或外部服务的 “假” 版本，这通常被称为 <strong>对象模拟</strong> 操作。Vitest 通过 <strong>vi</strong> 提供了一些实用的函数用于解决这个问题。你可以使用 <code>import { vi } from 'vitest'</code> 或者 <strong>全局配置</strong> 进行访问它(当启用 <strong>全局配置</strong> 时)。</p>
<pre><code class="language-ts">import { expect, vi } from 'vitest'
const fn = vi.fn()
fn('hello', 1)
expect(vi.isMockFunction(fn)).toBe(true)
expect(fn.mock.calls[0]).toEqual(['hello', 1])
fn.mockImplementation(arg =&gt; arg)
fn('world', 2)
expect(fn.mock.results[1].value).toBe('world')
</code></pre>
<p>Vitest 支持 <a href="https://github.com/capricorn86/happy-dom">happy-dom</a> 或 <a href="https://github.com/jsdom/jsdom">jsdom</a> 来模拟 DOM 和浏览器 API。Vitest 并不内置它们，所以需要安装：</p>
<pre><code>npm i -D happy-dom
# or
npm i -D jsdom
</code></pre>
<p>然后，更改 <code>environment</code> 配置文件中的选项：</p>
<pre><code class="language-ts">// vite.config.ts
import { defineConfig } from 'vitest/config'
export default defineConfig({
  test: {
    environment: 'happy-dom', // or 'jsdom', 'node'
  },
})
</code></pre>
<h3 id="测试覆盖率">测试覆盖率</h3>
<ol>
<li>Vitest 通过 c8 支持本机代码覆盖率。同时也支持 istanbul。默认情况下，启用 c8。可以通过将 <code>test.coverage.provider</code> 设置为 <code>c8</code> 或 <code>istanbul</code> 来选择覆盖工具：</li>
</ol>
<pre><code class="language-ts">// vite.config.ts
import { defineConfig } from 'vitest/config'

export default defineConfig({
  test: {
    coverage: {
      provider: 'istanbul', // or 'c8'
    },
  },
})
</code></pre>
<ol start="2">
<li>当你启动 Vitest 进程时，它会提示你自动安装相应的支持包：</li>
</ol>
<pre><code>npm i -D @vitest/coverage-c8
# or
npm i -D @vitest/coverage-istanbul
</code></pre>
<ol start="3">
<li>要在启用的情况下进行测试，在 CLI 中传递 <code>--coverage</code> 标志：</li>
</ol>
<pre><code class="language-json">{
  &quot;scripts&quot;: {
    &quot;test&quot;: &quot;vitest&quot;,
    &quot;coverage&quot;: &quot;vitest run --coverage&quot;
  }
}
</code></pre>
<ol start="4">
<li>要对其进行配置，需要在配置文件中设置 <code>test.coverage</code> 选项：</li>
</ol>
<pre><code class="language-ts">// vite.config.ts
import { defineConfig } from 'vitest/config'
export default defineConfig({
  test: {
    coverage: {
      reporter: ['text', 'json', 'html'],
    },
  },
})
</code></pre>
<ol start="5">
<li>也可以通过将 <code>'custom'</code> 传递给 <code>test.coverage.provider</code> 来配置你的自定义覆盖率提供者：</li>
</ol>
<pre><code class="language-ts">// vite.config.ts
import { defineConfig } from 'vitest/config'

export default defineConfig({
  test: {
    coverage: {
      provider: 'custom',
      customProviderModule: 'my-custom-coverage-provider',
    },
  },
})
</code></pre>
<p>自定义覆盖率提供者需要一个 <code>customProviderModule</code> 选项，它是一个模块名称或从中加载 <code>CoverageProviderModule</code> 的路径。它必须将实现 <code>CoverageProviderModule</code> 的对象导出为默认导出：</p>
<pre><code class="language-ts">// my-custom-coverage-provider.ts
import type {
  CoverageProvider,
  CoverageProviderModule,
  ResolvedCoverageOptions,
  Vitest,
} from 'vitest'

const CustomCoverageProviderModule: CoverageProviderModule = {
  getProvider(): CoverageProvider {
    return new CustomCoverageProvider()
  },

  // Implements rest of the CoverageProviderModule ...
}

class CustomCoverageProvider implements CoverageProvider {
  name = 'custom-coverage-provider'
  options!: ResolvedCoverageOptions

  initialize(ctx: Vitest) {
    this.options = ctx.config.coverage
  }

  // Implements rest of the CoverageProvider ...
}

export default CustomCoverageProviderModule
</code></pre>
<ol start="6">
<li>运行覆盖率报告时，会在项目的根目录中创建一个 <code>coverage</code> 文件夹。如果想将它移动到不同的目录，使用 <code>vite.config.js</code> 文件中的 <code>test.coverage.reportsDirectory</code> 属性：</li>
</ol>
<pre><code class="language-ts">import { defineConfig } from 'vite'

export default defineConfig({
  test: {
    coverage: {
      reportsDirectory: './tests/unit/coverage',
    },
  },
})
</code></pre>
<h3 id="命令行">命令行</h3>
<p>在安装了 Vitest 的项目中，可以在 npm 脚本中使用 vitest 脚本，或者直接使用 <code>npx vitest</code> 运行它。以下是脚手架 Vitest 项目中的默认 npm 脚本：</p>
<pre><code class="language-json">{
  &quot;scripts&quot;: {
    &quot;test&quot;: &quot;vitest&quot;,
    &quot;coverage&quot;: &quot;vitest run --coverage&quot;
  }
}
</code></pre>
<ol>
<li>vitest 在开发环境下默认启动时使用 <code>监听模式(watch mode)</code>，当你修改源代码或测试文件时，Vitest 智能搜索模块依赖树并只重新运行相关测试，就像 HMR 在 Vite 的工作方式一样！</li>
<li>在 CI 环境（当 <code>process.env.CI</code> 出现时）中以 <code>运行模式(run mode)</code> 启动，在不监视文更改的情况下执行单次运行。</li>
<li>可以使用 <code>vitest watch</code> 或 <code>vitest run</code> 明确指定所需的模式。</li>
<li>可以使用 CLI 按名称筛选测试文件，例如 <code>vitest basic</code> 将只执行包含 <code>basic</code> 路径名的测试文件。</li>
</ol>
<pre><code>basic.test.ts
basic-foo.test.ts
</code></pre>
<ol start="5">
<li>Vitest 默认启动多线程，可以通过 CLI 中的 <code>--no-threads</code> 禁用。</li>
<li>Vitest 还隔离了每个测试文件的运行环境，因此一个文件中的运行环境改变不会影响其他文件，可以通过将 <code>--no-isolate</code> 传递给 CLI 来禁用隔离（以正确性换取运行性能）。</li>
<li>还可以指定其他 CLI 选项，例如 <code>--port</code> 或 <code>--https</code>，在项目中运行 <code>npx vitest --help</code> 获取有关 CLI 选项的完整列表。</li>
</ol>
<h2 id="vitest-ui">Vitest UI</h2>
<p>Vitest 由 Vite 提供能力，在运行测试时有一个开发服务器。这允许 Vitest 提供一个漂亮的 UI 界面来查看并与测试交互。</p>
<ol>
<li>安装：</li>
</ol>
<pre><code>npm i -D @vitest/ui
</code></pre>
<ol start="2">
<li>通过传入 <code>--ui</code> 参数来启动测试的 UI 界面：</li>
</ol>
<pre><code>vitest --ui
</code></pre>
<ol start="3">
<li>通过 <code>http://localhost:51204/__vitest__/</code> 可以访问 Vitest UI 界面。</li>
<li>Vitest 0.26.0 开始, UI 也可以用作测试报告器。在 Vitest 配置中使用 <code>'html'</code> 报告器生成 HTML 输出并预览测试结果，如果仍想在终端中实时查看测试的运行情况，不要忘记将 <code>default</code> 报告器添加到 <code>reporters</code> 选项。</li>
</ol>
<pre><code class="language-ts">// vitest.config.ts

export default {
  test: {
    reporters: ['default', 'html'],
  },
}
</code></pre>
<ol start="5">
<li>要预览你的 HTML 报告，可以使用 <code>vite preview</code> 命令：</li>
</ol>
<pre><code class="language-js">npx vite preview --base __vitest__ --outDir ./html
</code></pre>
<p>可以使用 <code>--outputFile=&lt;path&gt;</code> 配置选项配置输出，<code>./html/index.html</code> 是默认值。</p>
<h2 id="api">API</h2>
<ul>
<li>
<p>describe 描述, 会形成一个作用域，用来组织测试和基准，使报告更加清晰</p>
</li>
<li>
<p>test 别名 it，定义了一组关于测试期望的方法，接收测试名称和一个含有测试期望的函数，可以提供一个超时时限（以毫秒为单位）用于指定等待多长时间后终止测试，默认为 5 秒，也可以通过 <code>testTimeout</code> 选项进行全局配置</p>
</li>
<li>
<p>expect 用来创建断言</p>
<ul>
<li>not 将会否定断言</li>
<li>toBe 可用于断言基础对象是否相等</li>
<li>toBeDefined 断言检查值是否不等于 undefined</li>
<li>toBeUndefined 断言检查值是否等于 undefined</li>
<li>toBeNull 简单地断言检查值是否为 null，是 .toBe(null) 的别名</li>
<li>toBeNaN 简单地断言是否为 NaN，是 .toBe(NaN) 的别名</li>
<li>toBeTruthy 会将检查值转换为布尔值，断言该值是否为 true</li>
<li>toBeFalsy 会将检测值转换为布尔值，断言该值是否为 false</li>
<li>toBeTypeOf 断言检查值是否属于接收的类型</li>
<li>toBeInstanceOf 断言检查值是否为接收的类的实例</li>
<li>toBeGreaterThan 断言检查值是否大于接收值</li>
<li>toBeGreaterThanOrEqual 断言检查值是否大于等于接收值</li>
<li>toBeLessThan 断言检查值是否小于接收值</li>
<li>toBeLessThanOrEqual 断言检查值是否小于等于接收值</li>
<li>toEqual 断言检查值是否等于接收值，或者是同样的结构，如果是对象类型（将会使用递归的方法进行比较）</li>
<li>toStrictEqual 断言检查值是否等于接收值或者同样的结构，如果是对象类型（将会使用递归的方法进行比较），并且会比较它们是否是相同的类型</li>
<li>toContain 断言检查值是否在数组中，还可以检查一个字符串是否为另一个字符串的子串</li>
<li>toContainEqual 断言在数组中是否包含具有特定结构和值的元素，就像对每个元素进行 toEqual 操作</li>
<li>toHaveLength 断言一个对象是否具有 .length 属性，并且为数值</li>
<li>toHaveProperty 用于断言对象上是否存在指定 key 的属性，同时该方法还提供了一个可选参数，用于进行深度对比，就像使用 toEqual 比较接收到的属性值</li>
<li>toMatch 断言字符串是否匹配指定的正则表达式或字符串</li>
<li>toMatchObject 用于断言对象是否匹配指定的对象属性的子集，还可以传递对象数组。如果我们只想检查两个数组的元素数量是否匹配，该方法就会很有用，它不同于 arrayContaining ，它允许接收数组中的额外元素</li>
<li>toThrowError 断言函数在调用时是否抛出错误，可以提供一个可选参数来测试是否引发了指定的错误：
<ul>
<li>正则表达式：错误信息通过正则表达式匹配</li>
<li>字符串：错误消息包含指定子串</li>
</ul>
</li>
<li>resolves 可以从待处理的 Promise 中去展开它的值，并使用通常的断言语句来断言它的值</li>
<li>rejects 可以来展开 Promise 被拒绝的原因，并使用通常的断言语句来断言它的值</li>
</ul>
</li>
<li>
<p>expect.assertions 在测试通过或失败后，它将会验证在测试期间调用了多少次断言，常用于检查异步代码是否被调用了</p>
</li>
<li>
<p>expect.anything 这种非对称匹配器与相等检查一起使用时，将始终返回 true，如果你只是想确保该属性存在时很有用</p>
</li>
<li>
<p>expect.any 这种非对称匹配器与相等检查一起使用时，仅当 value 是指定构造函数的实例时才会返回 true，如果你有一个每次都生成的值，并且只想知道它以正确的类型存在是很有用</p>
</li>
<li>
<p>expect.arrayContaining 当与相等检查一起使用时，如果 value 是一个数组并包含指定的选项，则此非对称匹配器将返回 true，可以将 expect.not 与此匹配器一起使用来否定预期值</p>
</li>
<li>
<p>expect.objectContaining 当与相等检查一起使用时，如果 value 具有相似的结构，则此非对称匹配器将返回 true，可以将 expect.not 与此匹配器一起使用来否定预期值</p>
</li>
<li>
<p>expect.stringContaining 当与相等检查一起使用时，如果 value 是字符串并且包含指定的子字符串，则此非对称匹配器将返回 true，可以将 expect.not 与此匹配器一起使用来否定预期值</p>
</li>
<li>
<p>expect.stringMatching 当与相等检查一起使用时，如果 value 是字符串并且包含指定的子字符串或字符串匹配正则表达式，则此非对称匹配器将返回 true，可以将 expect.not 与此匹配器一起使用来否定预期值</p>
</li>
<li></li>
<li>
<p><code>not</code></p>
</li>
</ul>
<pre><code class="language-ts">import { expect, test } from 'vitest'

const input = Math.sqrt(16)

expect(input).not.to.equal(2) // chai API
expect(input).not.toBe(2) // jest API
</code></pre>
<ul>
<li><code>toEqual</code> 和 <code>toBe</code> 之间的区别</li>
</ul>
<pre><code class="language-ts">import { expect, test } from 'vitest'

const stockBill = {
  type: 'apples',
  count: 13,
}

const stockMary = {
  type: 'apples',
  count: 13,
}

test('stocks have the same properties', () =&gt; {
  expect(stockBill).toEqual(stockMary)
})

test('stocks are not the same', () =&gt; {
  expect(stockBill).not.toBe(stockMary)
})
</code></pre>
<ul>
<li><code>toEqual</code> 和 <code>toStrictEqual</code> 之间的区别</li>
</ul>
<pre><code class="language-ts">import { expect, test } from 'vitest'

class Stock {
  constructor(type) {
    this.type = type
  }
}

test('structurally the same, but semantically different', () =&gt; {
  expect(new Stock('apples')).toEqual({ type: 'apples' })
  expect(new Stock('apples')).not.toStrictEqual({ type: 'apples' })
})
</code></pre>
<ul>
<li><code>toHaveProperty</code></li>
</ul>
<pre><code class="language-ts">import { expect, test } from 'vitest'

const invoice = {
  'isActive': true,
  'P.O': '12345',
  'customer': {
    first_name: 'John',
    last_name: 'Doe',
    location: 'China',
  },
  'total_amount': 5000,
  'items': [
    {
      type: 'apples',
      quantity: 10,
    },
    {
      type: 'oranges',
      quantity: 5,
    },
  ],
}

test('John Doe Invoice', () =&gt; {
  expect(invoice).toHaveProperty('isActive') // 断言 key 存在
  expect(invoice).toHaveProperty('total_amount', 5000) // 断言 key 存在且值相等

  expect(invoice).not.toHaveProperty('account') // 断言 key 不存在

  // 使用 dot 进行深度引用
  expect(invoice).toHaveProperty('customer.first_name')
  expect(invoice).toHaveProperty('customer.last_name', 'Doe')
  expect(invoice).not.toHaveProperty('customer.location', 'India')

  // 使用包含 key 的数组进行深度引用
  expect(invoice).toHaveProperty('items[0].type', 'apples')
  expect(invoice).toHaveProperty('items.0.type', 'apples') // 使用 dot 也可以工作

  // 在数组中包装你的 key 来避免它作为深度引用
  expect(invoice).toHaveProperty(['P.O'], '12345')
})
</code></pre>
<ul>
<li><code>toMatch</code></li>
</ul>
<pre><code class="language-ts">import { expect, test } from 'vitest'

test('top fruits', () =&gt; {
  expect('top fruits include apple, orange and grape').toMatch(/apple/)
  expect('applefruits').toMatch('fruit') // toMatch 也可以是一个字符串
})
</code></pre>
<ul>
<li><code>toMatchObject</code></li>
</ul>
<pre><code class="language-ts">import { expect, test } from 'vitest'

const johnInvoice = {
  isActive: true,
  customer: {
    first_name: 'John',
    last_name: 'Doe',
    location: 'China',
  },
  total_amount: 5000,
  items: [
    {
      type: 'apples',
      quantity: 10,
    },
    {
      type: 'oranges',
      quantity: 5,
    },
  ],
}

const johnDetails = {
  customer: {
    first_name: 'John',
    last_name: 'Doe',
    location: 'China',
  },
}

test('invoice has john personal details', () =&gt; {
  expect(johnInvoice).toMatchObject(johnDetails)
})

test('the number of elements must match exactly', () =&gt; {
  // 断言对象数组是否匹配
  expect([{ foo: 'bar' }, { baz: 1 }]).toMatchObject([
    { foo: 'bar' },
    { baz: 1 },
  ])
})
</code></pre>
<ul>
<li><code>toThrowError</code></li>
</ul>
<pre><code class="language-ts">import { expect, test } from 'vitest'

function getFruitStock(type) {
  if (type === 'pineapples') {
    throw new DiabetesError(
      'Pineapples is not good for people with diabetes'
    )
  }

  // 可以做一些其他的事情
}

test('throws on pineapples', () =&gt; {
  // 测试错误消息是否在某处显示 &quot;diabetes&quot; ：这些是等效的
  expect(() =&gt; getFruitStock('pineapples')).toThrowError(/diabetes/)
  expect(() =&gt; getFruitStock('pineapples')).toThrowError('diabetes')

  // 测试确切的错误信息
  expect(() =&gt; getFruitStock('pineapples')).toThrowError(
    /^Pineapples is not good for people with diabetes$/
  )
})
</code></pre>
<ul>
<li><code>resolves</code></li>
</ul>
<pre><code class="language-ts">import { expect, test } from 'vitest'

async function buyApples() {
  return fetch('/buy/apples').then(r =&gt; r.json())
}

test('buyApples returns new stock id', async () =&gt; {
  // toEqual 现在返回一个 Promise ，所以我们必须等待它
  await expect(buyApples()).resolves.toEqual({ id: 1 }) // jest API
  await expect(buyApples()).resolves.to.equal({ id: 1 }) // chai API
})
</code></pre>
<ul>
<li><code>rejects</code></li>
</ul>
<pre><code class="language-ts">import { expect, test } from 'vitest'

async function buyApples(id) {
  if (!id)
    throw new Error('no id')
}

test('buyApples throws an error when no id provided', async () =&gt; {
  // toThrow 现在返回一个 Promise ，所以你必须等待它
  await expect(buyApples()).rejects.toThrow('no id')
})
</code></pre>
<ul>
<li><code>expect.assertions</code></li>
</ul>
<pre><code class="language-ts">import { expect, test } from 'vitest'

async function doAsync(...cbs) {
  await Promise.all(cbs.map((cb, index) =&gt; cb({ index })))
}

test('all assertions are called', async () =&gt; {
  expect.assertions(2)
  function callback1(data) {
    expect(data).toBeTruthy()
  }
  function callback2(data) {
    expect(data).toBeTruthy()
  }

  await doAsync(callback1, callback2)
})
</code></pre>
<ul>
<li><code>expect.anything</code></li>
</ul>
<pre><code class="language-ts">import { expect, test } from 'vitest'

test('object has &quot;apples&quot; key', () =&gt; {
  expect({ apples: 22 }).toEqual({ apples: expect.anything() })
})
</code></pre>
<ul>
<li><code>expect.any</code></li>
</ul>
<pre><code class="language-ts">import { expect, test } from 'vitest'
import { generateId } from './generators'

test('&quot;id&quot; is a number', () =&gt; {
  expect({ id: generateId() }).toEqual({ id: expect.any(Number) })
})
</code></pre>
<ul>
<li><code>expect.arrayContaining</code></li>
</ul>
<pre><code class="language-ts">import { expect, test } from 'vitest'

test('basket includes fuji', () =&gt; {
  const basket = {
    varieties: ['Empire', 'Fuji', 'Gala'],
    count: 3,
  }
  expect(basket).toEqual({
    count: 3,
    varieties: expect.arrayContaining(['Fuji']),
  })
})
</code></pre>
<ul>
<li><code>expect.objectContaining</code></li>
</ul>
<pre><code class="language-ts">import { expect, test } from 'vitest'

test('basket has empire apples', () =&gt; {
  const basket = {
    varieties: [
      {
        name: 'Empire',
        count: 1,
      },
    ],
  }
  expect(basket).toEqual({
    varieties: [expect.objectContaining({ name: 'Empire' })],
  })
})
</code></pre>
<ul>
<li><code>expect.stringContaining</code></li>
</ul>
<pre><code class="language-ts">import { expect, test } from 'vitest'

test('variety has &quot;Emp&quot; in its name', () =&gt; {
  const variety = {
    name: 'Empire',
    count: 1,
  }
  expect(basket).toEqual({
    name: expect.stringContaining('Emp'),
    count: 1,
  })
})
</code></pre>
<ul>
<li><code>expect.stringMatching</code></li>
</ul>
<pre><code class="language-ts">import { expect, test } from 'vitest'

test('variety ends with &quot;re&quot;', () =&gt; {
  const variety = {
    name: 'Empire',
    count: 1,
  }
  expect(basket).toEqual({
    name: expect.stringMatching(/re$/),
    count: 1,
  })
})
</code></pre>
<h2 id="使用">使用</h2>
<ol>
<li>在 <code>package.json</code> 文件 <code>scripts</code> 部分添加如下命令：</li>
</ol>
<pre><code class="language-json">{
  &quot;scripts&quot;: {
    &quot;test&quot;: &quot;vitest&quot;,
    &quot;test:run&quot;: &quot;vitest run&quot;
  }
}
</code></pre>
<ol start="2">
<li>配置 <code>vite.config.ts</code>：</li>
</ol>
<pre><code class="language-ts">/// &lt;reference types=&quot;vitest&quot; /&gt;

// Configure Vitest (https://vitest.dev/config/)

import { defineConfig } from 'vite'

export default defineConfig({
  test: {
    /* for example, use global to avoid globals imports (describe, test, expect): */
    // globals: true,
  },
})
</code></pre>
<ol start="3">
<li>定义文件。</li>
</ol>
<ul>
<li><code>suite.test.ts</code></li>
</ul>
<pre><code class="language-ts">import { assert, describe, expect, it } from 'vitest'

describe('suite name', () =&gt; {
  it('foo', () =&gt; {
    assert.equal(Math.sqrt(4), 2)
  })

  it('bar', () =&gt; {
    expect(1 + 1).eq(2)
  })

  it('snapshot', () =&gt; {
    expect({ foo: 'bar' }).toMatchSnapshot()
  })
})
</code></pre>
<ul>
<li><code>sum.ts</code></li>
</ul>
<pre><code class="language-ts">export default function sum(...numbers:number[]){
  return numbers.reduce((total,number)=&gt;total+number,0)
}
</code></pre>
<ul>
<li><code>sum.test.ts</code></li>
</ul>
<pre><code class="language-ts">import sum from './sum'
import {describe,expect,it} from &quot;vitest&quot;
describe(&quot;#sum&quot;, () =&gt; {
  it(&quot;returns 0 with no numbers&quot;, () =&gt; {
    expect(sum()).toBe(0)
  })
})
</code></pre>
<ol start="3">
<li>运行测试 <code>pnpm run test:run</code>，在 <code>suite.test.ts</code> 文件目录下面生成了一个快照文件 <code>__snapshots__/suite.test.ts.snap</code>：</li>
</ol>
<pre><code>// Vitest Snapshot v1

exports[`suite name &gt; snapshot 1`] = `
{
  &quot;foo&quot;: &quot;bar&quot;,
}
`;
</code></pre>
<h2 id="组件测试示例">组件测试示例</h2>
<ol>
<li>定义组件：</li>
</ol>
<ul>
<li>Case.tsx</li>
</ul>
<pre><code class="language-tsx">import { defineComponent, ref, watchEffect } from 'vue'

export default defineComponent({
  name: 'TestComponent',
  props: {
    value: String,
  },
  emits: ['update:value'],
  setup(props, { emit }) {
    const local = ref('')

    watchEffect(() =&gt; {
      emit('update:value', local)
    })
    watchEffect(() =&gt; {
      local.value = props.value!
    })

    return {
      local,
    }
  },
  render() {
    return (
      &lt;a-select v-model={[this.local, 'value']}&gt;
        &lt;a-select-option value=&quot;aaa&quot;&gt;aaa&lt;/a-select-option&gt;
      &lt;/a-select&gt;
    )
  },
})
</code></pre>
<ul>
<li>Link.tsx</li>
</ul>
<pre><code class="language-tsx">import { defineComponent, PropType, ref } from &quot;vue&quot;;

export type IType = 'default' | 'primary' | 'success' | 'warning' | 'danger'| 'info'
export type IColor = 'black' | 'blue' | 'green' | 'yellow'| 'red' | 'gray'
export const props = {
  type: {
    type: String as PropType&lt;IType&gt;,
    default: &quot;default&quot;,
  },
  color: {
    type: String as PropType&lt;IColor&gt;,
    default: &quot;black&quot;,
  },
  plain: {
    type: Boolean,
    default: true,
  },
  href: {
    type: String,
    required: true,
  },
} as const;

export default defineComponent({
  name: &quot;CLink&quot;,
  props,
  setup(props, { slots }) {
        return () =&gt; (
      &lt;a
      class={`
        text-${props.plain ? props.color + &quot;-500&quot; : &quot;white&quot;}
        hover:text-${props.color}-400
        cursor-pointer
        text-lg
        hover:text-white
        transition duration-300 ease-in-out transform hover:scale-105
        mx-1
        decoration-none
        `}
      href={props.href}      
    &gt;
      {slots.default ? slots.default() : 'Link'}
    &lt;/a&gt;
    );    
  },
});
</code></pre>
<ol start="2">
<li>vitest 本身是不支持单元组件测试的，需要安装 Vue Test Utils：<code>pnpm add @vue/test-utils jsdom -D</code>。</li>
<li>配置：</li>
</ol>
<ul>
<li>package.json</li>
</ul>
<pre><code class="language-json">{
  &quot;scripts&quot;: {
    &quot;test&quot;: &quot;vitest&quot;,
    &quot;test:run&quot;: &quot;vitest run&quot;
  },
}
</code></pre>
<ul>
<li>vite.config.ts</li>
</ul>
<pre><code class="language-ts">import { defineConfig } from 'vite'
import Vue from '@vitejs/plugin-vue'
import Jsx from '@vitejs/plugin-vue-jsx'

export default defineConfig({
  plugins: [Vue(), Jsx()],
  test: {
    globals: true,
    environment: 'jsdom',
    transformMode: {
      web: [/.[tj]sx$/],
    },
  },
})
</code></pre>
<ol start="4">
<li>定义测试。</li>
</ol>
<ul>
<li>case.test.ts</li>
</ul>
<pre><code class="language-ts">//创建一个包含被挂载和渲染的组件的Wrapper，和mount不同的是shallowMount仅限测试组件，不牵扯子组件内容
import { shallowMount } from '@vue/test-utils'
import { expect, test } from 'vitest'
import Case from '../src/Case'

test('mount component', () =&gt; {
  const wrapper = shallowMount(Case, {
    props: {
      value: 'test',
    },
    global: {
      stubs: ['a-select', 'a-select-option'],
    },
  })
  //返回 Wrapper DOM 节点的 HTML 字符串到快照
  expect(wrapper.html()).toMatchSnapshot()
})
</code></pre>
<ul>
<li>link.test.ts</li>
</ul>
<pre><code class="language-ts">import Link from '../src/link/Link'
import { shallowMount } from '@vue/test-utils'
import { describe, expect, test } from 'vitest'
//使用shallowMount()方法挂载组件，并使用expect断言方法来检验组件的渲染是否正确
describe('Link', () =&gt; {
  test(&quot;mount @vue/test-utils&quot;, () =&gt; {
    const wrapper = shallowMount(Link, {
      slots: {
        default: 'Link'
      }
    });
    //断言
    expect(wrapper.text()).toBe(&quot;Link&quot;)
  })
})
//对组件颜色进行测试，测试默认link颜色
describe(&quot;Link&quot;, () =&gt; {
  test(&quot;default color is black&quot;, () =&gt; {
    // 使用 shallowMount 方法挂载组件
    const wrapper = shallowMount(Link);
    // 断言组件默认颜色是否是 black
    expect(wrapper.props().color).toBe(&quot;black&quot;);
  });
});
</code></pre>
<ol start="4">
<li>运行测试 <code>pnpm run test:run</code>，在 <code>case.test.ts</code> 文件目录下面生成了一个快照文件 <code>__snapshots__/case.test.ts.snap</code>：</li>
</ol>
<pre><code>// Vitest Snapshot v1

exports[`mount component 1`] = `&quot;&lt;a-select-stub value=\\&quot;test\\&quot;&gt;&lt;/a-select-stub&gt;&quot;`;
</code></pre>

                </div>
            </article>
        </div>

        
            <div class="next-post">
                <div class="next gt-c-content-color-first">下一篇</div>
                <a href="https://zkrisj.github.io/post/ce-shi-zhi-shi-zong-jie-or-qing-xun-ying-bi-ji/" class="post-title gt-a-link">
                    测试知识总结 ｜ 青训营笔记
                </a>
            </div>
        

        

        

        

        <div class="site-footer gt-c-content-color-first">
    <div class="slogan gt-c-content-color-first">全栈技术文章记录博客</div>
    <div class="social-container">
        
            
        
            
        
            
        
            
        
            
        
            
        
    </div>
    <div class="footer-info">
        
    </div>
    <div>
        Theme <a href="https://github.com/imhanjie/gridea-theme-pure" target="_blank">Pure</a>, Powered by <a
                href="https://gridea.dev" target="_blank">Gridea</a> | <a href="https://zkrisj.github.io/atom.xml" target="_blank">RSS</a>
    </div>
</div>

<script>
  hljs.highlightAll()
</script>

    </div>
</div>
</body>
</html>
