<html>
<head>
    <meta charset="utf-8" />
<meta name="description" content="" />
<meta name="viewport" content="width=device-width, initial-scale=1" />

<title>TypeScript 编译选项、声明文件 ｜ 青训营笔记 | zkrisj</title>

<link rel="shortcut icon" href="https://zkrisj.github.io/favicon.ico?v=1683589449040">

<link href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" rel="stylesheet">
<link rel="stylesheet" href="https://zkrisj.github.io/styles/main.css">
<!-- <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.0/dist/css/bootstrap.min.css"> -->

<script src="https://cdn.jsdelivr.net/npm/@highlightjs/cdn-assets/highlight.min.js"></script>
<script src="https://cdn.bootcdn.net/ajax/libs/highlight.js/9.12.0/languages/dockerfile.min.js"></script>
<script src="https://cdn.bootcdn.net/ajax/libs/highlight.js/9.12.0/languages//dart.min.js"></script>

<!-- <script src="https://cdn.jsdelivr.net/npm/moment@2.27.0/moment.min.js"></script> -->
<!-- <script src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.slim.min.js"></script> -->
<!-- <script src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js"></script> -->
<!-- <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.0/dist/js/bootstrap.min.js"></script> -->
<!-- DEMO JS -->
<!--<script src="media/scripts/index.js"></script>-->



    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.css">
    
</head>
<body>
<div class="main gt-bg-theme-color-first">
    <nav class="navbar navbar-expand-lg">
    <a class="navbar-brand" href="/">
        <img class="user-avatar" src="/images/avatar.png" alt="头像">
        <div class="site-name gt-c-content-color-first">
            zkrisj
        </div>
    </a>
    <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent"
        aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation" id="changeNavbar">
        <i class="fas fa-bars gt-c-content-color-first" style="font-size: 18px"></i>
    </button>
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
        <div class="navbar-nav mr-auto" style="text-align: center">
            
            <div class="nav-item">
                
                <a href="/" class="menu gt-a-link">
                    首页
                </a>
                
            </div>
            
            <div class="nav-item">
                
                <a href="/archives" class="menu gt-a-link">
                    归档
                </a>
                
            </div>
            
            <div class="nav-item">
                
                <a href="/tags" class="menu gt-a-link">
                    标签
                </a>
                
            </div>
            
            <div class="nav-item">
                
                <a href="/post/about" class="menu gt-a-link">
                    关于
                </a>
                
            </div>
            
        </div>
        <div style="text-align: center">
            <form id="gridea-search-form" style="position: relative" data-update="1683589449040"
                action="/search/">
                <input class="search-input" autocomplete="off" spellcheck="false" name="q" placeholder="搜索文章" />
                <i class="fas fa-search gt-c-content-color-first" style="position: absolute; top: 7px; left: 10px;"></i>
            </form>
        </div>
    </div>
</nav>
<script>
    /* 移动端导航栏展开/收起切换 */
    document.getElementById('changeNavbar').onclick = () => {
        var element = document.getElementById('navbarSupportedContent');
        if (element.style.display === 'none' || element.style.display === '') {
            element.style.display = 'block';
        } else {
            element.style.display = 'none';
        }
    }
</script>

    <div class="post-container">
        <div class="post-detail gt-bg-theme-color-second">
            <article class="gt-post-content">
                <h2 class="post-title">
                    TypeScript 编译选项、声明文件 ｜ 青训营笔记
                </h2>
                <div class="post-info">
                    <time class="post-time gt-c-content-color-first">
                        · 2023-02-09 ·
                    </time>
                    
                        <a href="https://zkrisj.github.io/tag/Ra5sEQnVW/" class="post-tags">
                            # TypeScript
                        </a>
                    
                </div>
                <div class="post-content">
                    <h2 id="typescript-介绍">TypeScript 介绍</h2>
<ol>
<li>TypeScript 是 JavaScript 的超集，提供了 JavaScript 的所有功能，并提供了可选的静态类型、Mixin、类、接口和泛型等特性。</li>
<li>TypeScript 的目标是通过其类型系统帮助及早发现错误并提高 JavaScript 开发效率。</li>
<li>通过 TypeScript 编译器或 Babel 转码器转译为 JavaScript 代码，可运行在任何浏览器，任何操作系统。</li>
<li>任何现有的 JavaScript 程序都可以运行在 TypeScript 环境中，并只对其中的 TypeScript 代码进行编译。</li>
<li>在完整保留 JavaScript 运行时行为的基础上，通过引入静态类型定义来提高代码的可维护性，减少可能出现的 bug。</li>
<li>永远不会改变 JavaScript 代码的运行时行为，例如数字除以零等于 Infinity。这意味着，如果将代码从 JavaScript 迁移到 TypeScript ，即使 TypeScript 认为代码有类型错误，也可以保证以相同的方式运行。</li>
<li>对 JavaScript 类型进行了扩展，增加了例如 <code>any</code>、<code>unknown</code>、<code>never</code>、<code>void</code>。</li>
<li>一旦 TypeScript 的编译器完成了检查代码的工作，它就会 <strong>擦除</strong> 类型以生成最终的“已编译”代码。这意味着一旦代码被编译，生成的普通 JS 代码便没有类型信息。这也意味着 TypeScript 绝不会根据它推断的类型更改程序的 <strong>行为</strong>。最重要的是，尽管可能会在编译过程中看到类型错误，但类型系统自身与程序如何运行无关。</li>
<li>在较大型的项目中，可以在单独的文件 tsconfig.json 中声明 TypeScript 编译器的配置，并细化地调整其工作方式、严格程度、以及将编译后的文件存储在何处。</li>
</ol>
<h2 id="编译选项">编译选项</h2>
<p>TypeScript 提供了很多不同功能的编译选项，既可以通过配置 tsconfig.json 文件中的 <code>compilerOptions</code> 属性来实现编译，也可以使用在 <code>tsc</code> 命令后跟随参数这种形式，直接编译 <code>.ts</code> 文件。</p>
<p>以下这些选项可以同时在命令行和 tsconfig.json 里使用。</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>类型</th>
<th>默认值</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>–-allowJs</td>
<td>boolean</td>
<td>false</td>
<td>允许编译 JavaScript 文件</td>
</tr>
<tr>
<td>–-allowSyntheticDefaultImports</td>
<td>boolean</td>
<td>false</td>
<td>允许从没有设置默认导出的模块中默认导入</td>
</tr>
<tr>
<td>–-allowUnreachableCode</td>
<td>boolean</td>
<td>false</td>
<td>不报告执行不到的代码错误</td>
</tr>
<tr>
<td>–-allowUnusedLabels</td>
<td>boolean</td>
<td>false</td>
<td>不报告未使用的标签错误</td>
</tr>
<tr>
<td>–-alwaysStrict</td>
<td>boolean</td>
<td>false</td>
<td>以严格模式解析并为每个源文件生成 &quot;use strict&quot; 语句</td>
</tr>
<tr>
<td>-–checkJs</td>
<td>boolean</td>
<td>false</td>
<td>在 .js 文件中报告错误，与 --allowJs 配合使用</td>
</tr>
<tr>
<td>-–declaration -d</td>
<td>boolean</td>
<td>false</td>
<td>生成相应的 .d.ts 文件</td>
</tr>
<tr>
<td>-–declarationDir</td>
<td>string</td>
<td></td>
<td>生成声明文件的输出路径</td>
</tr>
<tr>
<td>-–diagnostics</td>
<td>boolean</td>
<td>false</td>
<td>显示诊断信息</td>
</tr>
<tr>
<td>–-experimentalDecorators</td>
<td>boolean</td>
<td>false</td>
<td>启用实验性的ES装饰器</td>
</tr>
<tr>
<td>–-extendedDiagnostics</td>
<td>boolean</td>
<td>false</td>
<td>显示详细的诊断信息</td>
</tr>
<tr>
<td>–-forceConsistentCasingInFileNames</td>
<td>boolean</td>
<td>false</td>
<td>禁止对同一个文件的不一致的引用</td>
</tr>
<tr>
<td>–-inlineSourceMap</td>
<td>boolean</td>
<td>false</td>
<td>生成单个 sourcemaps 文件，而不是将每 sourcemaps 生成不同的文件</td>
</tr>
<tr>
<td>–-inlineSources</td>
<td>boolean</td>
<td>false</td>
<td>将代码与 sourcemaps 生成到一个文件中，要求同时设置了 --inlineSourceMap 或 --sourceMap 属性</td>
</tr>
<tr>
<td>--init</td>
<td></td>
<td></td>
<td>初始化 TypeScript 项目并创建一个 tsconfig.json 文件</td>
</tr>
<tr>
<td>–-listEmittedFiles</td>
<td>boolean</td>
<td>false</td>
<td>打印出编译后生成文件的名字</td>
</tr>
<tr>
<td>–-listFiles</td>
<td>boolean</td>
<td>false</td>
<td>编译过程中打印文件名</td>
</tr>
<tr>
<td>--module -m</td>
<td>string</td>
<td>target == &quot;ES6&quot; ? &quot;ES6&quot; : &quot;commonjs&quot;</td>
<td>指定生成哪个模块系统代码： &quot;None&quot;、&quot;CommonJS&quot;、&quot;AMD&quot;、&quot;System&quot;、&quot;UMD&quot;、&quot;ES6&quot; 或 &quot;ES2015&quot;。<br>► 只有 &quot;AMD&quot; 和 &quot;System&quot; 能和 --outFile 一起使用。<br>► &quot;ES6&quot; 和 &quot;ES2015&quot; 可使用在目标输出为 &quot;ES5&quot; 或更低的情况下。</td>
</tr>
<tr>
<td>--moduleResolution</td>
<td>string</td>
<td>module == &quot;AMD&quot; or &quot;System&quot; or &quot;ES6&quot; ? &quot;Classic&quot; : &quot;Node&quot;</td>
<td>决定如何处理模块</td>
</tr>
<tr>
<td>--noEmit</td>
<td>boolean</td>
<td>false</td>
<td>不生成输出文件</td>
</tr>
<tr>
<td>--noEmitHelpers</td>
<td>boolean</td>
<td>false</td>
<td>不在输出文件中生成用户自定义的帮助函数代码，如 <code>__extends</code>。</td>
</tr>
<tr>
<td>--noEmitOnError</td>
<td>boolean</td>
<td>false</td>
<td>报错时不生成输出文件</td>
</tr>
<tr>
<td>--noErrorTruncation</td>
<td>boolean</td>
<td>false</td>
<td>不截短错误消息</td>
</tr>
<tr>
<td>--noFallthroughCasesInSwitch</td>
<td>boolean</td>
<td>false</td>
<td>报告 switch 语句的 fallthrough 错误（即不允许 switch 的 case 语句贯穿）</td>
</tr>
<tr>
<td>--noImplicitAny</td>
<td>boolean</td>
<td>false</td>
<td>在表达式和声明上有隐含的 any 类型时报错。</td>
</tr>
<tr>
<td>--noImplicitReturns</td>
<td>boolean</td>
<td>false</td>
<td>当不是函数的所有返回路径都有返回值时报错</td>
</tr>
<tr>
<td>--noImplicitThis</td>
<td>boolean</td>
<td>false</td>
<td>当 this 表达式的值为 any 类型时生成一个错误</td>
</tr>
<tr>
<td>--noImplicitUseStrict</td>
<td>boolean</td>
<td>false</td>
<td>模块输出中不包含 &quot;use strict&quot; 指令</td>
</tr>
<tr>
<td>--noLib</td>
<td>boolean</td>
<td>false</td>
<td>不包含默认的库文件（ lib.d.ts）</td>
</tr>
<tr>
<td>--noResolve</td>
<td>boolean</td>
<td>false</td>
<td>不把 <code>/// &lt;reference&gt;</code> 或模块导入的文件加到编译文件列表</td>
</tr>
<tr>
<td>--noStrictGenericChecks</td>
<td>boolean</td>
<td>false</td>
<td>禁用在函数类型里对泛型签名进行严格检查</td>
</tr>
<tr>
<td>--noUnusedLocals</td>
<td>boolean</td>
<td>false</td>
<td>若有未使用的局部变量则抛错</td>
</tr>
<tr>
<td>--noUnusedParameters</td>
<td>boolean</td>
<td>false</td>
<td>若有未使用的参数则抛错</td>
</tr>
<tr>
<td>--outDir</td>
<td>string</td>
<td></td>
<td>重定向输出目录</td>
</tr>
<tr>
<td>–-outFile</td>
<td>string</td>
<td></td>
<td>将输出文件合并为一个文件，合并的顺序是根据传入编译器的文件顺序和 <code>///&lt;reference&gt;</code> 和 import 的文件顺序决定的。</td>
</tr>
<tr>
<td>--preserveConstEnums</td>
<td>boolean</td>
<td>false</td>
<td>保留 const enum 声明</td>
</tr>
<tr>
<td>--preserveSymlinks</td>
<td>boolean</td>
<td>false</td>
<td>不把符号链接解析为其真实路径；将符号链接文件视为真正的文件</td>
</tr>
<tr>
<td>--preserveWatchOutput</td>
<td>boolean</td>
<td>false</td>
<td>保留 watch 模式下过时的控制台输出</td>
</tr>
<tr>
<td>--project -p</td>
<td>string</td>
<td></td>
<td>编译指定目录下的项目，这个目录应该包含一个 tsconfig.json文件来管理编译</td>
</tr>
<tr>
<td>--removeComments</td>
<td>boolean</td>
<td>false</td>
<td>删除所有注释，除了以 <code>/!*</code> 开头的版权信息</td>
</tr>
<tr>
<td>–-skipDefaultLibCheck</td>
<td>boolean</td>
<td>false</td>
<td>忽略库的默认声明文件的类型检查</td>
</tr>
<tr>
<td>–-skipLibCheck</td>
<td>boolean</td>
<td>false</td>
<td>忽略所有的声明文件（ <code>*.d.ts</code> ）的类型检查</td>
</tr>
<tr>
<td>--sourceMap</td>
<td>boolean</td>
<td>false</td>
<td>生成相应的 .map 文件</td>
</tr>
<tr>
<td>--sourceRoot</td>
<td>string</td>
<td></td>
<td>指定 TypeScript 源文件的路径，以便调试器定位。当 TypeScript 文件的位置是在运行时指定时使用此标记，路径信息会被加到 sourceMap 里。</td>
</tr>
<tr>
<td>--strict</td>
<td>boolean</td>
<td>false</td>
<td>启用所有严格类型检查选项，相当于启用 --noImplicitAny、--noImplicitThis、--alwaysStrict、--strictNullChecks、--strictFunctionTypes 和 --strictPropertyInitialization。</td>
</tr>
<tr>
<td>--strictFunctionTypes</td>
<td>boolean</td>
<td>false</td>
<td>禁用函数参数双向协变检查</td>
</tr>
<tr>
<td>--strictPropertyInitialization</td>
<td>boolean</td>
<td>false</td>
<td>确保类的非 undefined 属性已经在构造函数里初始化，需要同时启用 --strictNullChecks。</td>
</tr>
<tr>
<td>--strictNullChecks</td>
<td>boolean</td>
<td>false</td>
<td>在严格的 null 检查模式下，null 和 undefined 值不包含在任何类型里，只允许用它们自己和 any 来赋值（有个例外，undefined 可以赋值到 void）。</td>
</tr>
<tr>
<td>--target -t</td>
<td>string</td>
<td>ES3</td>
<td>指定 ECMAScript 目标版本 ES3（默认）、ES5、ES6/ ES2015、ES2016、ES2017 或 ESNext。<br>注意：ESNext 最新的生成目标列表为 <a href="https://github.com/tc39/proposals">ES proposed features</a>。</td>
</tr>
<tr>
<td>--traceResolution</td>
<td>boolean</td>
<td>false</td>
<td>生成模块解析日志信息</td>
</tr>
<tr>
<td>--types</td>
<td>string[]</td>
<td></td>
<td>要包含的类型声明文件名列表</td>
</tr>
<tr>
<td>--typeRoots</td>
<td>string[]</td>
<td></td>
<td>要包含的类型声明文件路径列表</td>
</tr>
<tr>
<td>–-watch -w</td>
<td></td>
<td></td>
<td>在监视模式下运行编译器，会监视输出文件，在它们改变时重新编译。监视文件和目录的具体实现可以通过环境变量进行配置。</td>
</tr>
</tbody>
</table>
<h2 id="tsconfigjson">tsconfig.json</h2>
<ol>
<li>可以通过 <code>tsc --init</code> 命令在根目录生成 <code>tsconfig.json</code> 文件。</li>
<li>目录中存在 <code>tsconfig.json</code> 文件表示该目录是 TypeScript 项目的根目录。</li>
<li><code>tsconfig.json</code> 文件指定编译项目所需的根文件和编译器选项，主要有以下配置项：</li>
</ol>
<pre><code>{
  &quot;compilerOptions&quot;: {},
  &quot;files&quot;: [
    &quot;core.ts&quot;,
    &quot;index.ts&quot;,
    &quot;types.ts&quot;
  ],
  &quot;exclude&quot;: [
    &quot;node_modules&quot;, 
    &quot;lib&quot;, 
    &quot;**/*.test.ts&quot;
  ],
  &quot;include&quot;: [
    &quot;src/**/*&quot;
  ],
  &quot;extends&quot;: &quot;@tsconfig/recommended/tsconfig.json&quot;
}
</code></pre>
<ul>
<li><code>compilerOptions</code> - 对象类型，用来设置编译选项，若不设置则默认使用上述编译选项的默认配置。</li>
<li><code>files</code> - 指定一个包含相对或绝对文件路径的列表，不支持 glob 匹配模式。</li>
<li><code>include</code> - 指定一个文件 glob 匹配模式列表。</li>
<li><code>exclude</code> - 排除一个文件 glob 匹配模式列表。</li>
<li><code>extends</code> - 字符串类型，指向另一个要继承的配置文件的路径。例如，可以继承一个推荐配置 <code>npm i @tsconfig/recommended</code>，<code>&quot;extends&quot;: &quot;@tsconfig/recommended/tsconfig.json&quot;</code>。
<ul>
<li>如果有同名配置，继承文件里的配置会覆盖源文件里的配置。</li>
<li>配置文件里的相对路径在解析时相对于它所在的文件。</li>
</ul>
</li>
</ul>
<blockquote>
<p>glob 通配符有:</p>
<ul>
<li><code>*</code> 匹配 0 或多个字符（不包括目录分隔符）</li>
<li><code>?</code> 匹配一个任意字符（不包括目录分隔符）</li>
<li><code>**/</code> 递归匹配任意子目录</li>
</ul>
</blockquote>
<ol>
<li>如果一个 glob 模式里的某部分不包含文件扩展名（只包含 <code>*</code> 或 <code>.*</code>），那么仅有支持的文件扩展名类型被包含在内（默认情况下为 .ts、.tsx 和 .d.ts），如果 <code>allowJs</code> 设置为 <code>true</code>，也包括 .js 和 .jsx。</li>
<li>如果 <code>files</code> 和 <code>include</code> 都没有被指定，编译器默认包含当前目录和子目录下所有的 TypeScript 文件（.ts、.tsx 和 .d.ts），排除在 <code>exclude</code> 里指定的文件。</li>
<li>如果同时指定了 <code>files</code> 或 <code>include</code>，编译器会将它们结合一并包含进来。</li>
<li>使用 <code>include</code> 引入的文件可以使用 <code>exclude</code> 属性过滤。然而，通过 <code>files</code> 属性明确指定的文件却总是会被包含在内，不管 <code>exclude</code> 如何设置。</li>
<li>使用 <code>outDir</code> 指定的目录下的文件永远会被编译器排除，除非明确地使用 <code>files</code> 将其包含进来（这时就算用 <code>exclude</code> 指定也没用）。</li>
<li>如果没有特殊指定，<code>exclude</code> 默认情况下会排除 node_modules、bower_components、jspm_packages 和 <code>outDir</code> 目录。</li>
<li>任何被 <code>files</code> 或 <code>include</code> 指定的文件所引用的文件也会被包含进来。例如，<code>A.ts</code> 引用了 <code>B.ts</code>，因此 <code>B.ts</code> 不能被排除，除非引用它的 <code>A.ts</code> 在 <code>exclude</code> 列表中。</li>
<li>编译器不会去引入那些可能作为输出的文件。例如，我们包含了 <code>index.ts</code>，那么 <code>index.d.ts</code> 和 <code>index.js</code> 会被排除在外。</li>
<li>优先级：命令行配置 &gt; <code>files</code> &gt; <code>exclude</code> &gt; <code>include</code>。</li>
</ol>
<h3 id="declaration">declaration</h3>
<p>用来为工程中的每个 TypeScript 或 JavaScript 文件生成 <code>.d.ts</code> 文件，这些 <code>.d.ts</code> 文件是描述模块外部 API 的类型定义文件。编辑工具可以通过 <code>.d.ts</code> 文件为非类型化的代码提供 intellisense 和精确的类型。</p>
<p>当 <code>declaration</code> 设置为 <code>true</code> 时，用编译器执行下面的 TypeScript 代码：</p>
<pre><code class="language-ts">export let helloWorld = &quot;hi&quot;;
</code></pre>
<p>将会生成如下这样的 <code>index.js</code> 文件：</p>
<pre><code class="language-ts">export let helloWorld = &quot;hi&quot;;
</code></pre>
<p>以及一个相应的 <code>helloWorld.d.ts</code>：</p>
<pre><code class="language-ts">export declare let helloWorld: string;
</code></pre>
<p>当使用 <code>.d.ts</code> 文件处理 JavaScript 文件时，需要使用 <code>emitDeclarationOnly</code> 或 <code>outDir</code> 来确保 JavaScript 文件不会被覆盖。</p>
<h3 id="strictfunctiontypes">strictFunctionTypes</h3>
<ul>
<li>协变：允许子类型转换为父类型(可以里式替换 LSP 原则进行理解)。</li>
<li>逆变：允许父类型转换为子类型。</li>
</ul>
<ol>
<li>在函数的参数类型中，是符合逆变的，函数的关系和参数的关系是相反的。</li>
<li>在老版本的 TS 中，函数参数是双向协变的。也就是说，既可以协变又可以逆变，但是这并不是类型安全的。</li>
<li>在新版本 TS(2.6+)中 ，可以通过开启 <code>strictFunctionTypes</code> 来修复这个问题。设置之后，函数参数就不再是双向协变的了，函数参数检查更正确。</li>
</ol>
<p>下面是一个禁用 <code>strictFunctionTypes</code> 的示例：</p>
<pre><code class="language-ts">// @strictFunctionTypes: false
function fn(x: string) {
  console.log(&quot;Hello, &quot; + x.toLowerCase());
}

type StringOrNumberFunc = (ns: string | number) =&gt; void;

// Unsafe assignment
let func: StringOrNumberFunc = fn;
// Unsafe call - will crash
func(10);
</code></pre>
<p>启用 <code>strictFunctionTypes</code> 后，将正确检测到错误：</p>
<pre><code class="language-ts">// @strictFunctionTypes: true
function fn(x: string) {
  console.log(&quot;Hello, &quot; + x.toLowerCase());
}

type StringOrNumberFunc = (ns: string | number) =&gt; void;

// Unsafe assignment
let func: StringOrNumberFunc = fn;
// Type '(x: string) =&gt; void' is not assignable to type 'StringOrNumberFunc'.
//   Types of parameters 'x' and 'ns' are incompatible.
//     Type 'string | number' is not assignable to type 'string'.
//       Type 'number' is not assignable to type 'string'.
</code></pre>
<p>在此功能的开发过程中，发现了大量本质上不安全的类层次结构，包括 DOM 中的一些。因此，该设置仅适用于以函数语法编写的函数，不适用于方法语法中的函数：</p>
<pre><code class="language-ts">// @strictFunctionTypes: true
type Methodish = {
  func(x: string | number): void;
};

function fn(x: string) {
  console.log(&quot;Hello, &quot; + x.toLowerCase());
}

// Ultimately an unsafe assignment, but not detected
const m: Methodish = {
  func: fn,
};
m.func(10);
</code></pre>
<h3 id="typeacquisition">typeAcquisition</h3>
<p>对象类型，用以设置自动引入库类型定义文件（.d.ts），该属性下面有3个子属性：</p>
<ul>
<li><code>enable</code>: 布尔类型，用以设置是否开启自动引入库类型定义文件</li>
<li><code>include</code>: 数组类型，允许自动引入的库名列表，如 <code>[&quot;jquery&quot;, &quot;kendo-ui&quot;]</code></li>
<li><code>exclude</code>: 数组类型，排除的库名列表</li>
</ul>
<h2 id="代码提示的秘密-dts">代码提示的秘密 - d.ts</h2>
<ol>
<li>在使用 TypeScript 的时候，最大的一个好处就是可以给 JS 各种类型约束，使得 JS 能够完成静态代码分析，推断代码中存在的类型错误或者进行类型提示。</li>
<li>而 TypeScript 完成类型推断，需要事先知道变量的类型，如果我们都是用 TypeScript 书写代码，并且给变量都指定了明确的类型，TypeScript 是可以很好的完成类型推断工作的。</li>
<li>但是有时，我们不免会引入外部的 JS 库，这时 TypeScript 就对引入的 JS 文件里变量的具体类型不明确了，为了告诉 TypeScript 变量的类型，因此就有了类型定义文件 <code>d.ts</code>（d 即 <code>declare</code>），TypeScript 的声明文件。</li>
<li>如何让这些第三方库也可以进行类型推导呢？需要考虑如何让 JS 库也能定义静态类型。JavaScript 和 TypeScript 的静态类型交叉口 — 类型定义文件，类似于 C/C++ 的 <code>.h</code>头文件（<code>#include &lt;stdio.h&gt;</code>），轻松让 JavaScript 也能支持定义静态类型。</li>
<li><code>d.ts</code> 文件用于为 TypeScript 提供有关用 JavaScript 编写的 API 的类型信息。简单讲，就是你可以在 ts 文件中调用的 js 文件的声明文件。</li>
<li>TypeScript 的核心在于静态类型，我们在编写 TS 的时候会定义很多的类型，但是主流的库都是 JS 编写的，并不支持类型系统。这个时候你不能用 TS 重写主流的库，我们只需要编写仅包含类型注释的 <code>d.ts</code> 文件，然后在你的 TS 代码中，可以在仍然使用纯 JS 库的同时，获得静态类型检查的优势。</li>
<li>在此期间，解决的方式经过了许多的变化，从 <a href="https://github.com/DefinitelyTyped/DefinitelyTyped">DefinitelyTyped</a> 到 <a href="https://github.com/typings/typings">typings</a>（已停止维护）。最后是 <a href="ttps://www.npmjs.com/~types">@types</a>。在 Typescript 2.0 之后，推荐使用 @types 方式，TypeScript 将会默认地检查 <code>./node_modules/@types</code> 文件夹，自动从这里来获取模块的类型定义，当然了，你需要独立安装这个类型定义。Microsoft 在 <a href="https://blogs.msdn.microsoft.com/typescript/2016/06/15/the-future-of-declaration-files/">The Future of Declaration Files</a> 介绍了 TypeScript 的这个新特性。</li>
</ol>
<h3 id="类型路径-types">类型路径 - @types</h3>
<ol>
<li>默认情况下，所有的 <code>@types</code> 包都会在编译时应用，任意层的 <code>node_modules/@types</code> 都会被使用，进一步说，在 <code>node_modules/@types</code> 中的任何包都被认为是可见的，这意味着包含了 <code>./node_modules/@types/</code>、<code>../node_modules/@types/</code>、<code>../../node_modules/@types/</code> 中所有的包。</li>
<li>如果你的类型定义不在上面这个默认文件夹中，可以使用 <code>typesRoot</code> 来配置，只有 <code>typeRoots</code> 下面的包才会被包含进来。例如：</li>
</ol>
<pre><code>{
  &quot;compilerOptions&quot;: {
    &quot;typeRoots&quot;: [&quot;./typings&quot;, &quot;./vendor/types&quot;]
  }
}
</code></pre>
<p>这个配置文件将包含 <code>./typings</code> 和 <code>./vendor/types</code> 下的所有包，而不包括 <code>./node_modules/@types</code> 下的。其中所有的路径都是相对于 <code>tsconfig.json</code>。</p>
<ol start="3">
<li>当 <code>types</code> 被指定，则只有列出的包才会被包含在全局范围内。例如：</li>
</ol>
<pre><code>{
  &quot;compilerOptions&quot;: {
    &quot;types&quot;: [&quot;node&quot;, &quot;jest&quot;, &quot;express&quot;]
  }
}
</code></pre>
<p>这个配置文件将只会包含 <code>./node_modules/@types/node</code>、<code>./node_modules/@types/jest</code> 和 <code>./node_modules/@types/express</code>。其他在 <code>node_modules/@types/*</code> 下的包将不会被包含。此功能与 <code>typeRoots</code> 不同的是，它只指定你想要包含的具体类型，而 <code>typeRoots</code> 支持你想要特定的文件夹。</p>
<ol start="4">
<li>可以指定 <code>&quot;types&quot;: []</code> 来禁用自动引入 <code>@types</code> 包。自动引入只在你使用了全局的声明（相反于模块）时是重要的，如果你使用 <code>import &quot;foo&quot;</code> 语句，TypeScript 仍然会查找 <code>node_modules</code> 和 <code>node_modules/@types</code> 文件夹来获取 <code>foo</code> 包。</li>
<li><code>types</code> 选项不会影响 <code>@types/*</code> 如何被包含在你的代码中，例如：</li>
</ol>
<pre><code class="language-ts">import * as moment from &quot;moment&quot;;
moment().format(&quot;MMMM Do YYYY, h:mm:ss a&quot;);
</code></pre>
<p><code>moment</code> 导入会有完整的类型。当你设置了不在 <code>types</code> 数组中包含它们时，它将：</p>
<ul>
<li>不会在你的项目中添加全局声明（例如 node 中的 <code>process</code> 或 Jest 中的 <code>expect</code>）。</li>
<li>导出不会出现在自动导入的建议中。</li>
</ul>
<h3 id="dts-和-types-的关系">d.ts 和 @types 的关系</h3>
<p><code>@types</code> 是 npm 的一个分支，用来存放 <code>d.ts</code> 文件，如果对应的 npm 包存放在 <code>@types</code> 中，要使用必须下载！如果是自己本地的 <code>d.ts</code> 申明文件，则和 <code>@types</code> 没有任何关系！</p>
<h3 id="实验">实验</h3>
<p>以下 <code>baby.ts</code> 文件，导出了一个 Baby 类，和一个叫 baby 的实例。<code>Baby</code> 包含一个私有的字段 <code>_name</code>，静态的方法 <code>smile</code>，公开的方法 <code>getBabyName</code>, 在通过 <code>new</code> 调用 <code>constructor</code> 的时候，会初始化我们的 <code>_name</code>，而 <code>getBabyName</code> 就是拿到我们私有的 <code>_name</code>，之所以需要 <code>getBabyName</code>，是因为通过 <code>private</code> 关键字指定的私有字段和方法，在实例中是无法访问的。</p>
<pre><code class="language-ts">export class Baby {
  private _name: string;
  constructor(name: string) {
    this._name = name;
    console.log('小宝贝正在哭泣，哇哇哇哇哇~~~')
  }

  static smile() {
    console.log('O(∩_∩)O哈！')
  }

  getBabyName(): string {
    return this._name;
  }
}

export let baby = new Baby('Nico');
</code></pre>
<p>我们加上 <code>-d</code> 选项编译 ts 文件：</p>
<pre><code class="language-ts">tsc baby.ts -d
</code></pre>
<p>会有一个编译后的 <code>baby.js</code> 文件，你还会发现我们多出了一个 <code>baby.d.ts</code> 文件。大多数 ts 初学者会这样问：请问一下，如何在 ts 文件里面，引入已经写好的 js 文件呢？答案就在这里，d.ts 文件。</p>
<pre><code class="language-ts">export declare class Baby {
  private _name;
  constructor(name: string);
  static smile(): void;
  getBabyName(): string;
}
export declare let baby: Baby;
</code></pre>
<p>我们发现 <code>baby.ts</code> 里面所有的方法声明都被导入到了 <code>baby.d.ts</code> 文件里面，而 TypeScript 恰恰就是通过这个 <code>d.ts</code> 文件进行代码提示的。</p>
<ol>
<li>现在重命名一下我们的 <code>baby.ts</code>，把它改成 <code>baby.copy.ts</code>。</li>
<li>新建 <code>main.ts</code> 文件，当使用 <code>import { baby } from &quot;./baby&quot;;</code> 语句导入的时候，VSCode 会自动提示 <code>baby.d.ts</code> 和 <code>baby.copy.ts</code>。</li>
<li>我们选择 <code>baby.d.ts</code>（<code>baby.js</code> 模块文件的声明文件），然后再敲 <code>baby.</code>，此时我们就看到了 <code>getBabyName</code> 方法的提示。</li>
<li>如果删除 <code>baby.d.ts</code> 文件，会发现提示警告：<code>无法找到模块“./baby”的声明文件。“baby.js”隐式拥有 &quot;any&quot; 类型。</code></li>
</ol>
<h3 id="添加自己的-typings-文件夹">添加自己的 typings 文件夹</h3>
<p>如何解决没有库的 d.ts 文件时报错？</p>
<ol>
<li>添加 <code>typeRoots</code> 配置项，就可以加载自己的 d.ts 文件了。</li>
</ol>
<pre><code class="language-json">{
  &quot;compilerOptions&quot;: {
    &quot;typeRoots&quot;: [&quot;typings&quot;]
  }
}
</code></pre>
<ol start="2">
<li>在 typings 目录下新建一个 xxx.d.ts ，xxx 可以随意写。</li>
</ol>
<pre><code class="language-ts">declare module &quot;koa&quot; {
  interface Context {
    render(filename: string, ...args: any[]) : any;
    session: any;
    i18n: any;
    csrf: any;
    flash: any;
  }
}
</code></pre>
<ol start="3">
<li><code>&quot;koa&quot;</code> 就是你的报错库的名称，这里就只是给 <code>koa</code> 库添加一些属性，防止代码编辑器报错。</li>
<li>还有一点要注意的是，报错一定是因为该包主目录下没有一个 <code>index.js</code>，或者放到 <code>lib</code> 目录下面了，新版本的 TypeScript 只要你安装了库，并且它的下面有 <code>index.js</code> 就可以加载到，不会报错但是会让你导入的是 <code>any</code> 类型。</li>
</ol>
<h3 id="如何发布-dts-文件">如何发布 d.ts 文件</h3>
<ol>
<li>第一种方式就是在你的库下面的 <code>package.json</code> 里面配置。这里最好写上相对路径：</li>
</ol>
<pre><code class="language-json">&quot;types&quot;: &quot;./lib/main.d.ts&quot;

// or
&quot;typings&quot;: &quot;./lib/main.d.ts&quot;
</code></pre>
<p>如果你的项目没有使用模块系统的话，可以将包中包含类型定义的 <code>.d.ts</code> 文件手动通过 <code>/// &lt;reference path=&quot;&quot; /&gt;</code> 引入。</p>
<ol start="2">
<li>第二种方式是给<a href="https://github.com/DefinitelyTyped/DefinitelyTyped.git">这个地址</a>提交 PR。</li>
</ol>
<pre><code>https://github.com/DefinitelyTyped/DefinitelyTyped.git
</code></pre>
<ul>
<li>最近的构建都具有完善的 <a href="https://github.com/microsoft/DefinitelyTyped-tools/tree/master/packages/dtslint">类型标注</a>：<a href="https://dev.azure.com/definitelytyped/DefinitelyTyped/_build/latest?definitionId=1&amp;branchName=master"><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7c023a6399374ad1893ceec98677e9b5~tplv-k3u1fbpfcp-zoom-1.image" alt="Build Status" loading="lazy"></a></li>
<li>所有的包基于 typescript@next 版本都有完善的类型标注：<a href="https://dev.azure.com/definitelytyped/DefinitelyTyped/_build/latest?definitionId=8"><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b97524c4b3554ca4bde374f32b2b4e9b~tplv-k3u1fbpfcp-zoom-1.image" alt="Build status" loading="lazy"></a></li>
<li>所有的包都会在1小时30分钟内 <a href="https://github.com/microsoft/DefinitelyTyped-tools/tree/master/packages/publisher">发布到 npm</a>: <a href="https://dev.azure.com/definitelytyped/DefinitelyTyped/_build/latest?definitionId=5&amp;branchName=master"><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/08125252f78c4b66934b6522f3fa2648~tplv-k3u1fbpfcp-zoom-1.image" alt="Publish Status" loading="lazy"></a></li>
<li><a href="https://github.com/typescript-bot">typescript-bot</a> 在 Definitely Typed 一直处于活跃状态 <a href="https://dev.azure.com/definitelytyped/DefinitelyTyped/_build/latest?definitionId=6&amp;branchName=master"><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ed9f6ecee6544cc4aa548f82c124c987~tplv-k3u1fbpfcp-zoom-1.image" alt="Activity Status" loading="lazy"></a></li>
</ul>
<h3 id="definitely-typed">Definitely Typed</h3>
<p>是一个高质量的 TypeScript 类型定义的仓库。</p>
<ol>
<li>npm 包中并不总是有可用的类型，可能有时项目不再维护，有时他们不感兴趣，或没有时间使用 TypeScript。</li>
<li>由于缺少类型，在 TypeScript 中使用非类型化 npm 包将不会再具有类型安全性。</li>
<li>为了帮助 TypeScript 开发人员使用这些包，有一个社区维护的项目叫做 Definitely Typed。</li>
<li>Definitely Typed 是一个为没有类型的 NPM 包提供类型脚本定义的中央存储库的项目。</li>
<li>安装声明包后，通常不需要其他步骤来使用类型，TypeScript 会在使用包本身时自动选择类型。</li>
</ol>
<pre><code>npm install --save-dev @types/jquery
npm install --save-dev @types/node
</code></pre>
<p>编译器中会自动引入这些类型。如果你的项目没有使用模块系统的话，你可能需要使用 <code>types</code> 指令进行手动引用：</p>
<pre><code class="language-ts">/// &lt;reference types=&quot;node&quot; /&gt;
</code></pre>
<ol start="6">
<li>当缺少类型时，VSCode 等编辑器通常会建议安装此类包。对于 npm 包 &quot;foo&quot;，它的类型定义的包名应该是 &quot;@types/foo&quot;。如果没有找到你的包，请在 <a href="https://microsoft.github.io/TypeSearch/">TypeSearch</a> 查询。</li>
<li>Definitely Typed 和 npm 上的 <a href="https://www.npmjs.com/~types">@types</a> 包有什么关系？Definitely Typed GitHub 仓库 <a href="https://github.com/DefinitelyTyped/DefinitelyTyped">master 分支</a> 会通过 <a href="https://github.com/microsoft/DefinitelyTyped-tools/tree/master/packages/publisher">DefinitelyTyped-tools</a> 自动发布到 npm 上的 <a href="https://www.npmjs.com/~types">@types</a>。</li>
</ol>

                </div>
            </article>
        </div>

        
            <div class="next-post">
                <div class="next gt-c-content-color-first">下一篇</div>
                <a href="https://zkrisj.github.io/post/typescript-ming-ming-kong-jian-mo-kuai-sheng-ming-he-bing-or-qing-xun-ying-bi-ji/" class="post-title gt-a-link">
                    TypeScript 命名空间、模块、声明合并 ｜ 青训营笔记
                </a>
            </div>
        

        

        

        

        <div class="site-footer gt-c-content-color-first">
    <div class="slogan gt-c-content-color-first">全栈技术文章记录博客</div>
    <div class="social-container">
        
            
        
            
        
            
        
            
        
            
        
            
        
    </div>
    <div class="footer-info">
        
    </div>
    <div>
        Theme <a href="https://github.com/imhanjie/gridea-theme-pure" target="_blank">Pure</a>, Powered by <a
                href="https://gridea.dev" target="_blank">Gridea</a> | <a href="https://zkrisj.github.io/atom.xml" target="_blank">RSS</a>
    </div>
</div>

<script>
  hljs.highlightAll()
</script>

    </div>
</div>
</body>
</html>
