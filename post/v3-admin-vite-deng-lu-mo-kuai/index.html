<html>
<head>
    <meta charset="utf-8" />
<meta name="description" content="" />
<meta name="viewport" content="width=device-width, initial-scale=1" />

<title>V3 Admin Vite 登录模块 | zkrisj</title>

<link rel="shortcut icon" href="https://zkrisj.github.io/favicon.ico?v=1683589449040">

<link href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" rel="stylesheet">
<link rel="stylesheet" href="https://zkrisj.github.io/styles/main.css">
<!-- <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.0/dist/css/bootstrap.min.css"> -->

<script src="https://cdn.jsdelivr.net/npm/@highlightjs/cdn-assets/highlight.min.js"></script>
<script src="https://cdn.bootcdn.net/ajax/libs/highlight.js/9.12.0/languages/dockerfile.min.js"></script>
<script src="https://cdn.bootcdn.net/ajax/libs/highlight.js/9.12.0/languages//dart.min.js"></script>

<!-- <script src="https://cdn.jsdelivr.net/npm/moment@2.27.0/moment.min.js"></script> -->
<!-- <script src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.slim.min.js"></script> -->
<!-- <script src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js"></script> -->
<!-- <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.0/dist/js/bootstrap.min.js"></script> -->
<!-- DEMO JS -->
<!--<script src="media/scripts/index.js"></script>-->



    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.css">
    
</head>
<body>
<div class="main gt-bg-theme-color-first">
    <nav class="navbar navbar-expand-lg">
    <a class="navbar-brand" href="/">
        <img class="user-avatar" src="/images/avatar.png" alt="头像">
        <div class="site-name gt-c-content-color-first">
            zkrisj
        </div>
    </a>
    <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent"
        aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation" id="changeNavbar">
        <i class="fas fa-bars gt-c-content-color-first" style="font-size: 18px"></i>
    </button>
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
        <div class="navbar-nav mr-auto" style="text-align: center">
            
            <div class="nav-item">
                
                <a href="/" class="menu gt-a-link">
                    首页
                </a>
                
            </div>
            
            <div class="nav-item">
                
                <a href="/archives" class="menu gt-a-link">
                    归档
                </a>
                
            </div>
            
            <div class="nav-item">
                
                <a href="/tags" class="menu gt-a-link">
                    标签
                </a>
                
            </div>
            
            <div class="nav-item">
                
                <a href="/post/about" class="menu gt-a-link">
                    关于
                </a>
                
            </div>
            
        </div>
        <div style="text-align: center">
            <form id="gridea-search-form" style="position: relative" data-update="1683589449040"
                action="/search/">
                <input class="search-input" autocomplete="off" spellcheck="false" name="q" placeholder="搜索文章" />
                <i class="fas fa-search gt-c-content-color-first" style="position: absolute; top: 7px; left: 10px;"></i>
            </form>
        </div>
    </div>
</nav>
<script>
    /* 移动端导航栏展开/收起切换 */
    document.getElementById('changeNavbar').onclick = () => {
        var element = document.getElementById('navbarSupportedContent');
        if (element.style.display === 'none' || element.style.display === '') {
            element.style.display = 'block';
        } else {
            element.style.display = 'none';
        }
    }
</script>

    <div class="post-container">
        <div class="post-detail gt-bg-theme-color-second">
            <article class="gt-post-content">
                <h2 class="post-title">
                    V3 Admin Vite 登录模块
                </h2>
                <div class="post-info">
                    <time class="post-time gt-c-content-color-first">
                        · 2023-05-07 ·
                    </time>
                    
                        <a href="https://zkrisj.github.io/tag/Gh8djQs1V/" class="post-tags">
                            # Vue
                        </a>
                    
                </div>
                <div class="post-content">
                    <h2 id="介绍">介绍</h2>
<p><a href="https://github.com/un-pany/v3-admin-vite">V3 Admin Vite</a> 是一个免费开源的中后台管理系统基础解决方案，基于 Vue3、TypeScript、Element Plus、Pinia 和 Vite 等主流技术。另外还有：</p>
<ul>
<li>Vue-Cli 5.x 版: <a href="https://github.com/un-pany/v3-admin">v3-admin</a></li>
<li>Electron 桌面版: <a href="https://github.com/un-pany/v3-electron-vite">v3-electron-vite</a></li>
</ul>
<h2 id="目录结构">目录结构</h2>
<pre><code class="language-sh"># v3-admin-vite
├─ .husky                # 用户提交代码时格式化代码
├─ .vscode               # 本项目推荐的 vscode 配置和拓展
├─ public
│  ├─ favicon.ico
│  ├─ app-loading.css    # 首屏加载 loading
├─ src
│  ├─ api                # api 接口
│  ├─ assets             # 静态资源
│  ├─ components         # 全局组件
│  ├─ config             # 全局配置
│  ├─ constant           # 常量/枚举
│  ├─ directives         # 全局指令
│  ├─ hooks              # 全局 hook
│  ├─ icons              # svg icon
│  ├─ layout             # 布局
│  ├─ plugins            # 全局插件
│  ├─ router             # 路由
│  ├─ store              # pinia store
│  ├─ styles             # 全局样式
│  ├─ utils              # 全局公共方法
│  └─ views              # 所有页面
│  ├─ App.vue            # 入口页面
│  └─ main.ts            # 入口文件
├─ tests                 # 单元测试
├─ types                 # ts 声明
├─ .env.development      # 开发环境
├─ .env.production       # 正式环境
├─ .env.staging          # 预发布环境
├─ .eslintrc.js          # eslint 配置
├─ .prettier.config.js   # prettier 配置
├─ tsconfig.json         # ts 编译配置
├─ unocss.config.ts      # unocss 配置
└─ vite.config.ts        # vite 配置
</code></pre>
<h2 id="建立目录结构">建立目录结构</h2>
<ol>
<li><code>@/src/api</code> 目录下的 <code>login</code> 文件夹（没有的话就需要新建一个）即代表了登录模块。</li>
<li>在 <code>login</code> 文件夹里面再建立一个 <code>types</code> 文件夹（专门放置和登录模块相关的 <code>TS 类型</code>）和 <code>index.ts</code>。</li>
</ol>
<figure data-type="image" tabindex="1"><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ddeb13d52fed498a992aa7d184af1dd3~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?" alt="" loading="lazy"></figure>
<blockquote>
<p>假如一个模块叫系统管理 <code>system</code>，里面有两个子模块，分别叫用户管理 <code>user</code>、角色管理 <code>role</code>，那么我们建立的目录大致就应该长这个样子：</p>
<figure data-type="image" tabindex="2"><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a5cee0f1f9484d88a4cd0840f8f0694b~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?" alt="" loading="lazy"></figure>
</blockquote>
<h2 id="编写-ts-类型">编写 TS 类型</h2>
<p>编写接口的 TS 类型，需要根据后端同事提供的接口文档，拿到接口的请求参数和响应数据的格式。</p>
<ol>
<li>请求数据类型 <code>ILoginRequestData</code>：</li>
</ol>
<pre><code class="language-ts">export interface ILoginRequestData {
  /** admin 或 editor */
  username: &quot;admin&quot; | &quot;editor&quot;
  /** 密码 */
  password: string
  /** 验证码 */
  code: string
}
</code></pre>
<ol start="2">
<li>响应数据类型 <code>LoginResponseData</code>：</li>
</ol>
<pre><code class="language-ts">export type LoginResponseData = IApiResponseData&lt;{ token: string }&gt;
</code></pre>
<ol start="3">
<li><code>IApiResponseData</code> 这个类型作为一个全局类型，被定义在 <code>@/types/api.d.ts</code> 文件里：</li>
</ol>
<pre><code class="language-ts">/** 所有 api 接口的响应数据都应该准守该格式 */
interface IApiResponseData&lt;T&gt; {
  code: number
  data: T
  message: string
}
</code></pre>
<ol start="4">
<li>所以最终响应数据类型 <code>LoginResponseData</code> 就相当于：</li>
</ol>
<pre><code class="language-ts">{
  code: number
  data: { token: string }
  message: string
}
</code></pre>
<ol start="5">
<li>最终效果如下：</li>
</ol>
<figure data-type="image" tabindex="3"><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a6479deb94544c98baf0c285a98e2dce~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?" alt="" loading="lazy"></figure>
<h2 id="编写接口">编写接口</h2>
<ol>
<li>发送请求是通过封装好的 Axios，所以第一步就是导入相关的方法：</li>
</ol>
<pre><code class="language-ts">import { request } from &quot;@/utils/service&quot;
</code></pre>
<ol start="2">
<li>将上文写好的登录接口的类型导入进来：</li>
</ol>
<pre><code class="language-ts">import type * as Login from &quot;./types/login&quot;
</code></pre>
<ol start="3">
<li>登录接口的函数名为 <code>loginApi</code>，它接受一个参数 <code>data</code>，类型为 <code>ILoginRequestData</code>。</li>
</ol>
<pre><code class="language-ts">/** 登录并返回 Token */
export function loginApi(data: Login.ILoginRequestData) {
  return request&lt;Login.LoginResponseData&gt;({
    url: &quot;users/login&quot;,
    method: &quot;post&quot;,
    data
  })
}
</code></pre>
<ul>
<li><code>request&lt;Login.LoginResponseData&gt;</code> 则表示的是待会接口响应成功的 <code>data</code> 数据类型为 <code>LoginResponseData</code>。</li>
<li><code>url</code> 代表接口地址，<code>method</code> 代表接口方法（get/post/put/delete），<code>data</code> 表示请求体数据（如果是 get 请求，则要换成 <code>params</code>）。</li>
</ul>
<ol start="6">
<li>接口写好后如下图：</li>
</ol>
<figure data-type="image" tabindex="4"><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d1a2151a47f640eebbba3e2661f4ac87~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?" alt="" loading="lazy"></figure>
<h2 id="调用登录接口">调用登录接口</h2>
<p>首先点击登录按钮将调用的函数是 <code>handleLogin</code>：</p>
<pre><code class="language-ts">const handleLogin = () =&gt; {
  loginFormRef.value?.validate((valid: boolean) =&gt; {
    if (valid) {
      loading.value = true
      useUserStore()
        .login({
          username: loginForm.username,
          password: loginForm.password,
          code: loginForm.code
        })
        .then(() =&gt; {
          router.push({ path: &quot;/&quot; })
        })
        .catch(() =&gt; {
          createCode()
          loginForm.password = &quot;&quot;
        })
        .finally(() =&gt; {
          loading.value = false
        })
    } else {
      return false
    }
  })
}
</code></pre>
<ul>
<li><code>loginFormRef.value?.validate</code> 是校验登录表单。</li>
<li><code>useUserStore()</code> 是状态管理器 Pinia 的 <code>Store</code>，调用该 Store 的 <code>login action</code>，并传入用户名、密码、验证码三个参数即可。</li>
<li><code>login action</code> 返回值是一个 Promise，所以后面链式跟一个 <code>.then</code> 、 <code>.catch</code> 和 <code>.finally</code>，接口调用成功则会执行 <code>.then</code> （跳转到首页），如果途中发生错误，则会执行 <code>.catch</code>，而无论什么情况都会执行 <code>.finally</code>。</li>
</ul>
<h2 id="状态管理">状态管理</h2>
<ol>
<li>由于点击登录按钮触发了 <code>useUserStore</code> 的 <code>login</code> action，然后在 <code>login</code> action 中调用这个 <code>loginApi</code> 并传入对应参数（<strong>如果这里参数传递错误，那么 TS 就会报错提醒我们，因为我们在上文中定义接口的时候已经约束了类型</strong>）。</li>
</ol>
<figure data-type="image" tabindex="5"><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3d4630a01f9e49f38625ff31d1dd57ab~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?" alt="" loading="lazy"></figure>
<ol start="2">
<li>调用登录接口成功时，我们将接口返回的响应数据 <code>res</code> 中的 <code>token</code> 分别保存到 <code>cookie</code>（对应语句 <code>setToken(res.data.token)</code>）和 <code>当前 Store</code>（对应语句 <code>token.value = res.data.token</code>） 中，如果接口失败，则直接 <code>reject</code>。</li>
<li>如果这里执行了 <code>.then</code> 那么登录页面也将执行 <code>.then</code>，也就会开始跳转路由到首页，那么就会触发路由守卫。</li>
</ol>
<h2 id="路由守卫">路由守卫</h2>
<ol>
<li><code>@/src/router/permission.ts</code> 包含了路由守卫全部的代码：</li>
</ol>
<pre><code class="language-ts">import router from &quot;@/router&quot;
import { useUserStoreHook } from &quot;@/store/modules/user&quot;
import { usePermissionStoreHook } from &quot;@/store/modules/permission&quot;
import { ElMessage } from &quot;element-plus&quot;
import { whiteList } from &quot;@/config/white-list&quot;
import { getToken } from &quot;@/utils/cache/cookies&quot;
import asyncRouteSettings from &quot;@/config/async-route&quot;
import NProgress from &quot;nprogress&quot;
import &quot;nprogress/nprogress.css&quot;

NProgress.configure({ showSpinner: false })

router.beforeEach(async (to, _from, next) =&gt; {
  NProgress.start()
  const userStore = useUserStoreHook()
  const permissionStore = usePermissionStoreHook()
  // 判断该用户是否登录
  if (getToken()) {
    if (to.path === &quot;/login&quot;) {
      // 如果已经登录，并准备进入 Login 页面，则重定向到主页
      next({ path: &quot;/&quot; })
      NProgress.done()
    } else {
      // 检查用户是否已获得其权限角色
      if (userStore.roles.length === 0) {
        try {
          if (asyncRouteSettings.open) {
            // 注意：角色必须是一个数组！ 例如: ['admin'] 或 ['developer', 'editor']
            await userStore.getInfo()
            const roles = userStore.roles
            // 根据角色生成可访问的 Routes（可访问路由 = 常驻路由 + 有访问权限的动态路由）
            permissionStore.setRoutes(roles)
          } else {
            // 没有开启动态路由功能，则启用默认角色
            userStore.setRoles(asyncRouteSettings.defaultRoles)
            permissionStore.setRoutes(asyncRouteSettings.defaultRoles)
          }
          // 将'有访问权限的动态路由' 添加到 Router 中
          permissionStore.dynamicRoutes.forEach((route) =&gt; {
            router.addRoute(route)
          })
          // 确保添加路由已完成
          // 设置 replace: true, 因此导航将不会留下历史记录
          next({ ...to, replace: true })
        } catch (err: any) {
          // 过程中发生任何错误，都直接重置 Token，并重定向到登录页面
          userStore.resetToken()
          ElMessage.error(err.message || &quot;路由守卫过程发生错误&quot;)
          next(&quot;/login&quot;)
          NProgress.done()
        }
      } else {
        next()
      }
    }
  } else {
    // 如果没有 Token
    if (whiteList.indexOf(to.path) !== -1) {
      // 如果在免登录的白名单中，则直接进入
      next()
    } else {
      // 其他没有访问权限的页面将被重定向到登录页面
      next(&quot;/login&quot;)
      NProgress.done()
    }
  }
})

router.afterEach(() =&gt; {
  NProgress.done()
})
</code></pre>
<ul>
<li>判断用户是否登录，没登录则只能进入白名单页面，比如登录页。</li>
<li>如果已经登录，将不允许进入登录页。</li>
<li>如果已经登录，还要检查是否拿到用户角色，如果没有，并且开启了动态路由功能，则要调用用户详情接口。</li>
<li>如果没有开启动态路由功能，则启用默认角色。</li>
<li>一旦发生错误，就重置 <code>Token</code>，并重定向到登录页。</li>
<li>如果通过路由守卫的检查后，就能正常跳转到首页了。</li>
</ul>
<h2 id="鉴权">鉴权</h2>
<ol>
<li>后续所有的操作，都将携带保存在前端的 <code>token</code> 去调用接口，<code>token</code> 将是后端服务判断当前请求合不合法的依据，项目本身已经写在 Axios 的封装里面了：</li>
</ol>
<figure data-type="image" tabindex="6"><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d3682dbd5f7744eda74b7b3dc9c12872~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?" alt="" loading="lazy"></figure>
<ol start="2">
<li>假如 <code>token</code> 已经过期后，理论上接口会抛出一个 <code>http code 401</code> 的错误，我们只需要在响应拦截器里重定向到登录页即可：</li>
</ol>
<figure data-type="image" tabindex="7"><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9aca133d3dfc4d09949e12478f2fe4b0~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?" alt="" loading="lazy"></figure>
<h2 id="参考资料">参考资料</h2>
<ol>
<li><a href="https://juejin.cn/post/7214026775143350329">【V3 Admin Vite】教程三：掌握登录模块（涉及 API、Axios、Pinia、路由守卫、鉴权）</a></li>
</ol>

                </div>
            </article>
        </div>

        
            <div class="next-post">
                <div class="next gt-c-content-color-first">下一篇</div>
                <a href="https://zkrisj.github.io/post/shi-yong-bian-liang-chong-zi-ji-shu-qi-kuo-zhan-css-dong-hua/" class="post-title gt-a-link">
                    使用变量种子计数器扩展 CSS 动画
                </a>
            </div>
        

        

        

        

        <div class="site-footer gt-c-content-color-first">
    <div class="slogan gt-c-content-color-first">全栈技术文章记录博客</div>
    <div class="social-container">
        
            
        
            
        
            
        
            
        
            
        
            
        
    </div>
    <div class="footer-info">
        
    </div>
    <div>
        Theme <a href="https://github.com/imhanjie/gridea-theme-pure" target="_blank">Pure</a>, Powered by <a
                href="https://gridea.dev" target="_blank">Gridea</a> | <a href="https://zkrisj.github.io/atom.xml" target="_blank">RSS</a>
    </div>
</div>

<script>
  hljs.highlightAll()
</script>

    </div>
</div>
</body>
</html>
